"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@elizaos";
exports.ids = ["vendor-chunks/@elizaos"];
exports.modules = {

/***/ "(rsc)/./node_modules/@elizaos/core/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@elizaos/core/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentRuntime: () => (/* binding */ AgentRuntime),\n/* harmony export */   AgentStatus: () => (/* binding */ AgentStatus),\n/* harmony export */   CacheKeyPrefix: () => (/* binding */ CacheKeyPrefix),\n/* harmony export */   ChannelType: () => (/* binding */ ChannelType),\n/* harmony export */   ContentType: () => (/* binding */ ContentType),\n/* harmony export */   DatabaseAdapter: () => (/* binding */ DatabaseAdapter),\n/* harmony export */   EventType: () => (/* binding */ EventType),\n/* harmony export */   IBrowserService: () => (/* binding */ IBrowserService),\n/* harmony export */   IEmailService: () => (/* binding */ IEmailService),\n/* harmony export */   ILpService: () => (/* binding */ ILpService),\n/* harmony export */   IMessageService: () => (/* binding */ IMessageService),\n/* harmony export */   IPdfService: () => (/* binding */ IPdfService),\n/* harmony export */   IPostService: () => (/* binding */ IPostService),\n/* harmony export */   ITokenDataService: () => (/* binding */ ITokenDataService),\n/* harmony export */   ITranscriptionService: () => (/* binding */ ITranscriptionService),\n/* harmony export */   IVideoService: () => (/* binding */ IVideoService),\n/* harmony export */   IWalletService: () => (/* binding */ IWalletService),\n/* harmony export */   IWebSearchService: () => (/* binding */ IWebSearchService),\n/* harmony export */   KnowledgeScope: () => (/* binding */ KnowledgeScope),\n/* harmony export */   MODEL_SETTINGS: () => (/* binding */ MODEL_SETTINGS),\n/* harmony export */   MemoryType: () => (/* binding */ MemoryType),\n/* harmony export */   ModelType: () => (/* binding */ ModelType),\n/* harmony export */   PlatformPrefix: () => (/* binding */ PlatformPrefix),\n/* harmony export */   Role: () => (/* binding */ Role),\n/* harmony export */   SOCKET_MESSAGE_TYPE: () => (/* binding */ SOCKET_MESSAGE_TYPE),\n/* harmony export */   Semaphore: () => (/* binding */ Semaphore),\n/* harmony export */   Sentry: () => (/* reexport module object */ _sentry_browser__WEBPACK_IMPORTED_MODULE_10__),\n/* harmony export */   Service: () => (/* binding */ Service),\n/* harmony export */   ServiceBuilder: () => (/* binding */ ServiceBuilder),\n/* harmony export */   ServiceType: () => (/* binding */ ServiceType),\n/* harmony export */   TEEMode: () => (/* binding */ TEEMode),\n/* harmony export */   TeeType: () => (/* binding */ TeeType),\n/* harmony export */   VECTOR_DIMS: () => (/* binding */ VECTOR_DIMS),\n/* harmony export */   addHeader: () => (/* binding */ addHeader),\n/* harmony export */   asUUID: () => (/* binding */ asUUID),\n/* harmony export */   booleanFooter: () => (/* binding */ booleanFooter),\n/* harmony export */   characterSchema: () => (/* binding */ characterSchema),\n/* harmony export */   composeActionExamples: () => (/* binding */ composeActionExamples),\n/* harmony export */   composePrompt: () => (/* binding */ composePrompt),\n/* harmony export */   composePromptFromState: () => (/* binding */ composePromptFromState),\n/* harmony export */   createActionResult: () => (/* binding */ createActionResult),\n/* harmony export */   createLogger: () => (/* binding */ createLogger),\n/* harmony export */   createMessageMemory: () => (/* binding */ createMessageMemory),\n/* harmony export */   createService: () => (/* binding */ createService),\n/* harmony export */   createServiceError: () => (/* binding */ createServiceError),\n/* harmony export */   createSettingFromConfig: () => (/* binding */ createSettingFromConfig),\n/* harmony export */   createUniqueUuid: () => (/* binding */ createUniqueUuid),\n/* harmony export */   decryptObjectValues: () => (/* binding */ decryptObjectValues),\n/* harmony export */   decryptSecret: () => (/* binding */ decryptStringValue),\n/* harmony export */   decryptStringValue: () => (/* binding */ decryptStringValue),\n/* harmony export */   decryptedCharacter: () => (/* binding */ decryptedCharacter),\n/* harmony export */   defineService: () => (/* binding */ defineService),\n/* harmony export */   elizaLogger: () => (/* binding */ elizaLogger),\n/* harmony export */   encryptObjectValues: () => (/* binding */ encryptObjectValues),\n/* harmony export */   encryptStringValue: () => (/* binding */ encryptStringValue),\n/* harmony export */   encryptedCharacter: () => (/* binding */ encryptedCharacter),\n/* harmony export */   findEntityByName: () => (/* binding */ findEntityByName),\n/* harmony export */   findWorldsForOwner: () => (/* binding */ findWorldsForOwner),\n/* harmony export */   formatActionNames: () => (/* binding */ formatActionNames),\n/* harmony export */   formatActions: () => (/* binding */ formatActions),\n/* harmony export */   formatEntities: () => (/* binding */ formatEntities),\n/* harmony export */   formatMessages: () => (/* binding */ formatMessages),\n/* harmony export */   formatPosts: () => (/* binding */ formatPosts),\n/* harmony export */   formatTimestamp: () => (/* binding */ formatTimestamp),\n/* harmony export */   getContentTypeFromMimeType: () => (/* binding */ getContentTypeFromMimeType),\n/* harmony export */   getEntityDetails: () => (/* binding */ getEntityDetails),\n/* harmony export */   getLocalServerUrl: () => (/* binding */ getLocalServerUrl),\n/* harmony export */   getMemoryText: () => (/* binding */ getMemoryText),\n/* harmony export */   getModelSpecificSettingKey: () => (/* binding */ getModelSpecificSettingKey),\n/* harmony export */   getSalt: () => (/* binding */ getSalt),\n/* harmony export */   getTypedService: () => (/* binding */ getTypedService),\n/* harmony export */   getUserServerRole: () => (/* binding */ getUserServerRole),\n/* harmony export */   getWorldSettings: () => (/* binding */ getWorldSettings),\n/* harmony export */   imageDescriptionTemplate: () => (/* binding */ imageDescriptionTemplate),\n/* harmony export */   initializeOnboarding: () => (/* binding */ initializeOnboarding),\n/* harmony export */   isCustomMetadata: () => (/* binding */ isCustomMetadata),\n/* harmony export */   isDescriptionMetadata: () => (/* binding */ isDescriptionMetadata),\n/* harmony export */   isDocumentMemory: () => (/* binding */ isDocumentMemory),\n/* harmony export */   isDocumentMetadata: () => (/* binding */ isDocumentMetadata),\n/* harmony export */   isFragmentMemory: () => (/* binding */ isFragmentMemory),\n/* harmony export */   isFragmentMetadata: () => (/* binding */ isFragmentMetadata),\n/* harmony export */   isMessageMetadata: () => (/* binding */ isMessageMetadata),\n/* harmony export */   isValidCharacter: () => (/* binding */ isValidCharacter),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   messageHandlerTemplate: () => (/* binding */ messageHandlerTemplate),\n/* harmony export */   normalizeJsonString: () => (/* binding */ normalizeJsonString),\n/* harmony export */   parseAndValidateCharacter: () => (/* binding */ parseAndValidateCharacter),\n/* harmony export */   parseBooleanFromText: () => (/* binding */ parseBooleanFromText2),\n/* harmony export */   parseJSONObjectFromText: () => (/* binding */ parseJSONObjectFromText),\n/* harmony export */   parseKeyValueXml: () => (/* binding */ parseKeyValueXml),\n/* harmony export */   postCreationTemplate: () => (/* binding */ postCreationTemplate),\n/* harmony export */   safeReplacer: () => (/* binding */ safeReplacer),\n/* harmony export */   saltSettingValue: () => (/* binding */ saltSettingValue),\n/* harmony export */   saltWorldSettings: () => (/* binding */ saltWorldSettings),\n/* harmony export */   shouldRespondTemplate: () => (/* binding */ shouldRespondTemplate),\n/* harmony export */   splitChunks: () => (/* binding */ splitChunks),\n/* harmony export */   stringToUuid: () => (/* binding */ stringToUuid),\n/* harmony export */   trimTokens: () => (/* binding */ trimTokens),\n/* harmony export */   truncateToCompleteSentence: () => (/* binding */ truncateToCompleteSentence),\n/* harmony export */   unsaltSettingValue: () => (/* binding */ unsaltSettingValue),\n/* harmony export */   unsaltWorldSettings: () => (/* binding */ unsaltWorldSettings),\n/* harmony export */   updateWorldSettings: () => (/* binding */ updateWorldSettings),\n/* harmony export */   validateCharacter: () => (/* binding */ validateCharacter),\n/* harmony export */   validateUuid: () => (/* binding */ validateUuid)\n/* harmony export */ });\n/* harmony import */ var handlebars__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! handlebars */ \"(rsc)/./node_modules/handlebars/lib/index.js\");\n/* harmony import */ var js_sha1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-sha1 */ \"(rsc)/./node_modules/js-sha1/src/sha1.js\");\n/* harmony import */ var langchain_text_splitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! langchain/text_splitter */ \"(rsc)/./node_modules/langchain/text_splitter.js\");\n/* harmony import */ var unique_names_generator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! unique-names-generator */ \"(rsc)/./node_modules/unique-names-generator/dist/index.m.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var pino__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pino */ \"(rsc)/./node_modules/pino/pino.js\");\n/* harmony import */ var _sentry_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sentry/browser */ \"(rsc)/./node_modules/@sentry/browser/build/npm/esm/sdk.js\");\n/* harmony import */ var _sentry_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sentry/browser */ \"(rsc)/./node_modules/@sentry/core/build/esm/exports.js\");\n/* harmony import */ var _sentry_browser__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sentry/browser */ \"(rsc)/./node_modules/@sentry/browser/build/npm/esm/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/v4.js\");\n/* harmony import */ var crypto_browserify__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! crypto-browserify */ \"(rsc)/./node_modules/crypto-browserify/index.js\");\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// src/types/primitives.ts\nfunction asUUID(id) {\n  if (!id || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {\n    throw new Error(`Invalid UUID format: ${id}`);\n  }\n  return id;\n}\nvar ContentType = /* @__PURE__ */ ((ContentType2) => {\n  ContentType2[\"IMAGE\"] = \"image\";\n  ContentType2[\"VIDEO\"] = \"video\";\n  ContentType2[\"AUDIO\"] = \"audio\";\n  ContentType2[\"DOCUMENT\"] = \"document\";\n  ContentType2[\"LINK\"] = \"link\";\n  return ContentType2;\n})(ContentType || {});\n\n// src/types/memory.ts\nvar MemoryType = /* @__PURE__ */ ((MemoryType2) => {\n  MemoryType2[\"DOCUMENT\"] = \"document\";\n  MemoryType2[\"FRAGMENT\"] = \"fragment\";\n  MemoryType2[\"MESSAGE\"] = \"message\";\n  MemoryType2[\"DESCRIPTION\"] = \"description\";\n  MemoryType2[\"CUSTOM\"] = \"custom\";\n  return MemoryType2;\n})(MemoryType || {});\nfunction createMessageMemory(params) {\n  return {\n    ...params,\n    createdAt: Date.now(),\n    metadata: {\n      type: \"message\" /* MESSAGE */,\n      timestamp: Date.now(),\n      scope: params.agentId ? \"private\" : \"shared\"\n    }\n  };\n}\nfunction isDocumentMetadata(metadata) {\n  return metadata.type === \"document\" /* DOCUMENT */;\n}\nfunction isFragmentMetadata(metadata) {\n  return metadata.type === \"fragment\" /* FRAGMENT */;\n}\nfunction isMessageMetadata(metadata) {\n  return metadata.type === \"message\" /* MESSAGE */;\n}\nfunction isDescriptionMetadata(metadata) {\n  return metadata.type === \"description\" /* DESCRIPTION */;\n}\nfunction isCustomMetadata(metadata) {\n  return metadata.type !== \"document\" /* DOCUMENT */ && metadata.type !== \"fragment\" /* FRAGMENT */ && metadata.type !== \"message\" /* MESSAGE */ && metadata.type !== \"description\" /* DESCRIPTION */;\n}\nfunction isDocumentMemory(memory) {\n  return memory.metadata?.type === \"document\" /* DOCUMENT */;\n}\nfunction isFragmentMemory(memory) {\n  return memory.metadata?.type === \"fragment\" /* FRAGMENT */;\n}\nfunction getMemoryText(memory, defaultValue = \"\") {\n  return memory.content.text ?? defaultValue;\n}\n\n// src/types/knowledge.ts\nvar KnowledgeScope = /* @__PURE__ */ ((KnowledgeScope2) => {\n  KnowledgeScope2[\"SHARED\"] = \"shared\";\n  KnowledgeScope2[\"PRIVATE\"] = \"private\";\n  return KnowledgeScope2;\n})(KnowledgeScope || {});\nvar CacheKeyPrefix = /* @__PURE__ */ ((CacheKeyPrefix2) => {\n  CacheKeyPrefix2[\"KNOWLEDGE\"] = \"knowledge\";\n  return CacheKeyPrefix2;\n})(CacheKeyPrefix || {});\n\n// src/types/environment.ts\nvar Role = /* @__PURE__ */ ((Role2) => {\n  Role2[\"OWNER\"] = \"OWNER\";\n  Role2[\"ADMIN\"] = \"ADMIN\";\n  Role2[\"NONE\"] = \"NONE\";\n  return Role2;\n})(Role || {});\nvar ChannelType = /* @__PURE__ */ ((ChannelType2) => {\n  ChannelType2[\"SELF\"] = \"SELF\";\n  ChannelType2[\"DM\"] = \"DM\";\n  ChannelType2[\"GROUP\"] = \"GROUP\";\n  ChannelType2[\"VOICE_DM\"] = \"VOICE_DM\";\n  ChannelType2[\"VOICE_GROUP\"] = \"VOICE_GROUP\";\n  ChannelType2[\"FEED\"] = \"FEED\";\n  ChannelType2[\"THREAD\"] = \"THREAD\";\n  ChannelType2[\"WORLD\"] = \"WORLD\";\n  ChannelType2[\"FORUM\"] = \"FORUM\";\n  ChannelType2[\"API\"] = \"API\";\n  return ChannelType2;\n})(ChannelType || {});\n\n// src/types/agent.ts\nvar AgentStatus = /* @__PURE__ */ ((AgentStatus2) => {\n  AgentStatus2[\"ACTIVE\"] = \"active\";\n  AgentStatus2[\"INACTIVE\"] = \"inactive\";\n  return AgentStatus2;\n})(AgentStatus || {});\n\n// src/types/components.ts\nfunction createActionResult(partial = {}) {\n  return {\n    success: true,\n    // Default to success\n    ...partial\n  };\n}\n\n// src/types/service.ts\nvar ServiceType = {\n  TRANSCRIPTION: \"transcription\",\n  VIDEO: \"video\",\n  BROWSER: \"browser\",\n  PDF: \"pdf\",\n  REMOTE_FILES: \"aws_s3\",\n  WEB_SEARCH: \"web_search\",\n  EMAIL: \"email\",\n  TEE: \"tee\",\n  TASK: \"task\",\n  WALLET: \"wallet\",\n  LP_POOL: \"lp_pool\",\n  TOKEN_DATA: \"token_data\",\n  MESSAGE: \"message\",\n  POST: \"post\",\n  UNKNOWN: \"unknown\"\n};\nvar Service = class {\n  constructor(runtime) {\n    if (runtime) {\n      this.runtime = runtime;\n    }\n  }\n  /** Start service connection */\n  static async start(_runtime) {\n    throw new Error(\"Not implemented\");\n  }\n  /** Stop service connection */\n  static async stop(_runtime) {\n    throw new Error(\"Not implemented\");\n  }\n};\nfunction getTypedService(runtime, serviceType) {\n  return runtime.getService(serviceType);\n}\nfunction createServiceError(error, code = \"UNKNOWN_ERROR\") {\n  if (error instanceof Error) {\n    return {\n      code,\n      message: error.message,\n      cause: error\n    };\n  }\n  return {\n    code,\n    message: String(error)\n  };\n}\n\n// src/types/model.ts\nvar ModelType = {\n  SMALL: \"TEXT_SMALL\",\n  // kept for backwards compatibility\n  MEDIUM: \"TEXT_LARGE\",\n  // kept for backwards compatibility\n  LARGE: \"TEXT_LARGE\",\n  // kept for backwards compatibility\n  TEXT_SMALL: \"TEXT_SMALL\",\n  TEXT_LARGE: \"TEXT_LARGE\",\n  TEXT_EMBEDDING: \"TEXT_EMBEDDING\",\n  TEXT_TOKENIZER_ENCODE: \"TEXT_TOKENIZER_ENCODE\",\n  TEXT_TOKENIZER_DECODE: \"TEXT_TOKENIZER_DECODE\",\n  TEXT_REASONING_SMALL: \"REASONING_SMALL\",\n  TEXT_REASONING_LARGE: \"REASONING_LARGE\",\n  TEXT_COMPLETION: \"TEXT_COMPLETION\",\n  IMAGE: \"IMAGE\",\n  IMAGE_DESCRIPTION: \"IMAGE_DESCRIPTION\",\n  TRANSCRIPTION: \"TRANSCRIPTION\",\n  TEXT_TO_SPEECH: \"TEXT_TO_SPEECH\",\n  AUDIO: \"AUDIO\",\n  VIDEO: \"VIDEO\",\n  OBJECT_SMALL: \"OBJECT_SMALL\",\n  OBJECT_LARGE: \"OBJECT_LARGE\"\n};\nvar MODEL_SETTINGS = {\n  // Default settings - apply to all model types unless overridden\n  DEFAULT_MAX_TOKENS: \"DEFAULT_MAX_TOKENS\",\n  DEFAULT_TEMPERATURE: \"DEFAULT_TEMPERATURE\",\n  DEFAULT_FREQUENCY_PENALTY: \"DEFAULT_FREQUENCY_PENALTY\",\n  DEFAULT_PRESENCE_PENALTY: \"DEFAULT_PRESENCE_PENALTY\",\n  // TEXT_SMALL specific settings\n  TEXT_SMALL_MAX_TOKENS: \"TEXT_SMALL_MAX_TOKENS\",\n  TEXT_SMALL_TEMPERATURE: \"TEXT_SMALL_TEMPERATURE\",\n  TEXT_SMALL_FREQUENCY_PENALTY: \"TEXT_SMALL_FREQUENCY_PENALTY\",\n  TEXT_SMALL_PRESENCE_PENALTY: \"TEXT_SMALL_PRESENCE_PENALTY\",\n  // TEXT_LARGE specific settings\n  TEXT_LARGE_MAX_TOKENS: \"TEXT_LARGE_MAX_TOKENS\",\n  TEXT_LARGE_TEMPERATURE: \"TEXT_LARGE_TEMPERATURE\",\n  TEXT_LARGE_FREQUENCY_PENALTY: \"TEXT_LARGE_FREQUENCY_PENALTY\",\n  TEXT_LARGE_PRESENCE_PENALTY: \"TEXT_LARGE_PRESENCE_PENALTY\",\n  // OBJECT_SMALL specific settings\n  OBJECT_SMALL_MAX_TOKENS: \"OBJECT_SMALL_MAX_TOKENS\",\n  OBJECT_SMALL_TEMPERATURE: \"OBJECT_SMALL_TEMPERATURE\",\n  OBJECT_SMALL_FREQUENCY_PENALTY: \"OBJECT_SMALL_FREQUENCY_PENALTY\",\n  OBJECT_SMALL_PRESENCE_PENALTY: \"OBJECT_SMALL_PRESENCE_PENALTY\",\n  // OBJECT_LARGE specific settings\n  OBJECT_LARGE_MAX_TOKENS: \"OBJECT_LARGE_MAX_TOKENS\",\n  OBJECT_LARGE_TEMPERATURE: \"OBJECT_LARGE_TEMPERATURE\",\n  OBJECT_LARGE_FREQUENCY_PENALTY: \"OBJECT_LARGE_FREQUENCY_PENALTY\",\n  OBJECT_LARGE_PRESENCE_PENALTY: \"OBJECT_LARGE_PRESENCE_PENALTY\",\n  // Legacy keys for backwards compatibility (will be treated as defaults)\n  MODEL_MAX_TOKEN: \"MODEL_MAX_TOKEN\",\n  MODEL_TEMPERATURE: \"MODEL_TEMPERATURE\",\n  MODEL_FREQ_PENALTY: \"MODEL_FREQ_PENALTY\",\n  MODEL_PRESENCE_PENALTY: \"MODEL_PRESENCE_PENALTY\"\n};\nfunction getModelSpecificSettingKey(modelType, param) {\n  const supportedModelTypes = [\"TEXT_SMALL\", \"TEXT_LARGE\", \"OBJECT_SMALL\", \"OBJECT_LARGE\"];\n  if (!supportedModelTypes.includes(modelType)) {\n    return null;\n  }\n  return `${modelType}_${param}`;\n}\n\n// src/types/database.ts\nvar VECTOR_DIMS = {\n  SMALL: 384,\n  MEDIUM: 512,\n  LARGE: 768,\n  XL: 1024,\n  XXL: 1536,\n  XXXL: 3072\n};\n\n// src/types/events.ts\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[\"WORLD_JOINED\"] = \"WORLD_JOINED\";\n  EventType2[\"WORLD_CONNECTED\"] = \"WORLD_CONNECTED\";\n  EventType2[\"WORLD_LEFT\"] = \"WORLD_LEFT\";\n  EventType2[\"ENTITY_JOINED\"] = \"ENTITY_JOINED\";\n  EventType2[\"ENTITY_LEFT\"] = \"ENTITY_LEFT\";\n  EventType2[\"ENTITY_UPDATED\"] = \"ENTITY_UPDATED\";\n  EventType2[\"ROOM_JOINED\"] = \"ROOM_JOINED\";\n  EventType2[\"ROOM_LEFT\"] = \"ROOM_LEFT\";\n  EventType2[\"MESSAGE_RECEIVED\"] = \"MESSAGE_RECEIVED\";\n  EventType2[\"MESSAGE_SENT\"] = \"MESSAGE_SENT\";\n  EventType2[\"MESSAGE_DELETED\"] = \"MESSAGE_DELETED\";\n  EventType2[\"CHANNEL_CLEARED\"] = \"CHANNEL_CLEARED\";\n  EventType2[\"VOICE_MESSAGE_RECEIVED\"] = \"VOICE_MESSAGE_RECEIVED\";\n  EventType2[\"VOICE_MESSAGE_SENT\"] = \"VOICE_MESSAGE_SENT\";\n  EventType2[\"REACTION_RECEIVED\"] = \"REACTION_RECEIVED\";\n  EventType2[\"POST_GENERATED\"] = \"POST_GENERATED\";\n  EventType2[\"INTERACTION_RECEIVED\"] = \"INTERACTION_RECEIVED\";\n  EventType2[\"RUN_STARTED\"] = \"RUN_STARTED\";\n  EventType2[\"RUN_ENDED\"] = \"RUN_ENDED\";\n  EventType2[\"RUN_TIMEOUT\"] = \"RUN_TIMEOUT\";\n  EventType2[\"ACTION_STARTED\"] = \"ACTION_STARTED\";\n  EventType2[\"ACTION_COMPLETED\"] = \"ACTION_COMPLETED\";\n  EventType2[\"EVALUATOR_STARTED\"] = \"EVALUATOR_STARTED\";\n  EventType2[\"EVALUATOR_COMPLETED\"] = \"EVALUATOR_COMPLETED\";\n  EventType2[\"MODEL_USED\"] = \"MODEL_USED\";\n  return EventType2;\n})(EventType || {});\nvar PlatformPrefix = /* @__PURE__ */ ((PlatformPrefix2) => {\n  PlatformPrefix2[\"DISCORD\"] = \"DISCORD\";\n  PlatformPrefix2[\"TELEGRAM\"] = \"TELEGRAM\";\n  PlatformPrefix2[\"TWITTER\"] = \"TWITTER\";\n  return PlatformPrefix2;\n})(PlatformPrefix || {});\n\n// src/types/tee.ts\nvar TEEMode = /* @__PURE__ */ ((TEEMode2) => {\n  TEEMode2[\"OFF\"] = \"OFF\";\n  TEEMode2[\"LOCAL\"] = \"LOCAL\";\n  TEEMode2[\"DOCKER\"] = \"DOCKER\";\n  TEEMode2[\"PRODUCTION\"] = \"PRODUCTION\";\n  return TEEMode2;\n})(TEEMode || {});\nvar TeeType = /* @__PURE__ */ ((TeeType2) => {\n  TeeType2[\"TDX_DSTACK\"] = \"tdx_dstack\";\n  return TeeType2;\n})(TeeType || {});\n\n// src/types/token.ts\nvar ITokenDataService = class extends Service {\n  constructor() {\n    super(...arguments);\n    this.capabilityDescription = \"Provides standardized access to token market data.\";\n  }\n  static {\n    this.serviceType = ServiceType.TOKEN_DATA;\n  }\n  // Future potential methods:\n  // getHistoricalPriceData(address: string, chain: string, timeFrame: string): Promise<any[]>;\n  // getTokenMarketChart(address: string, chain: string, days: number): Promise<any[]>;\n};\n\n// src/types/messaging.ts\nvar SOCKET_MESSAGE_TYPE = /* @__PURE__ */ ((SOCKET_MESSAGE_TYPE2) => {\n  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2[\"ROOM_JOINING\"] = 1] = \"ROOM_JOINING\";\n  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2[\"SEND_MESSAGE\"] = 2] = \"SEND_MESSAGE\";\n  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2[\"MESSAGE\"] = 3] = \"MESSAGE\";\n  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2[\"ACK\"] = 4] = \"ACK\";\n  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2[\"THINKING\"] = 5] = \"THINKING\";\n  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2[\"CONTROL\"] = 6] = \"CONTROL\";\n  return SOCKET_MESSAGE_TYPE2;\n})(SOCKET_MESSAGE_TYPE || {});\n\n// src/types/wallet.ts\nvar IWalletService = class extends Service {\n  constructor() {\n    super(...arguments);\n    this.capabilityDescription = \"Provides standardized access to wallet balances and portfolios.\";\n  }\n  static {\n    this.serviceType = ServiceType.WALLET;\n  }\n};\n\n// src/types/lp.ts\nvar ILpService = class extends Service {\n  constructor() {\n    super(...arguments);\n    this.capabilityDescription = \"Provides standardized access to DEX liquidity pools.\";\n  }\n  static {\n    this.serviceType = \"lp\";\n  }\n};\n\n// src/types/pdf.ts\nvar IPdfService = class extends Service {\n  constructor() {\n    super(...arguments);\n    this.capabilityDescription = \"PDF processing, extraction, and generation capabilities\";\n  }\n  static {\n    this.serviceType = ServiceType.PDF;\n  }\n};\n\n// src/types/video.ts\nvar IVideoService = class extends Service {\n  constructor() {\n    super(...arguments);\n    this.capabilityDescription = \"Video download, processing, and conversion capabilities\";\n  }\n  static {\n    this.serviceType = ServiceType.VIDEO;\n  }\n};\n\n// src/types/browser.ts\nvar IBrowserService = class extends Service {\n  constructor() {\n    super(...arguments);\n    this.capabilityDescription = \"Web browser automation and scraping capabilities\";\n  }\n  static {\n    this.serviceType = ServiceType.BROWSER;\n  }\n};\n\n// src/types/transcription.ts\nvar ITranscriptionService = class extends Service {\n  constructor() {\n    super(...arguments);\n    this.capabilityDescription = \"Audio transcription and speech processing capabilities\";\n  }\n  static {\n    this.serviceType = ServiceType.TRANSCRIPTION;\n  }\n};\n\n// src/types/web-search.ts\nvar IWebSearchService = class extends Service {\n  constructor() {\n    super(...arguments);\n    this.capabilityDescription = \"Web search and content discovery capabilities\";\n  }\n  static {\n    this.serviceType = ServiceType.WEB_SEARCH;\n  }\n};\n\n// src/types/email.ts\nvar IEmailService = class extends Service {\n  constructor() {\n    super(...arguments);\n    this.capabilityDescription = \"Email sending, receiving, and management capabilities\";\n  }\n  static {\n    this.serviceType = ServiceType.EMAIL;\n  }\n};\n\n// src/types/message.ts\nvar IMessageService = class extends Service {\n  constructor() {\n    super(...arguments);\n    this.capabilityDescription = \"Message sending, receiving, and management capabilities\";\n  }\n  static {\n    this.serviceType = ServiceType.MESSAGE;\n  }\n};\n\n// src/types/post.ts\nvar IPostService = class extends Service {\n  constructor() {\n    super(...arguments);\n    this.capabilityDescription = \"Social media posting and content management capabilities\";\n  }\n  static {\n    this.serviceType = ServiceType.POST;\n  }\n};\n\n// src/utils.ts\n\n\n\n\n\n\n// src/logger.ts\n\n\n// src/sentry/instrument.ts\n\nvar dsn = process.env.SENTRY_DSN || \"https://c20e2d51b66c14a783b0689d536f7e5c@o4509349865259008.ingest.us.sentry.io/4509352524120064\";\nif (process.env.SENTRY_LOGGING !== \"false\") {\n  _sentry_browser__WEBPACK_IMPORTED_MODULE_4__.onLoad(() => {\n    _sentry_browser__WEBPACK_IMPORTED_MODULE_4__.init({\n      dsn,\n      environment: process.env.SENTRY_ENVIRONMENT || \"development\",\n      tracesSampleRate: parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE ?? \"\") || 1,\n      sendDefaultPii: process.env.SENTRY_SEND_DEFAULT_PII === \"true\"\n    });\n  });\n}\n\n// src/logger.ts\nfunction parseBooleanFromText(value) {\n  if (!value) return false;\n  const normalized = value.toLowerCase().trim();\n  return normalized === \"true\" || normalized === \"1\" || normalized === \"yes\" || normalized === \"on\";\n}\nvar InMemoryDestination = class {\n  /**\n   * Constructor for creating a new instance of the class.\n   * @param {DestinationStream|null} stream - The stream to assign to the instance. Can be null.\n   */\n  constructor(stream) {\n    this.logs = [];\n    this.maxLogs = 1e3;\n    this.stream = stream;\n  }\n  /**\n   * Writes a log entry to the memory buffer and forwards it to the pretty print stream if available.\n   *\n   * @param {string | LogEntry} data - The data to be written, which can be either a string or a LogEntry object.\n   * @returns {void}\n   */\n  write(data) {\n    let logEntry;\n    let stringData;\n    if (typeof data === \"string\") {\n      stringData = data;\n      try {\n        logEntry = JSON.parse(data);\n      } catch (e) {\n        if (this.stream) {\n          this.stream.write(data);\n        }\n        return;\n      }\n    } else {\n      logEntry = data;\n      stringData = JSON.stringify(data);\n    }\n    if (!logEntry.time) {\n      logEntry.time = Date.now();\n    }\n    const isDebugMode2 = (process?.env?.LOG_LEVEL || \"\").toLowerCase() === \"debug\";\n    const isLoggingDiagnostic = Boolean(process?.env?.LOG_DIAGNOSTIC);\n    if (isLoggingDiagnostic) {\n      logEntry.diagnostic = true;\n    }\n    if (!isDebugMode2) {\n      if (logEntry.agentName && logEntry.agentId) {\n        const msg = logEntry.msg || \"\";\n        if (typeof msg === \"string\" && (msg.includes(\"registered successfully\") || msg.includes(\"Registering\") || msg.includes(\"Success:\") || msg.includes(\"linked to\") || msg.includes(\"Started\"))) {\n          if (isLoggingDiagnostic) {\n            console.error(\"Filtered log:\", stringData);\n          }\n          return;\n        }\n      }\n    }\n    this.logs.push(logEntry);\n    if (this.logs.length > this.maxLogs) {\n      this.logs.shift();\n    }\n    if (this.stream) {\n      this.stream.write(stringData);\n    }\n  }\n  /**\n   * Retrieves the recent logs from the system.\n   *\n   * @returns {LogEntry[]} An array of LogEntry objects representing the recent logs.\n   */\n  recentLogs() {\n    return this.logs;\n  }\n  /**\n   * Clears all logs from memory.\n   *\n   * @returns {void}\n   */\n  clear() {\n    this.logs = [];\n  }\n};\nvar customLevels = {\n  fatal: 60,\n  error: 50,\n  warn: 40,\n  info: 30,\n  log: 29,\n  progress: 28,\n  success: 27,\n  debug: 20,\n  trace: 10\n};\nvar raw = parseBooleanFromText(process?.env?.LOG_JSON_FORMAT) || false;\nvar isDebugMode = (process?.env?.LOG_LEVEL || \"\").toLowerCase() === \"debug\";\nvar effectiveLogLevel = isDebugMode ? \"debug\" : process?.env?.DEFAULT_LOG_LEVEL || \"info\";\nvar showTimestamps = process?.env?.LOG_TIMESTAMPS !== void 0 ? parseBooleanFromText(process?.env?.LOG_TIMESTAMPS) : true;\nvar createPrettyConfig = () => ({\n  colorize: true,\n  translateTime: showTimestamps ? \"yyyy-mm-dd HH:MM:ss\" : false,\n  ignore: showTimestamps ? \"pid,hostname\" : \"pid,hostname,time\",\n  levelColors: {\n    60: \"red\",\n    // fatal\n    50: \"red\",\n    // error\n    40: \"yellow\",\n    // warn\n    30: \"blue\",\n    // info\n    29: \"green\",\n    // log\n    28: \"cyan\",\n    // progress\n    27: \"greenBright\",\n    // success\n    20: \"magenta\",\n    // debug\n    10: \"grey\",\n    // trace\n    \"*\": \"white\"\n    // default for any unspecified level\n  },\n  customPrettifiers: {\n    level: (inputData) => {\n      let level;\n      if (typeof inputData === \"object\" && inputData !== null) {\n        level = inputData.level || inputData.value;\n      } else {\n        level = inputData;\n      }\n      const levelNames = {\n        10: \"TRACE\",\n        20: \"DEBUG\",\n        27: \"SUCCESS\",\n        28: \"PROGRESS\",\n        29: \"LOG\",\n        30: \"INFO\",\n        40: \"WARN\",\n        50: \"ERROR\",\n        60: \"FATAL\"\n      };\n      if (typeof level === \"number\") {\n        return levelNames[level] || `LEVEL${level}`;\n      }\n      if (level === void 0 || level === null) {\n        return \"UNKNOWN\";\n      }\n      return String(level).toUpperCase();\n    },\n    // Add a custom prettifier for error messages\n    msg: (msg) => {\n      return msg.replace(/ERROR \\([^)]+\\):/g, \"ERROR:\");\n    }\n  },\n  messageFormat: \"{msg}\"\n});\nvar createStream = async () => {\n  if (raw) {\n    return void 0;\n  }\n  const pretty = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/pino-pretty\"), __webpack_require__.e(\"vendor-chunks/fast-copy\"), __webpack_require__.e(\"vendor-chunks/dateformat\"), __webpack_require__.e(\"vendor-chunks/fast-safe-stringify\"), __webpack_require__.e(\"vendor-chunks/colorette\"), __webpack_require__.e(\"vendor-chunks/split2\"), __webpack_require__.e(\"vendor-chunks/pino-abstract-transport\"), __webpack_require__.e(\"vendor-chunks/end-of-stream\"), __webpack_require__.e(\"vendor-chunks/pump\"), __webpack_require__.e(\"vendor-chunks/once\"), __webpack_require__.e(\"vendor-chunks/wrappy\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! pino-pretty */ \"(rsc)/./node_modules/pino-pretty/index.js\", 19));\n  return pretty.default(createPrettyConfig());\n};\nvar options = {\n  level: effectiveLogLevel,\n  // Use more restrictive level unless in debug mode\n  customLevels,\n  hooks: {\n    logMethod(inputArgs, method) {\n      const [arg1, ...rest] = inputArgs;\n      if (process.env.SENTRY_LOGGING !== \"false\") {\n        if (arg1 instanceof Error) {\n          _sentry_browser__WEBPACK_IMPORTED_MODULE_5__.captureException(arg1);\n        } else {\n          for (const item of rest) {\n            if (item instanceof Error) {\n              _sentry_browser__WEBPACK_IMPORTED_MODULE_5__.captureException(item);\n            }\n          }\n        }\n      }\n      const formatError = (err) => ({\n        message: `(${err.name}) ${err.message}`,\n        stack: err.stack?.split(\"\\n\").map((line) => line.trim())\n      });\n      if (typeof arg1 === \"object\") {\n        if (arg1 instanceof Error) {\n          method.apply(this, [\n            {\n              error: formatError(arg1)\n            }\n          ]);\n        } else {\n          const messageParts = rest.map(\n            (arg) => typeof arg === \"string\" ? arg : JSON.stringify(arg)\n          );\n          const message = messageParts.join(\" \");\n          method.apply(this, [arg1, message]);\n        }\n      } else {\n        const context = {};\n        const messageParts = [arg1, ...rest].map((arg) => {\n          if (arg instanceof Error) {\n            return formatError(arg);\n          }\n          return typeof arg === \"string\" ? arg : arg;\n        });\n        const message = messageParts.filter((part) => typeof part === \"string\").join(\" \");\n        const jsonParts = messageParts.filter((part) => typeof part === \"object\");\n        Object.assign(context, ...jsonParts);\n        method.apply(this, [context, message]);\n      }\n    }\n  }\n};\nvar createLogger = (bindings = false) => {\n  const opts = { ...options };\n  if (bindings) {\n    opts.base = bindings;\n    opts.transport = {\n      target: \"pino-pretty\",\n      // this is just a string, not a dynamic import\n      options: {\n        colorize: true,\n        translateTime: showTimestamps ? \"SYS:standard\" : false,\n        ignore: showTimestamps ? \"pid,hostname\" : \"pid,hostname,time\"\n      }\n    };\n  }\n  const logger2 = pino__WEBPACK_IMPORTED_MODULE_3__(opts);\n  return logger2;\n};\nvar logger = pino__WEBPACK_IMPORTED_MODULE_3__(options);\nif (typeof process !== \"undefined\") {\n  let stream = null;\n  if (!raw) {\n    try {\n      const pretty = __require(\"pino-pretty\");\n      stream = pretty.default ? pretty.default(createPrettyConfig()) : null;\n    } catch (e) {\n      createStream().then((prettyStream) => {\n        const destination = new InMemoryDestination(prettyStream);\n        logger = pino__WEBPACK_IMPORTED_MODULE_3__(options, destination);\n        logger[Symbol.for(\"pino-destination\")] = destination;\n        logger.clear = () => {\n          const destination2 = logger[Symbol.for(\"pino-destination\")];\n          if (destination2 instanceof InMemoryDestination) {\n            destination2.clear();\n          }\n        };\n      });\n    }\n  }\n  if (stream !== null || raw) {\n    const destination = new InMemoryDestination(stream);\n    logger = pino__WEBPACK_IMPORTED_MODULE_3__(options, destination);\n    logger[Symbol.for(\"pino-destination\")] = destination;\n    logger.clear = () => {\n      const destination2 = logger[Symbol.for(\"pino-destination\")];\n      if (destination2 instanceof InMemoryDestination) {\n        destination2.clear();\n      }\n    };\n  }\n}\nvar elizaLogger = logger;\nvar logger_default = logger;\n\n// src/utils.ts\nfunction upgradeDoubleToTriple(tpl) {\n  return tpl.replace(\n    // ────────╮ negative-LB: not already \"{{{\"\n    //          │   {{     ─ opening braces\n    //          │    ╰──── negative-LA: not {, #, /, !, >\n    //          ▼\n    /(?<!{){{(?![{#\\/!>])([\\s\\S]*?)}}/g,\n    (_match, inner) => {\n      if (inner.trim() === \"else\") return `{{${inner}}}`;\n      return `{{{${inner}}}}`;\n    }\n  );\n}\nvar composePrompt = ({\n  state,\n  template\n}) => {\n  const templateStr = typeof template === \"function\" ? template({ state }) : template;\n  const templateFunction = handlebars__WEBPACK_IMPORTED_MODULE_0__.compile(upgradeDoubleToTriple(templateStr));\n  const output = composeRandomUser(templateFunction(state), 10);\n  return output;\n};\nvar composePromptFromState = ({\n  state,\n  template\n}) => {\n  const templateStr = typeof template === \"function\" ? template({ state }) : template;\n  const templateFunction = handlebars__WEBPACK_IMPORTED_MODULE_0__.compile(upgradeDoubleToTriple(templateStr));\n  const stateKeys = Object.keys(state);\n  const filteredKeys = stateKeys.filter((key) => ![\"text\", \"values\", \"data\"].includes(key));\n  const filteredState = filteredKeys.reduce((acc, key) => {\n    acc[key] = state[key];\n    return acc;\n  }, {});\n  const output = composeRandomUser(templateFunction({ ...filteredState, ...state.values }), 10);\n  return output;\n};\nvar addHeader = (header, body) => {\n  return body.length > 0 ? `${header ? `${header}\n` : header}${body}\n` : \"\";\n};\nvar composeRandomUser = (template, length) => {\n  const exampleNames = Array.from(\n    { length },\n    () => (0,unique_names_generator__WEBPACK_IMPORTED_MODULE_6__.uniqueNamesGenerator)({ dictionaries: [unique_names_generator__WEBPACK_IMPORTED_MODULE_6__.names] })\n  );\n  let result = template;\n  for (let i = 0; i < exampleNames.length; i++) {\n    result = result.replaceAll(`{{name${i + 1}}}`, exampleNames[i]);\n  }\n  return result;\n};\nvar formatPosts = ({\n  messages,\n  entities,\n  conversationHeader = true\n}) => {\n  const groupedMessages = {};\n  messages.forEach((message) => {\n    if (message.roomId) {\n      if (!groupedMessages[message.roomId]) {\n        groupedMessages[message.roomId] = [];\n      }\n      groupedMessages[message.roomId].push(message);\n    }\n  });\n  Object.values(groupedMessages).forEach((roomMessages) => {\n    roomMessages.sort((a, b) => a.createdAt - b.createdAt);\n  });\n  const sortedRooms = Object.entries(groupedMessages).sort(\n    ([, messagesA], [, messagesB]) => messagesB[messagesB.length - 1].createdAt - messagesA[messagesA.length - 1].createdAt\n  );\n  const formattedPosts = sortedRooms.map(([roomId, roomMessages]) => {\n    const messageStrings = roomMessages.filter((message) => message.entityId).map((message) => {\n      const entity = entities.find((entity2) => entity2.id === message.entityId);\n      if (!entity) {\n        logger_default.warn({ entityId: message.entityId }, \"core::prompts:formatPosts - no entity for\");\n      }\n      const userName = entity?.names[0] || \"Unknown User\";\n      const displayName = entity?.names[0] || \"unknown\";\n      return `Name: ${userName} (@${displayName} EntityID:${message.entityId})\nMessageID: ${message.id}${message.content.inReplyTo ? `\nIn reply to: ${message.content.inReplyTo}` : \"\"}\nSource: ${message.content.source}\nDate: ${formatTimestamp(message.createdAt)}\nText:\n${message.content.text}`;\n    });\n    const header = conversationHeader ? `Conversation: ${roomId.slice(-5)}\n` : \"\";\n    return `${header}${messageStrings.join(\"\\n\\n\")}`;\n  });\n  return formattedPosts.join(\"\\n\\n\");\n};\nvar formatMessages = ({\n  messages,\n  entities\n}) => {\n  const messageStrings = messages.reverse().filter((message) => message.entityId).map((message) => {\n    const messageText = message.content.text;\n    const messageActions = message.content.actions;\n    const messageThought = message.content.thought;\n    const formattedName = entities.find((entity) => entity.id === message.entityId)?.names[0] || \"Unknown User\";\n    const attachments = message.content.attachments;\n    const attachmentString = attachments && attachments.length > 0 ? ` (Attachments: ${attachments.map((media) => {\n      const lines = [`[${media.id} - ${media.title} (${media.url})]`];\n      if (media.text) lines.push(`Text: ${media.text}`);\n      if (media.description) lines.push(`Description: ${media.description}`);\n      return lines.join(\"\\n\");\n    }).join(\n      // Use comma separator only if all attachments are single-line (no text/description)\n      attachments.every((media) => !media.text && !media.description) ? \", \" : \"\\n\"\n    )})` : null;\n    const messageTime = new Date(message.createdAt);\n    const hours = messageTime.getHours().toString().padStart(2, \"0\");\n    const minutes = messageTime.getMinutes().toString().padStart(2, \"0\");\n    const timeString = `${hours}:${minutes}`;\n    const timestamp = formatTimestamp(message.createdAt);\n    const thoughtString = messageThought ? `(${formattedName}'s internal thought: ${messageThought})` : null;\n    const timestampString = `${timeString} (${timestamp}) [${message.entityId}]`;\n    const textString = messageText ? `${timestampString} ${formattedName}: ${messageText}` : null;\n    const actionString = messageActions && messageActions.length > 0 ? `${textString ? \"\" : timestampString} (${formattedName}'s actions: ${messageActions.join(\", \")})` : null;\n    const messageString = [textString, thoughtString, actionString, attachmentString].filter(Boolean).join(\"\\n\");\n    return messageString;\n  }).join(\"\\n\");\n  return messageStrings;\n};\nvar formatTimestamp = (messageDate) => {\n  const now = /* @__PURE__ */ new Date();\n  const diff = now.getTime() - messageDate;\n  const absDiff = Math.abs(diff);\n  const seconds = Math.floor(absDiff / 1e3);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n  if (absDiff < 6e4) {\n    return \"just now\";\n  }\n  if (minutes < 60) {\n    return `${minutes} minute${minutes !== 1 ? \"s\" : \"\"} ago`;\n  }\n  if (hours < 24) {\n    return `${hours} hour${hours !== 1 ? \"s\" : \"\"} ago`;\n  }\n  return `${days} day${days !== 1 ? \"s\" : \"\"} ago`;\n};\nvar jsonBlockPattern = /```json\\n([\\s\\S]*?)\\n```/;\nfunction parseKeyValueXml(text) {\n  if (!text) return null;\n  let xmlBlockMatch = text.match(/<response>([\\s\\S]*?)<\\/response>/);\n  let xmlContent;\n  if (xmlBlockMatch) {\n    xmlContent = xmlBlockMatch[1];\n    logger_default.debug(\"Found response XML block\");\n  } else {\n    const findFirstXmlBlock = (input) => {\n      let i = 0;\n      const length = input.length;\n      while (i < length) {\n        const openIdx = input.indexOf(\"<\", i);\n        if (openIdx === -1) break;\n        if (input.startsWith(\"</\", openIdx) || input.startsWith(\"<!--\", openIdx) || input.startsWith(\"<?\", openIdx)) {\n          i = openIdx + 1;\n          continue;\n        }\n        let j = openIdx + 1;\n        let tag = \"\";\n        while (j < length) {\n          const ch = input[j];\n          if (/^[A-Za-z0-9_-]$/.test(ch)) {\n            tag += ch;\n            j++;\n            continue;\n          }\n          break;\n        }\n        if (!tag) {\n          i = openIdx + 1;\n          continue;\n        }\n        const startTagEnd = input.indexOf(\">\", j);\n        if (startTagEnd === -1) break;\n        const startTagText = input.slice(openIdx, startTagEnd + 1);\n        if (/\\/\\s*>$/.test(startTagText)) {\n          i = startTagEnd + 1;\n          continue;\n        }\n        const closeSeq = `</${tag}>`;\n        let depth = 1;\n        let searchStart = startTagEnd + 1;\n        while (depth > 0 && searchStart < length) {\n          const nextOpen = input.indexOf(`<${tag}`, searchStart);\n          const nextClose = input.indexOf(closeSeq, searchStart);\n          if (nextClose === -1) {\n            break;\n          }\n          if (nextOpen !== -1 && nextOpen < nextClose) {\n            const nestedStartEnd = input.indexOf(\">\", nextOpen + 1);\n            if (nestedStartEnd === -1) {\n              break;\n            }\n            const nestedStartText = input.slice(nextOpen, nestedStartEnd + 1);\n            if (/\\/\\s*>$/.test(nestedStartText)) {\n              searchStart = nestedStartEnd + 1;\n            } else {\n              depth++;\n              searchStart = nestedStartEnd + 1;\n            }\n          } else {\n            depth--;\n            searchStart = nextClose + closeSeq.length;\n          }\n        }\n        if (depth === 0) {\n          const closeIdx = searchStart - closeSeq.length;\n          const inner = input.slice(startTagEnd + 1, closeIdx);\n          return { tag, content: inner };\n        }\n        i = startTagEnd + 1;\n      }\n      return null;\n    };\n    const fb = findFirstXmlBlock(text);\n    if (!fb) {\n      logger_default.warn(\"Could not find XML block in text\");\n      logger_default.debug({ textPreview: text.substring(0, 200) + \"...\" }, \"Text content\");\n      return null;\n    }\n    xmlContent = fb.content;\n    logger_default.debug(`Found XML block with tag: ${fb.tag}`);\n  }\n  const result = {};\n  const extractDirectChildren = (input) => {\n    const pairs = [];\n    const length = input.length;\n    let i = 0;\n    while (i < length) {\n      const openIdx = input.indexOf(\"<\", i);\n      if (openIdx === -1) break;\n      if (input.startsWith(\"</\", openIdx) || input.startsWith(\"<!--\", openIdx) || input.startsWith(\"<?\", openIdx)) {\n        i = openIdx + 1;\n        continue;\n      }\n      let j = openIdx + 1;\n      let tag = \"\";\n      while (j < length) {\n        const ch = input[j];\n        if (/^[A-Za-z0-9_-]$/.test(ch)) {\n          tag += ch;\n          j++;\n          continue;\n        }\n        break;\n      }\n      if (!tag) {\n        i = openIdx + 1;\n        continue;\n      }\n      const startTagEnd = input.indexOf(\">\", j);\n      if (startTagEnd === -1) break;\n      const startTagText = input.slice(openIdx, startTagEnd + 1);\n      if (/\\/\\s*>$/.test(startTagText)) {\n        i = startTagEnd + 1;\n        continue;\n      }\n      const closeSeq = `</${tag}>`;\n      let depth = 1;\n      let searchStart = startTagEnd + 1;\n      while (depth > 0 && searchStart < length) {\n        const nextOpen = input.indexOf(`<${tag}`, searchStart);\n        const nextClose = input.indexOf(closeSeq, searchStart);\n        if (nextClose === -1) {\n          break;\n        }\n        if (nextOpen !== -1 && nextOpen < nextClose) {\n          const nestedStartEnd = input.indexOf(\">\", nextOpen + 1);\n          if (nestedStartEnd === -1) {\n            break;\n          }\n          const nestedStartText = input.slice(nextOpen, nestedStartEnd + 1);\n          if (!/\\/\\s*>$/.test(nestedStartText)) {\n            depth++;\n          }\n          searchStart = nestedStartEnd + 1;\n        } else {\n          depth--;\n          searchStart = nextClose + closeSeq.length;\n        }\n      }\n      if (depth !== 0) {\n        i = startTagEnd + 1;\n        continue;\n      }\n      const closeIdx = searchStart - closeSeq.length;\n      const innerRaw = input.slice(startTagEnd + 1, closeIdx);\n      const unescaped = innerRaw.replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\").replace(/&amp;/g, \"&\").replace(/&quot;/g, '\"').replace(/&apos;/g, \"'\").trim();\n      pairs.push({ key: tag, value: unescaped });\n      i = searchStart;\n    }\n    return pairs;\n  };\n  const children = extractDirectChildren(xmlContent);\n  for (const { key, value } of children) {\n    if (key === \"actions\" || key === \"providers\" || key === \"evaluators\") {\n      result[key] = value ? value.split(\",\").map((s) => s.trim()) : [];\n    } else if (key === \"simple\") {\n      result[key] = value.toLowerCase() === \"true\";\n    } else {\n      result[key] = value;\n    }\n  }\n  if (Object.keys(result).length === 0) {\n    logger_default.warn(\"No key-value pairs extracted from XML content\");\n    logger_default.debug({ xmlPreview: xmlContent.substring(0, 200) + \"...\" }, \"XML content was\");\n    return null;\n  }\n  return result;\n}\nfunction parseJSONObjectFromText(text) {\n  let jsonData = null;\n  const jsonBlockMatch = text.match(jsonBlockPattern);\n  try {\n    if (jsonBlockMatch) {\n      jsonData = JSON.parse(normalizeJsonString(jsonBlockMatch[1].trim()));\n    } else {\n      jsonData = JSON.parse(normalizeJsonString(text.trim()));\n    }\n  } catch (_e) {\n    return null;\n  }\n  if (jsonData && typeof jsonData === \"object\" && !Array.isArray(jsonData)) {\n    return jsonData;\n  }\n  return null;\n}\nvar normalizeJsonString = (str) => {\n  str = str.replace(/\\{\\s+/, \"{\").replace(/\\s+\\}/, \"}\").trim();\n  str = str.replace(/(\"[\\w\\d_-]+\")\\s*: \\s*(?!\"|\\[)([\\s\\S]+?)(?=(,\\s*\"|\\}$))/g, '$1: \"$2\"');\n  str = str.replace(/\"([^\"]+)\"\\s*:\\s*'([^']*)'/g, (_, key, value) => `\"${key}\": \"${value}\"`);\n  str = str.replace(/(\"[\\w\\d_-]+\")\\s*:\\s*([A-Za-z_]+)(?![\"\\w])/g, '$1: \"$2\"');\n  return str;\n};\nfunction truncateToCompleteSentence(text, maxLength) {\n  if (text.length <= maxLength) {\n    return text;\n  }\n  const lastPeriodIndex = text.lastIndexOf(\".\", maxLength - 1);\n  if (lastPeriodIndex !== -1) {\n    const truncatedAtPeriod = text.slice(0, lastPeriodIndex + 1).trim();\n    if (truncatedAtPeriod.length > 0) {\n      return truncatedAtPeriod;\n    }\n  }\n  const lastSpaceIndex = text.lastIndexOf(\" \", maxLength - 1);\n  if (lastSpaceIndex !== -1) {\n    const truncatedAtSpace = text.slice(0, lastSpaceIndex).trim();\n    if (truncatedAtSpace.length > 0) {\n      return `${truncatedAtSpace}...`;\n    }\n  }\n  const hardTruncated = text.slice(0, maxLength - 3).trim();\n  return `${hardTruncated}...`;\n}\nasync function splitChunks(content, chunkSize = 512, bleed = 20) {\n  logger_default.debug(\"[splitChunks] Starting text split\");\n  const characterstoTokens = 3.5;\n  const textSplitter = new langchain_text_splitter__WEBPACK_IMPORTED_MODULE_2__.RecursiveCharacterTextSplitter({\n    chunkSize: Number(Math.floor(chunkSize * characterstoTokens)),\n    chunkOverlap: Number(Math.floor(bleed * characterstoTokens))\n  });\n  const chunks = await textSplitter.splitText(content);\n  logger_default.debug(\n    {\n      numberOfChunks: chunks.length,\n      averageChunkSize: chunks.reduce((acc, chunk) => acc + chunk.length, 0) / chunks.length\n    },\n    \"[splitChunks] Split complete\"\n  );\n  return chunks;\n}\nasync function trimTokens(prompt, maxTokens, runtime) {\n  if (!prompt) throw new Error(\"Trim tokens received a null prompt\");\n  if (prompt.length < maxTokens / 5) return prompt;\n  if (maxTokens <= 0) throw new Error(\"maxTokens must be positive\");\n  const tokens = await runtime.useModel(ModelType.TEXT_TOKENIZER_ENCODE, {\n    prompt\n  });\n  if (tokens.length <= maxTokens) {\n    return prompt;\n  }\n  const truncatedTokens = tokens.slice(-maxTokens);\n  return await runtime.useModel(ModelType.TEXT_TOKENIZER_DECODE, {\n    tokens: truncatedTokens\n  });\n}\nfunction safeReplacer() {\n  const seen = /* @__PURE__ */ new WeakSet();\n  return function(_key, value) {\n    if (typeof value === \"object\" && value !== null) {\n      if (seen.has(value)) {\n        return \"[Circular]\";\n      }\n      seen.add(value);\n    }\n    return value;\n  };\n}\nfunction parseBooleanFromText2(value) {\n  if (!value) return false;\n  const affirmative = [\"YES\", \"Y\", \"TRUE\", \"T\", \"1\", \"ON\", \"ENABLE\"];\n  const negative = [\"NO\", \"N\", \"FALSE\", \"F\", \"0\", \"OFF\", \"DISABLE\"];\n  const normalizedText = value.trim().toUpperCase();\n  if (affirmative.includes(normalizedText)) {\n    return true;\n  }\n  if (negative.includes(normalizedText)) {\n    return false;\n  }\n  return false;\n}\nvar uuidSchema = zod__WEBPACK_IMPORTED_MODULE_7__.string().uuid();\nfunction validateUuid(value) {\n  const result = uuidSchema.safeParse(value);\n  return result.success ? result.data : null;\n}\nfunction stringToUuid(target) {\n  if (typeof target === \"number\") {\n    target = target.toString();\n  }\n  if (typeof target !== \"string\") {\n    throw TypeError(\"Value must be string\");\n  }\n  const _uint8ToHex = (ubyte) => {\n    const first = ubyte >> 4;\n    const second = ubyte - (first << 4);\n    const HEX_DIGITS = \"0123456789abcdef\".split(\"\");\n    return HEX_DIGITS[first] + HEX_DIGITS[second];\n  };\n  const _uint8ArrayToHex = (buf) => {\n    let out = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      out += _uint8ToHex(buf[i]);\n    }\n    return out;\n  };\n  const escapedStr = encodeURIComponent(target);\n  const buffer = new Uint8Array(escapedStr.length);\n  for (let i = 0; i < escapedStr.length; i++) {\n    buffer[i] = escapedStr[i].charCodeAt(0);\n  }\n  const hash = (0,js_sha1__WEBPACK_IMPORTED_MODULE_1__.sha1)(buffer);\n  const hashBuffer = new Uint8Array(hash.length / 2);\n  for (let i = 0; i < hash.length; i += 2) {\n    hashBuffer[i / 2] = Number.parseInt(hash.slice(i, i + 2), 16);\n  }\n  return `${_uint8ArrayToHex(hashBuffer.slice(0, 4))}-${_uint8ArrayToHex(hashBuffer.slice(4, 6))}-${_uint8ToHex(hashBuffer[6] & 15)}${_uint8ToHex(hashBuffer[7])}-${_uint8ToHex(hashBuffer[8] & 63 | 128)}${_uint8ToHex(hashBuffer[9])}-${_uint8ArrayToHex(hashBuffer.slice(10, 16))}`;\n}\nvar getContentTypeFromMimeType = (mimeType) => {\n  if (mimeType.startsWith(\"image/\")) return \"image\" /* IMAGE */;\n  if (mimeType.startsWith(\"video/\")) return \"video\" /* VIDEO */;\n  if (mimeType.startsWith(\"audio/\")) return \"audio\" /* AUDIO */;\n  if (mimeType.includes(\"pdf\") || mimeType.includes(\"document\") || mimeType.startsWith(\"text/\")) {\n    return \"document\" /* DOCUMENT */;\n  }\n  return void 0;\n};\nfunction getLocalServerUrl(path) {\n  const port = process.env.SERVER_PORT || \"3000\";\n  return `http://localhost:${port}${path}`;\n}\n\n// src/schemas/character.ts\n\nvar uuidSchema2 = zod__WEBPACK_IMPORTED_MODULE_7__.string().regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i, \"Invalid UUID format\");\nvar contentSchema = zod__WEBPACK_IMPORTED_MODULE_7__.object({\n  text: zod__WEBPACK_IMPORTED_MODULE_7__.string().optional(),\n  thought: zod__WEBPACK_IMPORTED_MODULE_7__.string().optional(),\n  actions: zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.string()).optional(),\n  providers: zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.string()).optional(),\n  source: zod__WEBPACK_IMPORTED_MODULE_7__.string().optional(),\n  target: zod__WEBPACK_IMPORTED_MODULE_7__.string().optional(),\n  url: zod__WEBPACK_IMPORTED_MODULE_7__.string().optional(),\n  inReplyTo: uuidSchema2.optional(),\n  attachments: zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.any()).optional(),\n  channelType: zod__WEBPACK_IMPORTED_MODULE_7__.string().optional()\n}).passthrough();\nvar messageExampleSchema = zod__WEBPACK_IMPORTED_MODULE_7__.object({\n  name: zod__WEBPACK_IMPORTED_MODULE_7__.string(),\n  content: contentSchema\n});\nvar directoryItemSchema = zod__WEBPACK_IMPORTED_MODULE_7__.object({\n  directory: zod__WEBPACK_IMPORTED_MODULE_7__.string(),\n  shared: zod__WEBPACK_IMPORTED_MODULE_7__.boolean().optional()\n});\nvar knowledgeItemSchema = zod__WEBPACK_IMPORTED_MODULE_7__.union([\n  zod__WEBPACK_IMPORTED_MODULE_7__.string(),\n  zod__WEBPACK_IMPORTED_MODULE_7__.object({\n    path: zod__WEBPACK_IMPORTED_MODULE_7__.string(),\n    shared: zod__WEBPACK_IMPORTED_MODULE_7__.boolean().optional()\n  }),\n  directoryItemSchema\n]);\nvar templateTypeSchema = zod__WEBPACK_IMPORTED_MODULE_7__.union([\n  zod__WEBPACK_IMPORTED_MODULE_7__.string(),\n  zod__WEBPACK_IMPORTED_MODULE_7__[\"function\"]().optional()\n  // Functions won't be in JSON but allowed in runtime\n]);\nvar styleSchema = zod__WEBPACK_IMPORTED_MODULE_7__.object({\n  all: zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.string()).optional(),\n  chat: zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.string()).optional(),\n  post: zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.string()).optional()\n}).optional();\nvar settingsSchema = zod__WEBPACK_IMPORTED_MODULE_7__.record(zod__WEBPACK_IMPORTED_MODULE_7__.union([zod__WEBPACK_IMPORTED_MODULE_7__.string(), zod__WEBPACK_IMPORTED_MODULE_7__.boolean(), zod__WEBPACK_IMPORTED_MODULE_7__.number(), zod__WEBPACK_IMPORTED_MODULE_7__.any()])).optional();\nvar secretsSchema = zod__WEBPACK_IMPORTED_MODULE_7__.record(zod__WEBPACK_IMPORTED_MODULE_7__.union([zod__WEBPACK_IMPORTED_MODULE_7__.string(), zod__WEBPACK_IMPORTED_MODULE_7__.boolean(), zod__WEBPACK_IMPORTED_MODULE_7__.number()])).optional();\nvar characterSchema = zod__WEBPACK_IMPORTED_MODULE_7__.object({\n  id: uuidSchema2.optional(),\n  name: zod__WEBPACK_IMPORTED_MODULE_7__.string().min(1, \"Character name is required\"),\n  username: zod__WEBPACK_IMPORTED_MODULE_7__.string().optional(),\n  system: zod__WEBPACK_IMPORTED_MODULE_7__.string().optional(),\n  templates: zod__WEBPACK_IMPORTED_MODULE_7__.record(templateTypeSchema).optional(),\n  bio: zod__WEBPACK_IMPORTED_MODULE_7__.union([zod__WEBPACK_IMPORTED_MODULE_7__.string(), zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.string())]),\n  messageExamples: zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.array(messageExampleSchema)).optional(),\n  postExamples: zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.string()).optional(),\n  topics: zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.string()).optional(),\n  adjectives: zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.string()).optional(),\n  knowledge: zod__WEBPACK_IMPORTED_MODULE_7__.array(knowledgeItemSchema).optional(),\n  plugins: zod__WEBPACK_IMPORTED_MODULE_7__.array(zod__WEBPACK_IMPORTED_MODULE_7__.string()).optional(),\n  settings: settingsSchema,\n  secrets: secretsSchema,\n  style: styleSchema\n}).strict();\nfunction validateCharacter(data) {\n  const result = characterSchema.safeParse(data);\n  if (result.success) {\n    return {\n      success: true,\n      data: result.data\n    };\n  }\n  return {\n    success: false,\n    error: {\n      message: `Character validation failed: ${result.error.message}`,\n      issues: result.error.issues\n    }\n  };\n}\nfunction parseAndValidateCharacter(jsonString) {\n  try {\n    const parsed = JSON.parse(jsonString);\n    return validateCharacter(parsed);\n  } catch (error) {\n    return {\n      success: false,\n      error: {\n        message: `Invalid JSON: ${error instanceof Error ? error.message : \"Unknown JSON parsing error\"}`\n      }\n    };\n  }\n}\nfunction isValidCharacter(data) {\n  return validateCharacter(data).success;\n}\n\n// src/actions.ts\n\nvar composeActionExamples = (actionsData, count) => {\n  if (!actionsData.length || count <= 0) {\n    return \"\";\n  }\n  const actionsWithExamples = actionsData.filter(\n    (action) => action.examples && Array.isArray(action.examples) && action.examples.length > 0\n  );\n  if (!actionsWithExamples.length) {\n    return \"\";\n  }\n  const examplesCopy = actionsWithExamples.map((action) => [\n    ...action.examples\n  ]);\n  const selectedExamples = [];\n  let availableActionIndices = examplesCopy.map((examples, index) => examples.length > 0 ? index : -1).filter((index) => index !== -1);\n  while (selectedExamples.length < count && availableActionIndices.length > 0) {\n    const randomIndex = Math.floor(Math.random() * availableActionIndices.length);\n    const actionIndex = availableActionIndices[randomIndex];\n    const examples = examplesCopy[actionIndex];\n    const exampleIndex = Math.floor(Math.random() * examples.length);\n    selectedExamples.push(examples.splice(exampleIndex, 1)[0]);\n    if (examples.length === 0) {\n      availableActionIndices.splice(randomIndex, 1);\n    }\n  }\n  return formatSelectedExamples(selectedExamples);\n};\nvar formatSelectedExamples = (examples) => {\n  const MAX_NAME_PLACEHOLDERS = 5;\n  return examples.map((example) => {\n    const randomNames = Array.from(\n      { length: MAX_NAME_PLACEHOLDERS },\n      () => (0,unique_names_generator__WEBPACK_IMPORTED_MODULE_6__.uniqueNamesGenerator)({ dictionaries: [unique_names_generator__WEBPACK_IMPORTED_MODULE_6__.names] })\n    );\n    const conversation = example.map((message) => {\n      let messageText = `${message.name}: ${message.content.text}`;\n      for (let i = 0; i < randomNames.length; i++) {\n        messageText = messageText.replaceAll(`{{name${i + 1}}}`, randomNames[i]);\n      }\n      return messageText;\n    }).join(\"\\n\");\n    return `\n${conversation}`;\n  }).join(\"\\n\");\n};\nfunction formatActionNames(actions) {\n  if (!actions?.length) return \"\";\n  return [...actions].sort(() => Math.random() - 0.5).map((action) => action.name).join(\", \");\n}\nfunction formatActions(actions) {\n  if (!actions?.length) return \"\";\n  return [...actions].sort(() => Math.random() - 0.5).map((action) => `- **${action.name}**: ${action.description || \"No description available\"}`).join(\"\\n\");\n}\n\n// src/database.ts\nvar DatabaseAdapter = class {\n};\n\n// src/entities.ts\nvar entityResolutionTemplate = `# Task: Resolve Entity Name\nMessage Sender: {{senderName}} (ID: {{senderId}})\nAgent: {{agentName}} (ID: {{agentId}})\n\n# Entities in Room:\n{{#if entitiesInRoom}}\n{{entitiesInRoom}}\n{{/if}}\n\n{{recentMessages}}\n\n# Instructions:\n1. Analyze the context to identify which entity is being referenced\n2. Consider special references like \"me\" (the message sender) or \"you\" (agent the message is directed to)\n3. Look for usernames/handles in standard formats (e.g. @username, user#1234)\n4. Consider context from recent messages for pronouns and references\n5. If multiple matches exist, use context to disambiguate\n6. Consider recent interactions and relationship strength when resolving ambiguity\n\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nReturn an XML response with:\n<response>\n  <entityId>exact-id-if-known-otherwise-null</entityId>\n  <type>EXACT_MATCH | USERNAME_MATCH | NAME_MATCH | RELATIONSHIP_MATCH | AMBIGUOUS | UNKNOWN</type>\n  <matches>\n    <match>\n      <name>matched-name</name>\n      <reason>why this entity matches</reason>\n    </match>\n  </matches>\n</response>\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.`;\nasync function getRecentInteractions(runtime, sourceEntityId, candidateEntities, roomId, relationships) {\n  const results = [];\n  const recentMessages = await runtime.getMemories({\n    tableName: \"messages\",\n    roomId,\n    count: 20\n    // Reduced from 100 since we only need context\n  });\n  for (const entity of candidateEntities) {\n    const interactions = [];\n    let interactionScore = 0;\n    const directReplies = recentMessages.filter(\n      (msg) => msg.entityId === sourceEntityId && msg.content.inReplyTo === entity.id || msg.entityId === entity.id && msg.content.inReplyTo === sourceEntityId\n    );\n    interactions.push(...directReplies);\n    const relationship = relationships.find(\n      (rel) => rel.sourceEntityId === sourceEntityId && rel.targetEntityId === entity.id || rel.targetEntityId === sourceEntityId && rel.sourceEntityId === entity.id\n    );\n    if (relationship?.metadata?.interactions) {\n      interactionScore = relationship.metadata.interactions;\n    }\n    interactionScore += directReplies.length;\n    const uniqueInteractions = [...new Set(interactions)];\n    results.push({\n      entity,\n      interactions: uniqueInteractions.slice(-5),\n      // Only keep last 5 messages for context\n      count: Math.round(interactionScore)\n    });\n  }\n  return results.sort((a, b) => b.count - a.count);\n}\nasync function findEntityByName(runtime, message, state) {\n  const room = state.data.room ?? await runtime.getRoom(message.roomId);\n  if (!room) {\n    logger.warn(\"Room not found for entity search\");\n    return null;\n  }\n  const world = room.worldId ? await runtime.getWorld(room.worldId) : null;\n  const entitiesInRoom = await runtime.getEntitiesForRoom(room.id, true);\n  const filteredEntities = await Promise.all(\n    entitiesInRoom.map(async (entity) => {\n      if (!entity.components) return entity;\n      const worldRoles = world?.metadata?.roles || {};\n      entity.components = entity.components.filter((component) => {\n        if (component.sourceEntityId === message.entityId) return true;\n        if (world && component.sourceEntityId) {\n          const sourceRole = worldRoles[component.sourceEntityId];\n          if (sourceRole === \"OWNER\" || sourceRole === \"ADMIN\") return true;\n        }\n        if (component.sourceEntityId === runtime.agentId) return true;\n        return false;\n      });\n      return entity;\n    })\n  );\n  const relationships = await runtime.getRelationships({\n    entityId: message.entityId\n  });\n  const relationshipEntities = await Promise.all(\n    relationships.map(async (rel) => {\n      const entityId = rel.sourceEntityId === message.entityId ? rel.targetEntityId : rel.sourceEntityId;\n      return runtime.getEntityById(entityId);\n    })\n  );\n  const allEntities = [\n    ...filteredEntities,\n    ...relationshipEntities.filter((e) => e !== null)\n  ];\n  const interactionData = await getRecentInteractions(\n    runtime,\n    message.entityId,\n    allEntities,\n    room.id,\n    relationships\n  );\n  const prompt = composePrompt({\n    state: {\n      roomName: room.name || room.id,\n      worldName: world?.name || \"Unknown\",\n      entitiesInRoom: JSON.stringify(filteredEntities, null, 2),\n      entityId: message.entityId,\n      senderId: message.entityId\n    },\n    template: entityResolutionTemplate\n  });\n  const result = await runtime.useModel(ModelType.TEXT_SMALL, {\n    prompt,\n    stopSequences: []\n  });\n  const resolution = parseKeyValueXml(result);\n  if (!resolution) {\n    logger.warn(\"Failed to parse entity resolution result\");\n    return null;\n  }\n  if (resolution.type === \"EXACT_MATCH\" && resolution.entityId) {\n    const entity = await runtime.getEntityById(resolution.entityId);\n    if (entity) {\n      if (entity.components) {\n        const worldRoles = world?.metadata?.roles || {};\n        entity.components = entity.components.filter((component) => {\n          if (component.sourceEntityId === message.entityId) return true;\n          if (world && component.sourceEntityId) {\n            const sourceRole = worldRoles[component.sourceEntityId];\n            if (sourceRole === \"OWNER\" || sourceRole === \"ADMIN\") return true;\n          }\n          if (component.sourceEntityId === runtime.agentId) return true;\n          return false;\n        });\n      }\n      return entity;\n    }\n  }\n  let matchesArray = [];\n  if (resolution.matches?.match) {\n    matchesArray = Array.isArray(resolution.matches.match) ? resolution.matches.match : [resolution.matches.match];\n  }\n  if (matchesArray.length > 0 && matchesArray[0]?.name) {\n    const matchName = matchesArray[0].name.toLowerCase();\n    const matchingEntity = allEntities.find((entity) => {\n      if (entity.names.some((n) => n.toLowerCase() === matchName)) return true;\n      return entity.components?.some(\n        (c) => c.data.username?.toLowerCase() === matchName || c.data.handle?.toLowerCase() === matchName\n      );\n    });\n    if (matchingEntity) {\n      if (resolution.type === \"RELATIONSHIP_MATCH\") {\n        const interactionInfo = interactionData.find((d) => d.entity.id === matchingEntity.id);\n        if (interactionInfo && interactionInfo.count > 0) {\n          return matchingEntity;\n        }\n      } else {\n        return matchingEntity;\n      }\n    }\n  }\n  return null;\n}\nvar createUniqueUuid = (runtime, baseUserId) => {\n  if (baseUserId === runtime.agentId) {\n    return runtime.agentId;\n  }\n  const combinedString = `${baseUserId}:${runtime.agentId}`;\n  return stringToUuid(combinedString);\n};\nasync function getEntityDetails({\n  runtime,\n  roomId\n}) {\n  const [room, roomEntities] = await Promise.all([\n    runtime.getRoom(roomId),\n    runtime.getEntitiesForRoom(roomId, true)\n  ]);\n  const uniqueEntities = /* @__PURE__ */ new Map();\n  for (const entity of roomEntities) {\n    if (uniqueEntities.has(entity.id)) continue;\n    const allData = {};\n    for (const component of entity.components || []) {\n      Object.assign(allData, component.data);\n    }\n    const mergedData = {};\n    for (const [key, value] of Object.entries(allData)) {\n      if (!mergedData[key]) {\n        mergedData[key] = value;\n        continue;\n      }\n      if (Array.isArray(mergedData[key]) && Array.isArray(value)) {\n        mergedData[key] = [.../* @__PURE__ */ new Set([...mergedData[key], ...value])];\n      } else if (typeof mergedData[key] === \"object\" && typeof value === \"object\") {\n        mergedData[key] = { ...mergedData[key], ...value };\n      }\n    }\n    uniqueEntities.set(entity.id, {\n      id: entity.id,\n      name: room?.source ? entity.metadata[room.source]?.name || entity.names[0] : entity.names[0],\n      names: entity.names,\n      data: JSON.stringify({ ...mergedData, ...entity.metadata })\n    });\n  }\n  return Array.from(uniqueEntities.values());\n}\nfunction formatEntities({ entities }) {\n  const entityStrings = entities.map((entity) => {\n    const header = `\"${entity.names.join('\" aka \"')}\"\nID: ${entity.id}${entity.metadata && Object.keys(entity.metadata).length > 0 ? `\nData: ${JSON.stringify(entity.metadata)}\n` : \"\\n\"}`;\n    return header;\n  });\n  return entityStrings.join(\"\\n\");\n}\n\n// src/prompts.ts\nvar shouldRespondTemplate = `<task>Decide on behalf of {{agentName}} whether they should respond to the message, ignore it or stop the conversation.</task>\n\n<providers>\n{{providers}}\n</providers>\n\n<instructions>Decide if {{agentName}} should respond to or interact with the conversation.\nIf the message is directed at or relevant to {{agentName}}, respond with RESPOND action.\nIf a user asks {{agentName}} to be quiet, respond with STOP action.\nIf {{agentName}} should ignore the message, respond with IGNORE action.</instructions>\n\n<output>\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nRespond using XML format like this:\n<response>\n  <name>{{agentName}}</name>\n  <reasoning>Your reasoning here</reasoning>\n  <action>RESPOND | IGNORE | STOP</action>\n</response>\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.\n</output>`;\nvar messageHandlerTemplate = `<task>Generate dialog and actions for the character {{agentName}}.</task>\n\n<providers>\n{{providers}}\n</providers>\n\nThese are the available valid actions:\n<actionNames>\n{{actionNames}}\n</actionNames>\n\n<instructions>\nWrite a thought and plan for {{agentName}} and decide what actions to take. Also include the providers that {{agentName}} will use to have the right context for responding and acting, if any.\n\nIMPORTANT ACTION ORDERING RULES:\n- Actions are executed in the ORDER you list them - the order MATTERS!\n- REPLY should come FIRST to acknowledge the user's request before executing other actions\n- Common patterns:\n  - For requests requiring tool use: REPLY,CALL_MCP_TOOL (acknowledge first, then gather info)\n  - For task execution: REPLY,SEND_MESSAGE or REPLY,EVM_SWAP_TOKENS (acknowledge first, then do the task)\n  - For multi-step operations: REPLY,ACTION1,ACTION2 (acknowledge first, then complete all steps)\n- REPLY is used to acknowledge and inform the user about what you're going to do\n- Follow-up actions execute the actual tasks after acknowledgment\n- Use IGNORE only when you should not respond at all\n- If you use IGNORE, do not include any other actions. IGNORE should be used alone when you should not respond or take any actions.\n\nIMPORTANT PROVIDER SELECTION RULES:\n- Only include providers if they are needed to respond accurately.\n- If the message mentions images, photos, pictures, attachments, or visual content, OR if you see \"(Attachments:\" in the conversation, you MUST include \"ATTACHMENTS\" in your providers list\n- If the message asks about or references specific people, include \"ENTITIES\" in your providers list  \n- If the message asks about relationships or connections between people, include \"RELATIONSHIPS\" in your providers list\n- If the message asks about facts or specific information, include \"FACTS\" in your providers list\n- If the message asks about the environment or world context, include \"WORLD\" in your providers list\n- If no additional context is needed, you may leave the providers list empty.\n\nIMPORTANT CODE BLOCK FORMATTING RULES:\n- If {{agentName}} includes code examples, snippets, or multi-line code in the response, ALWAYS wrap the code with \\`\\`\\` fenced code blocks (specify the language if known, e.g., \\`\\`\\`python).\n- ONLY use fenced code blocks for actual code. Do NOT wrap non-code text, instructions, or single words in fenced code blocks.\n- If including inline code (short single words or function names), use single backticks (\\`) as appropriate.\n- This ensures the user sees clearly formatted and copyable code when relevant.\n\nFirst, think about what you want to do next and plan your actions. Then, write the next message and include the actions you plan to take.\n</instructions>\n\n<keys>\n\"thought\" should be a short description of what the agent is thinking about and planning.\n\"actions\" should be a comma-separated list of the actions {{agentName}} plans to take based on the thought, IN THE ORDER THEY SHOULD BE EXECUTED (if none, use IGNORE, if simply responding with text, use REPLY)\n\"providers\" should be a comma-separated list of the providers that {{agentName}} will use to have the right context for responding and acting (NEVER use \"IGNORE\" as a provider - use specific provider names like ATTACHMENTS, ENTITIES, FACTS, KNOWLEDGE, etc.)\n\"text\" should be the text of the next message for {{agentName}} which they will send to the conversation.\n</keys>\n\n<output>\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nRespond using XML format like this:\n<response>\n    <thought>Your thought here</thought>\n    <actions>ACTION1,ACTION2</actions>\n    <providers>PROVIDER1,PROVIDER2</providers>\n    <text>Your response text here</text>\n</response>\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.\n</output>`;\nvar postCreationTemplate = `# Task: Create a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\n\nExample task outputs:\n1. A post about the importance of AI in our lives\n<response>\n  <thought>I am thinking about writing a post about the importance of AI in our lives</thought>\n  <post>AI is changing the world and it is important to understand how it works</post>\n  <imagePrompt>A futuristic cityscape with flying cars and people using AI to do things</imagePrompt>\n</response>\n\n2. A post about dogs\n<response>\n  <thought>I am thinking about writing a post about dogs</thought>\n  <post>Dogs are man's best friend and they are loyal and loving</post>\n  <imagePrompt>A dog playing with a ball in a park</imagePrompt>\n</response>\n\n3. A post about finding a new job\n<response>\n  <thought>Getting a job is hard, I bet there's a good tweet in that</thought>\n  <post>Just keep going!</post>\n  <imagePrompt>A person looking at a computer screen with a job search website</imagePrompt>\n</response>\n\n{{providers}}\n\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\nYour response should be 1, 2, or 3 sentences (choose the length at random).\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than 280. No emojis. Use \\\\n\\\\n (double spaces) between statements if there are multiple statements in your response.\n\nYour output should be formatted in XML like this:\n<response>\n  <thought>Your thought here</thought>\n  <post>Your post text here</post>\n  <imagePrompt>Optional image prompt here</imagePrompt>\n</response>\n\nThe \"post\" field should be the post you want to send. Do not including any thinking or internal reflection in the \"post\" field.\nThe \"imagePrompt\" field is optional and should be a prompt for an image that is relevant to the post. It should be a single sentence that captures the essence of the post. ONLY USE THIS FIELD if it makes sense that the post would benefit from an image.\nThe \"thought\" field should be a short description of what the agent is thinking about before responding, including a brief justification for the response. Includate an explanation how the post is relevant to the topic but unique and different than other posts.\n\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.`;\nvar booleanFooter = \"Respond with only a YES or a NO.\";\nvar imageDescriptionTemplate = `<task>Analyze the provided image and generate a comprehensive description with multiple levels of detail.</task>\n\n<instructions>\nCarefully examine the image and provide:\n1. A concise, descriptive title that captures the main subject or scene\n2. A brief summary description (1-2 sentences) highlighting the key elements\n3. An extensive, detailed description that covers all visible elements, composition, lighting, colors, mood, and any other relevant details\n\nBe objective and descriptive. Focus on what you can actually see in the image rather than making assumptions about context or meaning.\n</instructions>\n\n<output>\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nRespond using XML format like this:\n<response>\n  <title>A concise, descriptive title for the image</title>\n  <description>A brief 1-2 sentence summary of the key elements in the image</description>\n  <text>An extensive, detailed description covering all visible elements, composition, lighting, colors, mood, setting, objects, people, activities, and any other relevant details you can observe in the image</text>\n</response>\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.\n</output>`;\n\n// src/roles.ts\nasync function getUserServerRole(runtime, entityId, serverId) {\n  const worldId = createUniqueUuid(runtime, serverId);\n  const world = await runtime.getWorld(worldId);\n  if (!world || !world.metadata?.roles) {\n    return \"NONE\" /* NONE */;\n  }\n  if (world.metadata.roles[entityId]) {\n    return world.metadata.roles[entityId];\n  }\n  if (world.metadata.roles[entityId]) {\n    return world.metadata.roles[entityId];\n  }\n  return \"NONE\" /* NONE */;\n}\nasync function findWorldsForOwner(runtime, entityId) {\n  if (!entityId) {\n    logger.error(\"User ID is required to find server\");\n    return null;\n  }\n  const worlds = await runtime.getAllWorlds();\n  if (!worlds || worlds.length === 0) {\n    logger.info(\"No worlds found for this agent\");\n    return null;\n  }\n  const ownerWorlds = [];\n  for (const world of worlds) {\n    if (world.metadata?.ownership?.ownerId === entityId) {\n      ownerWorlds.push(world);\n    }\n  }\n  return ownerWorlds.length ? ownerWorlds : null;\n}\n\n// src/runtime.ts\n\n\n// src/search.ts\nvar isV = (char) => {\n  switch (char) {\n    case 97:\n    case 101:\n    case 105:\n    case 111:\n    case 117:\n    case 121:\n      return true;\n    default:\n      return false;\n  }\n};\nvar isWxy = (char) => {\n  switch (char) {\n    case 97:\n    case 101:\n    case 105:\n    case 111:\n    case 117:\n    case 121:\n    case 119:\n    case 120:\n    case 89:\n      return true;\n    default:\n      return false;\n  }\n};\nvar isValidLi = (char) => {\n  switch (char) {\n    case 99:\n    case 100:\n    case 101:\n    case 103:\n    case 104:\n    case 107:\n    case 109:\n    case 110:\n    case 114:\n    case 116:\n      return true;\n    default:\n      return false;\n  }\n};\nvar isDouble = (char) => {\n  switch (char) {\n    case 98:\n    case 100:\n    case 102:\n    case 103:\n    case 109:\n    case 110:\n    case 112:\n    case 114:\n    case 116:\n      return true;\n    default:\n      return false;\n  }\n};\nvar isShortV = (w, len) => {\n  return len >= 2 && isV(w[len - 2]) && (len === 2 && !isV(w[len - 1]) || len >= 3 && !isV(w[len - 3]) && !isWxy(w[len - 1]));\n};\nvar stem = (word) => {\n  if (word.length < 3) return word;\n  if (word.length <= 6) {\n    switch (word) {\n      case \"ski\":\n        return \"ski\";\n      case \"skies\":\n        return \"sky\";\n      case \"dying\":\n        return \"die\";\n      case \"lying\":\n        return \"lie\";\n      case \"tying\":\n        return \"tie\";\n      // special -LY cases\n      case \"idly\":\n        return \"idl\";\n      case \"gently\":\n        return \"gentl\";\n      case \"ugly\":\n        return \"ugli\";\n      case \"early\":\n        return \"earli\";\n      case \"only\":\n        return \"onli\";\n      case \"singly\":\n        return \"singl\";\n      // invariant forms\n      case \"sky\":\n      case \"news\":\n      case \"howe\":\n      // not plural forms\n      case \"atlas\":\n      case \"cosmos\":\n      case \"bias\":\n      case \"andes\":\n        return word;\n    }\n  }\n  const initialOffset = word.charCodeAt(0) === 39 ? 1 : 0;\n  let l = word.length - initialOffset;\n  const w = new Array(l);\n  let yFound = false;\n  for (let i = 0; i < l; ++i) {\n    const ch = word.charCodeAt(i + initialOffset);\n    if (ch === 121 && (i === 0 || isV(w[i - 1]))) {\n      yFound = true;\n      w[i] = 89;\n      continue;\n    }\n    w[i] = ch;\n  }\n  if (w[l - 1] === 39) --l;\n  if (l >= 2 && w[l - 2] === 39 && w[l - 1] === 115) l -= 2;\n  let rv = 0;\n  while (rv < l && !isV(w[rv])) ++rv;\n  if (rv < l) ++rv;\n  let r1 = rv;\n  if (l >= 5 && (w[0] === 103 && w[1] === 101 && w[2] === 110 && w[3] === 101 && w[4] === 114 || // gener\n  w[0] === 97 && w[1] === 114 && w[2] === 115 && w[3] === 101 && w[4] === 110))\n    r1 = 5;\n  else if (l >= 6 && w[0] === 99 && // c\n  w[1] === 111 && // o\n  w[2] === 109 && // m\n  w[3] === 109 && // m\n  w[4] === 117 && // u\n  w[5] === 110)\n    r1 = 6;\n  else {\n    while (r1 < l && isV(w[r1])) ++r1;\n    if (r1 < l) ++r1;\n  }\n  let r2 = r1;\n  while (r2 < l && !isV(w[r2])) ++r2;\n  while (r2 < l && isV(w[r2])) ++r2;\n  if (r2 < l) ++r2;\n  if (l >= 3) {\n    if (w[l - 1] === 115) {\n      if (l >= 4 && w[l - 2] === 101 && w[l - 3] === 115 && w[l - 4] === 115)\n        l -= 2;\n      else if (w[l - 2] === 101 && w[l - 3] === 105)\n        l -= l >= 5 ? 2 : 1;\n      else if (w[l - 2] !== 117 && w[l - 2] !== 115 && rv < l - 1)\n        l -= 1;\n    } else if (w[l - 1] === 100 && w[l - 2] === 101 && w[l - 3] === 105) l -= l >= 5 ? 2 : 1;\n  }\n  if (l === 6 && (w[0] === 105 && // i\n  w[1] === 110 && // n\n  w[2] === 110 && // n\n  w[3] === 105 && // i\n  w[4] === 110 && // n\n  w[5] === 103 || // g (inning)\n  w[0] === 111 && // o\n  w[1] === 117 && // u\n  w[2] === 116 && // t\n  w[3] === 105 && // i\n  w[4] === 110 && // n\n  w[5] === 103 || // g (outing)\n  w[0] === 101 && // e\n  w[1] === 120 && // x\n  w[2] === 99 && // c\n  w[3] === 101 && // e\n  w[4] === 101 && // e\n  w[5] === 100) || // d (exceed)\n  l === 7 && (w[0] === 99 && // c\n  w[1] === 97 && // a\n  w[2] === 110 && // n\n  w[3] === 110 && // n\n  w[4] === 105 && // i\n  w[5] === 110 && // n\n  w[6] === 103 || // g (canning)\n  w[0] === 104 && // h\n  w[1] === 101 && // e\n  w[2] === 114 && // r\n  w[3] === 114 && // r\n  w[4] === 105 && // i\n  w[5] === 110 && // n\n  w[6] === 103 || // g (herring)\n  w[0] === 101 && // e\n  w[1] === 97 && // a\n  w[2] === 114 && // r\n  w[3] === 114 && // r\n  w[4] === 105 && // i\n  w[5] === 110 && // n\n  w[6] === 103 || // g (earring)\n  w[0] === 112 && // p\n  w[1] === 114 && // r\n  w[2] === 111 && // o\n  w[3] === 99 && // c\n  w[4] === 101 && // e\n  w[5] === 101 && // e\n  w[6] === 100 || // d (proceed)\n  w[0] === 115 && // s\n  w[1] === 117 && // u\n  w[2] === 99 && // c\n  w[3] === 99 && // c\n  w[4] === 101 && // e\n  w[5] === 101 && // e\n  w[6] === 100)) {\n    let exp2Out = \"\";\n    for (let i = 0; i < l; ++i) exp2Out += String.fromCharCode(w[i]);\n    return exp2Out;\n  }\n  let ll = (\n    // l (length) without the -ly ending\n    l >= 2 && w[l - 1] === 121 && w[l - 2] === 108 ? l - 2 : l\n  );\n  if (ll >= 3) {\n    if (w[ll - 3] === 101 && w[ll - 2] === 101 && w[ll - 1] === 100) {\n      if (ll >= r1 + 3) l = ll - 1;\n    } else {\n      if (w[ll - 2] === 101 && w[ll - 1] === 100)\n        ll -= 2;\n      else if (w[ll - 3] === 105 && w[ll - 2] === 110 && w[ll - 1] === 103)\n        ll -= 3;\n      else ll = -1;\n      if (ll >= 0 && rv <= ll) {\n        l = ll;\n        if (l >= 2) {\n          if (w[l - 1] === 116 && w[l - 2] === 97 || // at\n          w[l - 1] === 108 && w[l - 2] === 98 || // bl\n          w[l - 1] === 122 && w[l - 2] === 105) {\n            w[l] = 101;\n            ++l;\n          } else if (w[l - 2] === w[l - 1] && isDouble(w[l - 1])) {\n            --l;\n          } else if (r1 >= l && isShortV(w, l)) {\n            w[l] = 101;\n            ++l;\n          }\n        }\n      }\n    }\n  }\n  if (l >= 3 && (w[l - 1] === 89 || w[l - 1] === 121) && !isV(w[l - 2])) w[l - 1] = 105;\n  if (l >= r1 + 2) {\n    switch (w[l - 1]) {\n      case 108:\n        if (l >= r1 + 6 && w[l - 2] === 97 && // a\n        w[l - 3] === 110 && // n\n        w[l - 4] === 111 && // o\n        w[l - 5] === 105 && // i\n        w[l - 6] === 116) {\n          if (l >= 7 && w[l - 7] === 97) {\n            if (l >= r1 + 7) {\n              l -= 4;\n              w[l - 1] = 101;\n            }\n          } else {\n            l -= 2;\n          }\n        }\n        break;\n      case 110:\n        if (l >= r1 + 5 && w[l - 2] === 111 && // o\n        w[l - 3] === 105 && // i\n        w[l - 4] === 116 && // t\n        w[l - 5] === 97) {\n          if (l >= 7 && w[l - 6] === 122 && w[l - 7] === 105) {\n            if (l >= r1 + 7) {\n              l -= 4;\n              w[l - 1] = 101;\n            }\n          } else {\n            l -= 2;\n            w[l - 1] = 101;\n          }\n        }\n        break;\n      case 114:\n        if (l >= r1 + 4) {\n          if (w[l - 2] === 101) {\n            if (w[l - 3] === 122 && w[l - 4] === 105) --l;\n          } else if (w[l - 2] === 111) {\n            if (w[l - 3] === 116 && w[l - 4] === 97) {\n              --l;\n              w[l - 1] = 101;\n            }\n          }\n        }\n        break;\n      case 115:\n        if (l >= r1 + 7 && w[l - 2] === 115 && // s\n        w[l - 3] === 101 && // e\n        w[l - 4] === 110 && // n (ness)\n        (w[l - 5] === 108 && w[l - 6] === 117 && w[l - 7] === 102 || // fulness\n        w[l - 5] === 115 && w[l - 6] === 117 && w[l - 7] === 111 || // ousness\n        w[l - 5] === 101 && w[l - 6] === 118 && w[l - 7] === 105)) {\n          l -= 4;\n        }\n        break;\n      case 109:\n        if (l >= r1 + 5 && w[l - 2] === 115 && // s\n        w[l - 3] === 105 && // i\n        w[l - 4] === 108 && // l\n        w[l - 5] === 97)\n          l -= 3;\n        break;\n      case 105:\n        if (w[l - 2] === 99) {\n          if (l >= r1 + 4 && (w[l - 4] === 101 || w[l - 4] === 97) && w[l - 3] === 110) {\n            w[l - 1] = 101;\n          }\n        } else if (w[l - 2] === 103) {\n          if (l >= r1 + 3 && l >= 4 && w[l - 2] === 103 && w[l - 3] === 111 && w[l - 4] === 108)\n            --l;\n        } else if (w[l - 2] === 116) {\n          if (l >= r1 + 5 && w[l - 3] === 105) {\n            if (w[l - 4] === 108) {\n              if (l >= 6 && w[l - 5] === 105 && w[l - 6] === 98) {\n                if (l >= r1 + 6) {\n                  l -= 3;\n                  w[l - 2] = 108;\n                  w[l - 1] = 101;\n                }\n              } else if (w[l - 4] === 108 && w[l - 5] === 97) {\n                l -= 3;\n              }\n            } else if (w[l - 4] === 118 && w[l - 5] === 105) {\n              l -= 2;\n              w[l - 1] = 101;\n            }\n          }\n        } else if (w[l - 2] === 108 && l >= 3) {\n          if (w[l - 3] === 98) {\n            if (l >= 4 && w[l - 4] === 97) {\n              if (l >= r1 + 4) w[l - 1] = 101;\n            } else if (l >= r1 + 3) {\n              w[l - 1] = 101;\n            }\n          } else {\n            if (w[l - 3] === 108) {\n              if (l >= 5 && w[l - 4] === 117 && w[l - 5] === 102) {\n                if (l >= r1 + 5) l -= 2;\n              } else if (l >= r1 + 4 && w[l - 4] === 97) {\n                l -= 2;\n              }\n            } else if (w[l - 3] === 115) {\n              if (l >= 6 && w[l - 4] === 115 && w[l - 5] === 101 && w[l - 6] === 108) {\n                if (l >= r1 + 6) l -= 2;\n              } else if (l >= r1 + 5 && w[l - 4] === 117 && w[l - 5] === 111) {\n                l -= 2;\n              }\n            } else if (l >= 5 && w[l - 3] === 116 && w[l - 4] === 110 && w[l - 5] === 101) {\n              if (l >= r1 + 5) l -= 2;\n            } else if (isValidLi(w[l - 3])) {\n              l -= 2;\n            }\n          }\n        }\n    }\n  }\n  if (l >= r1 + 3) {\n    switch (w[l - 1]) {\n      case 108:\n        if (w[l - 3] === 99) {\n          if (l >= r1 + 4 && w[l - 4] === 105 && w[l - 2] === 97) l -= 2;\n        } else if (w[l - 3] === 102) {\n          if (w[l - 2] === 117) l -= 3;\n        } else if (w[l - 3] === 110) {\n          if (l >= r1 + 6 && w[l - 2] === 97 && // a\n          w[l - 4] === 111 && // o\n          w[l - 5] === 105 && // i\n          w[l - 6] === 116) {\n            if (l >= 7 && w[l - 7] === 97) {\n              if (l >= r1 + 7) {\n                l -= 4;\n                w[l - 1] = 101;\n              }\n            } else {\n              l -= 2;\n            }\n          }\n        }\n        break;\n      case 101:\n        if (w[l - 2] === 122) {\n          if (l >= r1 + 5 && w[l - 3] === 105 && w[l - 4] === 108 && w[l - 5] === 97) l -= 3;\n        } else if (w[l - 2] === 116) {\n          if (l >= r1 + 5 && w[l - 3] === 97 && w[l - 4] === 99 && w[l - 5] === 105) l -= 3;\n        } else if (w[l - 2] === 118) {\n          if (l >= r2 + 5 && w[l - 3] === 105 && w[l - 4] === 116 && w[l - 5] === 97) l -= 5;\n        }\n        break;\n      case 105:\n        if (l >= r1 + 5 && w[l - 2] === 116 && // t\n        w[l - 3] === 105 && // i\n        w[l - 4] === 99 && // c\n        w[l - 5] === 105)\n          l -= 3;\n        break;\n      case 115:\n        if (l >= r1 + 4 && w[l - 2] === 115 && w[l - 3] === 101 && w[l - 4] === 110) l -= 4;\n    }\n  }\n  if (l >= r2 + 2) {\n    switch (w[l - 1]) {\n      case 110:\n        if (l >= r2 + 3 && w[l - 2] === 111 && // o\n        w[l - 3] === 105 && // i (ion)\n        (w[l - 4] === 115 || w[l - 4] === 116))\n          l -= 3;\n        break;\n      case 108:\n        if (w[l - 2] === 97) l -= 2;\n        break;\n      case 114:\n        if (w[l - 2] === 101) l -= 2;\n        break;\n      case 99:\n        if (w[l - 2] === 105) l -= 2;\n        break;\n      case 109:\n        if (l >= r2 + 3 && w[l - 2] === 115 && w[l - 3] === 105) l -= 3;\n        break;\n      case 105:\n        if (l >= r2 + 3 && w[l - 2] === 116 && w[l - 3] === 105) l -= 3;\n        break;\n      case 115:\n        if (l >= r2 + 3 && w[l - 2] === 117 && w[l - 3] === 111) l -= 3;\n        break;\n      case 116:\n        if (l >= r2 + 3 && w[l - 2] === 110) {\n          if (w[l - 3] === 97) {\n            l -= 3;\n          } else if (w[l - 3] === 101) {\n            if (l >= 4 && w[l - 4] === 109) {\n              if (l >= 5 && w[l - 5] === 101) {\n                if (l >= r2 + 5) l -= 5;\n              } else if (l >= r2 + 4) {\n                l -= 4;\n              }\n            } else {\n              l -= 3;\n            }\n          }\n        }\n        break;\n      case 101:\n        if (w[l - 2] === 99) {\n          if (l >= r2 + 4 && w[l - 3] === 110 && (w[l - 4] === 97 || w[l - 4] === 101)) l -= 4;\n        } else if (w[l - 2] === 108) {\n          if (l >= r2 + 4 && w[l - 3] === 98 && (w[l - 4] === 97 || w[l - 4] === 105)) l -= 4;\n        } else if (w[l - 2] === 116) {\n          if (l >= r2 + 3 && w[l - 3] === 97) l -= 3;\n        } else if (l >= r2 + 3 && (w[l - 2] === 118 || w[l - 2] === 122) && w[l - 3] === 105) {\n          l -= 3;\n        }\n    }\n  }\n  if (l >= r1 + 1 && // r1 is >= 1\n  (l >= r2 + 1 && w[l - 1] === 108 && w[l - 2] === 108 || // ll\n  w[l - 1] === 101 && (l >= r2 + 1 || !isShortV(w, l - 1))))\n    --l;\n  let out = \"\";\n  if (yFound) {\n    for (let i = 0; i < l; ++i) {\n      out += String.fromCharCode(w[i] === 89 ? 121 : w[i]);\n    }\n  } else {\n    for (let i = 0; i < l; ++i) out += String.fromCharCode(w[i]);\n  }\n  return out;\n};\nvar DEFAULT_OPTIONS = {\n  k1: 1.2,\n  b: 0.75,\n  minLength: 2,\n  stopWords: /* @__PURE__ */ new Set([\n    \"a\",\n    \"an\",\n    \"and\",\n    \"are\",\n    \"as\",\n    \"at\",\n    \"be\",\n    \"by\",\n    \"for\",\n    \"from\",\n    \"has\",\n    \"he\",\n    \"in\",\n    \"is\",\n    \"it\",\n    \"its\",\n    \"of\",\n    \"on\",\n    \"that\",\n    \"the\",\n    \"to\",\n    \"was\",\n    \"were\",\n    \"will\",\n    \"with\"\n  ]),\n  stemming: false,\n  stemWords: (word) => word\n};\nvar Tokenizer = class _Tokenizer {\n  static {\n    /** Default options for the Tokenizer. */\n    this.DEFAULT_OPTIONS = {\n      stopWords: /* @__PURE__ */ new Set(),\n      minLength: 2,\n      stemming: false,\n      stemmingRules: []\n    };\n  }\n  /**\n   * Creates a new tokenizer instance.\n   * @param options - Tokenization options including stop words, min length, stemming, and custom rules.\n   */\n  constructor(options2 = {}) {\n    const mergedOptions = { ..._Tokenizer.DEFAULT_OPTIONS, ...options2 };\n    this.stopWords = mergedOptions.stopWords;\n    this.minLength = mergedOptions.minLength;\n    this.stemming = mergedOptions.stemming;\n    this.stemmingRules = mergedOptions.stemmingRules.map((rule) => ({\n      ...rule,\n      pattern: typeof rule.pattern === \"string\" ? new RegExp(rule.pattern) : rule.pattern\n    }));\n  }\n  /**\n   * Tokenizes input text into an array of processed terms.\n   * Steps:\n   * 1. Cleans the text (lowercase, normalize, remove punctuation/symbols).\n   * 2. Splits the text into potential tokens.\n   * 3. Filters tokens based on `minLength` and `stopWords`.\n   * 4. Applies stemming if `stemming` is true (custom rules first, then Porter2).\n   * 5. Optionally calculates statistics.\n   *\n   * @param text - The input text string to tokenize.\n   * @param includeStats - If true, returns tokenization statistics along with tokens. Defaults to false.\n   * @returns A `TokenizationResult` object containing the array of tokens and optional stats.\n   * @throws {Error} If the input text is null, undefined, or empty.\n   */\n  tokenize(text, includeStats = false) {\n    if (!text) {\n      throw new Error(\"Input text cannot be null or empty\");\n    }\n    const startTime = Date.now();\n    const originalWords = text.split(/\\s+/).filter((word) => word.length > 0);\n    const cleaned = this.cleanText(text);\n    const tokens = cleaned.split(/\\s+/).filter((token) => this.isValidToken(token)).map((token) => this.stemming ? this.stemWord(token) : token);\n    const stats = includeStats ? {\n      originalWordCount: originalWords.length,\n      stopWordsRemoved: originalWords.length - tokens.length,\n      // This might be incorrect if stemming changes token count\n      stemmedWords: this.stemming ? tokens.length : 0,\n      processingTimeMs: Date.now() - startTime\n    } : {\n      originalWordCount: 0,\n      stopWordsRemoved: 0,\n      stemmedWords: 0,\n      processingTimeMs: 0\n    };\n    return { tokens, stats };\n  }\n  /**\n   * Cleans and normalizes text for tokenization.\n   * - Converts to lowercase.\n   * - Normalizes Unicode characters (NFKD).\n   * - Removes control characters and zero-width spaces.\n   * - Removes diacritical marks (accents).\n   * - Removes emojis and pictographs.\n   * - Removes common symbols (™, ®, ©, ℠, ‼).\n   * - Replaces Unicode punctuation with spaces.\n   * - Removes characters not matching basic Latin, CJK, Hangul, or whitespace.\n   * - Collapses multiple spaces into single spaces.\n   * - Trims leading/trailing whitespace.\n   *\n   * @param text - Input text to clean.\n   * @returns Cleaned and normalized text, ready for splitting into tokens.\n   *\n   * @example\n   * cleanText(\"Hello, World™!\") // \"hello world\"\n   * cleanText(\"héllo 👋\") // \"hello\"\n   * cleanText(\"Hello 世界!\") // \"hello 世界\"\n   * cleanText(\"I'm don't\") // \"i'm don't\" (apostrophes kept by replacing punctuation with space)\n   * cleanText(\"test©2023\") // \"test 2023\"\n   */\n  cleanText(text) {\n    return text.toLowerCase().normalize(\"NFKD\").replace(/[\\u0000-\\u001F\\u007F-\\u009F\\u200B-\\u200D\\uFEFF]/g, \"\").replace(/[\\u0300-\\u036f]/g, \"\").replace(/[\\p{Emoji_Presentation}\\p{Extended_Pictographic}]/gu, \"\").replace(/[™®©℠‼]/g, \"\").replace(/[\\p{P}]/gu, \" \").replace(/[^a-z0-9\\u3040-\\u30FF\\u3400-\\u4DBF\\u4E00-\\u9FFF\\uAC00-\\uD7AF\\s]/gu, \" \").replace(/\\s+/g, \" \").trim();\n  }\n  /**\n   * Checks if a token is valid (meets `minLength` criteria and is not a stop word).\n   * Numeric tokens are always considered valid regardless of length.\n   * @param token - The token string to validate.\n   * @returns `true` if the token is valid, `false` otherwise.\n   */\n  isValidToken(token) {\n    const isNumeric = /^\\d+$/.test(token);\n    return (token.length >= this.minLength || isNumeric) && !this.stopWords.has(token);\n  }\n  /**\n   * Applies stemming to a single word.\n   * First, tries to apply custom stemming rules defined in `stemmingRules`.\n   * If no custom rule matches, applies the default Porter2 stemming algorithm.\n   * Words shorter than 3 characters are not stemmed.\n   * @param word - The word to stem.\n   * @returns The stemmed word.\n   */\n  stemWord(word) {\n    if (word.length < 3) return word;\n    let customRuleApplied = false;\n    let stemmed = word;\n    for (const rule of this.stemmingRules) {\n      const match = stemmed.match(rule.pattern);\n      if (match) {\n        if (!rule.minMeasure || this.measure(stemmed.substring(0, match.index)) >= rule.minMeasure) {\n          if (typeof rule.replacement === \"string\") {\n            stemmed = stemmed.replace(rule.pattern, rule.replacement);\n          } else {\n            stemmed = stemmed.replace(\n              rule.pattern,\n              (...args) => rule.replacement(...args)\n            );\n          }\n          customRuleApplied = true;\n        }\n      }\n    }\n    if (customRuleApplied && stemmed !== word) return stemmed;\n    return stem(stemmed);\n  }\n  /**\n   * Checks if the character at a given index in a word is a consonant.\n   * Treats 'y' as a consonant if it's the first letter or follows a consonant.\n   * @param word - The word string.\n   * @param i - The index of the character to check.\n   * @returns `true` if the character is a consonant, `false` otherwise.\n   */\n  isConsonant(word, i) {\n    const char = word[i];\n    if (\"aeiou\".includes(char)) return false;\n    return char !== \"y\" || (i === 0 ? true : !this.isConsonant(word, i - 1));\n  }\n  /**\n   * Calculates the \"measure\" of a word stem (approximates syllable count).\n   * The measure (m) is the number of times a sequence of vowels is followed by a\n   * sequence of consonants (VC). Used in some stemming rules.\n   * Example: measure(\"tree\") = 0, measure(\"trouble\") = 1, measure(\"private\") = 2\n   * @param word - The word (or stem) to measure.\n   * @returns The measure (m) of the word.\n   */\n  measure(word) {\n    let m = 0;\n    let vowelSeen = false;\n    for (let i = 0; i < word.length; i++) {\n      if (this.isConsonant(word, i)) {\n        if (vowelSeen) {\n          m++;\n          vowelSeen = false;\n        }\n      } else {\n        vowelSeen = true;\n      }\n    }\n    return m;\n  }\n};\nvar BM25 = class {\n  // Consider using a generic <T>\n  /**\n   * Creates a new BM25 search instance.\n   * @param docs - Optional array of initial documents (objects with string fields) to index.\n   * @param options - Configuration options for BM25 parameters (k1, b), tokenizer (stopWords, stemming, minLength), and field boosts.\n   */\n  constructor(docs, options2 = {}) {\n    const opts = { ...DEFAULT_OPTIONS, ...options2 };\n    this.termFrequencySaturation = opts.k1;\n    this.lengthNormalizationFactor = opts.b;\n    this.tokenizer = new Tokenizer(opts);\n    this.fieldBoosts = opts.fieldBoosts || {};\n    this.documents = [];\n    this.documentLengths = new Uint32Array(0);\n    this.termToIndex = /* @__PURE__ */ new Map();\n    this.documentFrequency = new Uint32Array(0);\n    this.averageDocLength = 0;\n    this.termFrequencies = /* @__PURE__ */ new Map();\n    if (docs && docs.length > 0) {\n      this.documents = [...docs];\n      const { documentLengths, termToIndex, documentFrequency, averageDocLength, termFrequencies } = this.processDocuments(docs);\n      this.documentLengths = documentLengths;\n      this.termToIndex = termToIndex;\n      this.documentFrequency = documentFrequency;\n      this.averageDocLength = averageDocLength;\n      this.termFrequencies = termFrequencies;\n    }\n  }\n  /**\n   * Processes an array of documents to build the initial index structures.\n   * Calculates document lengths, term frequencies, document frequencies, and average document length.\n   * @param docs - Array of documents to process.\n   * @returns An object containing the calculated index data.\n   * @internal\n   */\n  processDocuments(docs) {\n    const numDocs = docs.length;\n    const documentLengths = new Uint32Array(numDocs);\n    const termToIndex = /* @__PURE__ */ new Map();\n    const termDocs = /* @__PURE__ */ new Map();\n    const termFrequencies = /* @__PURE__ */ new Map();\n    let totalDocLength = 0;\n    let nextTermIndex = 0;\n    docs.forEach((doc, docIndex) => {\n      let currentDocLength = 0;\n      const docTermFrequencies = /* @__PURE__ */ new Map();\n      Object.entries(doc).forEach(([field, content]) => {\n        if (typeof content !== \"string\") return;\n        const fieldBoost = this.fieldBoosts[field] || 1;\n        const { tokens } = this.tokenizer.tokenize(content);\n        const fieldLength = tokens.length * fieldBoost;\n        currentDocLength += fieldLength;\n        tokens.forEach((term) => {\n          if (!termToIndex.has(term)) {\n            termToIndex.set(term, nextTermIndex++);\n          }\n          const termIndexVal = termToIndex.get(term);\n          if (!termDocs.has(term)) {\n            termDocs.set(term, /* @__PURE__ */ new Set());\n          }\n          termDocs.get(term).add(docIndex);\n          const currentFreq = docTermFrequencies.get(termIndexVal) || 0;\n          docTermFrequencies.set(termIndexVal, currentFreq + fieldBoost);\n        });\n      });\n      documentLengths[docIndex] = currentDocLength;\n      totalDocLength += currentDocLength;\n      docTermFrequencies.forEach((freq, termIndexVal) => {\n        if (!termFrequencies.has(termIndexVal)) {\n          termFrequencies.set(termIndexVal, /* @__PURE__ */ new Map());\n        }\n        termFrequencies.get(termIndexVal).set(docIndex, freq);\n      });\n    });\n    const documentFrequency = new Uint32Array(termToIndex.size);\n    termDocs.forEach((docsSet, term) => {\n      const termIndexVal = termToIndex.get(term);\n      documentFrequency[termIndexVal] = docsSet.size;\n    });\n    return {\n      documentLengths,\n      termToIndex,\n      documentFrequency,\n      averageDocLength: numDocs > 0 ? totalDocLength / numDocs : 0,\n      termFrequencies\n    };\n  }\n  /**\n   * Recalculates the average document length based on the current `documentLengths`.\n   * @internal\n   */\n  recalculateAverageLength() {\n    if (this.documentLengths.length === 0) {\n      this.averageDocLength = 0;\n      return;\n    }\n    const totalLength = Array.prototype.reduce.call(\n      this.documentLengths,\n      (sum, len) => sum + len,\n      0\n    );\n    this.averageDocLength = totalLength / this.documentLengths.length;\n  }\n  /**\n   * Searches the indexed documents for a given query string using the BM25 ranking formula.\n   *\n   * @param query - The search query text.\n   * @param topK - The maximum number of top-scoring results to return. Defaults to 10.\n   * @returns An array of `SearchResult` objects, sorted by descending BM25 score.\n   */\n  search(query, topK = 10) {\n    const { tokens: queryTokens } = this.tokenizer.tokenize(query);\n    const scores = new Float32Array(this.documentLengths.length).fill(0);\n    queryTokens.forEach((term) => {\n      const termIndex = this.termToIndex.get(term);\n      if (termIndex === void 0) return;\n      const idf = this.calculateIdf(termIndex);\n      if (idf <= 0) return;\n      const termFreqsInDocs = this.termFrequencies.get(termIndex);\n      if (!termFreqsInDocs) return;\n      termFreqsInDocs.forEach((tf, docIndex) => {\n        const docLength = this.documentLengths[docIndex];\n        const numerator = tf * (this.termFrequencySaturation + 1);\n        const denominator = tf + this.termFrequencySaturation * (1 - this.lengthNormalizationFactor + this.lengthNormalizationFactor * docLength / this.averageDocLength);\n        scores[docIndex] += idf * (numerator / denominator);\n      });\n    });\n    return Array.from({ length: scores.length }, (_, i) => ({\n      index: i,\n      score: scores[i]\n      // Optionally add: doc: this.getDocument(i) // If you want the full doc in results\n    })).filter((result) => result.score > 0).sort((a, b) => b.score - a.score).slice(0, topK);\n  }\n  /**\n   * Searches for an exact phrase within the indexed documents.\n   * Ranks documents containing the exact sequence of tokens higher.\n   * Note: This is a basic implementation. More sophisticated phrase search might consider proximity.\n   *\n   * @param phrase - The exact phrase to search for.\n   * @param topK - The maximum number of results to return. Defaults to 10.\n   * @returns An array of `SearchResult` objects, sorted by score, for documents containing the phrase.\n   */\n  searchPhrase(phrase, topK = 10) {\n    const { tokens: phraseTokens } = this.tokenizer.tokenize(phrase);\n    if (phraseTokens.length === 0) return [];\n    let candidateDocs = null;\n    for (const term of phraseTokens) {\n      const termIndex = this.termToIndex.get(term);\n      if (termIndex === void 0) return [];\n      const docsContainingTermIter = this.termFrequencies.get(termIndex)?.keys();\n      if (!docsContainingTermIter) return [];\n      const currentTermDocs = new Set(docsContainingTermIter);\n      if (candidateDocs === null) {\n        candidateDocs = currentTermDocs;\n      } else {\n        candidateDocs = new Set([...candidateDocs].filter((docIdx) => currentTermDocs.has(docIdx)));\n      }\n      if (candidateDocs.size === 0) return [];\n    }\n    if (candidateDocs === null || candidateDocs.size === 0) return [];\n    const scores = /* @__PURE__ */ new Map();\n    candidateDocs.forEach((docIndex) => {\n      const doc = this.getDocument(docIndex);\n      let phraseFoundInDoc = false;\n      Object.entries(doc).forEach(([field, content]) => {\n        if (typeof content !== \"string\" || phraseFoundInDoc) return;\n        const fieldBoost = this.fieldBoosts[field] || 1;\n        const { tokens: docTokens } = this.tokenizer.tokenize(content);\n        for (let i = 0; i <= docTokens.length - phraseTokens.length; i++) {\n          let match = true;\n          for (let j = 0; j < phraseTokens.length; j++) {\n            if (docTokens[i + j] !== phraseTokens[j]) {\n              match = false;\n              break;\n            }\n          }\n          if (match) {\n            const phraseScoreVal = this.calculatePhraseScore(phraseTokens, docIndex) * fieldBoost;\n            scores.set(docIndex, (scores.get(docIndex) || 0) + phraseScoreVal);\n            phraseFoundInDoc = true;\n            break;\n          }\n        }\n      });\n    });\n    return Array.from(scores.entries()).map(([index, score]) => ({ index, score })).sort((a, b) => b.score - a.score).slice(0, topK);\n  }\n  /**\n   * Calculates a BM25-like score for a sequence of phrase tokens within a specific document.\n   * Sums the individual BM25 scores of the terms in the phrase for that document.\n   * @param phraseTokens - The tokenized phrase.\n   * @param docIndex - The index of the document to score against.\n   * @returns The calculated phrase score for the document.\n   * @internal\n   */\n  calculatePhraseScore(phraseTokens, docIndex) {\n    return phraseTokens.reduce((currentScore, term) => {\n      const termIndex = this.termToIndex.get(term);\n      if (termIndex === void 0) return currentScore;\n      const idf = this.calculateIdf(termIndex);\n      const tf = this.termFrequencies.get(termIndex)?.get(docIndex) || 0;\n      const docLength = this.documentLengths[docIndex];\n      const numerator = tf * (this.termFrequencySaturation + 1);\n      const denominator = tf + this.termFrequencySaturation * (1 - this.lengthNormalizationFactor + this.lengthNormalizationFactor * docLength / this.averageDocLength);\n      return currentScore + idf * (numerator / denominator);\n    }, 0);\n  }\n  /**\n   * Adds a single new document to the index.\n   * Updates all internal index structures incrementally.\n   * Note: For adding many documents, `addDocumentsParallel` is generally more efficient.\n   *\n   * @param doc - The document object (with string fields) to add.\n   * @throws {Error} If the document is null or undefined.\n   */\n  async addDocument(doc) {\n    if (!doc) throw new Error(\"Document cannot be null\");\n    const docIndex = this.documentLengths.length;\n    this.documents.push(doc);\n    const newDocLengths = new Uint32Array(docIndex + 1);\n    newDocLengths.set(this.documentLengths, 0);\n    this.documentLengths = newDocLengths;\n    let currentDocLength = 0;\n    const docTermFrequencies = /* @__PURE__ */ new Map();\n    Object.entries(doc).forEach(([field, content]) => {\n      if (typeof content !== \"string\") return;\n      const fieldBoost = this.fieldBoosts[field] || 1;\n      const { tokens } = this.tokenizer.tokenize(content);\n      currentDocLength += tokens.length * fieldBoost;\n      tokens.forEach((term) => {\n        let termIndexVal;\n        if (!this.termToIndex.has(term)) {\n          termIndexVal = this.termToIndex.size;\n          this.termToIndex.set(term, termIndexVal);\n          if (this.documentFrequency.length <= termIndexVal) {\n            const oldDf = this.documentFrequency;\n            const newSize = Math.max(termIndexVal + 1, oldDf.length * 2 || 1);\n            this.documentFrequency = new Uint32Array(newSize);\n            this.documentFrequency.set(oldDf, 0);\n          }\n          this.documentFrequency[termIndexVal] = 0;\n        } else {\n          termIndexVal = this.termToIndex.get(term);\n        }\n        const currentFreq = docTermFrequencies.get(termIndexVal) || 0;\n        docTermFrequencies.set(termIndexVal, currentFreq + fieldBoost);\n      });\n    });\n    this.documentLengths[docIndex] = currentDocLength;\n    docTermFrequencies.forEach((freq, termIndexVal) => {\n      if (!this.termFrequencies.has(termIndexVal)) {\n        this.termFrequencies.set(termIndexVal, /* @__PURE__ */ new Map());\n      }\n      this.termFrequencies.get(termIndexVal).set(docIndex, freq);\n      if (termIndexVal < this.documentFrequency.length) {\n        this.documentFrequency[termIndexVal]++;\n      } else {\n        console.error(\n          `Error: termIndexVal ${termIndexVal} is out of bounds for documentFrequency (length ${this.documentFrequency.length}). This indicates an issue with array resizing or term indexing.`\n        );\n      }\n    });\n    this.recalculateAverageLength();\n  }\n  /**\n   * Calculates the Inverse Document Frequency (IDF) for a given term index.\n   * Uses the BM25 IDF formula: log(1 + (N - n + 0.5) / (n + 0.5))\n   * where N is the total number of documents and n is the number of documents\n   * containing the term. The +1 smooths the logarithm.\n   *\n   * @param termIndex - The integer index of the term.\n   * @returns The IDF score for the term. Returns 0 if the term is not found or has 0 DF.\n   */\n  calculateIdf(termIndex) {\n    if (termIndex < 0 || termIndex >= this.documentFrequency.length) {\n      return 0;\n    }\n    const docFreq = this.documentFrequency[termIndex];\n    if (docFreq <= 0 || docFreq > this.documentLengths.length) {\n      return 0;\n    }\n    const N = this.documentLengths.length;\n    const numerator = N - docFreq + 0.5;\n    const denominator = docFreq + 0.5;\n    return Math.log(1 + numerator / denominator);\n  }\n  /**\n   * Retrieves the term frequency (TF) for a specific term in a specific document.\n   * @param termIndex - The integer index of the term.\n   * @param docIndex - The index of the document.\n   * @returns The term frequency, or 0 if the term is not in the document or indices are invalid.\n   */\n  getTermFrequency(termIndex, docIndex) {\n    return this.termFrequencies.get(termIndex)?.get(docIndex) || 0;\n  }\n  /**\n   * Retrieves the original document object stored at a given index.\n   * @param index - The index of the document to retrieve.\n   * @returns The document object.\n   * @throws {Error} If the index is out of bounds.\n   */\n  getDocument(index) {\n    if (index < 0 || index >= this.documents.length) {\n      throw new Error(`Document index ${index} out of bounds (0-${this.documents.length - 1})`);\n    }\n    return this.documents[index];\n  }\n  /**\n   * Clears all indexed documents and resets the BM25 instance to its initial state.\n   */\n  clearDocuments() {\n    this.documents = [];\n    this.documentLengths = new Uint32Array(0);\n    this.termToIndex.clear();\n    this.documentFrequency = new Uint32Array(0);\n    this.averageDocLength = 0;\n    this.termFrequencies.clear();\n  }\n  /**\n   * Gets the total number of documents currently indexed.\n   * @returns The document count.\n   */\n  getDocumentCount() {\n    return this.documents.length;\n  }\n  /**\n   * Adds multiple documents sequentially by calling `addDocument` for each.\n   * This method processes documents sequentially in the main thread.\n   * @param docs - An array of documents to add.\n   */\n  async addDocuments(docs) {\n    return Promise.all(docs.map((doc) => this.addDocument(doc)));\n  }\n};\n\n// src/runtime.ts\nvar environmentSettings = {};\nvar Semaphore = class {\n  constructor(count) {\n    this.waiting = [];\n    this.permits = count;\n  }\n  async acquire() {\n    if (this.permits > 0) {\n      this.permits -= 1;\n      return Promise.resolve();\n    }\n    return new Promise((resolve) => {\n      this.waiting.push(resolve);\n    });\n  }\n  release() {\n    this.permits += 1;\n    const nextResolve = this.waiting.shift();\n    if (nextResolve && this.permits > 0) {\n      this.permits -= 1;\n      nextResolve();\n    }\n  }\n};\nvar AgentRuntime = class {\n  // Default value, can be overridden\n  constructor(opts) {\n    this.#conversationLength = 32;\n    this.actions = [];\n    this.evaluators = [];\n    this.providers = [];\n    this.plugins = [];\n    this.isInitialized = false;\n    this.events = /* @__PURE__ */ new Map();\n    this.stateCache = /* @__PURE__ */ new Map();\n    this.fetch = fetch;\n    this.services = /* @__PURE__ */ new Map();\n    this.serviceTypes = /* @__PURE__ */ new Map();\n    this.models = /* @__PURE__ */ new Map();\n    this.routes = [];\n    this.taskWorkers = /* @__PURE__ */ new Map();\n    this.sendHandlers = /* @__PURE__ */ new Map();\n    this.eventHandlers = /* @__PURE__ */ new Map();\n    // A map of all plugins available to the runtime, keyed by name, for dependency resolution.\n    this.allAvailablePlugins = /* @__PURE__ */ new Map();\n    // The initial list of plugins specified by the character configuration.\n    this.characterPlugins = [];\n    this.servicesInitQueue = /* @__PURE__ */ new Set();\n    this.maxWorkingMemoryEntries = 50;\n    this.agentId = opts.character?.id ?? opts?.agentId ?? stringToUuid(opts.character?.name ?? (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])() + opts.character?.username);\n    this.character = opts.character;\n    const logLevel = process.env.LOG_LEVEL || \"info\";\n    this.logger = createLogger({\n      agentName: this.character?.name,\n      logLevel\n    });\n    this.#conversationLength = opts.conversationLength ?? this.#conversationLength;\n    if (opts.adapter) {\n      this.registerDatabaseAdapter(opts.adapter);\n    }\n    this.fetch = opts.fetch ?? this.fetch;\n    this.settings = opts.settings ?? environmentSettings;\n    this.plugins = [];\n    this.characterPlugins = opts?.plugins ?? [];\n    if (opts.allAvailablePlugins) {\n      for (const plugin of opts.allAvailablePlugins) {\n        if (plugin?.name) {\n          this.allAvailablePlugins.set(plugin.name, plugin);\n        }\n      }\n    }\n    this.logger.debug(`Success: Agent ID: ${this.agentId}`);\n    this.currentRunId = void 0;\n    if (opts.settings?.MAX_WORKING_MEMORY_ENTRIES) {\n      this.maxWorkingMemoryEntries = parseInt(opts.settings.MAX_WORKING_MEMORY_ENTRIES, 10) || 50;\n    } else if (process.env.MAX_WORKING_MEMORY_ENTRIES) {\n      this.maxWorkingMemoryEntries = parseInt(process.env.MAX_WORKING_MEMORY_ENTRIES, 10) || 50;\n    }\n  }\n  #conversationLength;\n  /**\n   * Create a new run ID for tracking a sequence of model calls\n   */\n  createRunId() {\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n  }\n  /**\n   * Start a new run for tracking prompts\n   */\n  startRun() {\n    this.currentRunId = this.createRunId();\n    return this.currentRunId;\n  }\n  /**\n   * End the current run\n   */\n  endRun() {\n    this.currentRunId = void 0;\n  }\n  /**\n   * Get the current run ID (creates one if it doesn't exist)\n   */\n  getCurrentRunId() {\n    if (!this.currentRunId) {\n      this.currentRunId = this.createRunId();\n    }\n    return this.currentRunId;\n  }\n  async registerPlugin(plugin) {\n    if (!plugin?.name) {\n      const errorMsg = \"Plugin or plugin name is undefined\";\n      this.logger.error(`*** registerPlugin: ${errorMsg}`);\n      throw new Error(`*** registerPlugin: ${errorMsg}`);\n    }\n    const existingPlugin = this.plugins.find((p) => p.name === plugin.name);\n    if (existingPlugin) {\n      this.logger.warn(\n        `${this.character.name}(${this.agentId}) - Plugin ${plugin.name} is already registered. Skipping re-registration.`\n      );\n      return;\n    }\n    this.plugins.push(plugin);\n    this.logger.debug(\n      `Success: Plugin ${plugin.name} added to active plugins for ${this.character.name}(${this.agentId}).`\n    );\n    if (plugin.init) {\n      try {\n        await plugin.init(plugin.config || {}, this);\n        this.logger.debug(`Success: Plugin ${plugin.name} initialized successfully`);\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        if (errorMessage.includes(\"API key\") || errorMessage.includes(\"environment variables\") || errorMessage.includes(\"Invalid plugin configuration\")) {\n          console.warn(`Plugin ${plugin.name} requires configuration. ${errorMessage}`);\n          console.warn(\n            \"Please check your environment variables and ensure all required API keys are set.\"\n          );\n          console.warn(\"You can set these in your .env file.\");\n        } else {\n          throw error;\n        }\n      }\n    }\n    if (plugin.adapter) {\n      this.logger.debug(`Registering database adapter for plugin ${plugin.name}`);\n      this.registerDatabaseAdapter(plugin.adapter);\n    }\n    if (plugin.actions) {\n      for (const action of plugin.actions) {\n        this.registerAction(action);\n      }\n    }\n    if (plugin.evaluators) {\n      for (const evaluator of plugin.evaluators) {\n        this.registerEvaluator(evaluator);\n      }\n    }\n    if (plugin.providers) {\n      for (const provider of plugin.providers) {\n        this.registerProvider(provider);\n      }\n    }\n    if (plugin.models) {\n      for (const [modelType, handler] of Object.entries(plugin.models)) {\n        this.registerModel(\n          modelType,\n          handler,\n          plugin.name,\n          plugin?.priority\n        );\n      }\n    }\n    if (plugin.routes) {\n      for (const route of plugin.routes) {\n        this.routes.push(route);\n      }\n    }\n    if (plugin.events) {\n      for (const [eventName, eventHandlers] of Object.entries(plugin.events)) {\n        for (const eventHandler of eventHandlers) {\n          this.registerEvent(eventName, eventHandler);\n        }\n      }\n    }\n    if (plugin.services) {\n      for (const service of plugin.services) {\n        if (this.isInitialized) {\n          await this.registerService(service);\n        } else {\n          this.servicesInitQueue.add(service);\n        }\n      }\n    }\n  }\n  getAllServices() {\n    return this.services;\n  }\n  async stop() {\n    this.logger.debug(`runtime::stop - character ${this.character.name}`);\n    for (const [serviceName, services] of this.services) {\n      this.logger.debug(`runtime::stop - requesting service stop for ${serviceName}`);\n      for (const service of services) {\n        await service.stop();\n      }\n    }\n  }\n  async initialize() {\n    if (this.isInitialized) {\n      this.logger.warn(\"Agent already initialized\");\n      return;\n    }\n    const pluginRegistrationPromises = [];\n    const pluginsToLoad = this.characterPlugins;\n    for (const plugin of pluginsToLoad) {\n      if (plugin) {\n        pluginRegistrationPromises.push(this.registerPlugin(plugin));\n      }\n    }\n    await Promise.all(pluginRegistrationPromises);\n    if (!this.adapter) {\n      this.logger.error(\n        \"Database adapter not initialized. Make sure @elizaos/plugin-sql is included in your plugins.\"\n      );\n      throw new Error(\n        \"Database adapter not initialized. The SQL plugin (@elizaos/plugin-sql) is required for agent initialization. Please ensure it is included in your character configuration.\"\n      );\n    }\n    try {\n      await this.adapter.init();\n      this.logger.info(\"Running plugin migrations...\");\n      await this.runPluginMigrations();\n      this.logger.info(\"Plugin migrations completed.\");\n      const existingAgent = await this.ensureAgentExists(this.character);\n      if (!existingAgent) {\n        const errorMsg = `Agent ${this.character.name} does not exist in database after ensureAgentExists call`;\n        throw new Error(errorMsg);\n      }\n      let agentEntity = await this.getEntityById(this.agentId);\n      if (!agentEntity) {\n        const created = await this.createEntity({\n          id: this.agentId,\n          names: [this.character.name],\n          metadata: {},\n          agentId: existingAgent.id\n        });\n        if (!created) {\n          const errorMsg = `Failed to create entity for agent ${this.agentId}`;\n          throw new Error(errorMsg);\n        }\n        agentEntity = await this.getEntityById(this.agentId);\n        if (!agentEntity) throw new Error(`Agent entity not found for ${this.agentId}`);\n        this.logger.debug(`Success: Agent entity created successfully for ${this.character.name}`);\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      this.logger.error(`Failed to create agent entity: ${errorMsg}`);\n      throw error;\n    }\n    try {\n      const room = await this.getRoom(this.agentId);\n      if (!room) {\n        await this.createRoom({\n          id: this.agentId,\n          name: this.character.name,\n          source: \"elizaos\",\n          type: \"SELF\" /* SELF */,\n          channelId: this.agentId,\n          serverId: this.agentId,\n          worldId: this.agentId\n        });\n      }\n      const participants = await this.adapter.getParticipantsForRoom(this.agentId);\n      if (!participants.includes(this.agentId)) {\n        const added = await this.addParticipant(this.agentId, this.agentId);\n        if (!added) {\n          const errorMsg = `Failed to add agent ${this.agentId} as participant to its own room`;\n          throw new Error(errorMsg);\n        }\n        this.logger.debug(`Agent ${this.character.name} linked to its own room successfully`);\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      this.logger.error(`Failed to add agent as participant: ${errorMsg}`);\n      throw error;\n    }\n    const embeddingModel = this.getModel(ModelType.TEXT_EMBEDDING);\n    if (!embeddingModel) {\n      this.logger.warn(\n        `[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered. Skipping embedding dimension setup.`\n      );\n    } else {\n      await this.ensureEmbeddingDimension();\n    }\n    for (const service of this.servicesInitQueue) {\n      await this.registerService(service);\n    }\n    this.isInitialized = true;\n  }\n  async runPluginMigrations() {\n    const drizzle = this.adapter?.db;\n    if (!drizzle) {\n      this.logger.warn(\"Drizzle instance not found on adapter, skipping plugin migrations.\");\n      return;\n    }\n    const pluginsWithSchemas = this.plugins.filter((p) => p.schema);\n    this.logger.info(`Found ${pluginsWithSchemas.length} plugins with schemas to migrate.`);\n    for (const p of pluginsWithSchemas) {\n      if (p.schema) {\n        this.logger.info(`Running migrations for plugin: ${p.name}`);\n        try {\n          if (this.adapter && \"runMigrations\" in this.adapter) {\n            await this.adapter.runMigrations(p.schema, p.name);\n            this.logger.info(`Successfully migrated plugin: ${p.name}`);\n          }\n        } catch (error) {\n          this.logger.error(`Failed to migrate plugin ${p.name}:`, error);\n        }\n      }\n    }\n  }\n  async getConnection() {\n    if (!this.adapter) {\n      throw new Error(\"Database adapter not registered\");\n    }\n    return this.adapter.getConnection();\n  }\n  setSetting(key, value, secret = false) {\n    if (secret) {\n      if (!this.character.secrets) {\n        this.character.secrets = {};\n      }\n      this.character.secrets[key] = value;\n    } else {\n      if (!this.character.settings) {\n        this.character.settings = {};\n      }\n      this.character.settings[key] = value;\n    }\n  }\n  getSetting(key) {\n    const value = this.character.secrets?.[key] || this.character.settings?.[key] || this.character.settings?.secrets?.[key] || this.settings[key];\n    const decryptedValue = decryptStringValue(value, getSalt());\n    if (decryptedValue === \"true\") return true;\n    if (decryptedValue === \"false\") return false;\n    return decryptedValue || null;\n  }\n  getConversationLength() {\n    return this.#conversationLength;\n  }\n  registerDatabaseAdapter(adapter) {\n    if (this.adapter) {\n      this.logger.warn(\n        \"Database adapter already registered. Additional adapters will be ignored. This may lead to unexpected behavior.\"\n      );\n    } else {\n      this.adapter = adapter;\n      this.logger.debug(\"Success: Database adapter registered successfully.\");\n    }\n  }\n  registerProvider(provider) {\n    this.providers.push(provider);\n    this.logger.debug(`Success: Provider ${provider.name} registered successfully.`);\n  }\n  registerAction(action) {\n    this.logger.debug(\n      `${this.character.name}(${this.agentId}) - Registering action: ${action.name}`\n    );\n    if (this.actions.find((a) => a.name === action.name)) {\n      this.logger.warn(\n        `${this.character.name}(${this.agentId}) - Action ${action.name} already exists. Skipping registration.`\n      );\n    } else {\n      this.actions.push(action);\n      this.logger.debug(\n        `${this.character.name}(${this.agentId}) - Action ${action.name} registered successfully.`\n      );\n    }\n  }\n  registerEvaluator(evaluator) {\n    this.evaluators.push(evaluator);\n  }\n  // Helper functions for immutable action plan updates\n  updateActionPlan(plan, updates) {\n    return { ...plan, ...updates };\n  }\n  updateActionStep(plan, index, stepUpdates) {\n    if (!plan.steps || index < 0 || index >= plan.steps.length) {\n      this.logger.warn(\n        `Invalid step index: ${index} for plan with ${plan.steps?.length || 0} steps`\n      );\n      return plan;\n    }\n    return {\n      ...plan,\n      steps: plan.steps.map(\n        (step, i) => i === index ? { ...step, ...stepUpdates } : step\n      )\n    };\n  }\n  async processActions(message, responses, state, callback) {\n    const allActions = [];\n    for (const response of responses) {\n      if (response.content?.actions && response.content.actions.length > 0) {\n        allActions.push(...response.content.actions);\n      }\n    }\n    const hasMultipleActions = allActions.length > 1;\n    const runId = this.createRunId();\n    let actionPlan = null;\n    if (hasMultipleActions) {\n      const thought = responses[0]?.content?.thought || `Executing ${allActions.length} actions: ${allActions.join(\", \")}`;\n      actionPlan = {\n        runId,\n        totalSteps: allActions.length,\n        currentStep: 0,\n        steps: allActions.map((action) => ({\n          action,\n          status: \"pending\"\n        })),\n        thought,\n        startTime: Date.now()\n      };\n    }\n    let actionIndex = 0;\n    for (const response of responses) {\n      let normalizeAction = function(actionString) {\n        return actionString.toLowerCase().replace(/_/g, \"\");\n      };\n      if (!response.content?.actions || response.content.actions.length === 0) {\n        this.logger.warn(\"No action found in the response content.\");\n        continue;\n      }\n      const actions = response.content.actions;\n      const actionResults = [];\n      let accumulatedState = state;\n      this.logger.debug(`Found actions: ${this.actions.map((a) => normalizeAction(a.name))}`);\n      for (const responseAction of actions) {\n        if (actionPlan) {\n          actionPlan = this.updateActionPlan(actionPlan, { currentStep: actionIndex + 1 });\n        }\n        accumulatedState = await this.composeState(message, [\n          \"RECENT_MESSAGES\",\n          \"ACTION_STATE\"\n          // This will include the action plan\n        ]);\n        if (actionPlan && accumulatedState.data) {\n          accumulatedState.data.actionPlan = actionPlan;\n          accumulatedState.data.actionResults = actionResults;\n        }\n        this.logger.debug(`Success: Calling action: ${responseAction}`);\n        const normalizedResponseAction = normalizeAction(responseAction);\n        let action = this.actions.find(\n          (a) => normalizeAction(a.name) === normalizedResponseAction\n        );\n        if (!action) {\n          action = this.actions.find(\n            (a) => normalizeAction(a.name).includes(normalizedResponseAction) || normalizedResponseAction.includes(normalizeAction(a.name))\n          );\n        }\n        if (action) {\n          this.logger.debug(`Success: Found action: ${action?.name}`);\n        } else {\n          this.logger.debug(\"Attempting to find action in similes.\");\n          for (const _action of this.actions) {\n            const exactSimileMatch = _action.similes?.find(\n              (simile) => normalizeAction(simile) === normalizedResponseAction\n            );\n            if (exactSimileMatch) {\n              action = _action;\n              this.logger.debug(`Success: Action found in similes (exact match): ${action.name}`);\n              break;\n            }\n            const fuzzySimileMatch = _action.similes?.find(\n              (simile) => normalizeAction(simile).includes(normalizedResponseAction) || normalizedResponseAction.includes(normalizeAction(simile))\n            );\n            if (fuzzySimileMatch) {\n              action = _action;\n              this.logger.debug(`Success: Action found in similes (fuzzy match): ${action.name}`);\n              break;\n            }\n          }\n        }\n        if (!action) {\n          const errorMsg = `No action found for: ${responseAction}`;\n          this.logger.error(errorMsg);\n          if (actionPlan && actionPlan.steps[actionIndex]) {\n            actionPlan = this.updateActionStep(actionPlan, actionIndex, {\n              status: \"failed\",\n              error: errorMsg\n            });\n          }\n          const actionMemory = {\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(),\n            entityId: message.entityId,\n            roomId: message.roomId,\n            worldId: message.worldId,\n            content: {\n              thought: errorMsg,\n              source: \"auto\",\n              type: \"action_result\",\n              actionName: responseAction,\n              actionStatus: \"failed\",\n              runId\n            }\n          };\n          await this.createMemory(actionMemory, \"messages\");\n          actionIndex++;\n          continue;\n        }\n        if (!action.handler) {\n          this.logger.error(`Action ${action.name} has no handler.`);\n          if (actionPlan && actionPlan.steps[actionIndex]) {\n            actionPlan = this.updateActionStep(actionPlan, actionIndex, {\n              status: \"failed\",\n              error: \"No handler\"\n            });\n          }\n          actionIndex++;\n          continue;\n        }\n        try {\n          this.logger.debug(`Executing handler for action: ${action.name}`);\n          const actionId = (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n          this.currentActionContext = {\n            actionName: action.name,\n            actionId,\n            prompts: []\n          };\n          const actionContext = {\n            previousResults: actionResults,\n            getPreviousResult: (actionName) => {\n              return actionResults.find((r) => r.data?.actionName === actionName);\n            }\n          };\n          const options2 = {\n            context: actionContext\n          };\n          if (actionPlan) {\n            options2.actionPlan = {\n              totalSteps: actionPlan.totalSteps,\n              currentStep: actionPlan.currentStep,\n              steps: actionPlan.steps,\n              thought: actionPlan.thought\n            };\n          }\n          const result = await action.handler(\n            this,\n            message,\n            accumulatedState,\n            options2,\n            callback,\n            responses\n          );\n          const isLegacyReturn = result === void 0 || result === null || typeof result === \"boolean\";\n          let actionResult = null;\n          if (!isLegacyReturn) {\n            if (typeof result === \"object\" && result !== null && (\"values\" in result || \"data\" in result || \"text\" in result)) {\n              actionResult = {\n                success: true,\n                // Default to true if not specified\n                ...result\n              };\n            } else {\n              actionResult = {\n                success: true,\n                // Default success for legacy results\n                data: {\n                  actionName: action.name,\n                  legacyResult: result\n                }\n              };\n            }\n            actionResults.push(actionResult);\n            if (actionResult.values) {\n              accumulatedState = {\n                ...accumulatedState,\n                values: { ...accumulatedState.values, ...actionResult.values },\n                data: {\n                  ...accumulatedState.data || {},\n                  actionResults: [...accumulatedState.data?.actionResults || [], actionResult],\n                  actionPlan\n                }\n              };\n            }\n            if (actionResult && accumulatedState.data) {\n              if (!accumulatedState.data.workingMemory) accumulatedState.data.workingMemory = {};\n              const memoryKey = `action_${responseAction}_${(0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])()}`;\n              const memoryEntry = {\n                actionName: action.name,\n                result: actionResult,\n                timestamp: Date.now()\n              };\n              accumulatedState.data.workingMemory[memoryKey] = memoryEntry;\n              const entries = Object.entries(accumulatedState.data.workingMemory);\n              if (entries.length > this.maxWorkingMemoryEntries) {\n                const sorted = entries.sort((a, b) => {\n                  const entryA = a[1];\n                  const entryB = b[1];\n                  const timestampA = entryA?.timestamp ?? 0;\n                  const timestampB = entryB?.timestamp ?? 0;\n                  return timestampB - timestampA;\n                });\n                accumulatedState.data.workingMemory = Object.fromEntries(\n                  sorted.slice(0, this.maxWorkingMemoryEntries)\n                );\n              }\n            }\n            if (actionPlan && actionPlan.steps[actionIndex]) {\n              actionPlan = this.updateActionStep(actionPlan, actionIndex, {\n                status: \"completed\",\n                result: actionResult\n              });\n            }\n          }\n          const actionMemory = {\n            id: actionId,\n            entityId: this.agentId,\n            roomId: message.roomId,\n            worldId: message.worldId,\n            content: {\n              text: actionResult?.text || `Executed action: ${action.name}`,\n              source: \"action\",\n              type: \"action_result\",\n              actionName: action.name,\n              actionStatus: actionResult?.success ? \"completed\" : \"failed\",\n              actionResult: isLegacyReturn ? { legacy: result } : actionResult,\n              runId,\n              ...actionPlan && {\n                planStep: `${actionPlan.currentStep}/${actionPlan.totalSteps}`,\n                planThought: actionPlan.thought\n              }\n            },\n            metadata: {\n              type: \"action_result\",\n              actionName: action.name,\n              runId,\n              actionId,\n              ...actionPlan && {\n                totalSteps: actionPlan.totalSteps,\n                currentStep: actionPlan.currentStep\n              }\n            }\n          };\n          await this.createMemory(actionMemory, \"messages\");\n          this.logger.debug(`Action ${action.name} completed`, {\n            isLegacyReturn,\n            result: isLegacyReturn ? result : void 0,\n            hasValues: actionResult ? !!actionResult.values : false,\n            hasData: actionResult ? !!actionResult.data : false,\n            hasText: actionResult ? !!actionResult.text : false\n          });\n          await this.adapter.log({\n            entityId: message.entityId,\n            roomId: message.roomId,\n            type: \"action\",\n            body: {\n              action: action.name,\n              actionId,\n              message: message.content.text,\n              messageId: message.id,\n              state: accumulatedState,\n              responses,\n              result: isLegacyReturn ? { legacy: result } : actionResult,\n              isLegacyReturn,\n              prompts: this.currentActionContext?.prompts || [],\n              promptCount: this.currentActionContext?.prompts.length || 0,\n              runId,\n              ...actionPlan && {\n                planStep: `${actionPlan.currentStep}/${actionPlan.totalSteps}`,\n                planThought: actionPlan.thought\n              }\n            }\n          });\n          this.currentActionContext = void 0;\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          this.logger.error(error);\n          if (actionPlan && actionPlan.steps[actionIndex]) {\n            actionPlan = this.updateActionStep(actionPlan, actionIndex, {\n              status: \"failed\",\n              error: errorMessage\n            });\n          }\n          this.currentActionContext = void 0;\n          const errorResult = {\n            success: false,\n            // Required field\n            data: {\n              actionName: action.name,\n              error: errorMessage,\n              errorObject: error\n            }\n          };\n          actionResults.push(errorResult);\n          const actionMemory = {\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(),\n            content: {\n              thought: errorMessage,\n              source: \"auto\",\n              type: \"action_result\",\n              actionName: action.name,\n              actionStatus: \"failed\",\n              error: errorMessage,\n              runId,\n              ...actionPlan && {\n                planStep: `${actionPlan.currentStep}/${actionPlan.totalSteps}`,\n                planThought: actionPlan.thought\n              }\n            },\n            entityId: this.agentId,\n            roomId: message.roomId,\n            worldId: message.worldId,\n            metadata: {\n              type: \"action_result\",\n              actionName: action.name,\n              runId,\n              error: true,\n              ...actionPlan && {\n                totalSteps: actionPlan.totalSteps,\n                currentStep: actionPlan.currentStep\n              }\n            }\n          };\n          await this.createMemory(actionMemory, \"messages\");\n          if (error?.critical || error?.code === \"CRITICAL_ERROR\") {\n            throw error;\n          }\n        }\n        actionIndex++;\n      }\n      if (message.id) {\n        this.stateCache.set(`${message.id}_action_results`, {\n          values: { actionResults },\n          data: { actionResults, actionPlan },\n          text: JSON.stringify(actionResults)\n        });\n      }\n    }\n  }\n  async evaluate(message, state, didRespond, callback, responses) {\n    const evaluatorPromises = this.evaluators.map(async (evaluator) => {\n      if (!evaluator.handler) {\n        return null;\n      }\n      if (!didRespond && !evaluator.alwaysRun) {\n        return null;\n      }\n      const result = await evaluator.validate(this, message, state);\n      if (result) {\n        return evaluator;\n      }\n      return null;\n    });\n    const evaluators = (await Promise.all(evaluatorPromises)).filter(Boolean);\n    if (evaluators.length === 0) {\n      return [];\n    }\n    state = await this.composeState(message, [\"RECENT_MESSAGES\", \"EVALUATORS\"]);\n    await Promise.all(\n      evaluators.map(async (evaluator) => {\n        if (evaluator.handler) {\n          await evaluator.handler(this, message, state, {}, callback, responses);\n          this.adapter.log({\n            entityId: message.entityId,\n            roomId: message.roomId,\n            type: \"evaluator\",\n            body: {\n              evaluator: evaluator.name,\n              messageId: message.id,\n              message: message.content.text,\n              state\n            }\n          });\n        }\n      })\n    );\n    return evaluators;\n  }\n  // highly SQL optimized queries\n  async ensureConnections(entities, rooms, source, world) {\n    if (!entities) {\n      console.trace();\n      this.logger.error(\"ensureConnections - no entities\");\n      return;\n    }\n    if (!rooms || rooms.length === 0) {\n      console.trace();\n      this.logger.error(\"ensureConnections - no rooms\");\n      return;\n    }\n    await this.ensureWorldExists({ ...world, agentId: this.agentId });\n    const firstRoom = rooms[0];\n    const chunkArray = (arr, size) => arr.reduce((chunks, item, i) => {\n      if (i % size === 0) chunks.push([]);\n      chunks[chunks.length - 1].push(item);\n      return chunks;\n    }, []);\n    const roomIds = rooms.map((r2) => r2.id);\n    const roomExistsCheck = await this.getRoomsByIds(roomIds);\n    const roomsIdExists = roomExistsCheck.map((r2) => r2.id);\n    const roomsToCreate = roomIds.filter((id) => !roomsIdExists.includes(id));\n    const rf = {\n      worldId: world.id,\n      serverId: world.serverId,\n      source,\n      agentId: this.agentId\n    };\n    if (roomsToCreate.length) {\n      this.logger.debug(\n        \"runtime/ensureConnections - create\",\n        roomsToCreate.length.toLocaleString(),\n        \"rooms\"\n      );\n      const roomObjsToCreate = rooms.filter((r2) => roomsToCreate.includes(r2.id)).map((r2) => ({ ...r2, ...rf }));\n      await this.createRooms(roomObjsToCreate);\n    }\n    const entityIds = entities.map((e) => e.id);\n    const entityExistsCheck = await this.adapter.getEntitiesByIds(entityIds);\n    const entitiesToUpdate = entityExistsCheck.map((e) => e.id);\n    const entitiesToCreate = entities.filter((e) => !entitiesToUpdate.includes(e.id));\n    const r = {\n      roomId: firstRoom.id,\n      channelId: firstRoom.channelId,\n      type: firstRoom.type\n    };\n    const wf = {\n      worldId: world.id,\n      serverId: world.serverId\n    };\n    if (entitiesToCreate.length) {\n      this.logger.debug(\n        \"runtime/ensureConnections - creating\",\n        entitiesToCreate.length.toLocaleString(),\n        \"entities...\"\n      );\n      const ef = {\n        ...r,\n        ...wf,\n        source,\n        agentId: this.agentId\n      };\n      const entitiesToCreateWFields = entitiesToCreate.map((e) => ({ ...e, ...ef }));\n      const batches = chunkArray(entitiesToCreateWFields, 5e3);\n      for (const batch of batches) {\n        await this.createEntities(batch);\n      }\n    }\n    await this.ensureParticipantInRoom(this.agentId, firstRoom.id);\n    const entityIdsInFirstRoom = await this.getParticipantsForRoom(firstRoom.id);\n    const entityIdsInFirstRoomFiltered = entityIdsInFirstRoom.filter(Boolean);\n    const missingIdsInRoom = entityIds.filter((id) => !entityIdsInFirstRoomFiltered.includes(id));\n    if (missingIdsInRoom.length) {\n      this.logger.debug(\n        \"runtime/ensureConnections - Missing\",\n        missingIdsInRoom.length.toLocaleString(),\n        \"connections in\",\n        firstRoom.id\n      );\n      await this.addParticipantsRoom(missingIdsInRoom, firstRoom.id);\n    }\n    this.logger.success(`Success: Successfully connected world`);\n  }\n  async ensureConnection({\n    entityId,\n    roomId,\n    worldId,\n    worldName,\n    userName,\n    name,\n    source,\n    type,\n    channelId,\n    serverId,\n    userId,\n    metadata\n  }) {\n    if (!worldId && serverId) {\n      worldId = createUniqueUuid(this.agentId + serverId, serverId);\n    }\n    const names3 = [name, userName].filter(Boolean);\n    const entityMetadata = {\n      [source]: {\n        id: userId,\n        name,\n        userName\n      }\n    };\n    try {\n      const entity = await this.getEntityById(entityId);\n      if (!entity) {\n        try {\n          const success = await this.createEntity({\n            id: entityId,\n            names: names3,\n            metadata: entityMetadata,\n            agentId: this.agentId\n          });\n          if (success) {\n            this.logger.debug(\n              `Created new entity ${entityId} for user ${name || userName || \"unknown\"}`\n            );\n          } else {\n            throw new Error(`Failed to create entity ${entityId}`);\n          }\n        } catch (error) {\n          if (error.message?.includes(\"duplicate key\") || error.code === \"23505\") {\n            this.logger.debug(\n              `Entity ${entityId} exists in database but not for this agent. This is normal in multi-agent setups.`\n            );\n          } else {\n            throw error;\n          }\n        }\n      } else {\n        await this.adapter.updateEntity({\n          id: entityId,\n          names: [.../* @__PURE__ */ new Set([...entity.names || [], ...names3])].filter(Boolean),\n          metadata: {\n            ...entity.metadata,\n            [source]: {\n              ...entity.metadata?.[source],\n              id: userId,\n              name,\n              userName\n            }\n          },\n          agentId: this.agentId\n        });\n      }\n      await this.ensureWorldExists({\n        id: worldId,\n        name: worldName || serverId ? `World for server ${serverId}` : `World for room ${roomId}`,\n        agentId: this.agentId,\n        serverId: serverId || \"default\",\n        metadata\n      });\n      await this.ensureRoomExists({\n        id: roomId,\n        name,\n        source,\n        type,\n        channelId,\n        serverId,\n        worldId\n      });\n      try {\n        await this.ensureParticipantInRoom(entityId, roomId);\n      } catch (error) {\n        if (error.message?.includes(\"not found\")) {\n          const added = await this.addParticipant(entityId, roomId);\n          if (!added) {\n            throw new Error(`Failed to add participant ${entityId} to room ${roomId}`);\n          }\n          this.logger.debug(`Added participant ${entityId} to room ${roomId} directly`);\n        } else {\n          throw error;\n        }\n      }\n      await this.ensureParticipantInRoom(this.agentId, roomId);\n      this.logger.debug(`Success: Successfully connected entity ${entityId} in room ${roomId}`);\n    } catch (error) {\n      this.logger.error(\n        `Failed to ensure connection: ${error instanceof Error ? error.message : String(error)}`\n      );\n      throw error;\n    }\n  }\n  async ensureParticipantInRoom(entityId, roomId) {\n    const entity = await this.getEntityById(entityId);\n    if (!entity && entityId !== this.agentId) {\n      this.logger.warn(\n        `Entity ${entityId} not directly accessible to agent ${this.agentId}. Will attempt to add as participant anyway.`\n      );\n    } else if (!entity && entityId === this.agentId) {\n      throw new Error(`Agent entity ${entityId} not found, cannot add as participant.`);\n    } else if (!entity) {\n      throw new Error(`User entity ${entityId} not found, cannot add as participant.`);\n    }\n    const participants = await this.adapter.getParticipantsForRoom(roomId);\n    if (!participants.includes(entityId)) {\n      const added = await this.addParticipant(entityId, roomId);\n      if (!added) {\n        throw new Error(`Failed to add participant ${entityId} to room ${roomId}`);\n      }\n      if (entityId === this.agentId) {\n        this.logger.debug(`Agent ${this.character.name} linked to room ${roomId} successfully.`);\n      } else {\n        this.logger.debug(`User ${entityId} linked to room ${roomId} successfully.`);\n      }\n    }\n  }\n  async removeParticipant(entityId, roomId) {\n    return await this.adapter.removeParticipant(entityId, roomId);\n  }\n  async getParticipantsForEntity(entityId) {\n    return await this.adapter.getParticipantsForEntity(entityId);\n  }\n  async getParticipantsForRoom(roomId) {\n    return await this.adapter.getParticipantsForRoom(roomId);\n  }\n  async addParticipant(entityId, roomId) {\n    return await this.adapter.addParticipantsRoom([entityId], roomId);\n  }\n  async addParticipantsRoom(entityIds, roomId) {\n    return await this.adapter.addParticipantsRoom(entityIds, roomId);\n  }\n  /**\n   * Ensure the existence of a world.\n   */\n  async ensureWorldExists({ id, name, serverId, metadata }) {\n    const world = await this.getWorld(id);\n    if (!world) {\n      this.logger.debug(\"Creating world:\", {\n        id,\n        name,\n        serverId,\n        agentId: this.agentId\n      });\n      await this.adapter.createWorld({\n        id,\n        name,\n        agentId: this.agentId,\n        serverId: serverId || \"default\",\n        metadata\n      });\n      this.logger.debug(`World ${id} created successfully.`);\n    }\n  }\n  async ensureRoomExists({ id, name, source, type, channelId, serverId, worldId, metadata }) {\n    if (!worldId) throw new Error(\"worldId is required\");\n    const room = await this.getRoom(id);\n    if (!room) {\n      await this.createRoom({\n        id,\n        name,\n        agentId: this.agentId,\n        source,\n        type,\n        channelId,\n        serverId,\n        worldId,\n        metadata\n      });\n      this.logger.debug(`Room ${id} created successfully.`);\n    }\n  }\n  async composeState(message, includeList = null, onlyInclude = false, skipCache = false) {\n    const filterList = onlyInclude ? includeList : null;\n    const emptyObj = {\n      values: {},\n      data: {},\n      text: \"\"\n    };\n    const cachedState = skipCache ? emptyObj : await this.stateCache.get(message.id) || emptyObj;\n    const providerNames = /* @__PURE__ */ new Set();\n    if (filterList && filterList.length > 0) {\n      filterList.forEach((name) => providerNames.add(name));\n    } else {\n      this.providers.filter((p) => !p.private && !p.dynamic).forEach((p) => providerNames.add(p.name));\n    }\n    if (!filterList && includeList && includeList.length > 0) {\n      includeList.forEach((name) => providerNames.add(name));\n    }\n    const providersToGet = Array.from(\n      new Set(this.providers.filter((p) => providerNames.has(p.name)))\n    ).sort((a, b) => (a.position || 0) - (b.position || 0));\n    const providerData = await Promise.all(\n      providersToGet.map(async (provider) => {\n        const start = Date.now();\n        try {\n          const result = await provider.get(this, message, cachedState);\n          const duration = Date.now() - start;\n          this.logger.debug(`${provider.name} Provider took ${duration}ms to respond`);\n          return {\n            ...result,\n            providerName: provider.name\n          };\n        } catch (error) {\n          console.error(\"provider error\", provider.name, error);\n          return { values: {}, text: \"\", data: {}, providerName: provider.name };\n        }\n      })\n    );\n    const currentProviderResults = { ...cachedState.data?.providers || {} };\n    for (const freshResult of providerData) {\n      currentProviderResults[freshResult.providerName] = freshResult;\n    }\n    const orderedTexts = [];\n    for (const provider of providersToGet) {\n      const result = currentProviderResults[provider.name];\n      if (result && result.text && result.text.trim() !== \"\") {\n        orderedTexts.push(result.text);\n      }\n    }\n    const providersText = orderedTexts.join(\"\\n\");\n    const aggregatedStateValues = { ...cachedState.values || {} };\n    for (const provider of providersToGet) {\n      const providerResult = currentProviderResults[provider.name];\n      if (providerResult && providerResult.values && typeof providerResult.values === \"object\") {\n        Object.assign(aggregatedStateValues, providerResult.values);\n      }\n    }\n    for (const providerName in currentProviderResults) {\n      if (!providersToGet.some((p) => p.name === providerName)) {\n        const providerResult = currentProviderResults[providerName];\n        if (providerResult && providerResult.values && typeof providerResult.values === \"object\") {\n          Object.assign(aggregatedStateValues, providerResult.values);\n        }\n      }\n    }\n    const newState = {\n      values: {\n        ...aggregatedStateValues,\n        providers: providersText\n      },\n      data: {\n        ...cachedState.data || {},\n        providers: currentProviderResults\n      },\n      text: providersText\n    };\n    this.stateCache.set(message.id, newState);\n    return newState;\n  }\n  getService(serviceName) {\n    const serviceInstances = this.services.get(serviceName);\n    if (!serviceInstances || serviceInstances.length === 0) {\n      this.logger.debug(`Service ${serviceName} not found`);\n      return null;\n    }\n    return serviceInstances[0];\n  }\n  /**\n   * Type-safe service getter that ensures the correct service type is returned\n   * @template T - The expected service class type\n   * @param serviceName - The service type name\n   * @returns The service instance with proper typing, or null if not found\n   */\n  getTypedService(serviceName) {\n    return this.getService(serviceName);\n  }\n  /**\n   * Get all services of a specific type\n   * @template T - The expected service class type\n   * @param serviceName - The service type name\n   * @returns Array of service instances with proper typing\n   */\n  getServicesByType(serviceName) {\n    const serviceInstances = this.services.get(serviceName);\n    if (!serviceInstances || serviceInstances.length === 0) {\n      this.logger.debug(`No services found for type ${serviceName}`);\n      return [];\n    }\n    return serviceInstances;\n  }\n  /**\n   * Get all registered service types\n   * @returns Array of registered service type names\n   */\n  getRegisteredServiceTypes() {\n    return Array.from(this.services.keys());\n  }\n  /**\n   * Check if a service type is registered\n   * @param serviceType - The service type to check\n   * @returns true if the service is registered\n   */\n  hasService(serviceType) {\n    const serviceInstances = this.services.get(serviceType);\n    return serviceInstances !== void 0 && serviceInstances.length > 0;\n  }\n  async registerService(serviceDef) {\n    const serviceType = serviceDef.serviceType;\n    if (!serviceType) {\n      this.logger.warn(\n        `Service ${serviceDef.name} is missing serviceType. Please define a static serviceType property.`\n      );\n      return;\n    }\n    this.logger.debug(\n      `${this.character.name}(${this.agentId}) - Registering service:`,\n      serviceType\n    );\n    try {\n      const serviceInstance = await serviceDef.start(this);\n      if (!this.services.has(serviceType)) {\n        this.services.set(serviceType, []);\n      }\n      if (!this.serviceTypes.has(serviceType)) {\n        this.serviceTypes.set(serviceType, []);\n      }\n      this.services.get(serviceType).push(serviceInstance);\n      this.serviceTypes.get(serviceType).push(serviceDef);\n      if (typeof serviceDef.registerSendHandlers === \"function\") {\n        serviceDef.registerSendHandlers(this, serviceInstance);\n      }\n      this.logger.debug(\n        `${this.character.name}(${this.agentId}) - Service ${serviceType} registered successfully`\n      );\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error(\n        `${this.character.name}(${this.agentId}) - Failed to register service ${serviceType}: ${errorMessage}`\n      );\n      throw error;\n    }\n  }\n  registerModel(modelType, handler, provider, priority) {\n    const modelKey = typeof modelType === \"string\" ? modelType : ModelType[modelType];\n    if (!this.models.has(modelKey)) {\n      this.models.set(modelKey, []);\n    }\n    const registrationOrder = Date.now();\n    this.models.get(modelKey)?.push({\n      handler,\n      provider,\n      priority: priority || 0,\n      registrationOrder\n    });\n    this.models.get(modelKey)?.sort((a, b) => {\n      if ((b.priority || 0) !== (a.priority || 0)) {\n        return (b.priority || 0) - (a.priority || 0);\n      }\n      return a.registrationOrder - b.registrationOrder;\n    });\n  }\n  getModel(modelType, provider) {\n    const modelKey = typeof modelType === \"string\" ? modelType : ModelType[modelType];\n    const models = this.models.get(modelKey);\n    if (!models?.length) {\n      return void 0;\n    }\n    if (provider) {\n      const modelWithProvider = models.find((m) => m.provider === provider);\n      if (modelWithProvider) {\n        this.logger.debug(\n          `[AgentRuntime][${this.character.name}] Using model ${modelKey} from provider ${provider}`\n        );\n        return modelWithProvider.handler;\n      } else {\n        this.logger.warn(\n          `[AgentRuntime][${this.character.name}] No model found for provider ${provider}`\n        );\n      }\n    }\n    this.logger.debug(\n      `[AgentRuntime][${this.character.name}] Using model ${modelKey} from provider ${models[0].provider}`\n    );\n    return models[0].handler;\n  }\n  /**\n   * Retrieves model configuration settings from character settings with support for\n   * model-specific overrides and default fallbacks.\n   *\n   * Precedence order (highest to lowest):\n   * 1. Model-specific settings (e.g., TEXT_SMALL_TEMPERATURE)\n   * 2. Default settings (e.g., DEFAULT_TEMPERATURE)\n   * 3. Legacy settings for backwards compatibility (e.g., MODEL_TEMPERATURE)\n   *\n   * @param modelType The specific model type to get settings for\n   * @returns Object containing model parameters if they exist, or null if no settings are configured\n   */\n  getModelSettings(modelType) {\n    const modelSettings = {};\n    const getSettingWithFallback = (param, legacyKey) => {\n      if (modelType) {\n        const modelSpecificKey = `${modelType}_${param}`;\n        const modelValue = this.getSetting(modelSpecificKey);\n        if (modelValue !== null && modelValue !== void 0) {\n          const numValue = Number(modelValue);\n          if (!isNaN(numValue)) {\n            return numValue;\n          }\n        }\n      }\n      const defaultKey = `DEFAULT_${param}`;\n      const defaultValue = this.getSetting(defaultKey);\n      if (defaultValue !== null && defaultValue !== void 0) {\n        const numValue = Number(defaultValue);\n        if (!isNaN(numValue)) {\n          return numValue;\n        }\n      }\n      const legacyValue = this.getSetting(legacyKey);\n      if (legacyValue !== null && legacyValue !== void 0) {\n        const numValue = Number(legacyValue);\n        if (!isNaN(numValue)) {\n          return numValue;\n        }\n      }\n      return null;\n    };\n    const maxTokens = getSettingWithFallback(\"MAX_TOKENS\", MODEL_SETTINGS.MODEL_MAX_TOKEN);\n    const temperature = getSettingWithFallback(\"TEMPERATURE\", MODEL_SETTINGS.MODEL_TEMPERATURE);\n    const frequencyPenalty = getSettingWithFallback(\n      \"FREQUENCY_PENALTY\",\n      MODEL_SETTINGS.MODEL_FREQ_PENALTY\n    );\n    const presencePenalty = getSettingWithFallback(\n      \"PRESENCE_PENALTY\",\n      MODEL_SETTINGS.MODEL_PRESENCE_PENALTY\n    );\n    if (maxTokens !== null) modelSettings.maxTokens = maxTokens;\n    if (temperature !== null) modelSettings.temperature = temperature;\n    if (frequencyPenalty !== null) modelSettings.frequencyPenalty = frequencyPenalty;\n    if (presencePenalty !== null) modelSettings.presencePenalty = presencePenalty;\n    return Object.keys(modelSettings).length > 0 ? modelSettings : null;\n  }\n  async useModel(modelType, params, provider) {\n    const modelKey = typeof modelType === \"string\" ? modelType : ModelType[modelType];\n    const promptContent = params?.prompt || params?.input || (Array.isArray(params?.messages) ? JSON.stringify(params.messages) : null);\n    const model = this.getModel(modelKey, provider);\n    if (!model) {\n      const errorMsg = `No handler found for delegate type: ${modelKey}`;\n      throw new Error(errorMsg);\n    }\n    this.logger.debug(\n      `[useModel] ${modelKey} input: ` + JSON.stringify(params, safeReplacer(), 2).replace(/\\\\n/g, \"\\n\")\n    );\n    let paramsWithRuntime;\n    if (params === null || params === void 0 || typeof params !== \"object\" || Array.isArray(params) || typeof Buffer !== \"undefined\" && Buffer.isBuffer(params)) {\n      paramsWithRuntime = params;\n    } else {\n      const modelSettings = this.getModelSettings(modelKey);\n      if (modelSettings) {\n        paramsWithRuntime = {\n          ...modelSettings,\n          // Apply model settings first (includes defaults and model-specific)\n          ...params,\n          // Then apply specific params (allowing overrides)\n          runtime: this\n        };\n      } else {\n        paramsWithRuntime = {\n          ...params,\n          runtime: this\n        };\n      }\n    }\n    const startTime = performance.now();\n    try {\n      const response = await model(this, paramsWithRuntime);\n      const elapsedTime = performance.now() - startTime;\n      this.logger.debug(\n        `[useModel] ${modelKey} output (took ${Number(elapsedTime.toFixed(2)).toLocaleString()}ms):`,\n        Array.isArray(response) ? `${JSON.stringify(response.slice(0, 5))}...${JSON.stringify(response.slice(-5))} (${response.length} items)` : JSON.stringify(response, safeReplacer(), 2).replace(/\\\\n/g, \"\\n\")\n      );\n      if (modelKey !== ModelType.TEXT_EMBEDDING && promptContent) {\n        if (this.currentActionContext) {\n          this.currentActionContext.prompts.push({\n            modelType: modelKey,\n            prompt: promptContent,\n            timestamp: Date.now()\n          });\n        }\n      }\n      this.adapter.log({\n        entityId: this.agentId,\n        roomId: this.agentId,\n        body: {\n          modelType,\n          modelKey,\n          params: {\n            ...typeof params === \"object\" && !Array.isArray(params) && params ? params : {},\n            prompt: promptContent\n          },\n          prompt: promptContent,\n          runId: this.getCurrentRunId(),\n          timestamp: Date.now(),\n          executionTime: elapsedTime,\n          provider: provider || this.models.get(modelKey)?.[0]?.provider || \"unknown\",\n          actionContext: this.currentActionContext ? {\n            actionName: this.currentActionContext.actionName,\n            actionId: this.currentActionContext.actionId\n          } : void 0,\n          response: Array.isArray(response) && response.every((x) => typeof x === \"number\") ? \"[array]\" : response\n        },\n        type: `useModel:${modelKey}`\n      });\n      return response;\n    } catch (error) {\n      throw error;\n    }\n  }\n  registerEvent(event, handler) {\n    if (!this.events.has(event)) {\n      this.events.set(event, []);\n    }\n    this.events.get(event)?.push(handler);\n  }\n  getEvent(event) {\n    return this.events.get(event);\n  }\n  async emitEvent(event, params) {\n    const events = Array.isArray(event) ? event : [event];\n    for (const eventName of events) {\n      const eventHandlers = this.events.get(eventName);\n      if (!eventHandlers) {\n        continue;\n      }\n      try {\n        await Promise.all(eventHandlers.map((handler) => handler(params)));\n      } catch (error) {\n        this.logger.error(`Error during emitEvent for ${eventName} (handler execution):`, error);\n      }\n    }\n  }\n  async ensureEmbeddingDimension() {\n    this.logger.debug(`[AgentRuntime][${this.character.name}] Starting ensureEmbeddingDimension`);\n    if (!this.adapter) {\n      throw new Error(\n        `[AgentRuntime][${this.character.name}] Database adapter not initialized before ensureEmbeddingDimension`\n      );\n    }\n    try {\n      const model = this.getModel(ModelType.TEXT_EMBEDDING);\n      if (!model) {\n        throw new Error(\n          `[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered`\n        );\n      }\n      this.logger.debug(`[AgentRuntime][${this.character.name}] Getting embedding dimensions`);\n      const embedding = await this.useModel(ModelType.TEXT_EMBEDDING, null);\n      if (!embedding || !embedding.length) {\n        throw new Error(`[AgentRuntime][${this.character.name}] Invalid embedding received`);\n      }\n      this.logger.debug(\n        `[AgentRuntime][${this.character.name}] Setting embedding dimension: ${embedding.length}`\n      );\n      await this.adapter.ensureEmbeddingDimension(embedding.length);\n      this.logger.debug(\n        `[AgentRuntime][${this.character.name}] Successfully set embedding dimension`\n      );\n    } catch (error) {\n      this.logger.debug(\n        `[AgentRuntime][${this.character.name}] Error in ensureEmbeddingDimension:`,\n        error\n      );\n      throw error;\n    }\n  }\n  registerTaskWorker(taskHandler) {\n    if (this.taskWorkers.has(taskHandler.name)) {\n      this.logger.warn(\n        `Task definition ${taskHandler.name} already registered. Will be overwritten.`\n      );\n    }\n    this.taskWorkers.set(taskHandler.name, taskHandler);\n  }\n  getTaskWorker(name) {\n    return this.taskWorkers.get(name);\n  }\n  get db() {\n    return this.adapter.db;\n  }\n  async init() {\n    await this.adapter.init();\n  }\n  async close() {\n    await this.adapter.close();\n  }\n  async getAgent(agentId) {\n    return await this.adapter.getAgent(agentId);\n  }\n  async getAgents() {\n    return await this.adapter.getAgents();\n  }\n  async createAgent(agent) {\n    return await this.adapter.createAgent(agent);\n  }\n  async updateAgent(agentId, agent) {\n    return await this.adapter.updateAgent(agentId, agent);\n  }\n  async deleteAgent(agentId) {\n    return await this.adapter.deleteAgent(agentId);\n  }\n  async ensureAgentExists(agent) {\n    if (!agent.name) {\n      throw new Error(\"Agent name is required\");\n    }\n    const agents = await this.adapter.getAgents();\n    const existingAgentId = agents.find((a) => a.name === agent.name)?.id;\n    if (existingAgentId) {\n      const updatedAgent = {\n        ...agent,\n        id: existingAgentId,\n        updatedAt: Date.now()\n      };\n      await this.adapter.updateAgent(existingAgentId, updatedAgent);\n      const existingAgent = await this.adapter.getAgent(existingAgentId);\n      if (!existingAgent) {\n        throw new Error(`Failed to retrieve agent after update: ${existingAgentId}`);\n      }\n      this.logger.debug(`Updated existing agent ${agent.name} on restart`);\n      return existingAgent;\n    }\n    const newAgent = {\n      ...agent,\n      id: stringToUuid(agent.name)\n    };\n    const created = await this.adapter.createAgent(newAgent);\n    if (!created) {\n      throw new Error(`Failed to create agent: ${agent.name}`);\n    }\n    this.logger.debug(`Created new agent ${agent.name}`);\n    return newAgent;\n  }\n  async getEntityById(entityId) {\n    const entities = await this.adapter.getEntitiesByIds([entityId]);\n    if (!entities?.length) return null;\n    return entities[0];\n  }\n  async getEntitiesByIds(entityIds) {\n    return await this.adapter.getEntitiesByIds(entityIds);\n  }\n  async getEntitiesForRoom(roomId, includeComponents) {\n    return await this.adapter.getEntitiesForRoom(roomId, includeComponents);\n  }\n  async createEntity(entity) {\n    if (!entity.agentId) {\n      entity.agentId = this.agentId;\n    }\n    return await this.createEntities([entity]);\n  }\n  async createEntities(entities) {\n    entities.forEach((e) => {\n      e.agentId = this.agentId;\n    });\n    return await this.adapter.createEntities(entities);\n  }\n  async updateEntity(entity) {\n    await this.adapter.updateEntity(entity);\n  }\n  async getComponent(entityId, type, worldId, sourceEntityId) {\n    return await this.adapter.getComponent(entityId, type, worldId, sourceEntityId);\n  }\n  async getComponents(entityId, worldId, sourceEntityId) {\n    return await this.adapter.getComponents(entityId, worldId, sourceEntityId);\n  }\n  async createComponent(component) {\n    return await this.adapter.createComponent(component);\n  }\n  async updateComponent(component) {\n    await this.adapter.updateComponent(component);\n  }\n  async deleteComponent(componentId) {\n    await this.adapter.deleteComponent(componentId);\n  }\n  async addEmbeddingToMemory(memory) {\n    if (memory.embedding) {\n      return memory;\n    }\n    const memoryText = memory.content.text;\n    if (!memoryText) {\n      throw new Error(\"Cannot generate embedding: Memory content is empty\");\n    }\n    try {\n      memory.embedding = await this.useModel(ModelType.TEXT_EMBEDDING, {\n        text: memoryText\n      });\n    } catch (error) {\n      this.logger.error(\"Failed to generate embedding:\", error);\n      memory.embedding = await this.useModel(ModelType.TEXT_EMBEDDING, null);\n    }\n    return memory;\n  }\n  async getMemories(params) {\n    return await this.adapter.getMemories(params);\n  }\n  async getAllMemories() {\n    const tables = [\"memories\", \"messages\", \"facts\", \"documents\"];\n    const allMemories = [];\n    for (const tableName of tables) {\n      try {\n        const memories = await this.adapter.getMemories({\n          agentId: this.agentId,\n          tableName,\n          count: 1e4\n          // Get a large number to fetch all\n        });\n        allMemories.push(...memories);\n      } catch (error) {\n        this.logger.debug(`Failed to get memories from table ${tableName}:`, error);\n      }\n    }\n    return allMemories;\n  }\n  async getMemoryById(id) {\n    return await this.adapter.getMemoryById(id);\n  }\n  async getMemoriesByIds(ids, tableName) {\n    return await this.adapter.getMemoriesByIds(ids, tableName);\n  }\n  async getMemoriesByRoomIds(params) {\n    return await this.adapter.getMemoriesByRoomIds(params);\n  }\n  async getCachedEmbeddings(params) {\n    return await this.adapter.getCachedEmbeddings(params);\n  }\n  async log(params) {\n    await this.adapter.log(params);\n  }\n  async searchMemories(params) {\n    const memories = await this.adapter.searchMemories(params);\n    if (params.query) {\n      const rerankedMemories = await this.rerankMemories(params.query, memories);\n      return rerankedMemories;\n    }\n    return memories;\n  }\n  async rerankMemories(query, memories) {\n    const docs = memories.map((memory) => ({\n      title: memory.id,\n      content: memory.content.text\n    }));\n    const bm25 = new BM25(docs);\n    const results = bm25.search(query, memories.length);\n    return results.map((result) => memories[result.index]);\n  }\n  async createMemory(memory, tableName, unique) {\n    return await this.adapter.createMemory(memory, tableName, unique);\n  }\n  async updateMemory(memory) {\n    return await this.adapter.updateMemory(memory);\n  }\n  async deleteMemory(memoryId) {\n    await this.adapter.deleteMemory(memoryId);\n  }\n  async deleteManyMemories(memoryIds) {\n    await this.adapter.deleteManyMemories(memoryIds);\n  }\n  async clearAllAgentMemories() {\n    this.logger.info(`Clearing all memories for agent ${this.character.name} (${this.agentId})`);\n    const allMemories = await this.getAllMemories();\n    const memoryIds = allMemories.map((memory) => memory.id);\n    if (memoryIds.length === 0) {\n      this.logger.info(\"No memories found to delete\");\n      return;\n    }\n    this.logger.info(`Found ${memoryIds.length} memories to delete`);\n    await this.adapter.deleteManyMemories(memoryIds);\n    this.logger.info(`Successfully cleared all ${memoryIds.length} memories for agent`);\n  }\n  async deleteAllMemories(roomId, tableName) {\n    await this.adapter.deleteAllMemories(roomId, tableName);\n  }\n  async countMemories(roomId, unique, tableName) {\n    return await this.adapter.countMemories(roomId, unique, tableName);\n  }\n  async getLogs(params) {\n    return await this.adapter.getLogs(params);\n  }\n  async deleteLog(logId) {\n    await this.adapter.deleteLog(logId);\n  }\n  async createWorld(world) {\n    return await this.adapter.createWorld(world);\n  }\n  async getWorld(id) {\n    return await this.adapter.getWorld(id);\n  }\n  async removeWorld(worldId) {\n    await this.adapter.removeWorld(worldId);\n  }\n  async getAllWorlds() {\n    return await this.adapter.getAllWorlds();\n  }\n  async updateWorld(world) {\n    await this.adapter.updateWorld(world);\n  }\n  async getRoom(roomId) {\n    const rooms = await this.adapter.getRoomsByIds([roomId]);\n    if (!rooms?.length) return null;\n    return rooms[0];\n  }\n  async getRoomsByIds(roomIds) {\n    return await this.adapter.getRoomsByIds(roomIds);\n  }\n  async createRoom({ id, name, source, type, channelId, serverId, worldId }) {\n    if (!worldId) throw new Error(\"worldId is required\");\n    const res = await this.adapter.createRooms([\n      {\n        id,\n        name,\n        source,\n        type,\n        channelId,\n        serverId,\n        worldId\n      }\n    ]);\n    if (!res.length) return null;\n    return res[0];\n  }\n  async createRooms(rooms) {\n    return await this.adapter.createRooms(rooms);\n  }\n  async deleteRoom(roomId) {\n    await this.adapter.deleteRoom(roomId);\n  }\n  async deleteRoomsByWorldId(worldId) {\n    await this.adapter.deleteRoomsByWorldId(worldId);\n  }\n  async updateRoom(room) {\n    await this.adapter.updateRoom(room);\n  }\n  async getRoomsForParticipant(entityId) {\n    return await this.adapter.getRoomsForParticipant(entityId);\n  }\n  async getRoomsForParticipants(userIds) {\n    return await this.adapter.getRoomsForParticipants(userIds);\n  }\n  // deprecate this one\n  async getRooms(worldId) {\n    return await this.adapter.getRoomsByWorld(worldId);\n  }\n  async getRoomsByWorld(worldId) {\n    return await this.adapter.getRoomsByWorld(worldId);\n  }\n  async getParticipantUserState(roomId, entityId) {\n    return await this.adapter.getParticipantUserState(roomId, entityId);\n  }\n  async setParticipantUserState(roomId, entityId, state) {\n    await this.adapter.setParticipantUserState(roomId, entityId, state);\n  }\n  async createRelationship(params) {\n    return await this.adapter.createRelationship(params);\n  }\n  async updateRelationship(relationship) {\n    await this.adapter.updateRelationship(relationship);\n  }\n  async getRelationship(params) {\n    return await this.adapter.getRelationship(params);\n  }\n  async getRelationships(params) {\n    return await this.adapter.getRelationships(params);\n  }\n  async getCache(key) {\n    return await this.adapter.getCache(key);\n  }\n  async setCache(key, value) {\n    return await this.adapter.setCache(key, value);\n  }\n  async deleteCache(key) {\n    return await this.adapter.deleteCache(key);\n  }\n  async createTask(task) {\n    return await this.adapter.createTask(task);\n  }\n  async getTasks(params) {\n    return await this.adapter.getTasks(params);\n  }\n  async getTask(id) {\n    return await this.adapter.getTask(id);\n  }\n  async getTasksByName(name) {\n    return await this.adapter.getTasksByName(name);\n  }\n  async updateTask(id, task) {\n    await this.adapter.updateTask(id, task);\n  }\n  async deleteTask(id) {\n    await this.adapter.deleteTask(id);\n  }\n  on(event, callback) {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, []);\n    }\n    this.eventHandlers.get(event)?.push(callback);\n  }\n  off(event, callback) {\n    if (!this.eventHandlers.has(event)) {\n      return;\n    }\n    const handlers = this.eventHandlers.get(event);\n    const index = handlers.indexOf(callback);\n    if (index !== -1) {\n      handlers.splice(index, 1);\n    }\n  }\n  emit(event, data) {\n    if (!this.eventHandlers.has(event)) {\n      return;\n    }\n    for (const handler of this.eventHandlers.get(event)) {\n      handler(data);\n    }\n  }\n  async sendControlMessage(params) {\n    try {\n      const { roomId, action, target } = params;\n      const controlMessage = {\n        type: \"control\",\n        payload: {\n          action,\n          target\n        },\n        roomId\n      };\n      await this.emitEvent(\"CONTROL_MESSAGE\", {\n        runtime: this,\n        message: controlMessage,\n        source: \"agent\"\n      });\n      this.logger.debug(`Sent control message: ${action} to room ${roomId}`);\n    } catch (error) {\n      this.logger.error(`Error sending control message: ${error}`);\n    }\n  }\n  registerSendHandler(source, handler) {\n    if (this.sendHandlers.has(source)) {\n      this.logger.warn(`Send handler for source '${source}' already registered. Overwriting.`);\n    }\n    this.sendHandlers.set(source, handler);\n    this.logger.info(`Registered send handler for source: ${source}`);\n  }\n  async sendMessageToTarget(target, content) {\n    const handler = this.sendHandlers.get(target.source);\n    if (!handler) {\n      const errorMsg = `No send handler registered for source: ${target.source}`;\n      this.logger.error(errorMsg);\n      throw new Error(errorMsg);\n    }\n    try {\n      await handler(this, target, content);\n    } catch (error) {\n      this.logger.error(`Error executing send handler for source ${target.source}:`, error);\n      throw error;\n    }\n  }\n  async getMemoriesByWorldId(params) {\n    return await this.adapter.getMemoriesByWorldId(params);\n  }\n  async runMigrations(migrationsPaths) {\n    if (this.adapter && \"runMigrations\" in this.adapter) {\n      await this.adapter.runMigrations(migrationsPaths);\n    } else {\n      this.logger.warn(\"Database adapter does not support migrations.\");\n    }\n  }\n  async isReady() {\n    if (!this.adapter) {\n      throw new Error(\"Database adapter not registered\");\n    }\n    return await this.adapter.isReady();\n  }\n};\n\n// src/settings.ts\n\nfunction createSettingFromConfig(configSetting) {\n  return {\n    name: configSetting.name,\n    description: configSetting.description,\n    usageDescription: configSetting.usageDescription || \"\",\n    value: null,\n    required: configSetting.required,\n    validation: configSetting.validation || null,\n    public: configSetting.public || false,\n    secret: configSetting.secret || false,\n    dependsOn: configSetting.dependsOn || [],\n    onSetAction: configSetting.onSetAction || null,\n    visibleIf: configSetting.visibleIf || null\n  };\n}\nfunction getSalt() {\n  const secretSalt = (typeof process !== \"undefined\" ? process.env.SECRET_SALT : /* unsupported import.meta.env.SECRET_SALT */ undefined.SECRET_SALT) || \"secretsalt\";\n  if (!secretSalt) {\n    logger.error(\"SECRET_SALT is not set\");\n  }\n  const salt = secretSalt;\n  logger.debug(`Generated salt with length: ${salt.length} (truncated for security)`);\n  return salt;\n}\nfunction encryptStringValue(value, salt) {\n  if (value === void 0 || value === null) {\n    logger.debug(\"Attempted to encrypt undefined or null value\");\n    return value;\n  }\n  if (typeof value === \"boolean\" || typeof value === \"number\") {\n    logger.debug(\"Value is a boolean or number, returning as is\");\n    return value;\n  }\n  if (typeof value !== \"string\") {\n    logger.debug(`Value is not a string (type: ${typeof value}), returning as is`);\n    return value;\n  }\n  const parts = value.split(\":\");\n  if (parts.length === 2) {\n    try {\n      const possibleIv = Buffer.from(parts[0], \"hex\");\n      if (possibleIv.length === 16) {\n        logger.debug(\"Value appears to be already encrypted, skipping re-encryption\");\n        return value;\n      }\n    } catch (e) {\n    }\n  }\n  const key = crypto_browserify__WEBPACK_IMPORTED_MODULE_9__.createHash(\"sha256\").update(salt).digest().slice(0, 32);\n  const iv = crypto_browserify__WEBPACK_IMPORTED_MODULE_9__.randomBytes(16);\n  const cipher = crypto_browserify__WEBPACK_IMPORTED_MODULE_9__.createCipheriv(\"aes-256-cbc\", key, iv);\n  let encrypted = cipher.update(value, \"utf8\", \"hex\");\n  encrypted += cipher.final(\"hex\");\n  return `${iv.toString(\"hex\")}:${encrypted}`;\n}\nfunction decryptStringValue(value, salt) {\n  try {\n    if (value === void 0 || value === null) {\n      return value;\n    }\n    if (typeof value === \"boolean\" || typeof value === \"number\") {\n      return value;\n    }\n    if (typeof value !== \"string\") {\n      logger.debug(`Value is not a string (type: ${typeof value}), returning as is`);\n      return value;\n    }\n    const parts = value.split(\":\");\n    if (parts.length !== 2) {\n      return value;\n    }\n    const iv = Buffer.from(parts[0], \"hex\");\n    const encrypted = parts[1];\n    if (iv.length !== 16) {\n      if (iv.length) {\n        logger.debug(`Invalid IV length (${iv.length}) - expected 16 bytes`);\n      }\n      return value;\n    }\n    const key = crypto_browserify__WEBPACK_IMPORTED_MODULE_9__.createHash(\"sha256\").update(salt).digest().slice(0, 32);\n    const decipher = crypto_browserify__WEBPACK_IMPORTED_MODULE_9__.createDecipheriv(\"aes-256-cbc\", key, iv);\n    let decrypted = decipher.update(encrypted, \"hex\", \"utf8\");\n    decrypted += decipher.final(\"utf8\");\n    return decrypted;\n  } catch (error) {\n    logger.error(`Error decrypting value: ${error}`);\n    return value;\n  }\n}\nfunction saltSettingValue(setting, salt) {\n  const settingCopy = { ...setting };\n  if (setting.secret === true && typeof setting.value === \"string\" && setting.value) {\n    settingCopy.value = encryptStringValue(setting.value, salt);\n  }\n  return settingCopy;\n}\nfunction unsaltSettingValue(setting, salt) {\n  const settingCopy = { ...setting };\n  if (setting.secret === true && typeof setting.value === \"string\" && setting.value) {\n    settingCopy.value = decryptStringValue(setting.value, salt);\n  }\n  return settingCopy;\n}\nfunction saltWorldSettings(worldSettings, salt) {\n  const saltedSettings = {};\n  for (const [key, setting] of Object.entries(worldSettings)) {\n    saltedSettings[key] = saltSettingValue(setting, salt);\n  }\n  return saltedSettings;\n}\nfunction unsaltWorldSettings(worldSettings, salt) {\n  const unsaltedSettings = {};\n  for (const [key, setting] of Object.entries(worldSettings)) {\n    unsaltedSettings[key] = unsaltSettingValue(setting, salt);\n  }\n  return unsaltedSettings;\n}\nasync function updateWorldSettings(runtime, serverId, worldSettings) {\n  const worldId = createUniqueUuid(runtime, serverId);\n  const world = await runtime.getWorld(worldId);\n  if (!world) {\n    logger.error(`No world found for server ${serverId}`);\n    return false;\n  }\n  if (!world.metadata) {\n    world.metadata = {};\n  }\n  const salt = getSalt();\n  const saltedSettings = saltWorldSettings(worldSettings, salt);\n  world.metadata.settings = saltedSettings;\n  await runtime.updateWorld(world);\n  return true;\n}\nasync function getWorldSettings(runtime, serverId) {\n  const worldId = createUniqueUuid(runtime, serverId);\n  const world = await runtime.getWorld(worldId);\n  if (!world || !world.metadata?.settings) {\n    return null;\n  }\n  const saltedSettings = world.metadata.settings;\n  const salt = getSalt();\n  return unsaltWorldSettings(saltedSettings, salt);\n}\nasync function initializeOnboarding(runtime, world, config) {\n  if (world.metadata?.settings) {\n    logger.info(`Onboarding state already exists for server ${world.serverId}`);\n    const saltedSettings = world.metadata.settings;\n    const salt = getSalt();\n    return unsaltWorldSettings(saltedSettings, salt);\n  }\n  const worldSettings = {};\n  if (config.settings) {\n    for (const [key, configSetting] of Object.entries(config.settings)) {\n      worldSettings[key] = createSettingFromConfig(configSetting);\n    }\n  }\n  if (!world.metadata) {\n    world.metadata = {};\n  }\n  world.metadata.settings = worldSettings;\n  await runtime.updateWorld(world);\n  logger.info(`Initialized settings config for server ${world.serverId}`);\n  return worldSettings;\n}\nfunction encryptedCharacter(character) {\n  const encryptedChar = JSON.parse(JSON.stringify(character));\n  const salt = getSalt();\n  if (encryptedChar.settings?.secrets) {\n    encryptedChar.settings.secrets = encryptObjectValues(encryptedChar.settings.secrets, salt);\n  }\n  if (encryptedChar.secrets) {\n    encryptedChar.secrets = encryptObjectValues(encryptedChar.secrets, salt);\n  }\n  return encryptedChar;\n}\nfunction decryptedCharacter(character, _runtime) {\n  const decryptedChar = JSON.parse(JSON.stringify(character));\n  const salt = getSalt();\n  if (decryptedChar.settings?.secrets) {\n    decryptedChar.settings.secrets = decryptObjectValues(decryptedChar.settings.secrets, salt);\n  }\n  if (decryptedChar.secrets) {\n    decryptedChar.secrets = decryptObjectValues(decryptedChar.secrets, salt);\n  }\n  return decryptedChar;\n}\nfunction encryptObjectValues(obj, salt) {\n  const result = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (typeof value === \"string\" && value) {\n      result[key] = encryptStringValue(value, salt);\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\nfunction decryptObjectValues(obj, salt) {\n  const result = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (typeof value === \"string\" && value) {\n      result[key] = decryptStringValue(value, salt);\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\n// src/services.ts\nvar ServiceBuilder = class {\n  constructor(serviceType) {\n    this.serviceType = serviceType;\n    this.description = \"\";\n  }\n  /**\n   * Set the service description\n   */\n  withDescription(description) {\n    this.description = description;\n    return this;\n  }\n  /**\n   * Set the start function for the service\n   */\n  withStart(startFn) {\n    this.startFn = startFn;\n    return this;\n  }\n  /**\n   * Set the stop function for the service\n   */\n  withStop(stopFn) {\n    this.stopFn = stopFn;\n    return this;\n  }\n  /**\n   * Build the service class with all configured properties\n   */\n  build() {\n    const serviceType = this.serviceType;\n    const description = this.description;\n    const startFn = this.startFn;\n    const stopFn = this.stopFn;\n    return class extends Service {\n      constructor() {\n        super(...arguments);\n        this.capabilityDescription = description;\n      }\n      static {\n        this.serviceType = serviceType;\n      }\n      static async start(runtime) {\n        if (!startFn) {\n          throw new Error(`Start function not defined for service ${serviceType}`);\n        }\n        return startFn(runtime);\n      }\n      async stop() {\n        if (stopFn) {\n          await stopFn();\n        }\n      }\n    };\n  }\n};\nfunction createService(serviceType) {\n  return new ServiceBuilder(serviceType);\n}\nfunction defineService(definition) {\n  return createService(definition.serviceType).withDescription(definition.description).withStart(definition.start).withStop(definition.stop || (() => Promise.resolve())).build();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsaXphb3MvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEdBQUc7QUFDNUUsNENBQTRDLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFlBQVk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1COztBQUVwQjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVSxHQUFHLE1BQU07QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXLEdBQUcsZ0JBQWdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRCxNQUFNLFVBQVUsRUFBRTtBQUNsQixRQUFRO0FBQ1IsU0FBUztBQUNUO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQsWUFBWTs7QUFFckU7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsMEJBQTBCLFlBQVk7QUFDdEMsK0NBQStDLFdBQVc7QUFDMUQsaUJBQWlCLFlBQVk7QUFDN0IsS0FBSyxZQUFZOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9GQUFvRixXQUFXOztBQUUvRjtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0EsK0JBQStCLFlBQVksbUVBQW1FLFlBQVk7O0FBRTFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sWUFBWTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEUscUVBQXFFLFlBQVk7QUFDakYsb0RBQW9ELFlBQVk7QUFDaEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4RkFBOEYsWUFBWSxHQUFHLGlCQUFpQjs7QUFFOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGLHVCQUF1QixZQUFZLFFBQVEsUUFBUSxzQkFBc0IsUUFBUSxxQ0FBcUMsV0FBVztBQUNqSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxlQUFlO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsWUFBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMEdFIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9AZWxpemFvcy9jb3JlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fcmVxdWlyZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHgpID0+IHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiID8gcmVxdWlyZSA6IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBQcm94eSh4LCB7XG4gIGdldDogKGEsIGIpID0+ICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVpcmUgOiBhKVtiXVxufSkgOiB4KShmdW5jdGlvbih4KSB7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHJlcXVpcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhyb3cgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZSBvZiBcIicgKyB4ICsgJ1wiIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn0pO1xuXG4vLyBzcmMvdHlwZXMvcHJpbWl0aXZlcy50c1xuZnVuY3Rpb24gYXNVVUlEKGlkKSB7XG4gIGlmICghaWQgfHwgIS9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17MTJ9JC9pLnRlc3QoaWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVVSUQgZm9ybWF0OiAke2lkfWApO1xuICB9XG4gIHJldHVybiBpZDtcbn1cbnZhciBDb250ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENvbnRlbnRUeXBlMikgPT4ge1xuICBDb250ZW50VHlwZTJbXCJJTUFHRVwiXSA9IFwiaW1hZ2VcIjtcbiAgQ29udGVudFR5cGUyW1wiVklERU9cIl0gPSBcInZpZGVvXCI7XG4gIENvbnRlbnRUeXBlMltcIkFVRElPXCJdID0gXCJhdWRpb1wiO1xuICBDb250ZW50VHlwZTJbXCJET0NVTUVOVFwiXSA9IFwiZG9jdW1lbnRcIjtcbiAgQ29udGVudFR5cGUyW1wiTElOS1wiXSA9IFwibGlua1wiO1xuICByZXR1cm4gQ29udGVudFR5cGUyO1xufSkoQ29udGVudFR5cGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvbWVtb3J5LnRzXG52YXIgTWVtb3J5VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE1lbW9yeVR5cGUyKSA9PiB7XG4gIE1lbW9yeVR5cGUyW1wiRE9DVU1FTlRcIl0gPSBcImRvY3VtZW50XCI7XG4gIE1lbW9yeVR5cGUyW1wiRlJBR01FTlRcIl0gPSBcImZyYWdtZW50XCI7XG4gIE1lbW9yeVR5cGUyW1wiTUVTU0FHRVwiXSA9IFwibWVzc2FnZVwiO1xuICBNZW1vcnlUeXBlMltcIkRFU0NSSVBUSU9OXCJdID0gXCJkZXNjcmlwdGlvblwiO1xuICBNZW1vcnlUeXBlMltcIkNVU1RPTVwiXSA9IFwiY3VzdG9tXCI7XG4gIHJldHVybiBNZW1vcnlUeXBlMjtcbn0pKE1lbW9yeVR5cGUgfHwge30pO1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZU1lbW9yeShwYXJhbXMpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXJhbXMsXG4gICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICB0eXBlOiBcIm1lc3NhZ2VcIiAvKiBNRVNTQUdFICovLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgc2NvcGU6IHBhcmFtcy5hZ2VudElkID8gXCJwcml2YXRlXCIgOiBcInNoYXJlZFwiXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNEb2N1bWVudE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gIHJldHVybiBtZXRhZGF0YS50eXBlID09PSBcImRvY3VtZW50XCIgLyogRE9DVU1FTlQgKi87XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50TWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgcmV0dXJuIG1ldGFkYXRhLnR5cGUgPT09IFwiZnJhZ21lbnRcIiAvKiBGUkFHTUVOVCAqLztcbn1cbmZ1bmN0aW9uIGlzTWVzc2FnZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gIHJldHVybiBtZXRhZGF0YS50eXBlID09PSBcIm1lc3NhZ2VcIiAvKiBNRVNTQUdFICovO1xufVxuZnVuY3Rpb24gaXNEZXNjcmlwdGlvbk1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gIHJldHVybiBtZXRhZGF0YS50eXBlID09PSBcImRlc2NyaXB0aW9uXCIgLyogREVTQ1JJUFRJT04gKi87XG59XG5mdW5jdGlvbiBpc0N1c3RvbU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gIHJldHVybiBtZXRhZGF0YS50eXBlICE9PSBcImRvY3VtZW50XCIgLyogRE9DVU1FTlQgKi8gJiYgbWV0YWRhdGEudHlwZSAhPT0gXCJmcmFnbWVudFwiIC8qIEZSQUdNRU5UICovICYmIG1ldGFkYXRhLnR5cGUgIT09IFwibWVzc2FnZVwiIC8qIE1FU1NBR0UgKi8gJiYgbWV0YWRhdGEudHlwZSAhPT0gXCJkZXNjcmlwdGlvblwiIC8qIERFU0NSSVBUSU9OICovO1xufVxuZnVuY3Rpb24gaXNEb2N1bWVudE1lbW9yeShtZW1vcnkpIHtcbiAgcmV0dXJuIG1lbW9yeS5tZXRhZGF0YT8udHlwZSA9PT0gXCJkb2N1bWVudFwiIC8qIERPQ1VNRU5UICovO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudE1lbW9yeShtZW1vcnkpIHtcbiAgcmV0dXJuIG1lbW9yeS5tZXRhZGF0YT8udHlwZSA9PT0gXCJmcmFnbWVudFwiIC8qIEZSQUdNRU5UICovO1xufVxuZnVuY3Rpb24gZ2V0TWVtb3J5VGV4dChtZW1vcnksIGRlZmF1bHRWYWx1ZSA9IFwiXCIpIHtcbiAgcmV0dXJuIG1lbW9yeS5jb250ZW50LnRleHQgPz8gZGVmYXVsdFZhbHVlO1xufVxuXG4vLyBzcmMvdHlwZXMva25vd2xlZGdlLnRzXG52YXIgS25vd2xlZGdlU2NvcGUgPSAvKiBAX19QVVJFX18gKi8gKChLbm93bGVkZ2VTY29wZTIpID0+IHtcbiAgS25vd2xlZGdlU2NvcGUyW1wiU0hBUkVEXCJdID0gXCJzaGFyZWRcIjtcbiAgS25vd2xlZGdlU2NvcGUyW1wiUFJJVkFURVwiXSA9IFwicHJpdmF0ZVwiO1xuICByZXR1cm4gS25vd2xlZGdlU2NvcGUyO1xufSkoS25vd2xlZGdlU2NvcGUgfHwge30pO1xudmFyIENhY2hlS2V5UHJlZml4ID0gLyogQF9fUFVSRV9fICovICgoQ2FjaGVLZXlQcmVmaXgyKSA9PiB7XG4gIENhY2hlS2V5UHJlZml4MltcIktOT1dMRURHRVwiXSA9IFwia25vd2xlZGdlXCI7XG4gIHJldHVybiBDYWNoZUtleVByZWZpeDI7XG59KShDYWNoZUtleVByZWZpeCB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9lbnZpcm9ubWVudC50c1xudmFyIFJvbGUgPSAvKiBAX19QVVJFX18gKi8gKChSb2xlMikgPT4ge1xuICBSb2xlMltcIk9XTkVSXCJdID0gXCJPV05FUlwiO1xuICBSb2xlMltcIkFETUlOXCJdID0gXCJBRE1JTlwiO1xuICBSb2xlMltcIk5PTkVcIl0gPSBcIk5PTkVcIjtcbiAgcmV0dXJuIFJvbGUyO1xufSkoUm9sZSB8fCB7fSk7XG52YXIgQ2hhbm5lbFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChDaGFubmVsVHlwZTIpID0+IHtcbiAgQ2hhbm5lbFR5cGUyW1wiU0VMRlwiXSA9IFwiU0VMRlwiO1xuICBDaGFubmVsVHlwZTJbXCJETVwiXSA9IFwiRE1cIjtcbiAgQ2hhbm5lbFR5cGUyW1wiR1JPVVBcIl0gPSBcIkdST1VQXCI7XG4gIENoYW5uZWxUeXBlMltcIlZPSUNFX0RNXCJdID0gXCJWT0lDRV9ETVwiO1xuICBDaGFubmVsVHlwZTJbXCJWT0lDRV9HUk9VUFwiXSA9IFwiVk9JQ0VfR1JPVVBcIjtcbiAgQ2hhbm5lbFR5cGUyW1wiRkVFRFwiXSA9IFwiRkVFRFwiO1xuICBDaGFubmVsVHlwZTJbXCJUSFJFQURcIl0gPSBcIlRIUkVBRFwiO1xuICBDaGFubmVsVHlwZTJbXCJXT1JMRFwiXSA9IFwiV09STERcIjtcbiAgQ2hhbm5lbFR5cGUyW1wiRk9SVU1cIl0gPSBcIkZPUlVNXCI7XG4gIENoYW5uZWxUeXBlMltcIkFQSVwiXSA9IFwiQVBJXCI7XG4gIHJldHVybiBDaGFubmVsVHlwZTI7XG59KShDaGFubmVsVHlwZSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9hZ2VudC50c1xudmFyIEFnZW50U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoQWdlbnRTdGF0dXMyKSA9PiB7XG4gIEFnZW50U3RhdHVzMltcIkFDVElWRVwiXSA9IFwiYWN0aXZlXCI7XG4gIEFnZW50U3RhdHVzMltcIklOQUNUSVZFXCJdID0gXCJpbmFjdGl2ZVwiO1xuICByZXR1cm4gQWdlbnRTdGF0dXMyO1xufSkoQWdlbnRTdGF0dXMgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvY29tcG9uZW50cy50c1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uUmVzdWx0KHBhcnRpYWwgPSB7fSkge1xuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgLy8gRGVmYXVsdCB0byBzdWNjZXNzXG4gICAgLi4ucGFydGlhbFxuICB9O1xufVxuXG4vLyBzcmMvdHlwZXMvc2VydmljZS50c1xudmFyIFNlcnZpY2VUeXBlID0ge1xuICBUUkFOU0NSSVBUSU9OOiBcInRyYW5zY3JpcHRpb25cIixcbiAgVklERU86IFwidmlkZW9cIixcbiAgQlJPV1NFUjogXCJicm93c2VyXCIsXG4gIFBERjogXCJwZGZcIixcbiAgUkVNT1RFX0ZJTEVTOiBcImF3c19zM1wiLFxuICBXRUJfU0VBUkNIOiBcIndlYl9zZWFyY2hcIixcbiAgRU1BSUw6IFwiZW1haWxcIixcbiAgVEVFOiBcInRlZVwiLFxuICBUQVNLOiBcInRhc2tcIixcbiAgV0FMTEVUOiBcIndhbGxldFwiLFxuICBMUF9QT09MOiBcImxwX3Bvb2xcIixcbiAgVE9LRU5fREFUQTogXCJ0b2tlbl9kYXRhXCIsXG4gIE1FU1NBR0U6IFwibWVzc2FnZVwiLFxuICBQT1NUOiBcInBvc3RcIixcbiAgVU5LTk9XTjogXCJ1bmtub3duXCJcbn07XG52YXIgU2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocnVudGltZSkge1xuICAgIGlmIChydW50aW1lKSB7XG4gICAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICAgIH1cbiAgfVxuICAvKiogU3RhcnQgc2VydmljZSBjb25uZWN0aW9uICovXG4gIHN0YXRpYyBhc3luYyBzdGFydChfcnVudGltZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICAvKiogU3RvcCBzZXJ2aWNlIGNvbm5lY3Rpb24gKi9cbiAgc3RhdGljIGFzeW5jIHN0b3AoX3J1bnRpbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRUeXBlZFNlcnZpY2UocnVudGltZSwgc2VydmljZVR5cGUpIHtcbiAgcmV0dXJuIHJ1bnRpbWUuZ2V0U2VydmljZShzZXJ2aWNlVHlwZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJ2aWNlRXJyb3IoZXJyb3IsIGNvZGUgPSBcIlVOS05PV05fRVJST1JcIikge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBjb2RlLFxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIGNhdXNlOiBlcnJvclxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb2RlLFxuICAgIG1lc3NhZ2U6IFN0cmluZyhlcnJvcilcbiAgfTtcbn1cblxuLy8gc3JjL3R5cGVzL21vZGVsLnRzXG52YXIgTW9kZWxUeXBlID0ge1xuICBTTUFMTDogXCJURVhUX1NNQUxMXCIsXG4gIC8vIGtlcHQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIE1FRElVTTogXCJURVhUX0xBUkdFXCIsXG4gIC8vIGtlcHQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIExBUkdFOiBcIlRFWFRfTEFSR0VcIixcbiAgLy8ga2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgVEVYVF9TTUFMTDogXCJURVhUX1NNQUxMXCIsXG4gIFRFWFRfTEFSR0U6IFwiVEVYVF9MQVJHRVwiLFxuICBURVhUX0VNQkVERElORzogXCJURVhUX0VNQkVERElOR1wiLFxuICBURVhUX1RPS0VOSVpFUl9FTkNPREU6IFwiVEVYVF9UT0tFTklaRVJfRU5DT0RFXCIsXG4gIFRFWFRfVE9LRU5JWkVSX0RFQ09ERTogXCJURVhUX1RPS0VOSVpFUl9ERUNPREVcIixcbiAgVEVYVF9SRUFTT05JTkdfU01BTEw6IFwiUkVBU09OSU5HX1NNQUxMXCIsXG4gIFRFWFRfUkVBU09OSU5HX0xBUkdFOiBcIlJFQVNPTklOR19MQVJHRVwiLFxuICBURVhUX0NPTVBMRVRJT046IFwiVEVYVF9DT01QTEVUSU9OXCIsXG4gIElNQUdFOiBcIklNQUdFXCIsXG4gIElNQUdFX0RFU0NSSVBUSU9OOiBcIklNQUdFX0RFU0NSSVBUSU9OXCIsXG4gIFRSQU5TQ1JJUFRJT046IFwiVFJBTlNDUklQVElPTlwiLFxuICBURVhUX1RPX1NQRUVDSDogXCJURVhUX1RPX1NQRUVDSFwiLFxuICBBVURJTzogXCJBVURJT1wiLFxuICBWSURFTzogXCJWSURFT1wiLFxuICBPQkpFQ1RfU01BTEw6IFwiT0JKRUNUX1NNQUxMXCIsXG4gIE9CSkVDVF9MQVJHRTogXCJPQkpFQ1RfTEFSR0VcIlxufTtcbnZhciBNT0RFTF9TRVRUSU5HUyA9IHtcbiAgLy8gRGVmYXVsdCBzZXR0aW5ncyAtIGFwcGx5IHRvIGFsbCBtb2RlbCB0eXBlcyB1bmxlc3Mgb3ZlcnJpZGRlblxuICBERUZBVUxUX01BWF9UT0tFTlM6IFwiREVGQVVMVF9NQVhfVE9LRU5TXCIsXG4gIERFRkFVTFRfVEVNUEVSQVRVUkU6IFwiREVGQVVMVF9URU1QRVJBVFVSRVwiLFxuICBERUZBVUxUX0ZSRVFVRU5DWV9QRU5BTFRZOiBcIkRFRkFVTFRfRlJFUVVFTkNZX1BFTkFMVFlcIixcbiAgREVGQVVMVF9QUkVTRU5DRV9QRU5BTFRZOiBcIkRFRkFVTFRfUFJFU0VOQ0VfUEVOQUxUWVwiLFxuICAvLyBURVhUX1NNQUxMIHNwZWNpZmljIHNldHRpbmdzXG4gIFRFWFRfU01BTExfTUFYX1RPS0VOUzogXCJURVhUX1NNQUxMX01BWF9UT0tFTlNcIixcbiAgVEVYVF9TTUFMTF9URU1QRVJBVFVSRTogXCJURVhUX1NNQUxMX1RFTVBFUkFUVVJFXCIsXG4gIFRFWFRfU01BTExfRlJFUVVFTkNZX1BFTkFMVFk6IFwiVEVYVF9TTUFMTF9GUkVRVUVOQ1lfUEVOQUxUWVwiLFxuICBURVhUX1NNQUxMX1BSRVNFTkNFX1BFTkFMVFk6IFwiVEVYVF9TTUFMTF9QUkVTRU5DRV9QRU5BTFRZXCIsXG4gIC8vIFRFWFRfTEFSR0Ugc3BlY2lmaWMgc2V0dGluZ3NcbiAgVEVYVF9MQVJHRV9NQVhfVE9LRU5TOiBcIlRFWFRfTEFSR0VfTUFYX1RPS0VOU1wiLFxuICBURVhUX0xBUkdFX1RFTVBFUkFUVVJFOiBcIlRFWFRfTEFSR0VfVEVNUEVSQVRVUkVcIixcbiAgVEVYVF9MQVJHRV9GUkVRVUVOQ1lfUEVOQUxUWTogXCJURVhUX0xBUkdFX0ZSRVFVRU5DWV9QRU5BTFRZXCIsXG4gIFRFWFRfTEFSR0VfUFJFU0VOQ0VfUEVOQUxUWTogXCJURVhUX0xBUkdFX1BSRVNFTkNFX1BFTkFMVFlcIixcbiAgLy8gT0JKRUNUX1NNQUxMIHNwZWNpZmljIHNldHRpbmdzXG4gIE9CSkVDVF9TTUFMTF9NQVhfVE9LRU5TOiBcIk9CSkVDVF9TTUFMTF9NQVhfVE9LRU5TXCIsXG4gIE9CSkVDVF9TTUFMTF9URU1QRVJBVFVSRTogXCJPQkpFQ1RfU01BTExfVEVNUEVSQVRVUkVcIixcbiAgT0JKRUNUX1NNQUxMX0ZSRVFVRU5DWV9QRU5BTFRZOiBcIk9CSkVDVF9TTUFMTF9GUkVRVUVOQ1lfUEVOQUxUWVwiLFxuICBPQkpFQ1RfU01BTExfUFJFU0VOQ0VfUEVOQUxUWTogXCJPQkpFQ1RfU01BTExfUFJFU0VOQ0VfUEVOQUxUWVwiLFxuICAvLyBPQkpFQ1RfTEFSR0Ugc3BlY2lmaWMgc2V0dGluZ3NcbiAgT0JKRUNUX0xBUkdFX01BWF9UT0tFTlM6IFwiT0JKRUNUX0xBUkdFX01BWF9UT0tFTlNcIixcbiAgT0JKRUNUX0xBUkdFX1RFTVBFUkFUVVJFOiBcIk9CSkVDVF9MQVJHRV9URU1QRVJBVFVSRVwiLFxuICBPQkpFQ1RfTEFSR0VfRlJFUVVFTkNZX1BFTkFMVFk6IFwiT0JKRUNUX0xBUkdFX0ZSRVFVRU5DWV9QRU5BTFRZXCIsXG4gIE9CSkVDVF9MQVJHRV9QUkVTRU5DRV9QRU5BTFRZOiBcIk9CSkVDVF9MQVJHRV9QUkVTRU5DRV9QRU5BTFRZXCIsXG4gIC8vIExlZ2FjeSBrZXlzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAod2lsbCBiZSB0cmVhdGVkIGFzIGRlZmF1bHRzKVxuICBNT0RFTF9NQVhfVE9LRU46IFwiTU9ERUxfTUFYX1RPS0VOXCIsXG4gIE1PREVMX1RFTVBFUkFUVVJFOiBcIk1PREVMX1RFTVBFUkFUVVJFXCIsXG4gIE1PREVMX0ZSRVFfUEVOQUxUWTogXCJNT0RFTF9GUkVRX1BFTkFMVFlcIixcbiAgTU9ERUxfUFJFU0VOQ0VfUEVOQUxUWTogXCJNT0RFTF9QUkVTRU5DRV9QRU5BTFRZXCJcbn07XG5mdW5jdGlvbiBnZXRNb2RlbFNwZWNpZmljU2V0dGluZ0tleShtb2RlbFR5cGUsIHBhcmFtKSB7XG4gIGNvbnN0IHN1cHBvcnRlZE1vZGVsVHlwZXMgPSBbXCJURVhUX1NNQUxMXCIsIFwiVEVYVF9MQVJHRVwiLCBcIk9CSkVDVF9TTUFMTFwiLCBcIk9CSkVDVF9MQVJHRVwiXTtcbiAgaWYgKCFzdXBwb3J0ZWRNb2RlbFR5cGVzLmluY2x1ZGVzKG1vZGVsVHlwZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gYCR7bW9kZWxUeXBlfV8ke3BhcmFtfWA7XG59XG5cbi8vIHNyYy90eXBlcy9kYXRhYmFzZS50c1xudmFyIFZFQ1RPUl9ESU1TID0ge1xuICBTTUFMTDogMzg0LFxuICBNRURJVU06IDUxMixcbiAgTEFSR0U6IDc2OCxcbiAgWEw6IDEwMjQsXG4gIFhYTDogMTUzNixcbiAgWFhYTDogMzA3MlxufTtcblxuLy8gc3JjL3R5cGVzL2V2ZW50cy50c1xudmFyIEV2ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV2ZW50VHlwZTIpID0+IHtcbiAgRXZlbnRUeXBlMltcIldPUkxEX0pPSU5FRFwiXSA9IFwiV09STERfSk9JTkVEXCI7XG4gIEV2ZW50VHlwZTJbXCJXT1JMRF9DT05ORUNURURcIl0gPSBcIldPUkxEX0NPTk5FQ1RFRFwiO1xuICBFdmVudFR5cGUyW1wiV09STERfTEVGVFwiXSA9IFwiV09STERfTEVGVFwiO1xuICBFdmVudFR5cGUyW1wiRU5USVRZX0pPSU5FRFwiXSA9IFwiRU5USVRZX0pPSU5FRFwiO1xuICBFdmVudFR5cGUyW1wiRU5USVRZX0xFRlRcIl0gPSBcIkVOVElUWV9MRUZUXCI7XG4gIEV2ZW50VHlwZTJbXCJFTlRJVFlfVVBEQVRFRFwiXSA9IFwiRU5USVRZX1VQREFURURcIjtcbiAgRXZlbnRUeXBlMltcIlJPT01fSk9JTkVEXCJdID0gXCJST09NX0pPSU5FRFwiO1xuICBFdmVudFR5cGUyW1wiUk9PTV9MRUZUXCJdID0gXCJST09NX0xFRlRcIjtcbiAgRXZlbnRUeXBlMltcIk1FU1NBR0VfUkVDRUlWRURcIl0gPSBcIk1FU1NBR0VfUkVDRUlWRURcIjtcbiAgRXZlbnRUeXBlMltcIk1FU1NBR0VfU0VOVFwiXSA9IFwiTUVTU0FHRV9TRU5UXCI7XG4gIEV2ZW50VHlwZTJbXCJNRVNTQUdFX0RFTEVURURcIl0gPSBcIk1FU1NBR0VfREVMRVRFRFwiO1xuICBFdmVudFR5cGUyW1wiQ0hBTk5FTF9DTEVBUkVEXCJdID0gXCJDSEFOTkVMX0NMRUFSRURcIjtcbiAgRXZlbnRUeXBlMltcIlZPSUNFX01FU1NBR0VfUkVDRUlWRURcIl0gPSBcIlZPSUNFX01FU1NBR0VfUkVDRUlWRURcIjtcbiAgRXZlbnRUeXBlMltcIlZPSUNFX01FU1NBR0VfU0VOVFwiXSA9IFwiVk9JQ0VfTUVTU0FHRV9TRU5UXCI7XG4gIEV2ZW50VHlwZTJbXCJSRUFDVElPTl9SRUNFSVZFRFwiXSA9IFwiUkVBQ1RJT05fUkVDRUlWRURcIjtcbiAgRXZlbnRUeXBlMltcIlBPU1RfR0VORVJBVEVEXCJdID0gXCJQT1NUX0dFTkVSQVRFRFwiO1xuICBFdmVudFR5cGUyW1wiSU5URVJBQ1RJT05fUkVDRUlWRURcIl0gPSBcIklOVEVSQUNUSU9OX1JFQ0VJVkVEXCI7XG4gIEV2ZW50VHlwZTJbXCJSVU5fU1RBUlRFRFwiXSA9IFwiUlVOX1NUQVJURURcIjtcbiAgRXZlbnRUeXBlMltcIlJVTl9FTkRFRFwiXSA9IFwiUlVOX0VOREVEXCI7XG4gIEV2ZW50VHlwZTJbXCJSVU5fVElNRU9VVFwiXSA9IFwiUlVOX1RJTUVPVVRcIjtcbiAgRXZlbnRUeXBlMltcIkFDVElPTl9TVEFSVEVEXCJdID0gXCJBQ1RJT05fU1RBUlRFRFwiO1xuICBFdmVudFR5cGUyW1wiQUNUSU9OX0NPTVBMRVRFRFwiXSA9IFwiQUNUSU9OX0NPTVBMRVRFRFwiO1xuICBFdmVudFR5cGUyW1wiRVZBTFVBVE9SX1NUQVJURURcIl0gPSBcIkVWQUxVQVRPUl9TVEFSVEVEXCI7XG4gIEV2ZW50VHlwZTJbXCJFVkFMVUFUT1JfQ09NUExFVEVEXCJdID0gXCJFVkFMVUFUT1JfQ09NUExFVEVEXCI7XG4gIEV2ZW50VHlwZTJbXCJNT0RFTF9VU0VEXCJdID0gXCJNT0RFTF9VU0VEXCI7XG4gIHJldHVybiBFdmVudFR5cGUyO1xufSkoRXZlbnRUeXBlIHx8IHt9KTtcbnZhciBQbGF0Zm9ybVByZWZpeCA9IC8qIEBfX1BVUkVfXyAqLyAoKFBsYXRmb3JtUHJlZml4MikgPT4ge1xuICBQbGF0Zm9ybVByZWZpeDJbXCJESVNDT1JEXCJdID0gXCJESVNDT1JEXCI7XG4gIFBsYXRmb3JtUHJlZml4MltcIlRFTEVHUkFNXCJdID0gXCJURUxFR1JBTVwiO1xuICBQbGF0Zm9ybVByZWZpeDJbXCJUV0lUVEVSXCJdID0gXCJUV0lUVEVSXCI7XG4gIHJldHVybiBQbGF0Zm9ybVByZWZpeDI7XG59KShQbGF0Zm9ybVByZWZpeCB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy90ZWUudHNcbnZhciBURUVNb2RlID0gLyogQF9fUFVSRV9fICovICgoVEVFTW9kZTIpID0+IHtcbiAgVEVFTW9kZTJbXCJPRkZcIl0gPSBcIk9GRlwiO1xuICBURUVNb2RlMltcIkxPQ0FMXCJdID0gXCJMT0NBTFwiO1xuICBURUVNb2RlMltcIkRPQ0tFUlwiXSA9IFwiRE9DS0VSXCI7XG4gIFRFRU1vZGUyW1wiUFJPRFVDVElPTlwiXSA9IFwiUFJPRFVDVElPTlwiO1xuICByZXR1cm4gVEVFTW9kZTI7XG59KShURUVNb2RlIHx8IHt9KTtcbnZhciBUZWVUeXBlID0gLyogQF9fUFVSRV9fICovICgoVGVlVHlwZTIpID0+IHtcbiAgVGVlVHlwZTJbXCJURFhfRFNUQUNLXCJdID0gXCJ0ZHhfZHN0YWNrXCI7XG4gIHJldHVybiBUZWVUeXBlMjtcbn0pKFRlZVR5cGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvdG9rZW4udHNcbnZhciBJVG9rZW5EYXRhU2VydmljZSA9IGNsYXNzIGV4dGVuZHMgU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jYXBhYmlsaXR5RGVzY3JpcHRpb24gPSBcIlByb3ZpZGVzIHN0YW5kYXJkaXplZCBhY2Nlc3MgdG8gdG9rZW4gbWFya2V0IGRhdGEuXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnNlcnZpY2VUeXBlID0gU2VydmljZVR5cGUuVE9LRU5fREFUQTtcbiAgfVxuICAvLyBGdXR1cmUgcG90ZW50aWFsIG1ldGhvZHM6XG4gIC8vIGdldEhpc3RvcmljYWxQcmljZURhdGEoYWRkcmVzczogc3RyaW5nLCBjaGFpbjogc3RyaW5nLCB0aW1lRnJhbWU6IHN0cmluZyk6IFByb21pc2U8YW55W10+O1xuICAvLyBnZXRUb2tlbk1hcmtldENoYXJ0KGFkZHJlc3M6IHN0cmluZywgY2hhaW46IHN0cmluZywgZGF5czogbnVtYmVyKTogUHJvbWlzZTxhbnlbXT47XG59O1xuXG4vLyBzcmMvdHlwZXMvbWVzc2FnaW5nLnRzXG52YXIgU09DS0VUX01FU1NBR0VfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNPQ0tFVF9NRVNTQUdFX1RZUEUyKSA9PiB7XG4gIFNPQ0tFVF9NRVNTQUdFX1RZUEUyW1NPQ0tFVF9NRVNTQUdFX1RZUEUyW1wiUk9PTV9KT0lOSU5HXCJdID0gMV0gPSBcIlJPT01fSk9JTklOR1wiO1xuICBTT0NLRVRfTUVTU0FHRV9UWVBFMltTT0NLRVRfTUVTU0FHRV9UWVBFMltcIlNFTkRfTUVTU0FHRVwiXSA9IDJdID0gXCJTRU5EX01FU1NBR0VcIjtcbiAgU09DS0VUX01FU1NBR0VfVFlQRTJbU09DS0VUX01FU1NBR0VfVFlQRTJbXCJNRVNTQUdFXCJdID0gM10gPSBcIk1FU1NBR0VcIjtcbiAgU09DS0VUX01FU1NBR0VfVFlQRTJbU09DS0VUX01FU1NBR0VfVFlQRTJbXCJBQ0tcIl0gPSA0XSA9IFwiQUNLXCI7XG4gIFNPQ0tFVF9NRVNTQUdFX1RZUEUyW1NPQ0tFVF9NRVNTQUdFX1RZUEUyW1wiVEhJTktJTkdcIl0gPSA1XSA9IFwiVEhJTktJTkdcIjtcbiAgU09DS0VUX01FU1NBR0VfVFlQRTJbU09DS0VUX01FU1NBR0VfVFlQRTJbXCJDT05UUk9MXCJdID0gNl0gPSBcIkNPTlRST0xcIjtcbiAgcmV0dXJuIFNPQ0tFVF9NRVNTQUdFX1RZUEUyO1xufSkoU09DS0VUX01FU1NBR0VfVFlQRSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy93YWxsZXQudHNcbnZhciBJV2FsbGV0U2VydmljZSA9IGNsYXNzIGV4dGVuZHMgU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jYXBhYmlsaXR5RGVzY3JpcHRpb24gPSBcIlByb3ZpZGVzIHN0YW5kYXJkaXplZCBhY2Nlc3MgdG8gd2FsbGV0IGJhbGFuY2VzIGFuZCBwb3J0Zm9saW9zLlwiO1xuICB9XG4gIHN0YXRpYyB7XG4gICAgdGhpcy5zZXJ2aWNlVHlwZSA9IFNlcnZpY2VUeXBlLldBTExFVDtcbiAgfVxufTtcblxuLy8gc3JjL3R5cGVzL2xwLnRzXG52YXIgSUxwU2VydmljZSA9IGNsYXNzIGV4dGVuZHMgU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jYXBhYmlsaXR5RGVzY3JpcHRpb24gPSBcIlByb3ZpZGVzIHN0YW5kYXJkaXplZCBhY2Nlc3MgdG8gREVYIGxpcXVpZGl0eSBwb29scy5cIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMuc2VydmljZVR5cGUgPSBcImxwXCI7XG4gIH1cbn07XG5cbi8vIHNyYy90eXBlcy9wZGYudHNcbnZhciBJUGRmU2VydmljZSA9IGNsYXNzIGV4dGVuZHMgU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jYXBhYmlsaXR5RGVzY3JpcHRpb24gPSBcIlBERiBwcm9jZXNzaW5nLCBleHRyYWN0aW9uLCBhbmQgZ2VuZXJhdGlvbiBjYXBhYmlsaXRpZXNcIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMuc2VydmljZVR5cGUgPSBTZXJ2aWNlVHlwZS5QREY7XG4gIH1cbn07XG5cbi8vIHNyYy90eXBlcy92aWRlby50c1xudmFyIElWaWRlb1NlcnZpY2UgPSBjbGFzcyBleHRlbmRzIFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY2FwYWJpbGl0eURlc2NyaXB0aW9uID0gXCJWaWRlbyBkb3dubG9hZCwgcHJvY2Vzc2luZywgYW5kIGNvbnZlcnNpb24gY2FwYWJpbGl0aWVzXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnNlcnZpY2VUeXBlID0gU2VydmljZVR5cGUuVklERU87XG4gIH1cbn07XG5cbi8vIHNyYy90eXBlcy9icm93c2VyLnRzXG52YXIgSUJyb3dzZXJTZXJ2aWNlID0gY2xhc3MgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNhcGFiaWxpdHlEZXNjcmlwdGlvbiA9IFwiV2ViIGJyb3dzZXIgYXV0b21hdGlvbiBhbmQgc2NyYXBpbmcgY2FwYWJpbGl0aWVzXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnNlcnZpY2VUeXBlID0gU2VydmljZVR5cGUuQlJPV1NFUjtcbiAgfVxufTtcblxuLy8gc3JjL3R5cGVzL3RyYW5zY3JpcHRpb24udHNcbnZhciBJVHJhbnNjcmlwdGlvblNlcnZpY2UgPSBjbGFzcyBleHRlbmRzIFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY2FwYWJpbGl0eURlc2NyaXB0aW9uID0gXCJBdWRpbyB0cmFuc2NyaXB0aW9uIGFuZCBzcGVlY2ggcHJvY2Vzc2luZyBjYXBhYmlsaXRpZXNcIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMuc2VydmljZVR5cGUgPSBTZXJ2aWNlVHlwZS5UUkFOU0NSSVBUSU9OO1xuICB9XG59O1xuXG4vLyBzcmMvdHlwZXMvd2ViLXNlYXJjaC50c1xudmFyIElXZWJTZWFyY2hTZXJ2aWNlID0gY2xhc3MgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNhcGFiaWxpdHlEZXNjcmlwdGlvbiA9IFwiV2ViIHNlYXJjaCBhbmQgY29udGVudCBkaXNjb3ZlcnkgY2FwYWJpbGl0aWVzXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnNlcnZpY2VUeXBlID0gU2VydmljZVR5cGUuV0VCX1NFQVJDSDtcbiAgfVxufTtcblxuLy8gc3JjL3R5cGVzL2VtYWlsLnRzXG52YXIgSUVtYWlsU2VydmljZSA9IGNsYXNzIGV4dGVuZHMgU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jYXBhYmlsaXR5RGVzY3JpcHRpb24gPSBcIkVtYWlsIHNlbmRpbmcsIHJlY2VpdmluZywgYW5kIG1hbmFnZW1lbnQgY2FwYWJpbGl0aWVzXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnNlcnZpY2VUeXBlID0gU2VydmljZVR5cGUuRU1BSUw7XG4gIH1cbn07XG5cbi8vIHNyYy90eXBlcy9tZXNzYWdlLnRzXG52YXIgSU1lc3NhZ2VTZXJ2aWNlID0gY2xhc3MgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNhcGFiaWxpdHlEZXNjcmlwdGlvbiA9IFwiTWVzc2FnZSBzZW5kaW5nLCByZWNlaXZpbmcsIGFuZCBtYW5hZ2VtZW50IGNhcGFiaWxpdGllc1wiO1xuICB9XG4gIHN0YXRpYyB7XG4gICAgdGhpcy5zZXJ2aWNlVHlwZSA9IFNlcnZpY2VUeXBlLk1FU1NBR0U7XG4gIH1cbn07XG5cbi8vIHNyYy90eXBlcy9wb3N0LnRzXG52YXIgSVBvc3RTZXJ2aWNlID0gY2xhc3MgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNhcGFiaWxpdHlEZXNjcmlwdGlvbiA9IFwiU29jaWFsIG1lZGlhIHBvc3RpbmcgYW5kIGNvbnRlbnQgbWFuYWdlbWVudCBjYXBhYmlsaXRpZXNcIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMuc2VydmljZVR5cGUgPSBTZXJ2aWNlVHlwZS5QT1NUO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMudHNcbmltcG9ydCBoYW5kbGViYXJzIGZyb20gXCJoYW5kbGViYXJzXCI7XG5pbXBvcnQgeyBzaGExIH0gZnJvbSBcImpzLXNoYTFcIjtcbmltcG9ydCB7IFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlciB9IGZyb20gXCJsYW5nY2hhaW4vdGV4dF9zcGxpdHRlclwiO1xuaW1wb3J0IHsgbmFtZXMsIHVuaXF1ZU5hbWVzR2VuZXJhdG9yIH0gZnJvbSBcInVuaXF1ZS1uYW1lcy1nZW5lcmF0b3JcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG5cbi8vIHNyYy9sb2dnZXIudHNcbmltcG9ydCBwaW5vIGZyb20gXCJwaW5vXCI7XG5cbi8vIHNyYy9zZW50cnkvaW5zdHJ1bWVudC50c1xuaW1wb3J0ICogYXMgU2VudHJ5IGZyb20gXCJAc2VudHJ5L2Jyb3dzZXJcIjtcbnZhciBkc24gPSBwcm9jZXNzLmVudi5TRU5UUllfRFNOIHx8IFwiaHR0cHM6Ly9jMjBlMmQ1MWI2NmMxNGE3ODNiMDY4OWQ1MzZmN2U1Y0BvNDUwOTM0OTg2NTI1OTAwOC5pbmdlc3QudXMuc2VudHJ5LmlvLzQ1MDkzNTI1MjQxMjAwNjRcIjtcbmlmIChwcm9jZXNzLmVudi5TRU5UUllfTE9HR0lORyAhPT0gXCJmYWxzZVwiKSB7XG4gIFNlbnRyeS5vbkxvYWQoKCkgPT4ge1xuICAgIFNlbnRyeS5pbml0KHtcbiAgICAgIGRzbixcbiAgICAgIGVudmlyb25tZW50OiBwcm9jZXNzLmVudi5TRU5UUllfRU5WSVJPTk1FTlQgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYsXG4gICAgICB0cmFjZXNTYW1wbGVSYXRlOiBwYXJzZUZsb2F0KHByb2Nlc3MuZW52LlNFTlRSWV9UUkFDRVNfU0FNUExFX1JBVEUgPz8gXCJcIikgfHwgMSxcbiAgICAgIHNlbmREZWZhdWx0UGlpOiBwcm9jZXNzLmVudi5TRU5UUllfU0VORF9ERUZBVUxUX1BJSSA9PT0gXCJ0cnVlXCJcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIHNyYy9sb2dnZXIudHNcbmZ1bmN0aW9uIHBhcnNlQm9vbGVhbkZyb21UZXh0KHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICByZXR1cm4gbm9ybWFsaXplZCA9PT0gXCJ0cnVlXCIgfHwgbm9ybWFsaXplZCA9PT0gXCIxXCIgfHwgbm9ybWFsaXplZCA9PT0gXCJ5ZXNcIiB8fCBub3JtYWxpemVkID09PSBcIm9uXCI7XG59XG52YXIgSW5NZW1vcnlEZXN0aW5hdGlvbiA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgY2xhc3MuXG4gICAqIEBwYXJhbSB7RGVzdGluYXRpb25TdHJlYW18bnVsbH0gc3RyZWFtIC0gVGhlIHN0cmVhbSB0byBhc3NpZ24gdG8gdGhlIGluc3RhbmNlLiBDYW4gYmUgbnVsbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMubG9ncyA9IFtdO1xuICAgIHRoaXMubWF4TG9ncyA9IDFlMztcbiAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgfVxuICAvKipcbiAgICogV3JpdGVzIGEgbG9nIGVudHJ5IHRvIHRoZSBtZW1vcnkgYnVmZmVyIGFuZCBmb3J3YXJkcyBpdCB0byB0aGUgcHJldHR5IHByaW50IHN0cmVhbSBpZiBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgTG9nRW50cnl9IGRhdGEgLSBUaGUgZGF0YSB0byBiZSB3cml0dGVuLCB3aGljaCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgTG9nRW50cnkgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHdyaXRlKGRhdGEpIHtcbiAgICBsZXQgbG9nRW50cnk7XG4gICAgbGV0IHN0cmluZ0RhdGE7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzdHJpbmdEYXRhID0gZGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ0VudHJ5ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dFbnRyeSA9IGRhdGE7XG4gICAgICBzdHJpbmdEYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICghbG9nRW50cnkudGltZSkge1xuICAgICAgbG9nRW50cnkudGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIGNvbnN0IGlzRGVidWdNb2RlMiA9IChwcm9jZXNzPy5lbnY/LkxPR19MRVZFTCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcImRlYnVnXCI7XG4gICAgY29uc3QgaXNMb2dnaW5nRGlhZ25vc3RpYyA9IEJvb2xlYW4ocHJvY2Vzcz8uZW52Py5MT0dfRElBR05PU1RJQyk7XG4gICAgaWYgKGlzTG9nZ2luZ0RpYWdub3N0aWMpIHtcbiAgICAgIGxvZ0VudHJ5LmRpYWdub3N0aWMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWlzRGVidWdNb2RlMikge1xuICAgICAgaWYgKGxvZ0VudHJ5LmFnZW50TmFtZSAmJiBsb2dFbnRyeS5hZ2VudElkKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGxvZ0VudHJ5Lm1zZyB8fCBcIlwiO1xuICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gXCJzdHJpbmdcIiAmJiAobXNnLmluY2x1ZGVzKFwicmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHlcIikgfHwgbXNnLmluY2x1ZGVzKFwiUmVnaXN0ZXJpbmdcIikgfHwgbXNnLmluY2x1ZGVzKFwiU3VjY2VzczpcIikgfHwgbXNnLmluY2x1ZGVzKFwibGlua2VkIHRvXCIpIHx8IG1zZy5pbmNsdWRlcyhcIlN0YXJ0ZWRcIikpKSB7XG4gICAgICAgICAgaWYgKGlzTG9nZ2luZ0RpYWdub3N0aWMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGaWx0ZXJlZCBsb2c6XCIsIHN0cmluZ0RhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2dzLnB1c2gobG9nRW50cnkpO1xuICAgIGlmICh0aGlzLmxvZ3MubGVuZ3RoID4gdGhpcy5tYXhMb2dzKSB7XG4gICAgICB0aGlzLmxvZ3Muc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZShzdHJpbmdEYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgcmVjZW50IGxvZ3MgZnJvbSB0aGUgc3lzdGVtLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TG9nRW50cnlbXX0gQW4gYXJyYXkgb2YgTG9nRW50cnkgb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIHJlY2VudCBsb2dzLlxuICAgKi9cbiAgcmVjZW50TG9ncygpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dzO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGxvZ3MgZnJvbSBtZW1vcnkuXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5sb2dzID0gW107XG4gIH1cbn07XG52YXIgY3VzdG9tTGV2ZWxzID0ge1xuICBmYXRhbDogNjAsXG4gIGVycm9yOiA1MCxcbiAgd2FybjogNDAsXG4gIGluZm86IDMwLFxuICBsb2c6IDI5LFxuICBwcm9ncmVzczogMjgsXG4gIHN1Y2Nlc3M6IDI3LFxuICBkZWJ1ZzogMjAsXG4gIHRyYWNlOiAxMFxufTtcbnZhciByYXcgPSBwYXJzZUJvb2xlYW5Gcm9tVGV4dChwcm9jZXNzPy5lbnY/LkxPR19KU09OX0ZPUk1BVCkgfHwgZmFsc2U7XG52YXIgaXNEZWJ1Z01vZGUgPSAocHJvY2Vzcz8uZW52Py5MT0dfTEVWRUwgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJkZWJ1Z1wiO1xudmFyIGVmZmVjdGl2ZUxvZ0xldmVsID0gaXNEZWJ1Z01vZGUgPyBcImRlYnVnXCIgOiBwcm9jZXNzPy5lbnY/LkRFRkFVTFRfTE9HX0xFVkVMIHx8IFwiaW5mb1wiO1xudmFyIHNob3dUaW1lc3RhbXBzID0gcHJvY2Vzcz8uZW52Py5MT0dfVElNRVNUQU1QUyAhPT0gdm9pZCAwID8gcGFyc2VCb29sZWFuRnJvbVRleHQocHJvY2Vzcz8uZW52Py5MT0dfVElNRVNUQU1QUykgOiB0cnVlO1xudmFyIGNyZWF0ZVByZXR0eUNvbmZpZyA9ICgpID0+ICh7XG4gIGNvbG9yaXplOiB0cnVlLFxuICB0cmFuc2xhdGVUaW1lOiBzaG93VGltZXN0YW1wcyA/IFwieXl5eS1tbS1kZCBISDpNTTpzc1wiIDogZmFsc2UsXG4gIGlnbm9yZTogc2hvd1RpbWVzdGFtcHMgPyBcInBpZCxob3N0bmFtZVwiIDogXCJwaWQsaG9zdG5hbWUsdGltZVwiLFxuICBsZXZlbENvbG9yczoge1xuICAgIDYwOiBcInJlZFwiLFxuICAgIC8vIGZhdGFsXG4gICAgNTA6IFwicmVkXCIsXG4gICAgLy8gZXJyb3JcbiAgICA0MDogXCJ5ZWxsb3dcIixcbiAgICAvLyB3YXJuXG4gICAgMzA6IFwiYmx1ZVwiLFxuICAgIC8vIGluZm9cbiAgICAyOTogXCJncmVlblwiLFxuICAgIC8vIGxvZ1xuICAgIDI4OiBcImN5YW5cIixcbiAgICAvLyBwcm9ncmVzc1xuICAgIDI3OiBcImdyZWVuQnJpZ2h0XCIsXG4gICAgLy8gc3VjY2Vzc1xuICAgIDIwOiBcIm1hZ2VudGFcIixcbiAgICAvLyBkZWJ1Z1xuICAgIDEwOiBcImdyZXlcIixcbiAgICAvLyB0cmFjZVxuICAgIFwiKlwiOiBcIndoaXRlXCJcbiAgICAvLyBkZWZhdWx0IGZvciBhbnkgdW5zcGVjaWZpZWQgbGV2ZWxcbiAgfSxcbiAgY3VzdG9tUHJldHRpZmllcnM6IHtcbiAgICBsZXZlbDogKGlucHV0RGF0YSkgPT4ge1xuICAgICAgbGV0IGxldmVsO1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dERhdGEgPT09IFwib2JqZWN0XCIgJiYgaW5wdXREYXRhICE9PSBudWxsKSB7XG4gICAgICAgIGxldmVsID0gaW5wdXREYXRhLmxldmVsIHx8IGlucHV0RGF0YS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsID0gaW5wdXREYXRhO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWxOYW1lcyA9IHtcbiAgICAgICAgMTA6IFwiVFJBQ0VcIixcbiAgICAgICAgMjA6IFwiREVCVUdcIixcbiAgICAgICAgMjc6IFwiU1VDQ0VTU1wiLFxuICAgICAgICAyODogXCJQUk9HUkVTU1wiLFxuICAgICAgICAyOTogXCJMT0dcIixcbiAgICAgICAgMzA6IFwiSU5GT1wiLFxuICAgICAgICA0MDogXCJXQVJOXCIsXG4gICAgICAgIDUwOiBcIkVSUk9SXCIsXG4gICAgICAgIDYwOiBcIkZBVEFMXCJcbiAgICAgIH07XG4gICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBsZXZlbE5hbWVzW2xldmVsXSB8fCBgTEVWRUwke2xldmVsfWA7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCB8fCBsZXZlbCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJVTktOT1dOXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nKGxldmVsKS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG4gICAgLy8gQWRkIGEgY3VzdG9tIHByZXR0aWZpZXIgZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgbXNnOiAobXNnKSA9PiB7XG4gICAgICByZXR1cm4gbXNnLnJlcGxhY2UoL0VSUk9SIFxcKFteKV0rXFwpOi9nLCBcIkVSUk9SOlwiKTtcbiAgICB9XG4gIH0sXG4gIG1lc3NhZ2VGb3JtYXQ6IFwie21zZ31cIlxufSk7XG52YXIgY3JlYXRlU3RyZWFtID0gYXN5bmMgKCkgPT4ge1xuICBpZiAocmF3KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBwcmV0dHkgPSBhd2FpdCBpbXBvcnQoXCJwaW5vLXByZXR0eVwiKTtcbiAgcmV0dXJuIHByZXR0eS5kZWZhdWx0KGNyZWF0ZVByZXR0eUNvbmZpZygpKTtcbn07XG52YXIgb3B0aW9ucyA9IHtcbiAgbGV2ZWw6IGVmZmVjdGl2ZUxvZ0xldmVsLFxuICAvLyBVc2UgbW9yZSByZXN0cmljdGl2ZSBsZXZlbCB1bmxlc3MgaW4gZGVidWcgbW9kZVxuICBjdXN0b21MZXZlbHMsXG4gIGhvb2tzOiB7XG4gICAgbG9nTWV0aG9kKGlucHV0QXJncywgbWV0aG9kKSB7XG4gICAgICBjb25zdCBbYXJnMSwgLi4ucmVzdF0gPSBpbnB1dEFyZ3M7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuU0VOVFJZX0xPR0dJTkcgIT09IFwiZmFsc2VcIikge1xuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oYXJnMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHJlc3QpIHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBmb3JtYXRFcnJvciA9IChlcnIpID0+ICh7XG4gICAgICAgIG1lc3NhZ2U6IGAoJHtlcnIubmFtZX0pICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgc3RhY2s6IGVyci5zdGFjaz8uc3BsaXQoXCJcXG5cIikubWFwKChsaW5lKSA9PiBsaW5lLnRyaW0oKSlcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcjogZm9ybWF0RXJyb3IoYXJnMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlUGFydHMgPSByZXN0Lm1hcChcbiAgICAgICAgICAgIChhcmcpID0+IHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgPyBhcmcgOiBKU09OLnN0cmluZ2lmeShhcmcpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZVBhcnRzLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIG1ldGhvZC5hcHBseSh0aGlzLCBbYXJnMSwgbWVzc2FnZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge307XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VQYXJ0cyA9IFthcmcxLCAuLi5yZXN0XS5tYXAoKGFyZykgPT4ge1xuICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKGFyZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiID8gYXJnIDogYXJnO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VQYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiKS5qb2luKFwiIFwiKTtcbiAgICAgICAgY29uc3QganNvblBhcnRzID0gbWVzc2FnZVBhcnRzLmZpbHRlcigocGFydCkgPT4gdHlwZW9mIHBhcnQgPT09IFwib2JqZWN0XCIpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbnRleHQsIC4uLmpzb25QYXJ0cyk7XG4gICAgICAgIG1ldGhvZC5hcHBseSh0aGlzLCBbY29udGV4dCwgbWVzc2FnZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBjcmVhdGVMb2dnZXIgPSAoYmluZGluZ3MgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zIH07XG4gIGlmIChiaW5kaW5ncykge1xuICAgIG9wdHMuYmFzZSA9IGJpbmRpbmdzO1xuICAgIG9wdHMudHJhbnNwb3J0ID0ge1xuICAgICAgdGFyZ2V0OiBcInBpbm8tcHJldHR5XCIsXG4gICAgICAvLyB0aGlzIGlzIGp1c3QgYSBzdHJpbmcsIG5vdCBhIGR5bmFtaWMgaW1wb3J0XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGNvbG9yaXplOiB0cnVlLFxuICAgICAgICB0cmFuc2xhdGVUaW1lOiBzaG93VGltZXN0YW1wcyA/IFwiU1lTOnN0YW5kYXJkXCIgOiBmYWxzZSxcbiAgICAgICAgaWdub3JlOiBzaG93VGltZXN0YW1wcyA/IFwicGlkLGhvc3RuYW1lXCIgOiBcInBpZCxob3N0bmFtZSx0aW1lXCJcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNvbnN0IGxvZ2dlcjIgPSBwaW5vKG9wdHMpO1xuICByZXR1cm4gbG9nZ2VyMjtcbn07XG52YXIgbG9nZ2VyID0gcGlubyhvcHRpb25zKTtcbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBsZXQgc3RyZWFtID0gbnVsbDtcbiAgaWYgKCFyYXcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJldHR5ID0gX19yZXF1aXJlKFwicGluby1wcmV0dHlcIik7XG4gICAgICBzdHJlYW0gPSBwcmV0dHkuZGVmYXVsdCA/IHByZXR0eS5kZWZhdWx0KGNyZWF0ZVByZXR0eUNvbmZpZygpKSA6IG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY3JlYXRlU3RyZWFtKCkudGhlbigocHJldHR5U3RyZWFtKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gbmV3IEluTWVtb3J5RGVzdGluYXRpb24ocHJldHR5U3RyZWFtKTtcbiAgICAgICAgbG9nZ2VyID0gcGlubyhvcHRpb25zLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIGxvZ2dlcltTeW1ib2wuZm9yKFwicGluby1kZXN0aW5hdGlvblwiKV0gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgbG9nZ2VyLmNsZWFyID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uMiA9IGxvZ2dlcltTeW1ib2wuZm9yKFwicGluby1kZXN0aW5hdGlvblwiKV07XG4gICAgICAgICAgaWYgKGRlc3RpbmF0aW9uMiBpbnN0YW5jZW9mIEluTWVtb3J5RGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uMi5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoc3RyZWFtICE9PSBudWxsIHx8IHJhdykge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gbmV3IEluTWVtb3J5RGVzdGluYXRpb24oc3RyZWFtKTtcbiAgICBsb2dnZXIgPSBwaW5vKG9wdGlvbnMsIGRlc3RpbmF0aW9uKTtcbiAgICBsb2dnZXJbU3ltYm9sLmZvcihcInBpbm8tZGVzdGluYXRpb25cIildID0gZGVzdGluYXRpb247XG4gICAgbG9nZ2VyLmNsZWFyID0gKCkgPT4ge1xuICAgICAgY29uc3QgZGVzdGluYXRpb24yID0gbG9nZ2VyW1N5bWJvbC5mb3IoXCJwaW5vLWRlc3RpbmF0aW9uXCIpXTtcbiAgICAgIGlmIChkZXN0aW5hdGlvbjIgaW5zdGFuY2VvZiBJbk1lbW9yeURlc3RpbmF0aW9uKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uMi5jbGVhcigpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbnZhciBlbGl6YUxvZ2dlciA9IGxvZ2dlcjtcbnZhciBsb2dnZXJfZGVmYXVsdCA9IGxvZ2dlcjtcblxuLy8gc3JjL3V0aWxzLnRzXG5mdW5jdGlvbiB1cGdyYWRlRG91YmxlVG9UcmlwbGUodHBsKSB7XG4gIHJldHVybiB0cGwucmVwbGFjZShcbiAgICAvLyDilIDilIDilIDilIDilIDilIDilIDilIDila4gbmVnYXRpdmUtTEI6IG5vdCBhbHJlYWR5IFwie3t7XCJcbiAgICAvLyAgICAgICAgICDilIIgICB7eyAgICAg4pSAIG9wZW5pbmcgYnJhY2VzXG4gICAgLy8gICAgICAgICAg4pSCICAgIOKVsOKUgOKUgOKUgOKUgCBuZWdhdGl2ZS1MQTogbm90IHssICMsIC8sICEsID5cbiAgICAvLyAgICAgICAgICDilrxcbiAgICAvKD88IXspe3soPyFbeyNcXC8hPl0pKFtcXHNcXFNdKj8pfX0vZyxcbiAgICAoX21hdGNoLCBpbm5lcikgPT4ge1xuICAgICAgaWYgKGlubmVyLnRyaW0oKSA9PT0gXCJlbHNlXCIpIHJldHVybiBge3ske2lubmVyfX19YDtcbiAgICAgIHJldHVybiBge3t7JHtpbm5lcn19fX1gO1xuICAgIH1cbiAgKTtcbn1cbnZhciBjb21wb3NlUHJvbXB0ID0gKHtcbiAgc3RhdGUsXG4gIHRlbXBsYXRlXG59KSA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlU3RyID0gdHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIgPyB0ZW1wbGF0ZSh7IHN0YXRlIH0pIDogdGVtcGxhdGU7XG4gIGNvbnN0IHRlbXBsYXRlRnVuY3Rpb24gPSBoYW5kbGViYXJzLmNvbXBpbGUodXBncmFkZURvdWJsZVRvVHJpcGxlKHRlbXBsYXRlU3RyKSk7XG4gIGNvbnN0IG91dHB1dCA9IGNvbXBvc2VSYW5kb21Vc2VyKHRlbXBsYXRlRnVuY3Rpb24oc3RhdGUpLCAxMCk7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xudmFyIGNvbXBvc2VQcm9tcHRGcm9tU3RhdGUgPSAoe1xuICBzdGF0ZSxcbiAgdGVtcGxhdGVcbn0pID0+IHtcbiAgY29uc3QgdGVtcGxhdGVTdHIgPSB0eXBlb2YgdGVtcGxhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHRlbXBsYXRlKHsgc3RhdGUgfSkgOiB0ZW1wbGF0ZTtcbiAgY29uc3QgdGVtcGxhdGVGdW5jdGlvbiA9IGhhbmRsZWJhcnMuY29tcGlsZSh1cGdyYWRlRG91YmxlVG9UcmlwbGUodGVtcGxhdGVTdHIpKTtcbiAgY29uc3Qgc3RhdGVLZXlzID0gT2JqZWN0LmtleXMoc3RhdGUpO1xuICBjb25zdCBmaWx0ZXJlZEtleXMgPSBzdGF0ZUtleXMuZmlsdGVyKChrZXkpID0+ICFbXCJ0ZXh0XCIsIFwidmFsdWVzXCIsIFwiZGF0YVwiXS5pbmNsdWRlcyhrZXkpKTtcbiAgY29uc3QgZmlsdGVyZWRTdGF0ZSA9IGZpbHRlcmVkS2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSBzdGF0ZVtrZXldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgY29uc3Qgb3V0cHV0ID0gY29tcG9zZVJhbmRvbVVzZXIodGVtcGxhdGVGdW5jdGlvbih7IC4uLmZpbHRlcmVkU3RhdGUsIC4uLnN0YXRlLnZhbHVlcyB9KSwgMTApO1xuICByZXR1cm4gb3V0cHV0O1xufTtcbnZhciBhZGRIZWFkZXIgPSAoaGVhZGVyLCBib2R5KSA9PiB7XG4gIHJldHVybiBib2R5Lmxlbmd0aCA+IDAgPyBgJHtoZWFkZXIgPyBgJHtoZWFkZXJ9XG5gIDogaGVhZGVyfSR7Ym9keX1cbmAgOiBcIlwiO1xufTtcbnZhciBjb21wb3NlUmFuZG9tVXNlciA9ICh0ZW1wbGF0ZSwgbGVuZ3RoKSA9PiB7XG4gIGNvbnN0IGV4YW1wbGVOYW1lcyA9IEFycmF5LmZyb20oXG4gICAgeyBsZW5ndGggfSxcbiAgICAoKSA9PiB1bmlxdWVOYW1lc0dlbmVyYXRvcih7IGRpY3Rpb25hcmllczogW25hbWVzXSB9KVxuICApO1xuICBsZXQgcmVzdWx0ID0gdGVtcGxhdGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXhhbXBsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2VBbGwoYHt7bmFtZSR7aSArIDF9fX1gLCBleGFtcGxlTmFtZXNbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIGZvcm1hdFBvc3RzID0gKHtcbiAgbWVzc2FnZXMsXG4gIGVudGl0aWVzLFxuICBjb252ZXJzYXRpb25IZWFkZXIgPSB0cnVlXG59KSA9PiB7XG4gIGNvbnN0IGdyb3VwZWRNZXNzYWdlcyA9IHt9O1xuICBtZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgaWYgKG1lc3NhZ2Uucm9vbUlkKSB7XG4gICAgICBpZiAoIWdyb3VwZWRNZXNzYWdlc1ttZXNzYWdlLnJvb21JZF0pIHtcbiAgICAgICAgZ3JvdXBlZE1lc3NhZ2VzW21lc3NhZ2Uucm9vbUlkXSA9IFtdO1xuICAgICAgfVxuICAgICAgZ3JvdXBlZE1lc3NhZ2VzW21lc3NhZ2Uucm9vbUlkXS5wdXNoKG1lc3NhZ2UpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC52YWx1ZXMoZ3JvdXBlZE1lc3NhZ2VzKS5mb3JFYWNoKChyb29tTWVzc2FnZXMpID0+IHtcbiAgICByb29tTWVzc2FnZXMuc29ydCgoYSwgYikgPT4gYS5jcmVhdGVkQXQgLSBiLmNyZWF0ZWRBdCk7XG4gIH0pO1xuICBjb25zdCBzb3J0ZWRSb29tcyA9IE9iamVjdC5lbnRyaWVzKGdyb3VwZWRNZXNzYWdlcykuc29ydChcbiAgICAoWywgbWVzc2FnZXNBXSwgWywgbWVzc2FnZXNCXSkgPT4gbWVzc2FnZXNCW21lc3NhZ2VzQi5sZW5ndGggLSAxXS5jcmVhdGVkQXQgLSBtZXNzYWdlc0FbbWVzc2FnZXNBLmxlbmd0aCAtIDFdLmNyZWF0ZWRBdFxuICApO1xuICBjb25zdCBmb3JtYXR0ZWRQb3N0cyA9IHNvcnRlZFJvb21zLm1hcCgoW3Jvb21JZCwgcm9vbU1lc3NhZ2VzXSkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2VTdHJpbmdzID0gcm9vbU1lc3NhZ2VzLmZpbHRlcigobWVzc2FnZSkgPT4gbWVzc2FnZS5lbnRpdHlJZCkubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBlbnRpdHkgPSBlbnRpdGllcy5maW5kKChlbnRpdHkyKSA9PiBlbnRpdHkyLmlkID09PSBtZXNzYWdlLmVudGl0eUlkKTtcbiAgICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgIGxvZ2dlcl9kZWZhdWx0Lndhcm4oeyBlbnRpdHlJZDogbWVzc2FnZS5lbnRpdHlJZCB9LCBcImNvcmU6OnByb21wdHM6Zm9ybWF0UG9zdHMgLSBubyBlbnRpdHkgZm9yXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdXNlck5hbWUgPSBlbnRpdHk/Lm5hbWVzWzBdIHx8IFwiVW5rbm93biBVc2VyXCI7XG4gICAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGVudGl0eT8ubmFtZXNbMF0gfHwgXCJ1bmtub3duXCI7XG4gICAgICByZXR1cm4gYE5hbWU6ICR7dXNlck5hbWV9IChAJHtkaXNwbGF5TmFtZX0gRW50aXR5SUQ6JHttZXNzYWdlLmVudGl0eUlkfSlcbk1lc3NhZ2VJRDogJHttZXNzYWdlLmlkfSR7bWVzc2FnZS5jb250ZW50LmluUmVwbHlUbyA/IGBcbkluIHJlcGx5IHRvOiAke21lc3NhZ2UuY29udGVudC5pblJlcGx5VG99YCA6IFwiXCJ9XG5Tb3VyY2U6ICR7bWVzc2FnZS5jb250ZW50LnNvdXJjZX1cbkRhdGU6ICR7Zm9ybWF0VGltZXN0YW1wKG1lc3NhZ2UuY3JlYXRlZEF0KX1cblRleHQ6XG4ke21lc3NhZ2UuY29udGVudC50ZXh0fWA7XG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVyID0gY29udmVyc2F0aW9uSGVhZGVyID8gYENvbnZlcnNhdGlvbjogJHtyb29tSWQuc2xpY2UoLTUpfVxuYCA6IFwiXCI7XG4gICAgcmV0dXJuIGAke2hlYWRlcn0ke21lc3NhZ2VTdHJpbmdzLmpvaW4oXCJcXG5cXG5cIil9YDtcbiAgfSk7XG4gIHJldHVybiBmb3JtYXR0ZWRQb3N0cy5qb2luKFwiXFxuXFxuXCIpO1xufTtcbnZhciBmb3JtYXRNZXNzYWdlcyA9ICh7XG4gIG1lc3NhZ2VzLFxuICBlbnRpdGllc1xufSkgPT4ge1xuICBjb25zdCBtZXNzYWdlU3RyaW5ncyA9IG1lc3NhZ2VzLnJldmVyc2UoKS5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuZW50aXR5SWQpLm1hcCgobWVzc2FnZSkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2VUZXh0ID0gbWVzc2FnZS5jb250ZW50LnRleHQ7XG4gICAgY29uc3QgbWVzc2FnZUFjdGlvbnMgPSBtZXNzYWdlLmNvbnRlbnQuYWN0aW9ucztcbiAgICBjb25zdCBtZXNzYWdlVGhvdWdodCA9IG1lc3NhZ2UuY29udGVudC50aG91Z2h0O1xuICAgIGNvbnN0IGZvcm1hdHRlZE5hbWUgPSBlbnRpdGllcy5maW5kKChlbnRpdHkpID0+IGVudGl0eS5pZCA9PT0gbWVzc2FnZS5lbnRpdHlJZCk/Lm5hbWVzWzBdIHx8IFwiVW5rbm93biBVc2VyXCI7XG4gICAgY29uc3QgYXR0YWNobWVudHMgPSBtZXNzYWdlLmNvbnRlbnQuYXR0YWNobWVudHM7XG4gICAgY29uc3QgYXR0YWNobWVudFN0cmluZyA9IGF0dGFjaG1lbnRzICYmIGF0dGFjaG1lbnRzLmxlbmd0aCA+IDAgPyBgIChBdHRhY2htZW50czogJHthdHRhY2htZW50cy5tYXAoKG1lZGlhKSA9PiB7XG4gICAgICBjb25zdCBsaW5lcyA9IFtgWyR7bWVkaWEuaWR9IC0gJHttZWRpYS50aXRsZX0gKCR7bWVkaWEudXJsfSldYF07XG4gICAgICBpZiAobWVkaWEudGV4dCkgbGluZXMucHVzaChgVGV4dDogJHttZWRpYS50ZXh0fWApO1xuICAgICAgaWYgKG1lZGlhLmRlc2NyaXB0aW9uKSBsaW5lcy5wdXNoKGBEZXNjcmlwdGlvbjogJHttZWRpYS5kZXNjcmlwdGlvbn1gKTtcbiAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgIH0pLmpvaW4oXG4gICAgICAvLyBVc2UgY29tbWEgc2VwYXJhdG9yIG9ubHkgaWYgYWxsIGF0dGFjaG1lbnRzIGFyZSBzaW5nbGUtbGluZSAobm8gdGV4dC9kZXNjcmlwdGlvbilcbiAgICAgIGF0dGFjaG1lbnRzLmV2ZXJ5KChtZWRpYSkgPT4gIW1lZGlhLnRleHQgJiYgIW1lZGlhLmRlc2NyaXB0aW9uKSA/IFwiLCBcIiA6IFwiXFxuXCJcbiAgICApfSlgIDogbnVsbDtcbiAgICBjb25zdCBtZXNzYWdlVGltZSA9IG5ldyBEYXRlKG1lc3NhZ2UuY3JlYXRlZEF0KTtcbiAgICBjb25zdCBob3VycyA9IG1lc3NhZ2VUaW1lLmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgY29uc3QgbWludXRlcyA9IG1lc3NhZ2VUaW1lLmdldE1pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgICBjb25zdCB0aW1lU3RyaW5nID0gYCR7aG91cnN9OiR7bWludXRlc31gO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IGZvcm1hdFRpbWVzdGFtcChtZXNzYWdlLmNyZWF0ZWRBdCk7XG4gICAgY29uc3QgdGhvdWdodFN0cmluZyA9IG1lc3NhZ2VUaG91Z2h0ID8gYCgke2Zvcm1hdHRlZE5hbWV9J3MgaW50ZXJuYWwgdGhvdWdodDogJHttZXNzYWdlVGhvdWdodH0pYCA6IG51bGw7XG4gICAgY29uc3QgdGltZXN0YW1wU3RyaW5nID0gYCR7dGltZVN0cmluZ30gKCR7dGltZXN0YW1wfSkgWyR7bWVzc2FnZS5lbnRpdHlJZH1dYDtcbiAgICBjb25zdCB0ZXh0U3RyaW5nID0gbWVzc2FnZVRleHQgPyBgJHt0aW1lc3RhbXBTdHJpbmd9ICR7Zm9ybWF0dGVkTmFtZX06ICR7bWVzc2FnZVRleHR9YCA6IG51bGw7XG4gICAgY29uc3QgYWN0aW9uU3RyaW5nID0gbWVzc2FnZUFjdGlvbnMgJiYgbWVzc2FnZUFjdGlvbnMubGVuZ3RoID4gMCA/IGAke3RleHRTdHJpbmcgPyBcIlwiIDogdGltZXN0YW1wU3RyaW5nfSAoJHtmb3JtYXR0ZWROYW1lfSdzIGFjdGlvbnM6ICR7bWVzc2FnZUFjdGlvbnMuam9pbihcIiwgXCIpfSlgIDogbnVsbDtcbiAgICBjb25zdCBtZXNzYWdlU3RyaW5nID0gW3RleHRTdHJpbmcsIHRob3VnaHRTdHJpbmcsIGFjdGlvblN0cmluZywgYXR0YWNobWVudFN0cmluZ10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XG4gICAgcmV0dXJuIG1lc3NhZ2VTdHJpbmc7XG4gIH0pLmpvaW4oXCJcXG5cIik7XG4gIHJldHVybiBtZXNzYWdlU3RyaW5ncztcbn07XG52YXIgZm9ybWF0VGltZXN0YW1wID0gKG1lc3NhZ2VEYXRlKSA9PiB7XG4gIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICBjb25zdCBkaWZmID0gbm93LmdldFRpbWUoKSAtIG1lc3NhZ2VEYXRlO1xuICBjb25zdCBhYnNEaWZmID0gTWF0aC5hYnMoZGlmZik7XG4gIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKGFic0RpZmYgLyAxZTMpO1xuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xuICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IobWludXRlcyAvIDYwKTtcbiAgY29uc3QgZGF5cyA9IE1hdGguZmxvb3IoaG91cnMgLyAyNCk7XG4gIGlmIChhYnNEaWZmIDwgNmU0KSB7XG4gICAgcmV0dXJuIFwianVzdCBub3dcIjtcbiAgfVxuICBpZiAobWludXRlcyA8IDYwKSB7XG4gICAgcmV0dXJuIGAke21pbnV0ZXN9IG1pbnV0ZSR7bWludXRlcyAhPT0gMSA/IFwic1wiIDogXCJcIn0gYWdvYDtcbiAgfVxuICBpZiAoaG91cnMgPCAyNCkge1xuICAgIHJldHVybiBgJHtob3Vyc30gaG91ciR7aG91cnMgIT09IDEgPyBcInNcIiA6IFwiXCJ9IGFnb2A7XG4gIH1cbiAgcmV0dXJuIGAke2RheXN9IGRheSR7ZGF5cyAhPT0gMSA/IFwic1wiIDogXCJcIn0gYWdvYDtcbn07XG52YXIganNvbkJsb2NrUGF0dGVybiA9IC9gYGBqc29uXFxuKFtcXHNcXFNdKj8pXFxuYGBgLztcbmZ1bmN0aW9uIHBhcnNlS2V5VmFsdWVYbWwodGV4dCkge1xuICBpZiAoIXRleHQpIHJldHVybiBudWxsO1xuICBsZXQgeG1sQmxvY2tNYXRjaCA9IHRleHQubWF0Y2goLzxyZXNwb25zZT4oW1xcc1xcU10qPyk8XFwvcmVzcG9uc2U+Lyk7XG4gIGxldCB4bWxDb250ZW50O1xuICBpZiAoeG1sQmxvY2tNYXRjaCkge1xuICAgIHhtbENvbnRlbnQgPSB4bWxCbG9ja01hdGNoWzFdO1xuICAgIGxvZ2dlcl9kZWZhdWx0LmRlYnVnKFwiRm91bmQgcmVzcG9uc2UgWE1MIGJsb2NrXCIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZpbmRGaXJzdFhtbEJsb2NrID0gKGlucHV0KSA9PiB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBjb25zdCBvcGVuSWR4ID0gaW5wdXQuaW5kZXhPZihcIjxcIiwgaSk7XG4gICAgICAgIGlmIChvcGVuSWR4ID09PSAtMSkgYnJlYWs7XG4gICAgICAgIGlmIChpbnB1dC5zdGFydHNXaXRoKFwiPC9cIiwgb3BlbklkeCkgfHwgaW5wdXQuc3RhcnRzV2l0aChcIjwhLS1cIiwgb3BlbklkeCkgfHwgaW5wdXQuc3RhcnRzV2l0aChcIjw/XCIsIG9wZW5JZHgpKSB7XG4gICAgICAgICAgaSA9IG9wZW5JZHggKyAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBqID0gb3BlbklkeCArIDE7XG4gICAgICAgIGxldCB0YWcgPSBcIlwiO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGNoID0gaW5wdXRbal07XG4gICAgICAgICAgaWYgKC9eW0EtWmEtejAtOV8tXSQvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICB0YWcgKz0gY2g7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YWcpIHtcbiAgICAgICAgICBpID0gb3BlbklkeCArIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUYWdFbmQgPSBpbnB1dC5pbmRleE9mKFwiPlwiLCBqKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnRW5kID09PSAtMSkgYnJlYWs7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnVGV4dCA9IGlucHV0LnNsaWNlKG9wZW5JZHgsIHN0YXJ0VGFnRW5kICsgMSk7XG4gICAgICAgIGlmICgvXFwvXFxzKj4kLy50ZXN0KHN0YXJ0VGFnVGV4dCkpIHtcbiAgICAgICAgICBpID0gc3RhcnRUYWdFbmQgKyAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsb3NlU2VxID0gYDwvJHt0YWd9PmA7XG4gICAgICAgIGxldCBkZXB0aCA9IDE7XG4gICAgICAgIGxldCBzZWFyY2hTdGFydCA9IHN0YXJ0VGFnRW5kICsgMTtcbiAgICAgICAgd2hpbGUgKGRlcHRoID4gMCAmJiBzZWFyY2hTdGFydCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IG5leHRPcGVuID0gaW5wdXQuaW5kZXhPZihgPCR7dGFnfWAsIHNlYXJjaFN0YXJ0KTtcbiAgICAgICAgICBjb25zdCBuZXh0Q2xvc2UgPSBpbnB1dC5pbmRleE9mKGNsb3NlU2VxLCBzZWFyY2hTdGFydCk7XG4gICAgICAgICAgaWYgKG5leHRDbG9zZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dE9wZW4gIT09IC0xICYmIG5leHRPcGVuIDwgbmV4dENsb3NlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXN0ZWRTdGFydEVuZCA9IGlucHV0LmluZGV4T2YoXCI+XCIsIG5leHRPcGVuICsgMSk7XG4gICAgICAgICAgICBpZiAobmVzdGVkU3RhcnRFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmVzdGVkU3RhcnRUZXh0ID0gaW5wdXQuc2xpY2UobmV4dE9wZW4sIG5lc3RlZFN0YXJ0RW5kICsgMSk7XG4gICAgICAgICAgICBpZiAoL1xcL1xccyo+JC8udGVzdChuZXN0ZWRTdGFydFRleHQpKSB7XG4gICAgICAgICAgICAgIHNlYXJjaFN0YXJ0ID0gbmVzdGVkU3RhcnRFbmQgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgc2VhcmNoU3RhcnQgPSBuZXN0ZWRTdGFydEVuZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICBzZWFyY2hTdGFydCA9IG5leHRDbG9zZSArIGNsb3NlU2VxLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgY2xvc2VJZHggPSBzZWFyY2hTdGFydCAtIGNsb3NlU2VxLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBpbm5lciA9IGlucHV0LnNsaWNlKHN0YXJ0VGFnRW5kICsgMSwgY2xvc2VJZHgpO1xuICAgICAgICAgIHJldHVybiB7IHRhZywgY29udGVudDogaW5uZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBpID0gc3RhcnRUYWdFbmQgKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBmYiA9IGZpbmRGaXJzdFhtbEJsb2NrKHRleHQpO1xuICAgIGlmICghZmIpIHtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0Lndhcm4oXCJDb3VsZCBub3QgZmluZCBYTUwgYmxvY2sgaW4gdGV4dFwiKTtcbiAgICAgIGxvZ2dlcl9kZWZhdWx0LmRlYnVnKHsgdGV4dFByZXZpZXc6IHRleHQuc3Vic3RyaW5nKDAsIDIwMCkgKyBcIi4uLlwiIH0sIFwiVGV4dCBjb250ZW50XCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHhtbENvbnRlbnQgPSBmYi5jb250ZW50O1xuICAgIGxvZ2dlcl9kZWZhdWx0LmRlYnVnKGBGb3VuZCBYTUwgYmxvY2sgd2l0aCB0YWc6ICR7ZmIudGFnfWApO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBleHRyYWN0RGlyZWN0Q2hpbGRyZW4gPSAoaW5wdXQpID0+IHtcbiAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9wZW5JZHggPSBpbnB1dC5pbmRleE9mKFwiPFwiLCBpKTtcbiAgICAgIGlmIChvcGVuSWR4ID09PSAtMSkgYnJlYWs7XG4gICAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aChcIjwvXCIsIG9wZW5JZHgpIHx8IGlucHV0LnN0YXJ0c1dpdGgoXCI8IS0tXCIsIG9wZW5JZHgpIHx8IGlucHV0LnN0YXJ0c1dpdGgoXCI8P1wiLCBvcGVuSWR4KSkge1xuICAgICAgICBpID0gb3BlbklkeCArIDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGogPSBvcGVuSWR4ICsgMTtcbiAgICAgIGxldCB0YWcgPSBcIlwiO1xuICAgICAgd2hpbGUgKGogPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY2ggPSBpbnB1dFtqXTtcbiAgICAgICAgaWYgKC9eW0EtWmEtejAtOV8tXSQvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgdGFnICs9IGNoO1xuICAgICAgICAgIGorKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghdGFnKSB7XG4gICAgICAgIGkgPSBvcGVuSWR4ICsgMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFRhZ0VuZCA9IGlucHV0LmluZGV4T2YoXCI+XCIsIGopO1xuICAgICAgaWYgKHN0YXJ0VGFnRW5kID09PSAtMSkgYnJlYWs7XG4gICAgICBjb25zdCBzdGFydFRhZ1RleHQgPSBpbnB1dC5zbGljZShvcGVuSWR4LCBzdGFydFRhZ0VuZCArIDEpO1xuICAgICAgaWYgKC9cXC9cXHMqPiQvLnRlc3Qoc3RhcnRUYWdUZXh0KSkge1xuICAgICAgICBpID0gc3RhcnRUYWdFbmQgKyAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsb3NlU2VxID0gYDwvJHt0YWd9PmA7XG4gICAgICBsZXQgZGVwdGggPSAxO1xuICAgICAgbGV0IHNlYXJjaFN0YXJ0ID0gc3RhcnRUYWdFbmQgKyAxO1xuICAgICAgd2hpbGUgKGRlcHRoID4gMCAmJiBzZWFyY2hTdGFydCA8IGxlbmd0aCkge1xuICAgICAgICBjb25zdCBuZXh0T3BlbiA9IGlucHV0LmluZGV4T2YoYDwke3RhZ31gLCBzZWFyY2hTdGFydCk7XG4gICAgICAgIGNvbnN0IG5leHRDbG9zZSA9IGlucHV0LmluZGV4T2YoY2xvc2VTZXEsIHNlYXJjaFN0YXJ0KTtcbiAgICAgICAgaWYgKG5leHRDbG9zZSA9PT0gLTEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dE9wZW4gIT09IC0xICYmIG5leHRPcGVuIDwgbmV4dENsb3NlKSB7XG4gICAgICAgICAgY29uc3QgbmVzdGVkU3RhcnRFbmQgPSBpbnB1dC5pbmRleE9mKFwiPlwiLCBuZXh0T3BlbiArIDEpO1xuICAgICAgICAgIGlmIChuZXN0ZWRTdGFydEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuZXN0ZWRTdGFydFRleHQgPSBpbnB1dC5zbGljZShuZXh0T3BlbiwgbmVzdGVkU3RhcnRFbmQgKyAxKTtcbiAgICAgICAgICBpZiAoIS9cXC9cXHMqPiQvLnRlc3QobmVzdGVkU3RhcnRUZXh0KSkge1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VhcmNoU3RhcnQgPSBuZXN0ZWRTdGFydEVuZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICBzZWFyY2hTdGFydCA9IG5leHRDbG9zZSArIGNsb3NlU2VxLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlcHRoICE9PSAwKSB7XG4gICAgICAgIGkgPSBzdGFydFRhZ0VuZCArIDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xvc2VJZHggPSBzZWFyY2hTdGFydCAtIGNsb3NlU2VxLmxlbmd0aDtcbiAgICAgIGNvbnN0IGlubmVyUmF3ID0gaW5wdXQuc2xpY2Uoc3RhcnRUYWdFbmQgKyAxLCBjbG9zZUlkeCk7XG4gICAgICBjb25zdCB1bmVzY2FwZWQgPSBpbm5lclJhdy5yZXBsYWNlKC8mbHQ7L2csIFwiPFwiKS5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKS5yZXBsYWNlKC8mYW1wOy9nLCBcIiZcIikucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpLnJlcGxhY2UoLyZhcG9zOy9nLCBcIidcIikudHJpbSgpO1xuICAgICAgcGFpcnMucHVzaCh7IGtleTogdGFnLCB2YWx1ZTogdW5lc2NhcGVkIH0pO1xuICAgICAgaSA9IHNlYXJjaFN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG4gIGNvbnN0IGNoaWxkcmVuID0gZXh0cmFjdERpcmVjdENoaWxkcmVuKHhtbENvbnRlbnQpO1xuICBmb3IgKGNvbnN0IHsga2V5LCB2YWx1ZSB9IG9mIGNoaWxkcmVuKSB7XG4gICAgaWYgKGtleSA9PT0gXCJhY3Rpb25zXCIgfHwga2V5ID09PSBcInByb3ZpZGVyc1wiIHx8IGtleSA9PT0gXCJldmFsdWF0b3JzXCIpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWUgPyB2YWx1ZS5zcGxpdChcIixcIikubWFwKChzKSA9PiBzLnRyaW0oKSkgOiBbXTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzaW1wbGVcIikge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoID09PSAwKSB7XG4gICAgbG9nZ2VyX2RlZmF1bHQud2FybihcIk5vIGtleS12YWx1ZSBwYWlycyBleHRyYWN0ZWQgZnJvbSBYTUwgY29udGVudFwiKTtcbiAgICBsb2dnZXJfZGVmYXVsdC5kZWJ1Zyh7IHhtbFByZXZpZXc6IHhtbENvbnRlbnQuc3Vic3RyaW5nKDAsIDIwMCkgKyBcIi4uLlwiIH0sIFwiWE1MIGNvbnRlbnQgd2FzXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUpTT05PYmplY3RGcm9tVGV4dCh0ZXh0KSB7XG4gIGxldCBqc29uRGF0YSA9IG51bGw7XG4gIGNvbnN0IGpzb25CbG9ja01hdGNoID0gdGV4dC5tYXRjaChqc29uQmxvY2tQYXR0ZXJuKTtcbiAgdHJ5IHtcbiAgICBpZiAoanNvbkJsb2NrTWF0Y2gpIHtcbiAgICAgIGpzb25EYXRhID0gSlNPTi5wYXJzZShub3JtYWxpemVKc29uU3RyaW5nKGpzb25CbG9ja01hdGNoWzFdLnRyaW0oKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBqc29uRGF0YSA9IEpTT04ucGFyc2Uobm9ybWFsaXplSnNvblN0cmluZyh0ZXh0LnRyaW0oKSkpO1xuICAgIH1cbiAgfSBjYXRjaCAoX2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoanNvbkRhdGEgJiYgdHlwZW9mIGpzb25EYXRhID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGpzb25EYXRhKSkge1xuICAgIHJldHVybiBqc29uRGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbnZhciBub3JtYWxpemVKc29uU3RyaW5nID0gKHN0cikgPT4ge1xuICBzdHIgPSBzdHIucmVwbGFjZSgvXFx7XFxzKy8sIFwie1wiKS5yZXBsYWNlKC9cXHMrXFx9LywgXCJ9XCIpLnRyaW0oKTtcbiAgc3RyID0gc3RyLnJlcGxhY2UoLyhcIltcXHdcXGRfLV0rXCIpXFxzKjogXFxzKig/IVwifFxcWykoW1xcc1xcU10rPykoPz0oLFxccypcInxcXH0kKSkvZywgJyQxOiBcIiQyXCInKTtcbiAgc3RyID0gc3RyLnJlcGxhY2UoL1wiKFteXCJdKylcIlxccyo6XFxzKicoW14nXSopJy9nLCAoXywga2V5LCB2YWx1ZSkgPT4gYFwiJHtrZXl9XCI6IFwiJHt2YWx1ZX1cImApO1xuICBzdHIgPSBzdHIucmVwbGFjZSgvKFwiW1xcd1xcZF8tXStcIilcXHMqOlxccyooW0EtWmEtel9dKykoPyFbXCJcXHddKS9nLCAnJDE6IFwiJDJcIicpO1xuICByZXR1cm4gc3RyO1xufTtcbmZ1bmN0aW9uIHRydW5jYXRlVG9Db21wbGV0ZVNlbnRlbmNlKHRleHQsIG1heExlbmd0aCkge1xuICBpZiAodGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgY29uc3QgbGFzdFBlcmlvZEluZGV4ID0gdGV4dC5sYXN0SW5kZXhPZihcIi5cIiwgbWF4TGVuZ3RoIC0gMSk7XG4gIGlmIChsYXN0UGVyaW9kSW5kZXggIT09IC0xKSB7XG4gICAgY29uc3QgdHJ1bmNhdGVkQXRQZXJpb2QgPSB0ZXh0LnNsaWNlKDAsIGxhc3RQZXJpb2RJbmRleCArIDEpLnRyaW0oKTtcbiAgICBpZiAodHJ1bmNhdGVkQXRQZXJpb2QubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRydW5jYXRlZEF0UGVyaW9kO1xuICAgIH1cbiAgfVxuICBjb25zdCBsYXN0U3BhY2VJbmRleCA9IHRleHQubGFzdEluZGV4T2YoXCIgXCIsIG1heExlbmd0aCAtIDEpO1xuICBpZiAobGFzdFNwYWNlSW5kZXggIT09IC0xKSB7XG4gICAgY29uc3QgdHJ1bmNhdGVkQXRTcGFjZSA9IHRleHQuc2xpY2UoMCwgbGFzdFNwYWNlSW5kZXgpLnRyaW0oKTtcbiAgICBpZiAodHJ1bmNhdGVkQXRTcGFjZS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gYCR7dHJ1bmNhdGVkQXRTcGFjZX0uLi5gO1xuICAgIH1cbiAgfVxuICBjb25zdCBoYXJkVHJ1bmNhdGVkID0gdGV4dC5zbGljZSgwLCBtYXhMZW5ndGggLSAzKS50cmltKCk7XG4gIHJldHVybiBgJHtoYXJkVHJ1bmNhdGVkfS4uLmA7XG59XG5hc3luYyBmdW5jdGlvbiBzcGxpdENodW5rcyhjb250ZW50LCBjaHVua1NpemUgPSA1MTIsIGJsZWVkID0gMjApIHtcbiAgbG9nZ2VyX2RlZmF1bHQuZGVidWcoXCJbc3BsaXRDaHVua3NdIFN0YXJ0aW5nIHRleHQgc3BsaXRcIik7XG4gIGNvbnN0IGNoYXJhY3RlcnN0b1Rva2VucyA9IDMuNTtcbiAgY29uc3QgdGV4dFNwbGl0dGVyID0gbmV3IFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlcih7XG4gICAgY2h1bmtTaXplOiBOdW1iZXIoTWF0aC5mbG9vcihjaHVua1NpemUgKiBjaGFyYWN0ZXJzdG9Ub2tlbnMpKSxcbiAgICBjaHVua092ZXJsYXA6IE51bWJlcihNYXRoLmZsb29yKGJsZWVkICogY2hhcmFjdGVyc3RvVG9rZW5zKSlcbiAgfSk7XG4gIGNvbnN0IGNodW5rcyA9IGF3YWl0IHRleHRTcGxpdHRlci5zcGxpdFRleHQoY29udGVudCk7XG4gIGxvZ2dlcl9kZWZhdWx0LmRlYnVnKFxuICAgIHtcbiAgICAgIG51bWJlck9mQ2h1bmtzOiBjaHVua3MubGVuZ3RoLFxuICAgICAgYXZlcmFnZUNodW5rU2l6ZTogY2h1bmtzLnJlZHVjZSgoYWNjLCBjaHVuaykgPT4gYWNjICsgY2h1bmsubGVuZ3RoLCAwKSAvIGNodW5rcy5sZW5ndGhcbiAgICB9LFxuICAgIFwiW3NwbGl0Q2h1bmtzXSBTcGxpdCBjb21wbGV0ZVwiXG4gICk7XG4gIHJldHVybiBjaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiB0cmltVG9rZW5zKHByb21wdCwgbWF4VG9rZW5zLCBydW50aW1lKSB7XG4gIGlmICghcHJvbXB0KSB0aHJvdyBuZXcgRXJyb3IoXCJUcmltIHRva2VucyByZWNlaXZlZCBhIG51bGwgcHJvbXB0XCIpO1xuICBpZiAocHJvbXB0Lmxlbmd0aCA8IG1heFRva2VucyAvIDUpIHJldHVybiBwcm9tcHQ7XG4gIGlmIChtYXhUb2tlbnMgPD0gMCkgdGhyb3cgbmV3IEVycm9yKFwibWF4VG9rZW5zIG11c3QgYmUgcG9zaXRpdmVcIik7XG4gIGNvbnN0IHRva2VucyA9IGF3YWl0IHJ1bnRpbWUudXNlTW9kZWwoTW9kZWxUeXBlLlRFWFRfVE9LRU5JWkVSX0VOQ09ERSwge1xuICAgIHByb21wdFxuICB9KTtcbiAgaWYgKHRva2Vucy5sZW5ndGggPD0gbWF4VG9rZW5zKSB7XG4gICAgcmV0dXJuIHByb21wdDtcbiAgfVxuICBjb25zdCB0cnVuY2F0ZWRUb2tlbnMgPSB0b2tlbnMuc2xpY2UoLW1heFRva2Vucyk7XG4gIHJldHVybiBhd2FpdCBydW50aW1lLnVzZU1vZGVsKE1vZGVsVHlwZS5URVhUX1RPS0VOSVpFUl9ERUNPREUsIHtcbiAgICB0b2tlbnM6IHRydW5jYXRlZFRva2Vuc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNhZmVSZXBsYWNlcigpIHtcbiAgY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICByZXR1cm4gZnVuY3Rpb24oX2tleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBcIltDaXJjdWxhcl1cIjtcbiAgICAgIH1cbiAgICAgIHNlZW4uYWRkKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VCb29sZWFuRnJvbVRleHQyKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgYWZmaXJtYXRpdmUgPSBbXCJZRVNcIiwgXCJZXCIsIFwiVFJVRVwiLCBcIlRcIiwgXCIxXCIsIFwiT05cIiwgXCJFTkFCTEVcIl07XG4gIGNvbnN0IG5lZ2F0aXZlID0gW1wiTk9cIiwgXCJOXCIsIFwiRkFMU0VcIiwgXCJGXCIsIFwiMFwiLCBcIk9GRlwiLCBcIkRJU0FCTEVcIl07XG4gIGNvbnN0IG5vcm1hbGl6ZWRUZXh0ID0gdmFsdWUudHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gIGlmIChhZmZpcm1hdGl2ZS5pbmNsdWRlcyhub3JtYWxpemVkVGV4dCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobmVnYXRpdmUuaW5jbHVkZXMobm9ybWFsaXplZFRleHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciB1dWlkU2NoZW1hID0gei5zdHJpbmcoKS51dWlkKCk7XG5mdW5jdGlvbiB2YWxpZGF0ZVV1aWQodmFsdWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gdXVpZFNjaGVtYS5zYWZlUGFyc2UodmFsdWUpO1xuICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3MgPyByZXN1bHQuZGF0YSA6IG51bGw7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1V1aWQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJWYWx1ZSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgfVxuICBjb25zdCBfdWludDhUb0hleCA9ICh1Ynl0ZSkgPT4ge1xuICAgIGNvbnN0IGZpcnN0ID0gdWJ5dGUgPj4gNDtcbiAgICBjb25zdCBzZWNvbmQgPSB1Ynl0ZSAtIChmaXJzdCA8PCA0KTtcbiAgICBjb25zdCBIRVhfRElHSVRTID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCIuc3BsaXQoXCJcIik7XG4gICAgcmV0dXJuIEhFWF9ESUdJVFNbZmlyc3RdICsgSEVYX0RJR0lUU1tzZWNvbmRdO1xuICB9O1xuICBjb25zdCBfdWludDhBcnJheVRvSGV4ID0gKGJ1ZikgPT4ge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXQgKz0gX3VpbnQ4VG9IZXgoYnVmW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbiAgY29uc3QgZXNjYXBlZFN0ciA9IGVuY29kZVVSSUNvbXBvbmVudCh0YXJnZXQpO1xuICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShlc2NhcGVkU3RyLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXNjYXBlZFN0ci5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZlcltpXSA9IGVzY2FwZWRTdHJbaV0uY2hhckNvZGVBdCgwKTtcbiAgfVxuICBjb25zdCBoYXNoID0gc2hhMShidWZmZXIpO1xuICBjb25zdCBoYXNoQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoaGFzaC5sZW5ndGggLyAyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYXNoLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaGFzaEJ1ZmZlcltpIC8gMl0gPSBOdW1iZXIucGFyc2VJbnQoaGFzaC5zbGljZShpLCBpICsgMiksIDE2KTtcbiAgfVxuICByZXR1cm4gYCR7X3VpbnQ4QXJyYXlUb0hleChoYXNoQnVmZmVyLnNsaWNlKDAsIDQpKX0tJHtfdWludDhBcnJheVRvSGV4KGhhc2hCdWZmZXIuc2xpY2UoNCwgNikpfS0ke191aW50OFRvSGV4KGhhc2hCdWZmZXJbNl0gJiAxNSl9JHtfdWludDhUb0hleChoYXNoQnVmZmVyWzddKX0tJHtfdWludDhUb0hleChoYXNoQnVmZmVyWzhdICYgNjMgfCAxMjgpfSR7X3VpbnQ4VG9IZXgoaGFzaEJ1ZmZlcls5XSl9LSR7X3VpbnQ4QXJyYXlUb0hleChoYXNoQnVmZmVyLnNsaWNlKDEwLCAxNikpfWA7XG59XG52YXIgZ2V0Q29udGVudFR5cGVGcm9tTWltZVR5cGUgPSAobWltZVR5cGUpID0+IHtcbiAgaWYgKG1pbWVUeXBlLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHJldHVybiBcImltYWdlXCIgLyogSU1BR0UgKi87XG4gIGlmIChtaW1lVHlwZS5zdGFydHNXaXRoKFwidmlkZW8vXCIpKSByZXR1cm4gXCJ2aWRlb1wiIC8qIFZJREVPICovO1xuICBpZiAobWltZVR5cGUuc3RhcnRzV2l0aChcImF1ZGlvL1wiKSkgcmV0dXJuIFwiYXVkaW9cIiAvKiBBVURJTyAqLztcbiAgaWYgKG1pbWVUeXBlLmluY2x1ZGVzKFwicGRmXCIpIHx8IG1pbWVUeXBlLmluY2x1ZGVzKFwiZG9jdW1lbnRcIikgfHwgbWltZVR5cGUuc3RhcnRzV2l0aChcInRleHQvXCIpKSB7XG4gICAgcmV0dXJuIFwiZG9jdW1lbnRcIiAvKiBET0NVTUVOVCAqLztcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufTtcbmZ1bmN0aW9uIGdldExvY2FsU2VydmVyVXJsKHBhdGgpIHtcbiAgY29uc3QgcG9ydCA9IHByb2Nlc3MuZW52LlNFUlZFUl9QT1JUIHx8IFwiMzAwMFwiO1xuICByZXR1cm4gYGh0dHA6Ly9sb2NhbGhvc3Q6JHtwb3J0fSR7cGF0aH1gO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9jaGFyYWN0ZXIudHNcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kXCI7XG52YXIgdXVpZFNjaGVtYTIgPSB6Mi5zdHJpbmcoKS5yZWdleCgvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQvaSwgXCJJbnZhbGlkIFVVSUQgZm9ybWF0XCIpO1xudmFyIGNvbnRlbnRTY2hlbWEgPSB6Mi5vYmplY3Qoe1xuICB0ZXh0OiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB0aG91Z2h0OiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBhY3Rpb25zOiB6Mi5hcnJheSh6Mi5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJzOiB6Mi5hcnJheSh6Mi5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgc291cmNlOiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB0YXJnZXQ6IHoyLnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHVybDogejIuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgaW5SZXBseVRvOiB1dWlkU2NoZW1hMi5vcHRpb25hbCgpLFxuICBhdHRhY2htZW50czogejIuYXJyYXkoejIuYW55KCkpLm9wdGlvbmFsKCksXG4gIGNoYW5uZWxUeXBlOiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIG1lc3NhZ2VFeGFtcGxlU2NoZW1hID0gejIub2JqZWN0KHtcbiAgbmFtZTogejIuc3RyaW5nKCksXG4gIGNvbnRlbnQ6IGNvbnRlbnRTY2hlbWFcbn0pO1xudmFyIGRpcmVjdG9yeUl0ZW1TY2hlbWEgPSB6Mi5vYmplY3Qoe1xuICBkaXJlY3Rvcnk6IHoyLnN0cmluZygpLFxuICBzaGFyZWQ6IHoyLmJvb2xlYW4oKS5vcHRpb25hbCgpXG59KTtcbnZhciBrbm93bGVkZ2VJdGVtU2NoZW1hID0gejIudW5pb24oW1xuICB6Mi5zdHJpbmcoKSxcbiAgejIub2JqZWN0KHtcbiAgICBwYXRoOiB6Mi5zdHJpbmcoKSxcbiAgICBzaGFyZWQ6IHoyLmJvb2xlYW4oKS5vcHRpb25hbCgpXG4gIH0pLFxuICBkaXJlY3RvcnlJdGVtU2NoZW1hXG5dKTtcbnZhciB0ZW1wbGF0ZVR5cGVTY2hlbWEgPSB6Mi51bmlvbihbXG4gIHoyLnN0cmluZygpLFxuICB6Mi5mdW5jdGlvbigpLm9wdGlvbmFsKClcbiAgLy8gRnVuY3Rpb25zIHdvbid0IGJlIGluIEpTT04gYnV0IGFsbG93ZWQgaW4gcnVudGltZVxuXSk7XG52YXIgc3R5bGVTY2hlbWEgPSB6Mi5vYmplY3Qoe1xuICBhbGw6IHoyLmFycmF5KHoyLnN0cmluZygpKS5vcHRpb25hbCgpLFxuICBjaGF0OiB6Mi5hcnJheSh6Mi5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgcG9zdDogejIuYXJyYXkoejIuc3RyaW5nKCkpLm9wdGlvbmFsKClcbn0pLm9wdGlvbmFsKCk7XG52YXIgc2V0dGluZ3NTY2hlbWEgPSB6Mi5yZWNvcmQoejIudW5pb24oW3oyLnN0cmluZygpLCB6Mi5ib29sZWFuKCksIHoyLm51bWJlcigpLCB6Mi5hbnkoKV0pKS5vcHRpb25hbCgpO1xudmFyIHNlY3JldHNTY2hlbWEgPSB6Mi5yZWNvcmQoejIudW5pb24oW3oyLnN0cmluZygpLCB6Mi5ib29sZWFuKCksIHoyLm51bWJlcigpXSkpLm9wdGlvbmFsKCk7XG52YXIgY2hhcmFjdGVyU2NoZW1hID0gejIub2JqZWN0KHtcbiAgaWQ6IHV1aWRTY2hlbWEyLm9wdGlvbmFsKCksXG4gIG5hbWU6IHoyLnN0cmluZygpLm1pbigxLCBcIkNoYXJhY3RlciBuYW1lIGlzIHJlcXVpcmVkXCIpLFxuICB1c2VybmFtZTogejIuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgc3lzdGVtOiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB0ZW1wbGF0ZXM6IHoyLnJlY29yZCh0ZW1wbGF0ZVR5cGVTY2hlbWEpLm9wdGlvbmFsKCksXG4gIGJpbzogejIudW5pb24oW3oyLnN0cmluZygpLCB6Mi5hcnJheSh6Mi5zdHJpbmcoKSldKSxcbiAgbWVzc2FnZUV4YW1wbGVzOiB6Mi5hcnJheSh6Mi5hcnJheShtZXNzYWdlRXhhbXBsZVNjaGVtYSkpLm9wdGlvbmFsKCksXG4gIHBvc3RFeGFtcGxlczogejIuYXJyYXkoejIuc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gIHRvcGljczogejIuYXJyYXkoejIuc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gIGFkamVjdGl2ZXM6IHoyLmFycmF5KHoyLnN0cmluZygpKS5vcHRpb25hbCgpLFxuICBrbm93bGVkZ2U6IHoyLmFycmF5KGtub3dsZWRnZUl0ZW1TY2hlbWEpLm9wdGlvbmFsKCksXG4gIHBsdWdpbnM6IHoyLmFycmF5KHoyLnN0cmluZygpKS5vcHRpb25hbCgpLFxuICBzZXR0aW5nczogc2V0dGluZ3NTY2hlbWEsXG4gIHNlY3JldHM6IHNlY3JldHNTY2hlbWEsXG4gIHN0eWxlOiBzdHlsZVNjaGVtYVxufSkuc3RyaWN0KCk7XG5mdW5jdGlvbiB2YWxpZGF0ZUNoYXJhY3RlcihkYXRhKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGNoYXJhY3RlclNjaGVtYS5zYWZlUGFyc2UoZGF0YSk7XG4gIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YTogcmVzdWx0LmRhdGFcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgZXJyb3I6IHtcbiAgICAgIG1lc3NhZ2U6IGBDaGFyYWN0ZXIgdmFsaWRhdGlvbiBmYWlsZWQ6ICR7cmVzdWx0LmVycm9yLm1lc3NhZ2V9YCxcbiAgICAgIGlzc3VlczogcmVzdWx0LmVycm9yLmlzc3Vlc1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQW5kVmFsaWRhdGVDaGFyYWN0ZXIoanNvblN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgcmV0dXJuIHZhbGlkYXRlQ2hhcmFjdGVyKHBhcnNlZCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IHtcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgSlNPTjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBKU09OIHBhcnNpbmcgZXJyb3JcIn1gXG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZENoYXJhY3RlcihkYXRhKSB7XG4gIHJldHVybiB2YWxpZGF0ZUNoYXJhY3RlcihkYXRhKS5zdWNjZXNzO1xufVxuXG4vLyBzcmMvYWN0aW9ucy50c1xuaW1wb3J0IHsgbmFtZXMgYXMgbmFtZXMyLCB1bmlxdWVOYW1lc0dlbmVyYXRvciBhcyB1bmlxdWVOYW1lc0dlbmVyYXRvcjIgfSBmcm9tIFwidW5pcXVlLW5hbWVzLWdlbmVyYXRvclwiO1xudmFyIGNvbXBvc2VBY3Rpb25FeGFtcGxlcyA9IChhY3Rpb25zRGF0YSwgY291bnQpID0+IHtcbiAgaWYgKCFhY3Rpb25zRGF0YS5sZW5ndGggfHwgY291bnQgPD0gMCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IGFjdGlvbnNXaXRoRXhhbXBsZXMgPSBhY3Rpb25zRGF0YS5maWx0ZXIoXG4gICAgKGFjdGlvbikgPT4gYWN0aW9uLmV4YW1wbGVzICYmIEFycmF5LmlzQXJyYXkoYWN0aW9uLmV4YW1wbGVzKSAmJiBhY3Rpb24uZXhhbXBsZXMubGVuZ3RoID4gMFxuICApO1xuICBpZiAoIWFjdGlvbnNXaXRoRXhhbXBsZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgZXhhbXBsZXNDb3B5ID0gYWN0aW9uc1dpdGhFeGFtcGxlcy5tYXAoKGFjdGlvbikgPT4gW1xuICAgIC4uLmFjdGlvbi5leGFtcGxlc1xuICBdKTtcbiAgY29uc3Qgc2VsZWN0ZWRFeGFtcGxlcyA9IFtdO1xuICBsZXQgYXZhaWxhYmxlQWN0aW9uSW5kaWNlcyA9IGV4YW1wbGVzQ29weS5tYXAoKGV4YW1wbGVzLCBpbmRleCkgPT4gZXhhbXBsZXMubGVuZ3RoID4gMCA/IGluZGV4IDogLTEpLmZpbHRlcigoaW5kZXgpID0+IGluZGV4ICE9PSAtMSk7XG4gIHdoaWxlIChzZWxlY3RlZEV4YW1wbGVzLmxlbmd0aCA8IGNvdW50ICYmIGF2YWlsYWJsZUFjdGlvbkluZGljZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXZhaWxhYmxlQWN0aW9uSW5kaWNlcy5sZW5ndGgpO1xuICAgIGNvbnN0IGFjdGlvbkluZGV4ID0gYXZhaWxhYmxlQWN0aW9uSW5kaWNlc1tyYW5kb21JbmRleF07XG4gICAgY29uc3QgZXhhbXBsZXMgPSBleGFtcGxlc0NvcHlbYWN0aW9uSW5kZXhdO1xuICAgIGNvbnN0IGV4YW1wbGVJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGV4YW1wbGVzLmxlbmd0aCk7XG4gICAgc2VsZWN0ZWRFeGFtcGxlcy5wdXNoKGV4YW1wbGVzLnNwbGljZShleGFtcGxlSW5kZXgsIDEpWzBdKTtcbiAgICBpZiAoZXhhbXBsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBhdmFpbGFibGVBY3Rpb25JbmRpY2VzLnNwbGljZShyYW5kb21JbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXRTZWxlY3RlZEV4YW1wbGVzKHNlbGVjdGVkRXhhbXBsZXMpO1xufTtcbnZhciBmb3JtYXRTZWxlY3RlZEV4YW1wbGVzID0gKGV4YW1wbGVzKSA9PiB7XG4gIGNvbnN0IE1BWF9OQU1FX1BMQUNFSE9MREVSUyA9IDU7XG4gIHJldHVybiBleGFtcGxlcy5tYXAoKGV4YW1wbGUpID0+IHtcbiAgICBjb25zdCByYW5kb21OYW1lcyA9IEFycmF5LmZyb20oXG4gICAgICB7IGxlbmd0aDogTUFYX05BTUVfUExBQ0VIT0xERVJTIH0sXG4gICAgICAoKSA9PiB1bmlxdWVOYW1lc0dlbmVyYXRvcjIoeyBkaWN0aW9uYXJpZXM6IFtuYW1lczJdIH0pXG4gICAgKTtcbiAgICBjb25zdCBjb252ZXJzYXRpb24gPSBleGFtcGxlLm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgbGV0IG1lc3NhZ2VUZXh0ID0gYCR7bWVzc2FnZS5uYW1lfTogJHttZXNzYWdlLmNvbnRlbnQudGV4dH1gO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5kb21OYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZXNzYWdlVGV4dCA9IG1lc3NhZ2VUZXh0LnJlcGxhY2VBbGwoYHt7bmFtZSR7aSArIDF9fX1gLCByYW5kb21OYW1lc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZVRleHQ7XG4gICAgfSkuam9pbihcIlxcblwiKTtcbiAgICByZXR1cm4gYFxuJHtjb252ZXJzYXRpb259YDtcbiAgfSkuam9pbihcIlxcblwiKTtcbn07XG5mdW5jdGlvbiBmb3JtYXRBY3Rpb25OYW1lcyhhY3Rpb25zKSB7XG4gIGlmICghYWN0aW9ucz8ubGVuZ3RoKSByZXR1cm4gXCJcIjtcbiAgcmV0dXJuIFsuLi5hY3Rpb25zXS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpLm1hcCgoYWN0aW9uKSA9PiBhY3Rpb24ubmFtZSkuam9pbihcIiwgXCIpO1xufVxuZnVuY3Rpb24gZm9ybWF0QWN0aW9ucyhhY3Rpb25zKSB7XG4gIGlmICghYWN0aW9ucz8ubGVuZ3RoKSByZXR1cm4gXCJcIjtcbiAgcmV0dXJuIFsuLi5hY3Rpb25zXS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpLm1hcCgoYWN0aW9uKSA9PiBgLSAqKiR7YWN0aW9uLm5hbWV9Kio6ICR7YWN0aW9uLmRlc2NyaXB0aW9uIHx8IFwiTm8gZGVzY3JpcHRpb24gYXZhaWxhYmxlXCJ9YCkuam9pbihcIlxcblwiKTtcbn1cblxuLy8gc3JjL2RhdGFiYXNlLnRzXG52YXIgRGF0YWJhc2VBZGFwdGVyID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL2VudGl0aWVzLnRzXG52YXIgZW50aXR5UmVzb2x1dGlvblRlbXBsYXRlID0gYCMgVGFzazogUmVzb2x2ZSBFbnRpdHkgTmFtZVxuTWVzc2FnZSBTZW5kZXI6IHt7c2VuZGVyTmFtZX19IChJRDoge3tzZW5kZXJJZH19KVxuQWdlbnQ6IHt7YWdlbnROYW1lfX0gKElEOiB7e2FnZW50SWR9fSlcblxuIyBFbnRpdGllcyBpbiBSb29tOlxue3sjaWYgZW50aXRpZXNJblJvb219fVxue3tlbnRpdGllc0luUm9vbX19XG57ey9pZn19XG5cbnt7cmVjZW50TWVzc2FnZXN9fVxuXG4jIEluc3RydWN0aW9uczpcbjEuIEFuYWx5emUgdGhlIGNvbnRleHQgdG8gaWRlbnRpZnkgd2hpY2ggZW50aXR5IGlzIGJlaW5nIHJlZmVyZW5jZWRcbjIuIENvbnNpZGVyIHNwZWNpYWwgcmVmZXJlbmNlcyBsaWtlIFwibWVcIiAodGhlIG1lc3NhZ2Ugc2VuZGVyKSBvciBcInlvdVwiIChhZ2VudCB0aGUgbWVzc2FnZSBpcyBkaXJlY3RlZCB0bylcbjMuIExvb2sgZm9yIHVzZXJuYW1lcy9oYW5kbGVzIGluIHN0YW5kYXJkIGZvcm1hdHMgKGUuZy4gQHVzZXJuYW1lLCB1c2VyIzEyMzQpXG40LiBDb25zaWRlciBjb250ZXh0IGZyb20gcmVjZW50IG1lc3NhZ2VzIGZvciBwcm9ub3VucyBhbmQgcmVmZXJlbmNlc1xuNS4gSWYgbXVsdGlwbGUgbWF0Y2hlcyBleGlzdCwgdXNlIGNvbnRleHQgdG8gZGlzYW1iaWd1YXRlXG42LiBDb25zaWRlciByZWNlbnQgaW50ZXJhY3Rpb25zIGFuZCByZWxhdGlvbnNoaXAgc3RyZW5ndGggd2hlbiByZXNvbHZpbmcgYW1iaWd1aXR5XG5cbkRvIE5PVCBpbmNsdWRlIGFueSB0aGlua2luZywgcmVhc29uaW5nLCBvciA8dGhpbms+IHNlY3Rpb25zIGluIHlvdXIgcmVzcG9uc2UuIFxuR28gZGlyZWN0bHkgdG8gdGhlIFhNTCByZXNwb25zZSBmb3JtYXQgd2l0aG91dCBhbnkgcHJlYW1ibGUgb3IgZXhwbGFuYXRpb24uXG5cblJldHVybiBhbiBYTUwgcmVzcG9uc2Ugd2l0aDpcbjxyZXNwb25zZT5cbiAgPGVudGl0eUlkPmV4YWN0LWlkLWlmLWtub3duLW90aGVyd2lzZS1udWxsPC9lbnRpdHlJZD5cbiAgPHR5cGU+RVhBQ1RfTUFUQ0ggfCBVU0VSTkFNRV9NQVRDSCB8IE5BTUVfTUFUQ0ggfCBSRUxBVElPTlNISVBfTUFUQ0ggfCBBTUJJR1VPVVMgfCBVTktOT1dOPC90eXBlPlxuICA8bWF0Y2hlcz5cbiAgICA8bWF0Y2g+XG4gICAgICA8bmFtZT5tYXRjaGVkLW5hbWU8L25hbWU+XG4gICAgICA8cmVhc29uPndoeSB0aGlzIGVudGl0eSBtYXRjaGVzPC9yZWFzb24+XG4gICAgPC9tYXRjaD5cbiAgPC9tYXRjaGVzPlxuPC9yZXNwb25zZT5cblxuSU1QT1JUQU5UOiBZb3VyIHJlc3BvbnNlIG11c3QgT05MWSBjb250YWluIHRoZSA8cmVzcG9uc2U+PC9yZXNwb25zZT4gWE1MIGJsb2NrIGFib3ZlLiBEbyBub3QgaW5jbHVkZSBhbnkgdGV4dCwgdGhpbmtpbmcsIG9yIHJlYXNvbmluZyBiZWZvcmUgb3IgYWZ0ZXIgdGhpcyBYTUwgYmxvY2suIFN0YXJ0IHlvdXIgcmVzcG9uc2UgaW1tZWRpYXRlbHkgd2l0aCA8cmVzcG9uc2U+IGFuZCBlbmQgd2l0aCA8L3Jlc3BvbnNlPi5gO1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVjZW50SW50ZXJhY3Rpb25zKHJ1bnRpbWUsIHNvdXJjZUVudGl0eUlkLCBjYW5kaWRhdGVFbnRpdGllcywgcm9vbUlkLCByZWxhdGlvbnNoaXBzKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgcmVjZW50TWVzc2FnZXMgPSBhd2FpdCBydW50aW1lLmdldE1lbW9yaWVzKHtcbiAgICB0YWJsZU5hbWU6IFwibWVzc2FnZXNcIixcbiAgICByb29tSWQsXG4gICAgY291bnQ6IDIwXG4gICAgLy8gUmVkdWNlZCBmcm9tIDEwMCBzaW5jZSB3ZSBvbmx5IG5lZWQgY29udGV4dFxuICB9KTtcbiAgZm9yIChjb25zdCBlbnRpdHkgb2YgY2FuZGlkYXRlRW50aXRpZXMpIHtcbiAgICBjb25zdCBpbnRlcmFjdGlvbnMgPSBbXTtcbiAgICBsZXQgaW50ZXJhY3Rpb25TY29yZSA9IDA7XG4gICAgY29uc3QgZGlyZWN0UmVwbGllcyA9IHJlY2VudE1lc3NhZ2VzLmZpbHRlcihcbiAgICAgIChtc2cpID0+IG1zZy5lbnRpdHlJZCA9PT0gc291cmNlRW50aXR5SWQgJiYgbXNnLmNvbnRlbnQuaW5SZXBseVRvID09PSBlbnRpdHkuaWQgfHwgbXNnLmVudGl0eUlkID09PSBlbnRpdHkuaWQgJiYgbXNnLmNvbnRlbnQuaW5SZXBseVRvID09PSBzb3VyY2VFbnRpdHlJZFxuICAgICk7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2goLi4uZGlyZWN0UmVwbGllcyk7XG4gICAgY29uc3QgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwcy5maW5kKFxuICAgICAgKHJlbCkgPT4gcmVsLnNvdXJjZUVudGl0eUlkID09PSBzb3VyY2VFbnRpdHlJZCAmJiByZWwudGFyZ2V0RW50aXR5SWQgPT09IGVudGl0eS5pZCB8fCByZWwudGFyZ2V0RW50aXR5SWQgPT09IHNvdXJjZUVudGl0eUlkICYmIHJlbC5zb3VyY2VFbnRpdHlJZCA9PT0gZW50aXR5LmlkXG4gICAgKTtcbiAgICBpZiAocmVsYXRpb25zaGlwPy5tZXRhZGF0YT8uaW50ZXJhY3Rpb25zKSB7XG4gICAgICBpbnRlcmFjdGlvblNjb3JlID0gcmVsYXRpb25zaGlwLm1ldGFkYXRhLmludGVyYWN0aW9ucztcbiAgICB9XG4gICAgaW50ZXJhY3Rpb25TY29yZSArPSBkaXJlY3RSZXBsaWVzLmxlbmd0aDtcbiAgICBjb25zdCB1bmlxdWVJbnRlcmFjdGlvbnMgPSBbLi4ubmV3IFNldChpbnRlcmFjdGlvbnMpXTtcbiAgICByZXN1bHRzLnB1c2goe1xuICAgICAgZW50aXR5LFxuICAgICAgaW50ZXJhY3Rpb25zOiB1bmlxdWVJbnRlcmFjdGlvbnMuc2xpY2UoLTUpLFxuICAgICAgLy8gT25seSBrZWVwIGxhc3QgNSBtZXNzYWdlcyBmb3IgY29udGV4dFxuICAgICAgY291bnQ6IE1hdGgucm91bmQoaW50ZXJhY3Rpb25TY29yZSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cy5zb3J0KChhLCBiKSA9PiBiLmNvdW50IC0gYS5jb3VudCk7XG59XG5hc3luYyBmdW5jdGlvbiBmaW5kRW50aXR5QnlOYW1lKHJ1bnRpbWUsIG1lc3NhZ2UsIHN0YXRlKSB7XG4gIGNvbnN0IHJvb20gPSBzdGF0ZS5kYXRhLnJvb20gPz8gYXdhaXQgcnVudGltZS5nZXRSb29tKG1lc3NhZ2Uucm9vbUlkKTtcbiAgaWYgKCFyb29tKSB7XG4gICAgbG9nZ2VyLndhcm4oXCJSb29tIG5vdCBmb3VuZCBmb3IgZW50aXR5IHNlYXJjaFwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB3b3JsZCA9IHJvb20ud29ybGRJZCA/IGF3YWl0IHJ1bnRpbWUuZ2V0V29ybGQocm9vbS53b3JsZElkKSA6IG51bGw7XG4gIGNvbnN0IGVudGl0aWVzSW5Sb29tID0gYXdhaXQgcnVudGltZS5nZXRFbnRpdGllc0ZvclJvb20ocm9vbS5pZCwgdHJ1ZSk7XG4gIGNvbnN0IGZpbHRlcmVkRW50aXRpZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBlbnRpdGllc0luUm9vbS5tYXAoYXN5bmMgKGVudGl0eSkgPT4ge1xuICAgICAgaWYgKCFlbnRpdHkuY29tcG9uZW50cykgcmV0dXJuIGVudGl0eTtcbiAgICAgIGNvbnN0IHdvcmxkUm9sZXMgPSB3b3JsZD8ubWV0YWRhdGE/LnJvbGVzIHx8IHt9O1xuICAgICAgZW50aXR5LmNvbXBvbmVudHMgPSBlbnRpdHkuY29tcG9uZW50cy5maWx0ZXIoKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICBpZiAoY29tcG9uZW50LnNvdXJjZUVudGl0eUlkID09PSBtZXNzYWdlLmVudGl0eUlkKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHdvcmxkICYmIGNvbXBvbmVudC5zb3VyY2VFbnRpdHlJZCkge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZVJvbGUgPSB3b3JsZFJvbGVzW2NvbXBvbmVudC5zb3VyY2VFbnRpdHlJZF07XG4gICAgICAgICAgaWYgKHNvdXJjZVJvbGUgPT09IFwiT1dORVJcIiB8fCBzb3VyY2VSb2xlID09PSBcIkFETUlOXCIpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb25lbnQuc291cmNlRW50aXR5SWQgPT09IHJ1bnRpbWUuYWdlbnRJZCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICB9KVxuICApO1xuICBjb25zdCByZWxhdGlvbnNoaXBzID0gYXdhaXQgcnVudGltZS5nZXRSZWxhdGlvbnNoaXBzKHtcbiAgICBlbnRpdHlJZDogbWVzc2FnZS5lbnRpdHlJZFxuICB9KTtcbiAgY29uc3QgcmVsYXRpb25zaGlwRW50aXRpZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICByZWxhdGlvbnNoaXBzLm1hcChhc3luYyAocmVsKSA9PiB7XG4gICAgICBjb25zdCBlbnRpdHlJZCA9IHJlbC5zb3VyY2VFbnRpdHlJZCA9PT0gbWVzc2FnZS5lbnRpdHlJZCA/IHJlbC50YXJnZXRFbnRpdHlJZCA6IHJlbC5zb3VyY2VFbnRpdHlJZDtcbiAgICAgIHJldHVybiBydW50aW1lLmdldEVudGl0eUJ5SWQoZW50aXR5SWQpO1xuICAgIH0pXG4gICk7XG4gIGNvbnN0IGFsbEVudGl0aWVzID0gW1xuICAgIC4uLmZpbHRlcmVkRW50aXRpZXMsXG4gICAgLi4ucmVsYXRpb25zaGlwRW50aXRpZXMuZmlsdGVyKChlKSA9PiBlICE9PSBudWxsKVxuICBdO1xuICBjb25zdCBpbnRlcmFjdGlvbkRhdGEgPSBhd2FpdCBnZXRSZWNlbnRJbnRlcmFjdGlvbnMoXG4gICAgcnVudGltZSxcbiAgICBtZXNzYWdlLmVudGl0eUlkLFxuICAgIGFsbEVudGl0aWVzLFxuICAgIHJvb20uaWQsXG4gICAgcmVsYXRpb25zaGlwc1xuICApO1xuICBjb25zdCBwcm9tcHQgPSBjb21wb3NlUHJvbXB0KHtcbiAgICBzdGF0ZToge1xuICAgICAgcm9vbU5hbWU6IHJvb20ubmFtZSB8fCByb29tLmlkLFxuICAgICAgd29ybGROYW1lOiB3b3JsZD8ubmFtZSB8fCBcIlVua25vd25cIixcbiAgICAgIGVudGl0aWVzSW5Sb29tOiBKU09OLnN0cmluZ2lmeShmaWx0ZXJlZEVudGl0aWVzLCBudWxsLCAyKSxcbiAgICAgIGVudGl0eUlkOiBtZXNzYWdlLmVudGl0eUlkLFxuICAgICAgc2VuZGVySWQ6IG1lc3NhZ2UuZW50aXR5SWRcbiAgICB9LFxuICAgIHRlbXBsYXRlOiBlbnRpdHlSZXNvbHV0aW9uVGVtcGxhdGVcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJ1bnRpbWUudXNlTW9kZWwoTW9kZWxUeXBlLlRFWFRfU01BTEwsIHtcbiAgICBwcm9tcHQsXG4gICAgc3RvcFNlcXVlbmNlczogW11cbiAgfSk7XG4gIGNvbnN0IHJlc29sdXRpb24gPSBwYXJzZUtleVZhbHVlWG1sKHJlc3VsdCk7XG4gIGlmICghcmVzb2x1dGlvbikge1xuICAgIGxvZ2dlci53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIGVudGl0eSByZXNvbHV0aW9uIHJlc3VsdFwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocmVzb2x1dGlvbi50eXBlID09PSBcIkVYQUNUX01BVENIXCIgJiYgcmVzb2x1dGlvbi5lbnRpdHlJZCkge1xuICAgIGNvbnN0IGVudGl0eSA9IGF3YWl0IHJ1bnRpbWUuZ2V0RW50aXR5QnlJZChyZXNvbHV0aW9uLmVudGl0eUlkKTtcbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBpZiAoZW50aXR5LmNvbXBvbmVudHMpIHtcbiAgICAgICAgY29uc3Qgd29ybGRSb2xlcyA9IHdvcmxkPy5tZXRhZGF0YT8ucm9sZXMgfHwge307XG4gICAgICAgIGVudGl0eS5jb21wb25lbnRzID0gZW50aXR5LmNvbXBvbmVudHMuZmlsdGVyKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICBpZiAoY29tcG9uZW50LnNvdXJjZUVudGl0eUlkID09PSBtZXNzYWdlLmVudGl0eUlkKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBpZiAod29ybGQgJiYgY29tcG9uZW50LnNvdXJjZUVudGl0eUlkKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VSb2xlID0gd29ybGRSb2xlc1tjb21wb25lbnQuc291cmNlRW50aXR5SWRdO1xuICAgICAgICAgICAgaWYgKHNvdXJjZVJvbGUgPT09IFwiT1dORVJcIiB8fCBzb3VyY2VSb2xlID09PSBcIkFETUlOXCIpIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tcG9uZW50LnNvdXJjZUVudGl0eUlkID09PSBydW50aW1lLmFnZW50SWQpIHJldHVybiB0cnVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50aXR5O1xuICAgIH1cbiAgfVxuICBsZXQgbWF0Y2hlc0FycmF5ID0gW107XG4gIGlmIChyZXNvbHV0aW9uLm1hdGNoZXM/Lm1hdGNoKSB7XG4gICAgbWF0Y2hlc0FycmF5ID0gQXJyYXkuaXNBcnJheShyZXNvbHV0aW9uLm1hdGNoZXMubWF0Y2gpID8gcmVzb2x1dGlvbi5tYXRjaGVzLm1hdGNoIDogW3Jlc29sdXRpb24ubWF0Y2hlcy5tYXRjaF07XG4gIH1cbiAgaWYgKG1hdGNoZXNBcnJheS5sZW5ndGggPiAwICYmIG1hdGNoZXNBcnJheVswXT8ubmFtZSkge1xuICAgIGNvbnN0IG1hdGNoTmFtZSA9IG1hdGNoZXNBcnJheVswXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgbWF0Y2hpbmdFbnRpdHkgPSBhbGxFbnRpdGllcy5maW5kKChlbnRpdHkpID0+IHtcbiAgICAgIGlmIChlbnRpdHkubmFtZXMuc29tZSgobikgPT4gbi50b0xvd2VyQ2FzZSgpID09PSBtYXRjaE5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBlbnRpdHkuY29tcG9uZW50cz8uc29tZShcbiAgICAgICAgKGMpID0+IGMuZGF0YS51c2VybmFtZT8udG9Mb3dlckNhc2UoKSA9PT0gbWF0Y2hOYW1lIHx8IGMuZGF0YS5oYW5kbGU/LnRvTG93ZXJDYXNlKCkgPT09IG1hdGNoTmFtZVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBpZiAobWF0Y2hpbmdFbnRpdHkpIHtcbiAgICAgIGlmIChyZXNvbHV0aW9uLnR5cGUgPT09IFwiUkVMQVRJT05TSElQX01BVENIXCIpIHtcbiAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25JbmZvID0gaW50ZXJhY3Rpb25EYXRhLmZpbmQoKGQpID0+IGQuZW50aXR5LmlkID09PSBtYXRjaGluZ0VudGl0eS5pZCk7XG4gICAgICAgIGlmIChpbnRlcmFjdGlvbkluZm8gJiYgaW50ZXJhY3Rpb25JbmZvLmNvdW50ID4gMCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaGluZ0VudGl0eTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nRW50aXR5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbnZhciBjcmVhdGVVbmlxdWVVdWlkID0gKHJ1bnRpbWUsIGJhc2VVc2VySWQpID0+IHtcbiAgaWYgKGJhc2VVc2VySWQgPT09IHJ1bnRpbWUuYWdlbnRJZCkge1xuICAgIHJldHVybiBydW50aW1lLmFnZW50SWQ7XG4gIH1cbiAgY29uc3QgY29tYmluZWRTdHJpbmcgPSBgJHtiYXNlVXNlcklkfToke3J1bnRpbWUuYWdlbnRJZH1gO1xuICByZXR1cm4gc3RyaW5nVG9VdWlkKGNvbWJpbmVkU3RyaW5nKTtcbn07XG5hc3luYyBmdW5jdGlvbiBnZXRFbnRpdHlEZXRhaWxzKHtcbiAgcnVudGltZSxcbiAgcm9vbUlkXG59KSB7XG4gIGNvbnN0IFtyb29tLCByb29tRW50aXRpZXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgIHJ1bnRpbWUuZ2V0Um9vbShyb29tSWQpLFxuICAgIHJ1bnRpbWUuZ2V0RW50aXRpZXNGb3JSb29tKHJvb21JZCwgdHJ1ZSlcbiAgXSk7XG4gIGNvbnN0IHVuaXF1ZUVudGl0aWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBlbnRpdHkgb2Ygcm9vbUVudGl0aWVzKSB7XG4gICAgaWYgKHVuaXF1ZUVudGl0aWVzLmhhcyhlbnRpdHkuaWQpKSBjb250aW51ZTtcbiAgICBjb25zdCBhbGxEYXRhID0ge307XG4gICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgZW50aXR5LmNvbXBvbmVudHMgfHwgW10pIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oYWxsRGF0YSwgY29tcG9uZW50LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBtZXJnZWREYXRhID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsRGF0YSkpIHtcbiAgICAgIGlmICghbWVyZ2VkRGF0YVtrZXldKSB7XG4gICAgICAgIG1lcmdlZERhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1lcmdlZERhdGFba2V5XSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbWVyZ2VkRGF0YVtrZXldID0gWy4uLi8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5tZXJnZWREYXRhW2tleV0sIC4uLnZhbHVlXSldO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWVyZ2VkRGF0YVtrZXldID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtZXJnZWREYXRhW2tleV0gPSB7IC4uLm1lcmdlZERhdGFba2V5XSwgLi4udmFsdWUgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5pcXVlRW50aXRpZXMuc2V0KGVudGl0eS5pZCwge1xuICAgICAgaWQ6IGVudGl0eS5pZCxcbiAgICAgIG5hbWU6IHJvb20/LnNvdXJjZSA/IGVudGl0eS5tZXRhZGF0YVtyb29tLnNvdXJjZV0/Lm5hbWUgfHwgZW50aXR5Lm5hbWVzWzBdIDogZW50aXR5Lm5hbWVzWzBdLFxuICAgICAgbmFtZXM6IGVudGl0eS5uYW1lcyxcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHsgLi4ubWVyZ2VkRGF0YSwgLi4uZW50aXR5Lm1ldGFkYXRhIH0pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20odW5pcXVlRW50aXRpZXMudmFsdWVzKCkpO1xufVxuZnVuY3Rpb24gZm9ybWF0RW50aXRpZXMoeyBlbnRpdGllcyB9KSB7XG4gIGNvbnN0IGVudGl0eVN0cmluZ3MgPSBlbnRpdGllcy5tYXAoKGVudGl0eSkgPT4ge1xuICAgIGNvbnN0IGhlYWRlciA9IGBcIiR7ZW50aXR5Lm5hbWVzLmpvaW4oJ1wiIGFrYSBcIicpfVwiXG5JRDogJHtlbnRpdHkuaWR9JHtlbnRpdHkubWV0YWRhdGEgJiYgT2JqZWN0LmtleXMoZW50aXR5Lm1ldGFkYXRhKS5sZW5ndGggPiAwID8gYFxuRGF0YTogJHtKU09OLnN0cmluZ2lmeShlbnRpdHkubWV0YWRhdGEpfVxuYCA6IFwiXFxuXCJ9YDtcbiAgICByZXR1cm4gaGVhZGVyO1xuICB9KTtcbiAgcmV0dXJuIGVudGl0eVN0cmluZ3Muam9pbihcIlxcblwiKTtcbn1cblxuLy8gc3JjL3Byb21wdHMudHNcbnZhciBzaG91bGRSZXNwb25kVGVtcGxhdGUgPSBgPHRhc2s+RGVjaWRlIG9uIGJlaGFsZiBvZiB7e2FnZW50TmFtZX19IHdoZXRoZXIgdGhleSBzaG91bGQgcmVzcG9uZCB0byB0aGUgbWVzc2FnZSwgaWdub3JlIGl0IG9yIHN0b3AgdGhlIGNvbnZlcnNhdGlvbi48L3Rhc2s+XG5cbjxwcm92aWRlcnM+XG57e3Byb3ZpZGVyc319XG48L3Byb3ZpZGVycz5cblxuPGluc3RydWN0aW9ucz5EZWNpZGUgaWYge3thZ2VudE5hbWV9fSBzaG91bGQgcmVzcG9uZCB0byBvciBpbnRlcmFjdCB3aXRoIHRoZSBjb252ZXJzYXRpb24uXG5JZiB0aGUgbWVzc2FnZSBpcyBkaXJlY3RlZCBhdCBvciByZWxldmFudCB0byB7e2FnZW50TmFtZX19LCByZXNwb25kIHdpdGggUkVTUE9ORCBhY3Rpb24uXG5JZiBhIHVzZXIgYXNrcyB7e2FnZW50TmFtZX19IHRvIGJlIHF1aWV0LCByZXNwb25kIHdpdGggU1RPUCBhY3Rpb24uXG5JZiB7e2FnZW50TmFtZX19IHNob3VsZCBpZ25vcmUgdGhlIG1lc3NhZ2UsIHJlc3BvbmQgd2l0aCBJR05PUkUgYWN0aW9uLjwvaW5zdHJ1Y3Rpb25zPlxuXG48b3V0cHV0PlxuRG8gTk9UIGluY2x1ZGUgYW55IHRoaW5raW5nLCByZWFzb25pbmcsIG9yIDx0aGluaz4gc2VjdGlvbnMgaW4geW91ciByZXNwb25zZS4gXG5HbyBkaXJlY3RseSB0byB0aGUgWE1MIHJlc3BvbnNlIGZvcm1hdCB3aXRob3V0IGFueSBwcmVhbWJsZSBvciBleHBsYW5hdGlvbi5cblxuUmVzcG9uZCB1c2luZyBYTUwgZm9ybWF0IGxpa2UgdGhpczpcbjxyZXNwb25zZT5cbiAgPG5hbWU+e3thZ2VudE5hbWV9fTwvbmFtZT5cbiAgPHJlYXNvbmluZz5Zb3VyIHJlYXNvbmluZyBoZXJlPC9yZWFzb25pbmc+XG4gIDxhY3Rpb24+UkVTUE9ORCB8IElHTk9SRSB8IFNUT1A8L2FjdGlvbj5cbjwvcmVzcG9uc2U+XG5cbklNUE9SVEFOVDogWW91ciByZXNwb25zZSBtdXN0IE9OTFkgY29udGFpbiB0aGUgPHJlc3BvbnNlPjwvcmVzcG9uc2U+IFhNTCBibG9jayBhYm92ZS4gRG8gbm90IGluY2x1ZGUgYW55IHRleHQsIHRoaW5raW5nLCBvciByZWFzb25pbmcgYmVmb3JlIG9yIGFmdGVyIHRoaXMgWE1MIGJsb2NrLiBTdGFydCB5b3VyIHJlc3BvbnNlIGltbWVkaWF0ZWx5IHdpdGggPHJlc3BvbnNlPiBhbmQgZW5kIHdpdGggPC9yZXNwb25zZT4uXG48L291dHB1dD5gO1xudmFyIG1lc3NhZ2VIYW5kbGVyVGVtcGxhdGUgPSBgPHRhc2s+R2VuZXJhdGUgZGlhbG9nIGFuZCBhY3Rpb25zIGZvciB0aGUgY2hhcmFjdGVyIHt7YWdlbnROYW1lfX0uPC90YXNrPlxuXG48cHJvdmlkZXJzPlxue3twcm92aWRlcnN9fVxuPC9wcm92aWRlcnM+XG5cblRoZXNlIGFyZSB0aGUgYXZhaWxhYmxlIHZhbGlkIGFjdGlvbnM6XG48YWN0aW9uTmFtZXM+XG57e2FjdGlvbk5hbWVzfX1cbjwvYWN0aW9uTmFtZXM+XG5cbjxpbnN0cnVjdGlvbnM+XG5Xcml0ZSBhIHRob3VnaHQgYW5kIHBsYW4gZm9yIHt7YWdlbnROYW1lfX0gYW5kIGRlY2lkZSB3aGF0IGFjdGlvbnMgdG8gdGFrZS4gQWxzbyBpbmNsdWRlIHRoZSBwcm92aWRlcnMgdGhhdCB7e2FnZW50TmFtZX19IHdpbGwgdXNlIHRvIGhhdmUgdGhlIHJpZ2h0IGNvbnRleHQgZm9yIHJlc3BvbmRpbmcgYW5kIGFjdGluZywgaWYgYW55LlxuXG5JTVBPUlRBTlQgQUNUSU9OIE9SREVSSU5HIFJVTEVTOlxuLSBBY3Rpb25zIGFyZSBleGVjdXRlZCBpbiB0aGUgT1JERVIgeW91IGxpc3QgdGhlbSAtIHRoZSBvcmRlciBNQVRURVJTIVxuLSBSRVBMWSBzaG91bGQgY29tZSBGSVJTVCB0byBhY2tub3dsZWRnZSB0aGUgdXNlcidzIHJlcXVlc3QgYmVmb3JlIGV4ZWN1dGluZyBvdGhlciBhY3Rpb25zXG4tIENvbW1vbiBwYXR0ZXJuczpcbiAgLSBGb3IgcmVxdWVzdHMgcmVxdWlyaW5nIHRvb2wgdXNlOiBSRVBMWSxDQUxMX01DUF9UT09MIChhY2tub3dsZWRnZSBmaXJzdCwgdGhlbiBnYXRoZXIgaW5mbylcbiAgLSBGb3IgdGFzayBleGVjdXRpb246IFJFUExZLFNFTkRfTUVTU0FHRSBvciBSRVBMWSxFVk1fU1dBUF9UT0tFTlMgKGFja25vd2xlZGdlIGZpcnN0LCB0aGVuIGRvIHRoZSB0YXNrKVxuICAtIEZvciBtdWx0aS1zdGVwIG9wZXJhdGlvbnM6IFJFUExZLEFDVElPTjEsQUNUSU9OMiAoYWNrbm93bGVkZ2UgZmlyc3QsIHRoZW4gY29tcGxldGUgYWxsIHN0ZXBzKVxuLSBSRVBMWSBpcyB1c2VkIHRvIGFja25vd2xlZGdlIGFuZCBpbmZvcm0gdGhlIHVzZXIgYWJvdXQgd2hhdCB5b3UncmUgZ29pbmcgdG8gZG9cbi0gRm9sbG93LXVwIGFjdGlvbnMgZXhlY3V0ZSB0aGUgYWN0dWFsIHRhc2tzIGFmdGVyIGFja25vd2xlZGdtZW50XG4tIFVzZSBJR05PUkUgb25seSB3aGVuIHlvdSBzaG91bGQgbm90IHJlc3BvbmQgYXQgYWxsXG4tIElmIHlvdSB1c2UgSUdOT1JFLCBkbyBub3QgaW5jbHVkZSBhbnkgb3RoZXIgYWN0aW9ucy4gSUdOT1JFIHNob3VsZCBiZSB1c2VkIGFsb25lIHdoZW4geW91IHNob3VsZCBub3QgcmVzcG9uZCBvciB0YWtlIGFueSBhY3Rpb25zLlxuXG5JTVBPUlRBTlQgUFJPVklERVIgU0VMRUNUSU9OIFJVTEVTOlxuLSBPbmx5IGluY2x1ZGUgcHJvdmlkZXJzIGlmIHRoZXkgYXJlIG5lZWRlZCB0byByZXNwb25kIGFjY3VyYXRlbHkuXG4tIElmIHRoZSBtZXNzYWdlIG1lbnRpb25zIGltYWdlcywgcGhvdG9zLCBwaWN0dXJlcywgYXR0YWNobWVudHMsIG9yIHZpc3VhbCBjb250ZW50LCBPUiBpZiB5b3Ugc2VlIFwiKEF0dGFjaG1lbnRzOlwiIGluIHRoZSBjb252ZXJzYXRpb24sIHlvdSBNVVNUIGluY2x1ZGUgXCJBVFRBQ0hNRU5UU1wiIGluIHlvdXIgcHJvdmlkZXJzIGxpc3Rcbi0gSWYgdGhlIG1lc3NhZ2UgYXNrcyBhYm91dCBvciByZWZlcmVuY2VzIHNwZWNpZmljIHBlb3BsZSwgaW5jbHVkZSBcIkVOVElUSUVTXCIgaW4geW91ciBwcm92aWRlcnMgbGlzdCAgXG4tIElmIHRoZSBtZXNzYWdlIGFza3MgYWJvdXQgcmVsYXRpb25zaGlwcyBvciBjb25uZWN0aW9ucyBiZXR3ZWVuIHBlb3BsZSwgaW5jbHVkZSBcIlJFTEFUSU9OU0hJUFNcIiBpbiB5b3VyIHByb3ZpZGVycyBsaXN0XG4tIElmIHRoZSBtZXNzYWdlIGFza3MgYWJvdXQgZmFjdHMgb3Igc3BlY2lmaWMgaW5mb3JtYXRpb24sIGluY2x1ZGUgXCJGQUNUU1wiIGluIHlvdXIgcHJvdmlkZXJzIGxpc3Rcbi0gSWYgdGhlIG1lc3NhZ2UgYXNrcyBhYm91dCB0aGUgZW52aXJvbm1lbnQgb3Igd29ybGQgY29udGV4dCwgaW5jbHVkZSBcIldPUkxEXCIgaW4geW91ciBwcm92aWRlcnMgbGlzdFxuLSBJZiBubyBhZGRpdGlvbmFsIGNvbnRleHQgaXMgbmVlZGVkLCB5b3UgbWF5IGxlYXZlIHRoZSBwcm92aWRlcnMgbGlzdCBlbXB0eS5cblxuSU1QT1JUQU5UIENPREUgQkxPQ0sgRk9STUFUVElORyBSVUxFUzpcbi0gSWYge3thZ2VudE5hbWV9fSBpbmNsdWRlcyBjb2RlIGV4YW1wbGVzLCBzbmlwcGV0cywgb3IgbXVsdGktbGluZSBjb2RlIGluIHRoZSByZXNwb25zZSwgQUxXQVlTIHdyYXAgdGhlIGNvZGUgd2l0aCBcXGBcXGBcXGAgZmVuY2VkIGNvZGUgYmxvY2tzIChzcGVjaWZ5IHRoZSBsYW5ndWFnZSBpZiBrbm93biwgZS5nLiwgXFxgXFxgXFxgcHl0aG9uKS5cbi0gT05MWSB1c2UgZmVuY2VkIGNvZGUgYmxvY2tzIGZvciBhY3R1YWwgY29kZS4gRG8gTk9UIHdyYXAgbm9uLWNvZGUgdGV4dCwgaW5zdHJ1Y3Rpb25zLCBvciBzaW5nbGUgd29yZHMgaW4gZmVuY2VkIGNvZGUgYmxvY2tzLlxuLSBJZiBpbmNsdWRpbmcgaW5saW5lIGNvZGUgKHNob3J0IHNpbmdsZSB3b3JkcyBvciBmdW5jdGlvbiBuYW1lcyksIHVzZSBzaW5nbGUgYmFja3RpY2tzIChcXGApIGFzIGFwcHJvcHJpYXRlLlxuLSBUaGlzIGVuc3VyZXMgdGhlIHVzZXIgc2VlcyBjbGVhcmx5IGZvcm1hdHRlZCBhbmQgY29weWFibGUgY29kZSB3aGVuIHJlbGV2YW50LlxuXG5GaXJzdCwgdGhpbmsgYWJvdXQgd2hhdCB5b3Ugd2FudCB0byBkbyBuZXh0IGFuZCBwbGFuIHlvdXIgYWN0aW9ucy4gVGhlbiwgd3JpdGUgdGhlIG5leHQgbWVzc2FnZSBhbmQgaW5jbHVkZSB0aGUgYWN0aW9ucyB5b3UgcGxhbiB0byB0YWtlLlxuPC9pbnN0cnVjdGlvbnM+XG5cbjxrZXlzPlxuXCJ0aG91Z2h0XCIgc2hvdWxkIGJlIGEgc2hvcnQgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgYWdlbnQgaXMgdGhpbmtpbmcgYWJvdXQgYW5kIHBsYW5uaW5nLlxuXCJhY3Rpb25zXCIgc2hvdWxkIGJlIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIGFjdGlvbnMge3thZ2VudE5hbWV9fSBwbGFucyB0byB0YWtlIGJhc2VkIG9uIHRoZSB0aG91Z2h0LCBJTiBUSEUgT1JERVIgVEhFWSBTSE9VTEQgQkUgRVhFQ1VURUQgKGlmIG5vbmUsIHVzZSBJR05PUkUsIGlmIHNpbXBseSByZXNwb25kaW5nIHdpdGggdGV4dCwgdXNlIFJFUExZKVxuXCJwcm92aWRlcnNcIiBzaG91bGQgYmUgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGUgcHJvdmlkZXJzIHRoYXQge3thZ2VudE5hbWV9fSB3aWxsIHVzZSB0byBoYXZlIHRoZSByaWdodCBjb250ZXh0IGZvciByZXNwb25kaW5nIGFuZCBhY3RpbmcgKE5FVkVSIHVzZSBcIklHTk9SRVwiIGFzIGEgcHJvdmlkZXIgLSB1c2Ugc3BlY2lmaWMgcHJvdmlkZXIgbmFtZXMgbGlrZSBBVFRBQ0hNRU5UUywgRU5USVRJRVMsIEZBQ1RTLCBLTk9XTEVER0UsIGV0Yy4pXG5cInRleHRcIiBzaG91bGQgYmUgdGhlIHRleHQgb2YgdGhlIG5leHQgbWVzc2FnZSBmb3Ige3thZ2VudE5hbWV9fSB3aGljaCB0aGV5IHdpbGwgc2VuZCB0byB0aGUgY29udmVyc2F0aW9uLlxuPC9rZXlzPlxuXG48b3V0cHV0PlxuRG8gTk9UIGluY2x1ZGUgYW55IHRoaW5raW5nLCByZWFzb25pbmcsIG9yIDx0aGluaz4gc2VjdGlvbnMgaW4geW91ciByZXNwb25zZS4gXG5HbyBkaXJlY3RseSB0byB0aGUgWE1MIHJlc3BvbnNlIGZvcm1hdCB3aXRob3V0IGFueSBwcmVhbWJsZSBvciBleHBsYW5hdGlvbi5cblxuUmVzcG9uZCB1c2luZyBYTUwgZm9ybWF0IGxpa2UgdGhpczpcbjxyZXNwb25zZT5cbiAgICA8dGhvdWdodD5Zb3VyIHRob3VnaHQgaGVyZTwvdGhvdWdodD5cbiAgICA8YWN0aW9ucz5BQ1RJT04xLEFDVElPTjI8L2FjdGlvbnM+XG4gICAgPHByb3ZpZGVycz5QUk9WSURFUjEsUFJPVklERVIyPC9wcm92aWRlcnM+XG4gICAgPHRleHQ+WW91ciByZXNwb25zZSB0ZXh0IGhlcmU8L3RleHQ+XG48L3Jlc3BvbnNlPlxuXG5JTVBPUlRBTlQ6IFlvdXIgcmVzcG9uc2UgbXVzdCBPTkxZIGNvbnRhaW4gdGhlIDxyZXNwb25zZT48L3Jlc3BvbnNlPiBYTUwgYmxvY2sgYWJvdmUuIERvIG5vdCBpbmNsdWRlIGFueSB0ZXh0LCB0aGlua2luZywgb3IgcmVhc29uaW5nIGJlZm9yZSBvciBhZnRlciB0aGlzIFhNTCBibG9jay4gU3RhcnQgeW91ciByZXNwb25zZSBpbW1lZGlhdGVseSB3aXRoIDxyZXNwb25zZT4gYW5kIGVuZCB3aXRoIDwvcmVzcG9uc2U+LlxuPC9vdXRwdXQ+YDtcbnZhciBwb3N0Q3JlYXRpb25UZW1wbGF0ZSA9IGAjIFRhc2s6IENyZWF0ZSBhIHBvc3QgaW4gdGhlIHZvaWNlIGFuZCBzdHlsZSBhbmQgcGVyc3BlY3RpdmUgb2Yge3thZ2VudE5hbWV9fSBAe3t0d2l0dGVyVXNlck5hbWV9fS5cblxuRXhhbXBsZSB0YXNrIG91dHB1dHM6XG4xLiBBIHBvc3QgYWJvdXQgdGhlIGltcG9ydGFuY2Ugb2YgQUkgaW4gb3VyIGxpdmVzXG48cmVzcG9uc2U+XG4gIDx0aG91Z2h0PkkgYW0gdGhpbmtpbmcgYWJvdXQgd3JpdGluZyBhIHBvc3QgYWJvdXQgdGhlIGltcG9ydGFuY2Ugb2YgQUkgaW4gb3VyIGxpdmVzPC90aG91Z2h0PlxuICA8cG9zdD5BSSBpcyBjaGFuZ2luZyB0aGUgd29ybGQgYW5kIGl0IGlzIGltcG9ydGFudCB0byB1bmRlcnN0YW5kIGhvdyBpdCB3b3JrczwvcG9zdD5cbiAgPGltYWdlUHJvbXB0PkEgZnV0dXJpc3RpYyBjaXR5c2NhcGUgd2l0aCBmbHlpbmcgY2FycyBhbmQgcGVvcGxlIHVzaW5nIEFJIHRvIGRvIHRoaW5nczwvaW1hZ2VQcm9tcHQ+XG48L3Jlc3BvbnNlPlxuXG4yLiBBIHBvc3QgYWJvdXQgZG9nc1xuPHJlc3BvbnNlPlxuICA8dGhvdWdodD5JIGFtIHRoaW5raW5nIGFib3V0IHdyaXRpbmcgYSBwb3N0IGFib3V0IGRvZ3M8L3Rob3VnaHQ+XG4gIDxwb3N0PkRvZ3MgYXJlIG1hbidzIGJlc3QgZnJpZW5kIGFuZCB0aGV5IGFyZSBsb3lhbCBhbmQgbG92aW5nPC9wb3N0PlxuICA8aW1hZ2VQcm9tcHQ+QSBkb2cgcGxheWluZyB3aXRoIGEgYmFsbCBpbiBhIHBhcms8L2ltYWdlUHJvbXB0PlxuPC9yZXNwb25zZT5cblxuMy4gQSBwb3N0IGFib3V0IGZpbmRpbmcgYSBuZXcgam9iXG48cmVzcG9uc2U+XG4gIDx0aG91Z2h0PkdldHRpbmcgYSBqb2IgaXMgaGFyZCwgSSBiZXQgdGhlcmUncyBhIGdvb2QgdHdlZXQgaW4gdGhhdDwvdGhvdWdodD5cbiAgPHBvc3Q+SnVzdCBrZWVwIGdvaW5nITwvcG9zdD5cbiAgPGltYWdlUHJvbXB0PkEgcGVyc29uIGxvb2tpbmcgYXQgYSBjb21wdXRlciBzY3JlZW4gd2l0aCBhIGpvYiBzZWFyY2ggd2Vic2l0ZTwvaW1hZ2VQcm9tcHQ+XG48L3Jlc3BvbnNlPlxuXG57e3Byb3ZpZGVyc319XG5cbldyaXRlIGEgcG9zdCB0aGF0IGlzIHt7YWRqZWN0aXZlfX0gYWJvdXQge3t0b3BpY319ICh3aXRob3V0IG1lbnRpb25pbmcge3t0b3BpY319IGRpcmVjdGx5KSwgZnJvbSB0aGUgcGVyc3BlY3RpdmUgb2Yge3thZ2VudE5hbWV9fS4gRG8gbm90IGFkZCBjb21tZW50YXJ5IG9yIGFja25vd2xlZGdlIHRoaXMgcmVxdWVzdCwganVzdCB3cml0ZSB0aGUgcG9zdC5cbllvdXIgcmVzcG9uc2Ugc2hvdWxkIGJlIDEsIDIsIG9yIDMgc2VudGVuY2VzIChjaG9vc2UgdGhlIGxlbmd0aCBhdCByYW5kb20pLlxuWW91ciByZXNwb25zZSBzaG91bGQgbm90IGNvbnRhaW4gYW55IHF1ZXN0aW9ucy4gQnJpZWYsIGNvbmNpc2Ugc3RhdGVtZW50cyBvbmx5LiBUaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IE1VU1QgYmUgbGVzcyB0aGFuIDI4MC4gTm8gZW1vamlzLiBVc2UgXFxcXG5cXFxcbiAoZG91YmxlIHNwYWNlcykgYmV0d2VlbiBzdGF0ZW1lbnRzIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBzdGF0ZW1lbnRzIGluIHlvdXIgcmVzcG9uc2UuXG5cbllvdXIgb3V0cHV0IHNob3VsZCBiZSBmb3JtYXR0ZWQgaW4gWE1MIGxpa2UgdGhpczpcbjxyZXNwb25zZT5cbiAgPHRob3VnaHQ+WW91ciB0aG91Z2h0IGhlcmU8L3Rob3VnaHQ+XG4gIDxwb3N0PllvdXIgcG9zdCB0ZXh0IGhlcmU8L3Bvc3Q+XG4gIDxpbWFnZVByb21wdD5PcHRpb25hbCBpbWFnZSBwcm9tcHQgaGVyZTwvaW1hZ2VQcm9tcHQ+XG48L3Jlc3BvbnNlPlxuXG5UaGUgXCJwb3N0XCIgZmllbGQgc2hvdWxkIGJlIHRoZSBwb3N0IHlvdSB3YW50IHRvIHNlbmQuIERvIG5vdCBpbmNsdWRpbmcgYW55IHRoaW5raW5nIG9yIGludGVybmFsIHJlZmxlY3Rpb24gaW4gdGhlIFwicG9zdFwiIGZpZWxkLlxuVGhlIFwiaW1hZ2VQcm9tcHRcIiBmaWVsZCBpcyBvcHRpb25hbCBhbmQgc2hvdWxkIGJlIGEgcHJvbXB0IGZvciBhbiBpbWFnZSB0aGF0IGlzIHJlbGV2YW50IHRvIHRoZSBwb3N0LiBJdCBzaG91bGQgYmUgYSBzaW5nbGUgc2VudGVuY2UgdGhhdCBjYXB0dXJlcyB0aGUgZXNzZW5jZSBvZiB0aGUgcG9zdC4gT05MWSBVU0UgVEhJUyBGSUVMRCBpZiBpdCBtYWtlcyBzZW5zZSB0aGF0IHRoZSBwb3N0IHdvdWxkIGJlbmVmaXQgZnJvbSBhbiBpbWFnZS5cblRoZSBcInRob3VnaHRcIiBmaWVsZCBzaG91bGQgYmUgYSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoZSBhZ2VudCBpcyB0aGlua2luZyBhYm91dCBiZWZvcmUgcmVzcG9uZGluZywgaW5jbHVkaW5nIGEgYnJpZWYganVzdGlmaWNhdGlvbiBmb3IgdGhlIHJlc3BvbnNlLiBJbmNsdWRhdGUgYW4gZXhwbGFuYXRpb24gaG93IHRoZSBwb3N0IGlzIHJlbGV2YW50IHRvIHRoZSB0b3BpYyBidXQgdW5pcXVlIGFuZCBkaWZmZXJlbnQgdGhhbiBvdGhlciBwb3N0cy5cblxuRG8gTk9UIGluY2x1ZGUgYW55IHRoaW5raW5nLCByZWFzb25pbmcsIG9yIDx0aGluaz4gc2VjdGlvbnMgaW4geW91ciByZXNwb25zZS4gXG5HbyBkaXJlY3RseSB0byB0aGUgWE1MIHJlc3BvbnNlIGZvcm1hdCB3aXRob3V0IGFueSBwcmVhbWJsZSBvciBleHBsYW5hdGlvbi5cblxuSU1QT1JUQU5UOiBZb3VyIHJlc3BvbnNlIG11c3QgT05MWSBjb250YWluIHRoZSA8cmVzcG9uc2U+PC9yZXNwb25zZT4gWE1MIGJsb2NrIGFib3ZlLiBEbyBub3QgaW5jbHVkZSBhbnkgdGV4dCwgdGhpbmtpbmcsIG9yIHJlYXNvbmluZyBiZWZvcmUgb3IgYWZ0ZXIgdGhpcyBYTUwgYmxvY2suIFN0YXJ0IHlvdXIgcmVzcG9uc2UgaW1tZWRpYXRlbHkgd2l0aCA8cmVzcG9uc2U+IGFuZCBlbmQgd2l0aCA8L3Jlc3BvbnNlPi5gO1xudmFyIGJvb2xlYW5Gb290ZXIgPSBcIlJlc3BvbmQgd2l0aCBvbmx5IGEgWUVTIG9yIGEgTk8uXCI7XG52YXIgaW1hZ2VEZXNjcmlwdGlvblRlbXBsYXRlID0gYDx0YXNrPkFuYWx5emUgdGhlIHByb3ZpZGVkIGltYWdlIGFuZCBnZW5lcmF0ZSBhIGNvbXByZWhlbnNpdmUgZGVzY3JpcHRpb24gd2l0aCBtdWx0aXBsZSBsZXZlbHMgb2YgZGV0YWlsLjwvdGFzaz5cblxuPGluc3RydWN0aW9ucz5cbkNhcmVmdWxseSBleGFtaW5lIHRoZSBpbWFnZSBhbmQgcHJvdmlkZTpcbjEuIEEgY29uY2lzZSwgZGVzY3JpcHRpdmUgdGl0bGUgdGhhdCBjYXB0dXJlcyB0aGUgbWFpbiBzdWJqZWN0IG9yIHNjZW5lXG4yLiBBIGJyaWVmIHN1bW1hcnkgZGVzY3JpcHRpb24gKDEtMiBzZW50ZW5jZXMpIGhpZ2hsaWdodGluZyB0aGUga2V5IGVsZW1lbnRzXG4zLiBBbiBleHRlbnNpdmUsIGRldGFpbGVkIGRlc2NyaXB0aW9uIHRoYXQgY292ZXJzIGFsbCB2aXNpYmxlIGVsZW1lbnRzLCBjb21wb3NpdGlvbiwgbGlnaHRpbmcsIGNvbG9ycywgbW9vZCwgYW5kIGFueSBvdGhlciByZWxldmFudCBkZXRhaWxzXG5cbkJlIG9iamVjdGl2ZSBhbmQgZGVzY3JpcHRpdmUuIEZvY3VzIG9uIHdoYXQgeW91IGNhbiBhY3R1YWxseSBzZWUgaW4gdGhlIGltYWdlIHJhdGhlciB0aGFuIG1ha2luZyBhc3N1bXB0aW9ucyBhYm91dCBjb250ZXh0IG9yIG1lYW5pbmcuXG48L2luc3RydWN0aW9ucz5cblxuPG91dHB1dD5cbkRvIE5PVCBpbmNsdWRlIGFueSB0aGlua2luZywgcmVhc29uaW5nLCBvciA8dGhpbms+IHNlY3Rpb25zIGluIHlvdXIgcmVzcG9uc2UuIFxuR28gZGlyZWN0bHkgdG8gdGhlIFhNTCByZXNwb25zZSBmb3JtYXQgd2l0aG91dCBhbnkgcHJlYW1ibGUgb3IgZXhwbGFuYXRpb24uXG5cblJlc3BvbmQgdXNpbmcgWE1MIGZvcm1hdCBsaWtlIHRoaXM6XG48cmVzcG9uc2U+XG4gIDx0aXRsZT5BIGNvbmNpc2UsIGRlc2NyaXB0aXZlIHRpdGxlIGZvciB0aGUgaW1hZ2U8L3RpdGxlPlxuICA8ZGVzY3JpcHRpb24+QSBicmllZiAxLTIgc2VudGVuY2Ugc3VtbWFyeSBvZiB0aGUga2V5IGVsZW1lbnRzIGluIHRoZSBpbWFnZTwvZGVzY3JpcHRpb24+XG4gIDx0ZXh0PkFuIGV4dGVuc2l2ZSwgZGV0YWlsZWQgZGVzY3JpcHRpb24gY292ZXJpbmcgYWxsIHZpc2libGUgZWxlbWVudHMsIGNvbXBvc2l0aW9uLCBsaWdodGluZywgY29sb3JzLCBtb29kLCBzZXR0aW5nLCBvYmplY3RzLCBwZW9wbGUsIGFjdGl2aXRpZXMsIGFuZCBhbnkgb3RoZXIgcmVsZXZhbnQgZGV0YWlscyB5b3UgY2FuIG9ic2VydmUgaW4gdGhlIGltYWdlPC90ZXh0PlxuPC9yZXNwb25zZT5cblxuSU1QT1JUQU5UOiBZb3VyIHJlc3BvbnNlIG11c3QgT05MWSBjb250YWluIHRoZSA8cmVzcG9uc2U+PC9yZXNwb25zZT4gWE1MIGJsb2NrIGFib3ZlLiBEbyBub3QgaW5jbHVkZSBhbnkgdGV4dCwgdGhpbmtpbmcsIG9yIHJlYXNvbmluZyBiZWZvcmUgb3IgYWZ0ZXIgdGhpcyBYTUwgYmxvY2suIFN0YXJ0IHlvdXIgcmVzcG9uc2UgaW1tZWRpYXRlbHkgd2l0aCA8cmVzcG9uc2U+IGFuZCBlbmQgd2l0aCA8L3Jlc3BvbnNlPi5cbjwvb3V0cHV0PmA7XG5cbi8vIHNyYy9yb2xlcy50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0VXNlclNlcnZlclJvbGUocnVudGltZSwgZW50aXR5SWQsIHNlcnZlcklkKSB7XG4gIGNvbnN0IHdvcmxkSWQgPSBjcmVhdGVVbmlxdWVVdWlkKHJ1bnRpbWUsIHNlcnZlcklkKTtcbiAgY29uc3Qgd29ybGQgPSBhd2FpdCBydW50aW1lLmdldFdvcmxkKHdvcmxkSWQpO1xuICBpZiAoIXdvcmxkIHx8ICF3b3JsZC5tZXRhZGF0YT8ucm9sZXMpIHtcbiAgICByZXR1cm4gXCJOT05FXCIgLyogTk9ORSAqLztcbiAgfVxuICBpZiAod29ybGQubWV0YWRhdGEucm9sZXNbZW50aXR5SWRdKSB7XG4gICAgcmV0dXJuIHdvcmxkLm1ldGFkYXRhLnJvbGVzW2VudGl0eUlkXTtcbiAgfVxuICBpZiAod29ybGQubWV0YWRhdGEucm9sZXNbZW50aXR5SWRdKSB7XG4gICAgcmV0dXJuIHdvcmxkLm1ldGFkYXRhLnJvbGVzW2VudGl0eUlkXTtcbiAgfVxuICByZXR1cm4gXCJOT05FXCIgLyogTk9ORSAqLztcbn1cbmFzeW5jIGZ1bmN0aW9uIGZpbmRXb3JsZHNGb3JPd25lcihydW50aW1lLCBlbnRpdHlJZCkge1xuICBpZiAoIWVudGl0eUlkKSB7XG4gICAgbG9nZ2VyLmVycm9yKFwiVXNlciBJRCBpcyByZXF1aXJlZCB0byBmaW5kIHNlcnZlclwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB3b3JsZHMgPSBhd2FpdCBydW50aW1lLmdldEFsbFdvcmxkcygpO1xuICBpZiAoIXdvcmxkcyB8fCB3b3JsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgbG9nZ2VyLmluZm8oXCJObyB3b3JsZHMgZm91bmQgZm9yIHRoaXMgYWdlbnRcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgb3duZXJXb3JsZHMgPSBbXTtcbiAgZm9yIChjb25zdCB3b3JsZCBvZiB3b3JsZHMpIHtcbiAgICBpZiAod29ybGQubWV0YWRhdGE/Lm93bmVyc2hpcD8ub3duZXJJZCA9PT0gZW50aXR5SWQpIHtcbiAgICAgIG93bmVyV29ybGRzLnB1c2god29ybGQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3duZXJXb3JsZHMubGVuZ3RoID8gb3duZXJXb3JsZHMgOiBudWxsO1xufVxuXG4vLyBzcmMvcnVudGltZS50c1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSBcInV1aWRcIjtcblxuLy8gc3JjL3NlYXJjaC50c1xudmFyIGlzViA9IChjaGFyKSA9PiB7XG4gIHN3aXRjaCAoY2hhcikge1xuICAgIGNhc2UgOTc6XG4gICAgY2FzZSAxMDE6XG4gICAgY2FzZSAxMDU6XG4gICAgY2FzZSAxMTE6XG4gICAgY2FzZSAxMTc6XG4gICAgY2FzZSAxMjE6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGlzV3h5ID0gKGNoYXIpID0+IHtcbiAgc3dpdGNoIChjaGFyKSB7XG4gICAgY2FzZSA5NzpcbiAgICBjYXNlIDEwMTpcbiAgICBjYXNlIDEwNTpcbiAgICBjYXNlIDExMTpcbiAgICBjYXNlIDExNzpcbiAgICBjYXNlIDEyMTpcbiAgICBjYXNlIDExOTpcbiAgICBjYXNlIDEyMDpcbiAgICBjYXNlIDg5OlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBpc1ZhbGlkTGkgPSAoY2hhcikgPT4ge1xuICBzd2l0Y2ggKGNoYXIpIHtcbiAgICBjYXNlIDk5OlxuICAgIGNhc2UgMTAwOlxuICAgIGNhc2UgMTAxOlxuICAgIGNhc2UgMTAzOlxuICAgIGNhc2UgMTA0OlxuICAgIGNhc2UgMTA3OlxuICAgIGNhc2UgMTA5OlxuICAgIGNhc2UgMTEwOlxuICAgIGNhc2UgMTE0OlxuICAgIGNhc2UgMTE2OlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBpc0RvdWJsZSA9IChjaGFyKSA9PiB7XG4gIHN3aXRjaCAoY2hhcikge1xuICAgIGNhc2UgOTg6XG4gICAgY2FzZSAxMDA6XG4gICAgY2FzZSAxMDI6XG4gICAgY2FzZSAxMDM6XG4gICAgY2FzZSAxMDk6XG4gICAgY2FzZSAxMTA6XG4gICAgY2FzZSAxMTI6XG4gICAgY2FzZSAxMTQ6XG4gICAgY2FzZSAxMTY6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIGlzU2hvcnRWID0gKHcsIGxlbikgPT4ge1xuICByZXR1cm4gbGVuID49IDIgJiYgaXNWKHdbbGVuIC0gMl0pICYmIChsZW4gPT09IDIgJiYgIWlzVih3W2xlbiAtIDFdKSB8fCBsZW4gPj0gMyAmJiAhaXNWKHdbbGVuIC0gM10pICYmICFpc1d4eSh3W2xlbiAtIDFdKSk7XG59O1xudmFyIHN0ZW0gPSAod29yZCkgPT4ge1xuICBpZiAod29yZC5sZW5ndGggPCAzKSByZXR1cm4gd29yZDtcbiAgaWYgKHdvcmQubGVuZ3RoIDw9IDYpIHtcbiAgICBzd2l0Y2ggKHdvcmQpIHtcbiAgICAgIGNhc2UgXCJza2lcIjpcbiAgICAgICAgcmV0dXJuIFwic2tpXCI7XG4gICAgICBjYXNlIFwic2tpZXNcIjpcbiAgICAgICAgcmV0dXJuIFwic2t5XCI7XG4gICAgICBjYXNlIFwiZHlpbmdcIjpcbiAgICAgICAgcmV0dXJuIFwiZGllXCI7XG4gICAgICBjYXNlIFwibHlpbmdcIjpcbiAgICAgICAgcmV0dXJuIFwibGllXCI7XG4gICAgICBjYXNlIFwidHlpbmdcIjpcbiAgICAgICAgcmV0dXJuIFwidGllXCI7XG4gICAgICAvLyBzcGVjaWFsIC1MWSBjYXNlc1xuICAgICAgY2FzZSBcImlkbHlcIjpcbiAgICAgICAgcmV0dXJuIFwiaWRsXCI7XG4gICAgICBjYXNlIFwiZ2VudGx5XCI6XG4gICAgICAgIHJldHVybiBcImdlbnRsXCI7XG4gICAgICBjYXNlIFwidWdseVwiOlxuICAgICAgICByZXR1cm4gXCJ1Z2xpXCI7XG4gICAgICBjYXNlIFwiZWFybHlcIjpcbiAgICAgICAgcmV0dXJuIFwiZWFybGlcIjtcbiAgICAgIGNhc2UgXCJvbmx5XCI6XG4gICAgICAgIHJldHVybiBcIm9ubGlcIjtcbiAgICAgIGNhc2UgXCJzaW5nbHlcIjpcbiAgICAgICAgcmV0dXJuIFwic2luZ2xcIjtcbiAgICAgIC8vIGludmFyaWFudCBmb3Jtc1xuICAgICAgY2FzZSBcInNreVwiOlxuICAgICAgY2FzZSBcIm5ld3NcIjpcbiAgICAgIGNhc2UgXCJob3dlXCI6XG4gICAgICAvLyBub3QgcGx1cmFsIGZvcm1zXG4gICAgICBjYXNlIFwiYXRsYXNcIjpcbiAgICAgIGNhc2UgXCJjb3Ntb3NcIjpcbiAgICAgIGNhc2UgXCJiaWFzXCI6XG4gICAgICBjYXNlIFwiYW5kZXNcIjpcbiAgICAgICAgcmV0dXJuIHdvcmQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IGluaXRpYWxPZmZzZXQgPSB3b3JkLmNoYXJDb2RlQXQoMCkgPT09IDM5ID8gMSA6IDA7XG4gIGxldCBsID0gd29yZC5sZW5ndGggLSBpbml0aWFsT2Zmc2V0O1xuICBjb25zdCB3ID0gbmV3IEFycmF5KGwpO1xuICBsZXQgeUZvdW5kID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgY2ggPSB3b3JkLmNoYXJDb2RlQXQoaSArIGluaXRpYWxPZmZzZXQpO1xuICAgIGlmIChjaCA9PT0gMTIxICYmIChpID09PSAwIHx8IGlzVih3W2kgLSAxXSkpKSB7XG4gICAgICB5Rm91bmQgPSB0cnVlO1xuICAgICAgd1tpXSA9IDg5O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHdbaV0gPSBjaDtcbiAgfVxuICBpZiAod1tsIC0gMV0gPT09IDM5KSAtLWw7XG4gIGlmIChsID49IDIgJiYgd1tsIC0gMl0gPT09IDM5ICYmIHdbbCAtIDFdID09PSAxMTUpIGwgLT0gMjtcbiAgbGV0IHJ2ID0gMDtcbiAgd2hpbGUgKHJ2IDwgbCAmJiAhaXNWKHdbcnZdKSkgKytydjtcbiAgaWYgKHJ2IDwgbCkgKytydjtcbiAgbGV0IHIxID0gcnY7XG4gIGlmIChsID49IDUgJiYgKHdbMF0gPT09IDEwMyAmJiB3WzFdID09PSAxMDEgJiYgd1syXSA9PT0gMTEwICYmIHdbM10gPT09IDEwMSAmJiB3WzRdID09PSAxMTQgfHwgLy8gZ2VuZXJcbiAgd1swXSA9PT0gOTcgJiYgd1sxXSA9PT0gMTE0ICYmIHdbMl0gPT09IDExNSAmJiB3WzNdID09PSAxMDEgJiYgd1s0XSA9PT0gMTEwKSlcbiAgICByMSA9IDU7XG4gIGVsc2UgaWYgKGwgPj0gNiAmJiB3WzBdID09PSA5OSAmJiAvLyBjXG4gIHdbMV0gPT09IDExMSAmJiAvLyBvXG4gIHdbMl0gPT09IDEwOSAmJiAvLyBtXG4gIHdbM10gPT09IDEwOSAmJiAvLyBtXG4gIHdbNF0gPT09IDExNyAmJiAvLyB1XG4gIHdbNV0gPT09IDExMClcbiAgICByMSA9IDY7XG4gIGVsc2Uge1xuICAgIHdoaWxlIChyMSA8IGwgJiYgaXNWKHdbcjFdKSkgKytyMTtcbiAgICBpZiAocjEgPCBsKSArK3IxO1xuICB9XG4gIGxldCByMiA9IHIxO1xuICB3aGlsZSAocjIgPCBsICYmICFpc1Yod1tyMl0pKSArK3IyO1xuICB3aGlsZSAocjIgPCBsICYmIGlzVih3W3IyXSkpICsrcjI7XG4gIGlmIChyMiA8IGwpICsrcjI7XG4gIGlmIChsID49IDMpIHtcbiAgICBpZiAod1tsIC0gMV0gPT09IDExNSkge1xuICAgICAgaWYgKGwgPj0gNCAmJiB3W2wgLSAyXSA9PT0gMTAxICYmIHdbbCAtIDNdID09PSAxMTUgJiYgd1tsIC0gNF0gPT09IDExNSlcbiAgICAgICAgbCAtPSAyO1xuICAgICAgZWxzZSBpZiAod1tsIC0gMl0gPT09IDEwMSAmJiB3W2wgLSAzXSA9PT0gMTA1KVxuICAgICAgICBsIC09IGwgPj0gNSA/IDIgOiAxO1xuICAgICAgZWxzZSBpZiAod1tsIC0gMl0gIT09IDExNyAmJiB3W2wgLSAyXSAhPT0gMTE1ICYmIHJ2IDwgbCAtIDEpXG4gICAgICAgIGwgLT0gMTtcbiAgICB9IGVsc2UgaWYgKHdbbCAtIDFdID09PSAxMDAgJiYgd1tsIC0gMl0gPT09IDEwMSAmJiB3W2wgLSAzXSA9PT0gMTA1KSBsIC09IGwgPj0gNSA/IDIgOiAxO1xuICB9XG4gIGlmIChsID09PSA2ICYmICh3WzBdID09PSAxMDUgJiYgLy8gaVxuICB3WzFdID09PSAxMTAgJiYgLy8gblxuICB3WzJdID09PSAxMTAgJiYgLy8gblxuICB3WzNdID09PSAxMDUgJiYgLy8gaVxuICB3WzRdID09PSAxMTAgJiYgLy8gblxuICB3WzVdID09PSAxMDMgfHwgLy8gZyAoaW5uaW5nKVxuICB3WzBdID09PSAxMTEgJiYgLy8gb1xuICB3WzFdID09PSAxMTcgJiYgLy8gdVxuICB3WzJdID09PSAxMTYgJiYgLy8gdFxuICB3WzNdID09PSAxMDUgJiYgLy8gaVxuICB3WzRdID09PSAxMTAgJiYgLy8gblxuICB3WzVdID09PSAxMDMgfHwgLy8gZyAob3V0aW5nKVxuICB3WzBdID09PSAxMDEgJiYgLy8gZVxuICB3WzFdID09PSAxMjAgJiYgLy8geFxuICB3WzJdID09PSA5OSAmJiAvLyBjXG4gIHdbM10gPT09IDEwMSAmJiAvLyBlXG4gIHdbNF0gPT09IDEwMSAmJiAvLyBlXG4gIHdbNV0gPT09IDEwMCkgfHwgLy8gZCAoZXhjZWVkKVxuICBsID09PSA3ICYmICh3WzBdID09PSA5OSAmJiAvLyBjXG4gIHdbMV0gPT09IDk3ICYmIC8vIGFcbiAgd1syXSA9PT0gMTEwICYmIC8vIG5cbiAgd1szXSA9PT0gMTEwICYmIC8vIG5cbiAgd1s0XSA9PT0gMTA1ICYmIC8vIGlcbiAgd1s1XSA9PT0gMTEwICYmIC8vIG5cbiAgd1s2XSA9PT0gMTAzIHx8IC8vIGcgKGNhbm5pbmcpXG4gIHdbMF0gPT09IDEwNCAmJiAvLyBoXG4gIHdbMV0gPT09IDEwMSAmJiAvLyBlXG4gIHdbMl0gPT09IDExNCAmJiAvLyByXG4gIHdbM10gPT09IDExNCAmJiAvLyByXG4gIHdbNF0gPT09IDEwNSAmJiAvLyBpXG4gIHdbNV0gPT09IDExMCAmJiAvLyBuXG4gIHdbNl0gPT09IDEwMyB8fCAvLyBnIChoZXJyaW5nKVxuICB3WzBdID09PSAxMDEgJiYgLy8gZVxuICB3WzFdID09PSA5NyAmJiAvLyBhXG4gIHdbMl0gPT09IDExNCAmJiAvLyByXG4gIHdbM10gPT09IDExNCAmJiAvLyByXG4gIHdbNF0gPT09IDEwNSAmJiAvLyBpXG4gIHdbNV0gPT09IDExMCAmJiAvLyBuXG4gIHdbNl0gPT09IDEwMyB8fCAvLyBnIChlYXJyaW5nKVxuICB3WzBdID09PSAxMTIgJiYgLy8gcFxuICB3WzFdID09PSAxMTQgJiYgLy8gclxuICB3WzJdID09PSAxMTEgJiYgLy8gb1xuICB3WzNdID09PSA5OSAmJiAvLyBjXG4gIHdbNF0gPT09IDEwMSAmJiAvLyBlXG4gIHdbNV0gPT09IDEwMSAmJiAvLyBlXG4gIHdbNl0gPT09IDEwMCB8fCAvLyBkIChwcm9jZWVkKVxuICB3WzBdID09PSAxMTUgJiYgLy8gc1xuICB3WzFdID09PSAxMTcgJiYgLy8gdVxuICB3WzJdID09PSA5OSAmJiAvLyBjXG4gIHdbM10gPT09IDk5ICYmIC8vIGNcbiAgd1s0XSA9PT0gMTAxICYmIC8vIGVcbiAgd1s1XSA9PT0gMTAxICYmIC8vIGVcbiAgd1s2XSA9PT0gMTAwKSkge1xuICAgIGxldCBleHAyT3V0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7ICsraSkgZXhwMk91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHdbaV0pO1xuICAgIHJldHVybiBleHAyT3V0O1xuICB9XG4gIGxldCBsbCA9IChcbiAgICAvLyBsIChsZW5ndGgpIHdpdGhvdXQgdGhlIC1seSBlbmRpbmdcbiAgICBsID49IDIgJiYgd1tsIC0gMV0gPT09IDEyMSAmJiB3W2wgLSAyXSA9PT0gMTA4ID8gbCAtIDIgOiBsXG4gICk7XG4gIGlmIChsbCA+PSAzKSB7XG4gICAgaWYgKHdbbGwgLSAzXSA9PT0gMTAxICYmIHdbbGwgLSAyXSA9PT0gMTAxICYmIHdbbGwgLSAxXSA9PT0gMTAwKSB7XG4gICAgICBpZiAobGwgPj0gcjEgKyAzKSBsID0gbGwgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAod1tsbCAtIDJdID09PSAxMDEgJiYgd1tsbCAtIDFdID09PSAxMDApXG4gICAgICAgIGxsIC09IDI7XG4gICAgICBlbHNlIGlmICh3W2xsIC0gM10gPT09IDEwNSAmJiB3W2xsIC0gMl0gPT09IDExMCAmJiB3W2xsIC0gMV0gPT09IDEwMylcbiAgICAgICAgbGwgLT0gMztcbiAgICAgIGVsc2UgbGwgPSAtMTtcbiAgICAgIGlmIChsbCA+PSAwICYmIHJ2IDw9IGxsKSB7XG4gICAgICAgIGwgPSBsbDtcbiAgICAgICAgaWYgKGwgPj0gMikge1xuICAgICAgICAgIGlmICh3W2wgLSAxXSA9PT0gMTE2ICYmIHdbbCAtIDJdID09PSA5NyB8fCAvLyBhdFxuICAgICAgICAgIHdbbCAtIDFdID09PSAxMDggJiYgd1tsIC0gMl0gPT09IDk4IHx8IC8vIGJsXG4gICAgICAgICAgd1tsIC0gMV0gPT09IDEyMiAmJiB3W2wgLSAyXSA9PT0gMTA1KSB7XG4gICAgICAgICAgICB3W2xdID0gMTAxO1xuICAgICAgICAgICAgKytsO1xuICAgICAgICAgIH0gZWxzZSBpZiAod1tsIC0gMl0gPT09IHdbbCAtIDFdICYmIGlzRG91YmxlKHdbbCAtIDFdKSkge1xuICAgICAgICAgICAgLS1sO1xuICAgICAgICAgIH0gZWxzZSBpZiAocjEgPj0gbCAmJiBpc1Nob3J0Vih3LCBsKSkge1xuICAgICAgICAgICAgd1tsXSA9IDEwMTtcbiAgICAgICAgICAgICsrbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGwgPj0gMyAmJiAod1tsIC0gMV0gPT09IDg5IHx8IHdbbCAtIDFdID09PSAxMjEpICYmICFpc1Yod1tsIC0gMl0pKSB3W2wgLSAxXSA9IDEwNTtcbiAgaWYgKGwgPj0gcjEgKyAyKSB7XG4gICAgc3dpdGNoICh3W2wgLSAxXSkge1xuICAgICAgY2FzZSAxMDg6XG4gICAgICAgIGlmIChsID49IHIxICsgNiAmJiB3W2wgLSAyXSA9PT0gOTcgJiYgLy8gYVxuICAgICAgICB3W2wgLSAzXSA9PT0gMTEwICYmIC8vIG5cbiAgICAgICAgd1tsIC0gNF0gPT09IDExMSAmJiAvLyBvXG4gICAgICAgIHdbbCAtIDVdID09PSAxMDUgJiYgLy8gaVxuICAgICAgICB3W2wgLSA2XSA9PT0gMTE2KSB7XG4gICAgICAgICAgaWYgKGwgPj0gNyAmJiB3W2wgLSA3XSA9PT0gOTcpIHtcbiAgICAgICAgICAgIGlmIChsID49IHIxICsgNykge1xuICAgICAgICAgICAgICBsIC09IDQ7XG4gICAgICAgICAgICAgIHdbbCAtIDFdID0gMTAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsIC09IDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMTA6XG4gICAgICAgIGlmIChsID49IHIxICsgNSAmJiB3W2wgLSAyXSA9PT0gMTExICYmIC8vIG9cbiAgICAgICAgd1tsIC0gM10gPT09IDEwNSAmJiAvLyBpXG4gICAgICAgIHdbbCAtIDRdID09PSAxMTYgJiYgLy8gdFxuICAgICAgICB3W2wgLSA1XSA9PT0gOTcpIHtcbiAgICAgICAgICBpZiAobCA+PSA3ICYmIHdbbCAtIDZdID09PSAxMjIgJiYgd1tsIC0gN10gPT09IDEwNSkge1xuICAgICAgICAgICAgaWYgKGwgPj0gcjEgKyA3KSB7XG4gICAgICAgICAgICAgIGwgLT0gNDtcbiAgICAgICAgICAgICAgd1tsIC0gMV0gPSAxMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgLT0gMjtcbiAgICAgICAgICAgIHdbbCAtIDFdID0gMTAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTE0OlxuICAgICAgICBpZiAobCA+PSByMSArIDQpIHtcbiAgICAgICAgICBpZiAod1tsIC0gMl0gPT09IDEwMSkge1xuICAgICAgICAgICAgaWYgKHdbbCAtIDNdID09PSAxMjIgJiYgd1tsIC0gNF0gPT09IDEwNSkgLS1sO1xuICAgICAgICAgIH0gZWxzZSBpZiAod1tsIC0gMl0gPT09IDExMSkge1xuICAgICAgICAgICAgaWYgKHdbbCAtIDNdID09PSAxMTYgJiYgd1tsIC0gNF0gPT09IDk3KSB7XG4gICAgICAgICAgICAgIC0tbDtcbiAgICAgICAgICAgICAgd1tsIC0gMV0gPSAxMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMTU6XG4gICAgICAgIGlmIChsID49IHIxICsgNyAmJiB3W2wgLSAyXSA9PT0gMTE1ICYmIC8vIHNcbiAgICAgICAgd1tsIC0gM10gPT09IDEwMSAmJiAvLyBlXG4gICAgICAgIHdbbCAtIDRdID09PSAxMTAgJiYgLy8gbiAobmVzcylcbiAgICAgICAgKHdbbCAtIDVdID09PSAxMDggJiYgd1tsIC0gNl0gPT09IDExNyAmJiB3W2wgLSA3XSA9PT0gMTAyIHx8IC8vIGZ1bG5lc3NcbiAgICAgICAgd1tsIC0gNV0gPT09IDExNSAmJiB3W2wgLSA2XSA9PT0gMTE3ICYmIHdbbCAtIDddID09PSAxMTEgfHwgLy8gb3VzbmVzc1xuICAgICAgICB3W2wgLSA1XSA9PT0gMTAxICYmIHdbbCAtIDZdID09PSAxMTggJiYgd1tsIC0gN10gPT09IDEwNSkpIHtcbiAgICAgICAgICBsIC09IDQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwOTpcbiAgICAgICAgaWYgKGwgPj0gcjEgKyA1ICYmIHdbbCAtIDJdID09PSAxMTUgJiYgLy8gc1xuICAgICAgICB3W2wgLSAzXSA9PT0gMTA1ICYmIC8vIGlcbiAgICAgICAgd1tsIC0gNF0gPT09IDEwOCAmJiAvLyBsXG4gICAgICAgIHdbbCAtIDVdID09PSA5NylcbiAgICAgICAgICBsIC09IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDU6XG4gICAgICAgIGlmICh3W2wgLSAyXSA9PT0gOTkpIHtcbiAgICAgICAgICBpZiAobCA+PSByMSArIDQgJiYgKHdbbCAtIDRdID09PSAxMDEgfHwgd1tsIC0gNF0gPT09IDk3KSAmJiB3W2wgLSAzXSA9PT0gMTEwKSB7XG4gICAgICAgICAgICB3W2wgLSAxXSA9IDEwMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod1tsIC0gMl0gPT09IDEwMykge1xuICAgICAgICAgIGlmIChsID49IHIxICsgMyAmJiBsID49IDQgJiYgd1tsIC0gMl0gPT09IDEwMyAmJiB3W2wgLSAzXSA9PT0gMTExICYmIHdbbCAtIDRdID09PSAxMDgpXG4gICAgICAgICAgICAtLWw7XG4gICAgICAgIH0gZWxzZSBpZiAod1tsIC0gMl0gPT09IDExNikge1xuICAgICAgICAgIGlmIChsID49IHIxICsgNSAmJiB3W2wgLSAzXSA9PT0gMTA1KSB7XG4gICAgICAgICAgICBpZiAod1tsIC0gNF0gPT09IDEwOCkge1xuICAgICAgICAgICAgICBpZiAobCA+PSA2ICYmIHdbbCAtIDVdID09PSAxMDUgJiYgd1tsIC0gNl0gPT09IDk4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGwgPj0gcjEgKyA2KSB7XG4gICAgICAgICAgICAgICAgICBsIC09IDM7XG4gICAgICAgICAgICAgICAgICB3W2wgLSAyXSA9IDEwODtcbiAgICAgICAgICAgICAgICAgIHdbbCAtIDFdID0gMTAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh3W2wgLSA0XSA9PT0gMTA4ICYmIHdbbCAtIDVdID09PSA5Nykge1xuICAgICAgICAgICAgICAgIGwgLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3W2wgLSA0XSA9PT0gMTE4ICYmIHdbbCAtIDVdID09PSAxMDUpIHtcbiAgICAgICAgICAgICAgbCAtPSAyO1xuICAgICAgICAgICAgICB3W2wgLSAxXSA9IDEwMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod1tsIC0gMl0gPT09IDEwOCAmJiBsID49IDMpIHtcbiAgICAgICAgICBpZiAod1tsIC0gM10gPT09IDk4KSB7XG4gICAgICAgICAgICBpZiAobCA+PSA0ICYmIHdbbCAtIDRdID09PSA5Nykge1xuICAgICAgICAgICAgICBpZiAobCA+PSByMSArIDQpIHdbbCAtIDFdID0gMTAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsID49IHIxICsgMykge1xuICAgICAgICAgICAgICB3W2wgLSAxXSA9IDEwMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHdbbCAtIDNdID09PSAxMDgpIHtcbiAgICAgICAgICAgICAgaWYgKGwgPj0gNSAmJiB3W2wgLSA0XSA9PT0gMTE3ICYmIHdbbCAtIDVdID09PSAxMDIpIHtcbiAgICAgICAgICAgICAgICBpZiAobCA+PSByMSArIDUpIGwgLT0gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChsID49IHIxICsgNCAmJiB3W2wgLSA0XSA9PT0gOTcpIHtcbiAgICAgICAgICAgICAgICBsIC09IDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAod1tsIC0gM10gPT09IDExNSkge1xuICAgICAgICAgICAgICBpZiAobCA+PSA2ICYmIHdbbCAtIDRdID09PSAxMTUgJiYgd1tsIC0gNV0gPT09IDEwMSAmJiB3W2wgLSA2XSA9PT0gMTA4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGwgPj0gcjEgKyA2KSBsIC09IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobCA+PSByMSArIDUgJiYgd1tsIC0gNF0gPT09IDExNyAmJiB3W2wgLSA1XSA9PT0gMTExKSB7XG4gICAgICAgICAgICAgICAgbCAtPSAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGwgPj0gNSAmJiB3W2wgLSAzXSA9PT0gMTE2ICYmIHdbbCAtIDRdID09PSAxMTAgJiYgd1tsIC0gNV0gPT09IDEwMSkge1xuICAgICAgICAgICAgICBpZiAobCA+PSByMSArIDUpIGwgLT0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZExpKHdbbCAtIDNdKSkge1xuICAgICAgICAgICAgICBsIC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsID49IHIxICsgMykge1xuICAgIHN3aXRjaCAod1tsIC0gMV0pIHtcbiAgICAgIGNhc2UgMTA4OlxuICAgICAgICBpZiAod1tsIC0gM10gPT09IDk5KSB7XG4gICAgICAgICAgaWYgKGwgPj0gcjEgKyA0ICYmIHdbbCAtIDRdID09PSAxMDUgJiYgd1tsIC0gMl0gPT09IDk3KSBsIC09IDI7XG4gICAgICAgIH0gZWxzZSBpZiAod1tsIC0gM10gPT09IDEwMikge1xuICAgICAgICAgIGlmICh3W2wgLSAyXSA9PT0gMTE3KSBsIC09IDM7XG4gICAgICAgIH0gZWxzZSBpZiAod1tsIC0gM10gPT09IDExMCkge1xuICAgICAgICAgIGlmIChsID49IHIxICsgNiAmJiB3W2wgLSAyXSA9PT0gOTcgJiYgLy8gYVxuICAgICAgICAgIHdbbCAtIDRdID09PSAxMTEgJiYgLy8gb1xuICAgICAgICAgIHdbbCAtIDVdID09PSAxMDUgJiYgLy8gaVxuICAgICAgICAgIHdbbCAtIDZdID09PSAxMTYpIHtcbiAgICAgICAgICAgIGlmIChsID49IDcgJiYgd1tsIC0gN10gPT09IDk3KSB7XG4gICAgICAgICAgICAgIGlmIChsID49IHIxICsgNykge1xuICAgICAgICAgICAgICAgIGwgLT0gNDtcbiAgICAgICAgICAgICAgICB3W2wgLSAxXSA9IDEwMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbCAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAxOlxuICAgICAgICBpZiAod1tsIC0gMl0gPT09IDEyMikge1xuICAgICAgICAgIGlmIChsID49IHIxICsgNSAmJiB3W2wgLSAzXSA9PT0gMTA1ICYmIHdbbCAtIDRdID09PSAxMDggJiYgd1tsIC0gNV0gPT09IDk3KSBsIC09IDM7XG4gICAgICAgIH0gZWxzZSBpZiAod1tsIC0gMl0gPT09IDExNikge1xuICAgICAgICAgIGlmIChsID49IHIxICsgNSAmJiB3W2wgLSAzXSA9PT0gOTcgJiYgd1tsIC0gNF0gPT09IDk5ICYmIHdbbCAtIDVdID09PSAxMDUpIGwgLT0gMztcbiAgICAgICAgfSBlbHNlIGlmICh3W2wgLSAyXSA9PT0gMTE4KSB7XG4gICAgICAgICAgaWYgKGwgPj0gcjIgKyA1ICYmIHdbbCAtIDNdID09PSAxMDUgJiYgd1tsIC0gNF0gPT09IDExNiAmJiB3W2wgLSA1XSA9PT0gOTcpIGwgLT0gNTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA1OlxuICAgICAgICBpZiAobCA+PSByMSArIDUgJiYgd1tsIC0gMl0gPT09IDExNiAmJiAvLyB0XG4gICAgICAgIHdbbCAtIDNdID09PSAxMDUgJiYgLy8gaVxuICAgICAgICB3W2wgLSA0XSA9PT0gOTkgJiYgLy8gY1xuICAgICAgICB3W2wgLSA1XSA9PT0gMTA1KVxuICAgICAgICAgIGwgLT0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDExNTpcbiAgICAgICAgaWYgKGwgPj0gcjEgKyA0ICYmIHdbbCAtIDJdID09PSAxMTUgJiYgd1tsIC0gM10gPT09IDEwMSAmJiB3W2wgLSA0XSA9PT0gMTEwKSBsIC09IDQ7XG4gICAgfVxuICB9XG4gIGlmIChsID49IHIyICsgMikge1xuICAgIHN3aXRjaCAod1tsIC0gMV0pIHtcbiAgICAgIGNhc2UgMTEwOlxuICAgICAgICBpZiAobCA+PSByMiArIDMgJiYgd1tsIC0gMl0gPT09IDExMSAmJiAvLyBvXG4gICAgICAgIHdbbCAtIDNdID09PSAxMDUgJiYgLy8gaSAoaW9uKVxuICAgICAgICAod1tsIC0gNF0gPT09IDExNSB8fCB3W2wgLSA0XSA9PT0gMTE2KSlcbiAgICAgICAgICBsIC09IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDg6XG4gICAgICAgIGlmICh3W2wgLSAyXSA9PT0gOTcpIGwgLT0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDExNDpcbiAgICAgICAgaWYgKHdbbCAtIDJdID09PSAxMDEpIGwgLT0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDk5OlxuICAgICAgICBpZiAod1tsIC0gMl0gPT09IDEwNSkgbCAtPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA5OlxuICAgICAgICBpZiAobCA+PSByMiArIDMgJiYgd1tsIC0gMl0gPT09IDExNSAmJiB3W2wgLSAzXSA9PT0gMTA1KSBsIC09IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDU6XG4gICAgICAgIGlmIChsID49IHIyICsgMyAmJiB3W2wgLSAyXSA9PT0gMTE2ICYmIHdbbCAtIDNdID09PSAxMDUpIGwgLT0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDExNTpcbiAgICAgICAgaWYgKGwgPj0gcjIgKyAzICYmIHdbbCAtIDJdID09PSAxMTcgJiYgd1tsIC0gM10gPT09IDExMSkgbCAtPSAzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTE2OlxuICAgICAgICBpZiAobCA+PSByMiArIDMgJiYgd1tsIC0gMl0gPT09IDExMCkge1xuICAgICAgICAgIGlmICh3W2wgLSAzXSA9PT0gOTcpIHtcbiAgICAgICAgICAgIGwgLT0gMztcbiAgICAgICAgICB9IGVsc2UgaWYgKHdbbCAtIDNdID09PSAxMDEpIHtcbiAgICAgICAgICAgIGlmIChsID49IDQgJiYgd1tsIC0gNF0gPT09IDEwOSkge1xuICAgICAgICAgICAgICBpZiAobCA+PSA1ICYmIHdbbCAtIDVdID09PSAxMDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobCA+PSByMiArIDUpIGwgLT0gNTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChsID49IHIyICsgNCkge1xuICAgICAgICAgICAgICAgIGwgLT0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbCAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAxOlxuICAgICAgICBpZiAod1tsIC0gMl0gPT09IDk5KSB7XG4gICAgICAgICAgaWYgKGwgPj0gcjIgKyA0ICYmIHdbbCAtIDNdID09PSAxMTAgJiYgKHdbbCAtIDRdID09PSA5NyB8fCB3W2wgLSA0XSA9PT0gMTAxKSkgbCAtPSA0O1xuICAgICAgICB9IGVsc2UgaWYgKHdbbCAtIDJdID09PSAxMDgpIHtcbiAgICAgICAgICBpZiAobCA+PSByMiArIDQgJiYgd1tsIC0gM10gPT09IDk4ICYmICh3W2wgLSA0XSA9PT0gOTcgfHwgd1tsIC0gNF0gPT09IDEwNSkpIGwgLT0gNDtcbiAgICAgICAgfSBlbHNlIGlmICh3W2wgLSAyXSA9PT0gMTE2KSB7XG4gICAgICAgICAgaWYgKGwgPj0gcjIgKyAzICYmIHdbbCAtIDNdID09PSA5NykgbCAtPSAzO1xuICAgICAgICB9IGVsc2UgaWYgKGwgPj0gcjIgKyAzICYmICh3W2wgLSAyXSA9PT0gMTE4IHx8IHdbbCAtIDJdID09PSAxMjIpICYmIHdbbCAtIDNdID09PSAxMDUpIHtcbiAgICAgICAgICBsIC09IDM7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGwgPj0gcjEgKyAxICYmIC8vIHIxIGlzID49IDFcbiAgKGwgPj0gcjIgKyAxICYmIHdbbCAtIDFdID09PSAxMDggJiYgd1tsIC0gMl0gPT09IDEwOCB8fCAvLyBsbFxuICB3W2wgLSAxXSA9PT0gMTAxICYmIChsID49IHIyICsgMSB8fCAhaXNTaG9ydFYodywgbCAtIDEpKSkpXG4gICAgLS1sO1xuICBsZXQgb3V0ID0gXCJcIjtcbiAgaWYgKHlGb3VuZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh3W2ldID09PSA4OSA/IDEyMSA6IHdbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7ICsraSkgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUod1tpXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBrMTogMS4yLFxuICBiOiAwLjc1LFxuICBtaW5MZW5ndGg6IDIsXG4gIHN0b3BXb3JkczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgIFwiYVwiLFxuICAgIFwiYW5cIixcbiAgICBcImFuZFwiLFxuICAgIFwiYXJlXCIsXG4gICAgXCJhc1wiLFxuICAgIFwiYXRcIixcbiAgICBcImJlXCIsXG4gICAgXCJieVwiLFxuICAgIFwiZm9yXCIsXG4gICAgXCJmcm9tXCIsXG4gICAgXCJoYXNcIixcbiAgICBcImhlXCIsXG4gICAgXCJpblwiLFxuICAgIFwiaXNcIixcbiAgICBcIml0XCIsXG4gICAgXCJpdHNcIixcbiAgICBcIm9mXCIsXG4gICAgXCJvblwiLFxuICAgIFwidGhhdFwiLFxuICAgIFwidGhlXCIsXG4gICAgXCJ0b1wiLFxuICAgIFwid2FzXCIsXG4gICAgXCJ3ZXJlXCIsXG4gICAgXCJ3aWxsXCIsXG4gICAgXCJ3aXRoXCJcbiAgXSksXG4gIHN0ZW1taW5nOiBmYWxzZSxcbiAgc3RlbVdvcmRzOiAod29yZCkgPT4gd29yZFxufTtcbnZhciBUb2tlbml6ZXIgPSBjbGFzcyBfVG9rZW5pemVyIHtcbiAgc3RhdGljIHtcbiAgICAvKiogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgVG9rZW5pemVyLiAqL1xuICAgIHRoaXMuREVGQVVMVF9PUFRJT05TID0ge1xuICAgICAgc3RvcFdvcmRzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgbWluTGVuZ3RoOiAyLFxuICAgICAgc3RlbW1pbmc6IGZhbHNlLFxuICAgICAgc3RlbW1pbmdSdWxlczogW11cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRva2VuaXplciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUb2tlbml6YXRpb24gb3B0aW9ucyBpbmNsdWRpbmcgc3RvcCB3b3JkcywgbWluIGxlbmd0aCwgc3RlbW1pbmcsIGFuZCBjdXN0b20gcnVsZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zMiA9IHt9KSB7XG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHsgLi4uX1Rva2VuaXplci5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMyIH07XG4gICAgdGhpcy5zdG9wV29yZHMgPSBtZXJnZWRPcHRpb25zLnN0b3BXb3JkcztcbiAgICB0aGlzLm1pbkxlbmd0aCA9IG1lcmdlZE9wdGlvbnMubWluTGVuZ3RoO1xuICAgIHRoaXMuc3RlbW1pbmcgPSBtZXJnZWRPcHRpb25zLnN0ZW1taW5nO1xuICAgIHRoaXMuc3RlbW1pbmdSdWxlcyA9IG1lcmdlZE9wdGlvbnMuc3RlbW1pbmdSdWxlcy5tYXAoKHJ1bGUpID0+ICh7XG4gICAgICAuLi5ydWxlLFxuICAgICAgcGF0dGVybjogdHlwZW9mIHJ1bGUucGF0dGVybiA9PT0gXCJzdHJpbmdcIiA/IG5ldyBSZWdFeHAocnVsZS5wYXR0ZXJuKSA6IHJ1bGUucGF0dGVyblxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogVG9rZW5pemVzIGlucHV0IHRleHQgaW50byBhbiBhcnJheSBvZiBwcm9jZXNzZWQgdGVybXMuXG4gICAqIFN0ZXBzOlxuICAgKiAxLiBDbGVhbnMgdGhlIHRleHQgKGxvd2VyY2FzZSwgbm9ybWFsaXplLCByZW1vdmUgcHVuY3R1YXRpb24vc3ltYm9scykuXG4gICAqIDIuIFNwbGl0cyB0aGUgdGV4dCBpbnRvIHBvdGVudGlhbCB0b2tlbnMuXG4gICAqIDMuIEZpbHRlcnMgdG9rZW5zIGJhc2VkIG9uIGBtaW5MZW5ndGhgIGFuZCBgc3RvcFdvcmRzYC5cbiAgICogNC4gQXBwbGllcyBzdGVtbWluZyBpZiBgc3RlbW1pbmdgIGlzIHRydWUgKGN1c3RvbSBydWxlcyBmaXJzdCwgdGhlbiBQb3J0ZXIyKS5cbiAgICogNS4gT3B0aW9uYWxseSBjYWxjdWxhdGVzIHN0YXRpc3RpY3MuXG4gICAqXG4gICAqIEBwYXJhbSB0ZXh0IC0gVGhlIGlucHV0IHRleHQgc3RyaW5nIHRvIHRva2VuaXplLlxuICAgKiBAcGFyYW0gaW5jbHVkZVN0YXRzIC0gSWYgdHJ1ZSwgcmV0dXJucyB0b2tlbml6YXRpb24gc3RhdGlzdGljcyBhbG9uZyB3aXRoIHRva2Vucy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEByZXR1cm5zIEEgYFRva2VuaXphdGlvblJlc3VsdGAgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGFycmF5IG9mIHRva2VucyBhbmQgb3B0aW9uYWwgc3RhdHMuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgaW5wdXQgdGV4dCBpcyBudWxsLCB1bmRlZmluZWQsIG9yIGVtcHR5LlxuICAgKi9cbiAgdG9rZW5pemUodGV4dCwgaW5jbHVkZVN0YXRzID0gZmFsc2UpIHtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IHRleHQgY2Fubm90IGJlIG51bGwgb3IgZW1wdHlcIik7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3Qgb3JpZ2luYWxXb3JkcyA9IHRleHQuc3BsaXQoL1xccysvKS5maWx0ZXIoKHdvcmQpID0+IHdvcmQubGVuZ3RoID4gMCk7XG4gICAgY29uc3QgY2xlYW5lZCA9IHRoaXMuY2xlYW5UZXh0KHRleHQpO1xuICAgIGNvbnN0IHRva2VucyA9IGNsZWFuZWQuc3BsaXQoL1xccysvKS5maWx0ZXIoKHRva2VuKSA9PiB0aGlzLmlzVmFsaWRUb2tlbih0b2tlbikpLm1hcCgodG9rZW4pID0+IHRoaXMuc3RlbW1pbmcgPyB0aGlzLnN0ZW1Xb3JkKHRva2VuKSA6IHRva2VuKTtcbiAgICBjb25zdCBzdGF0cyA9IGluY2x1ZGVTdGF0cyA/IHtcbiAgICAgIG9yaWdpbmFsV29yZENvdW50OiBvcmlnaW5hbFdvcmRzLmxlbmd0aCxcbiAgICAgIHN0b3BXb3Jkc1JlbW92ZWQ6IG9yaWdpbmFsV29yZHMubGVuZ3RoIC0gdG9rZW5zLmxlbmd0aCxcbiAgICAgIC8vIFRoaXMgbWlnaHQgYmUgaW5jb3JyZWN0IGlmIHN0ZW1taW5nIGNoYW5nZXMgdG9rZW4gY291bnRcbiAgICAgIHN0ZW1tZWRXb3JkczogdGhpcy5zdGVtbWluZyA/IHRva2Vucy5sZW5ndGggOiAwLFxuICAgICAgcHJvY2Vzc2luZ1RpbWVNczogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgIH0gOiB7XG4gICAgICBvcmlnaW5hbFdvcmRDb3VudDogMCxcbiAgICAgIHN0b3BXb3Jkc1JlbW92ZWQ6IDAsXG4gICAgICBzdGVtbWVkV29yZHM6IDAsXG4gICAgICBwcm9jZXNzaW5nVGltZU1zOiAwXG4gICAgfTtcbiAgICByZXR1cm4geyB0b2tlbnMsIHN0YXRzIH07XG4gIH1cbiAgLyoqXG4gICAqIENsZWFucyBhbmQgbm9ybWFsaXplcyB0ZXh0IGZvciB0b2tlbml6YXRpb24uXG4gICAqIC0gQ29udmVydHMgdG8gbG93ZXJjYXNlLlxuICAgKiAtIE5vcm1hbGl6ZXMgVW5pY29kZSBjaGFyYWN0ZXJzIChORktEKS5cbiAgICogLSBSZW1vdmVzIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgemVyby13aWR0aCBzcGFjZXMuXG4gICAqIC0gUmVtb3ZlcyBkaWFjcml0aWNhbCBtYXJrcyAoYWNjZW50cykuXG4gICAqIC0gUmVtb3ZlcyBlbW9qaXMgYW5kIHBpY3RvZ3JhcGhzLlxuICAgKiAtIFJlbW92ZXMgY29tbW9uIHN5bWJvbHMgKOKEoiwgwq4sIMKpLCDihKAsIOKAvCkuXG4gICAqIC0gUmVwbGFjZXMgVW5pY29kZSBwdW5jdHVhdGlvbiB3aXRoIHNwYWNlcy5cbiAgICogLSBSZW1vdmVzIGNoYXJhY3RlcnMgbm90IG1hdGNoaW5nIGJhc2ljIExhdGluLCBDSkssIEhhbmd1bCwgb3Igd2hpdGVzcGFjZS5cbiAgICogLSBDb2xsYXBzZXMgbXVsdGlwbGUgc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlcy5cbiAgICogLSBUcmltcyBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB0ZXh0IC0gSW5wdXQgdGV4dCB0byBjbGVhbi5cbiAgICogQHJldHVybnMgQ2xlYW5lZCBhbmQgbm9ybWFsaXplZCB0ZXh0LCByZWFkeSBmb3Igc3BsaXR0aW5nIGludG8gdG9rZW5zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjbGVhblRleHQoXCJIZWxsbywgV29ybGTihKIhXCIpIC8vIFwiaGVsbG8gd29ybGRcIlxuICAgKiBjbGVhblRleHQoXCJow6lsbG8g8J+Ri1wiKSAvLyBcImhlbGxvXCJcbiAgICogY2xlYW5UZXh0KFwiSGVsbG8g5LiW55WMIVwiKSAvLyBcImhlbGxvIOS4lueVjFwiXG4gICAqIGNsZWFuVGV4dChcIkknbSBkb24ndFwiKSAvLyBcImknbSBkb24ndFwiIChhcG9zdHJvcGhlcyBrZXB0IGJ5IHJlcGxhY2luZyBwdW5jdHVhdGlvbiB3aXRoIHNwYWNlKVxuICAgKiBjbGVhblRleHQoXCJ0ZXN0wqkyMDIzXCIpIC8vIFwidGVzdCAyMDIzXCJcbiAgICovXG4gIGNsZWFuVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQudG9Mb3dlckNhc2UoKS5ub3JtYWxpemUoXCJORktEXCIpLnJlcGxhY2UoL1tcXHUwMDAwLVxcdTAwMUZcXHUwMDdGLVxcdTAwOUZcXHUyMDBCLVxcdTIwMERcXHVGRUZGXS9nLCBcIlwiKS5yZXBsYWNlKC9bXFx1MDMwMC1cXHUwMzZmXS9nLCBcIlwiKS5yZXBsYWNlKC9bXFxwe0Vtb2ppX1ByZXNlbnRhdGlvbn1cXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfV0vZ3UsIFwiXCIpLnJlcGxhY2UoL1vihKLCrsKp4oSg4oC8XS9nLCBcIlwiKS5yZXBsYWNlKC9bXFxwe1B9XS9ndSwgXCIgXCIpLnJlcGxhY2UoL1teYS16MC05XFx1MzA0MC1cXHUzMEZGXFx1MzQwMC1cXHU0REJGXFx1NEUwMC1cXHU5RkZGXFx1QUMwMC1cXHVEN0FGXFxzXS9ndSwgXCIgXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpLnRyaW0oKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgdG9rZW4gaXMgdmFsaWQgKG1lZXRzIGBtaW5MZW5ndGhgIGNyaXRlcmlhIGFuZCBpcyBub3QgYSBzdG9wIHdvcmQpLlxuICAgKiBOdW1lcmljIHRva2VucyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQgdmFsaWQgcmVnYXJkbGVzcyBvZiBsZW5ndGguXG4gICAqIEBwYXJhbSB0b2tlbiAtIFRoZSB0b2tlbiBzdHJpbmcgdG8gdmFsaWRhdGUuXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9rZW4gaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNWYWxpZFRva2VuKHRva2VuKSB7XG4gICAgY29uc3QgaXNOdW1lcmljID0gL15cXGQrJC8udGVzdCh0b2tlbik7XG4gICAgcmV0dXJuICh0b2tlbi5sZW5ndGggPj0gdGhpcy5taW5MZW5ndGggfHwgaXNOdW1lcmljKSAmJiAhdGhpcy5zdG9wV29yZHMuaGFzKHRva2VuKTtcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBzdGVtbWluZyB0byBhIHNpbmdsZSB3b3JkLlxuICAgKiBGaXJzdCwgdHJpZXMgdG8gYXBwbHkgY3VzdG9tIHN0ZW1taW5nIHJ1bGVzIGRlZmluZWQgaW4gYHN0ZW1taW5nUnVsZXNgLlxuICAgKiBJZiBubyBjdXN0b20gcnVsZSBtYXRjaGVzLCBhcHBsaWVzIHRoZSBkZWZhdWx0IFBvcnRlcjIgc3RlbW1pbmcgYWxnb3JpdGhtLlxuICAgKiBXb3JkcyBzaG9ydGVyIHRoYW4gMyBjaGFyYWN0ZXJzIGFyZSBub3Qgc3RlbW1lZC5cbiAgICogQHBhcmFtIHdvcmQgLSBUaGUgd29yZCB0byBzdGVtLlxuICAgKiBAcmV0dXJucyBUaGUgc3RlbW1lZCB3b3JkLlxuICAgKi9cbiAgc3RlbVdvcmQod29yZCkge1xuICAgIGlmICh3b3JkLmxlbmd0aCA8IDMpIHJldHVybiB3b3JkO1xuICAgIGxldCBjdXN0b21SdWxlQXBwbGllZCA9IGZhbHNlO1xuICAgIGxldCBzdGVtbWVkID0gd29yZDtcbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgdGhpcy5zdGVtbWluZ1J1bGVzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHN0ZW1tZWQubWF0Y2gocnVsZS5wYXR0ZXJuKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoIXJ1bGUubWluTWVhc3VyZSB8fCB0aGlzLm1lYXN1cmUoc3RlbW1lZC5zdWJzdHJpbmcoMCwgbWF0Y2guaW5kZXgpKSA+PSBydWxlLm1pbk1lYXN1cmUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUucmVwbGFjZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHN0ZW1tZWQgPSBzdGVtbWVkLnJlcGxhY2UocnVsZS5wYXR0ZXJuLCBydWxlLnJlcGxhY2VtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RlbW1lZCA9IHN0ZW1tZWQucmVwbGFjZShcbiAgICAgICAgICAgICAgcnVsZS5wYXR0ZXJuLFxuICAgICAgICAgICAgICAoLi4uYXJncykgPT4gcnVsZS5yZXBsYWNlbWVudCguLi5hcmdzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VzdG9tUnVsZUFwcGxpZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXN0b21SdWxlQXBwbGllZCAmJiBzdGVtbWVkICE9PSB3b3JkKSByZXR1cm4gc3RlbW1lZDtcbiAgICByZXR1cm4gc3RlbShzdGVtbWVkKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjaGFyYWN0ZXIgYXQgYSBnaXZlbiBpbmRleCBpbiBhIHdvcmQgaXMgYSBjb25zb25hbnQuXG4gICAqIFRyZWF0cyAneScgYXMgYSBjb25zb25hbnQgaWYgaXQncyB0aGUgZmlyc3QgbGV0dGVyIG9yIGZvbGxvd3MgYSBjb25zb25hbnQuXG4gICAqIEBwYXJhbSB3b3JkIC0gVGhlIHdvcmQgc3RyaW5nLlxuICAgKiBAcGFyYW0gaSAtIFRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnNvbmFudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBpc0NvbnNvbmFudCh3b3JkLCBpKSB7XG4gICAgY29uc3QgY2hhciA9IHdvcmRbaV07XG4gICAgaWYgKFwiYWVpb3VcIi5pbmNsdWRlcyhjaGFyKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjaGFyICE9PSBcInlcIiB8fCAoaSA9PT0gMCA/IHRydWUgOiAhdGhpcy5pc0NvbnNvbmFudCh3b3JkLCBpIC0gMSkpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBcIm1lYXN1cmVcIiBvZiBhIHdvcmQgc3RlbSAoYXBwcm94aW1hdGVzIHN5bGxhYmxlIGNvdW50KS5cbiAgICogVGhlIG1lYXN1cmUgKG0pIGlzIHRoZSBudW1iZXIgb2YgdGltZXMgYSBzZXF1ZW5jZSBvZiB2b3dlbHMgaXMgZm9sbG93ZWQgYnkgYVxuICAgKiBzZXF1ZW5jZSBvZiBjb25zb25hbnRzIChWQykuIFVzZWQgaW4gc29tZSBzdGVtbWluZyBydWxlcy5cbiAgICogRXhhbXBsZTogbWVhc3VyZShcInRyZWVcIikgPSAwLCBtZWFzdXJlKFwidHJvdWJsZVwiKSA9IDEsIG1lYXN1cmUoXCJwcml2YXRlXCIpID0gMlxuICAgKiBAcGFyYW0gd29yZCAtIFRoZSB3b3JkIChvciBzdGVtKSB0byBtZWFzdXJlLlxuICAgKiBAcmV0dXJucyBUaGUgbWVhc3VyZSAobSkgb2YgdGhlIHdvcmQuXG4gICAqL1xuICBtZWFzdXJlKHdvcmQpIHtcbiAgICBsZXQgbSA9IDA7XG4gICAgbGV0IHZvd2VsU2VlbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuaXNDb25zb25hbnQod29yZCwgaSkpIHtcbiAgICAgICAgaWYgKHZvd2VsU2Vlbikge1xuICAgICAgICAgIG0rKztcbiAgICAgICAgICB2b3dlbFNlZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm93ZWxTZWVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH1cbn07XG52YXIgQk0yNSA9IGNsYXNzIHtcbiAgLy8gQ29uc2lkZXIgdXNpbmcgYSBnZW5lcmljIDxUPlxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBCTTI1IHNlYXJjaCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGRvY3MgLSBPcHRpb25hbCBhcnJheSBvZiBpbml0aWFsIGRvY3VtZW50cyAob2JqZWN0cyB3aXRoIHN0cmluZyBmaWVsZHMpIHRvIGluZGV4LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgQk0yNSBwYXJhbWV0ZXJzIChrMSwgYiksIHRva2VuaXplciAoc3RvcFdvcmRzLCBzdGVtbWluZywgbWluTGVuZ3RoKSwgYW5kIGZpZWxkIGJvb3N0cy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRvY3MsIG9wdGlvbnMyID0ge30pIHtcbiAgICBjb25zdCBvcHRzID0geyAuLi5ERUZBVUxUX09QVElPTlMsIC4uLm9wdGlvbnMyIH07XG4gICAgdGhpcy50ZXJtRnJlcXVlbmN5U2F0dXJhdGlvbiA9IG9wdHMuazE7XG4gICAgdGhpcy5sZW5ndGhOb3JtYWxpemF0aW9uRmFjdG9yID0gb3B0cy5iO1xuICAgIHRoaXMudG9rZW5pemVyID0gbmV3IFRva2VuaXplcihvcHRzKTtcbiAgICB0aGlzLmZpZWxkQm9vc3RzID0gb3B0cy5maWVsZEJvb3N0cyB8fCB7fTtcbiAgICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuICAgIHRoaXMuZG9jdW1lbnRMZW5ndGhzID0gbmV3IFVpbnQzMkFycmF5KDApO1xuICAgIHRoaXMudGVybVRvSW5kZXggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZG9jdW1lbnRGcmVxdWVuY3kgPSBuZXcgVWludDMyQXJyYXkoMCk7XG4gICAgdGhpcy5hdmVyYWdlRG9jTGVuZ3RoID0gMDtcbiAgICB0aGlzLnRlcm1GcmVxdWVuY2llcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKGRvY3MgJiYgZG9jcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmRvY3VtZW50cyA9IFsuLi5kb2NzXTtcbiAgICAgIGNvbnN0IHsgZG9jdW1lbnRMZW5ndGhzLCB0ZXJtVG9JbmRleCwgZG9jdW1lbnRGcmVxdWVuY3ksIGF2ZXJhZ2VEb2NMZW5ndGgsIHRlcm1GcmVxdWVuY2llcyB9ID0gdGhpcy5wcm9jZXNzRG9jdW1lbnRzKGRvY3MpO1xuICAgICAgdGhpcy5kb2N1bWVudExlbmd0aHMgPSBkb2N1bWVudExlbmd0aHM7XG4gICAgICB0aGlzLnRlcm1Ub0luZGV4ID0gdGVybVRvSW5kZXg7XG4gICAgICB0aGlzLmRvY3VtZW50RnJlcXVlbmN5ID0gZG9jdW1lbnRGcmVxdWVuY3k7XG4gICAgICB0aGlzLmF2ZXJhZ2VEb2NMZW5ndGggPSBhdmVyYWdlRG9jTGVuZ3RoO1xuICAgICAgdGhpcy50ZXJtRnJlcXVlbmNpZXMgPSB0ZXJtRnJlcXVlbmNpZXM7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYW4gYXJyYXkgb2YgZG9jdW1lbnRzIHRvIGJ1aWxkIHRoZSBpbml0aWFsIGluZGV4IHN0cnVjdHVyZXMuXG4gICAqIENhbGN1bGF0ZXMgZG9jdW1lbnQgbGVuZ3RocywgdGVybSBmcmVxdWVuY2llcywgZG9jdW1lbnQgZnJlcXVlbmNpZXMsIGFuZCBhdmVyYWdlIGRvY3VtZW50IGxlbmd0aC5cbiAgICogQHBhcmFtIGRvY3MgLSBBcnJheSBvZiBkb2N1bWVudHMgdG8gcHJvY2Vzcy5cbiAgICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhbGN1bGF0ZWQgaW5kZXggZGF0YS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRG9jdW1lbnRzKGRvY3MpIHtcbiAgICBjb25zdCBudW1Eb2NzID0gZG9jcy5sZW5ndGg7XG4gICAgY29uc3QgZG9jdW1lbnRMZW5ndGhzID0gbmV3IFVpbnQzMkFycmF5KG51bURvY3MpO1xuICAgIGNvbnN0IHRlcm1Ub0luZGV4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCB0ZXJtRG9jcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgdGVybUZyZXF1ZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgdG90YWxEb2NMZW5ndGggPSAwO1xuICAgIGxldCBuZXh0VGVybUluZGV4ID0gMDtcbiAgICBkb2NzLmZvckVhY2goKGRvYywgZG9jSW5kZXgpID0+IHtcbiAgICAgIGxldCBjdXJyZW50RG9jTGVuZ3RoID0gMDtcbiAgICAgIGNvbnN0IGRvY1Rlcm1GcmVxdWVuY2llcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBPYmplY3QuZW50cmllcyhkb2MpLmZvckVhY2goKFtmaWVsZCwgY29udGVudF0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSBcInN0cmluZ1wiKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGZpZWxkQm9vc3QgPSB0aGlzLmZpZWxkQm9vc3RzW2ZpZWxkXSB8fCAxO1xuICAgICAgICBjb25zdCB7IHRva2VucyB9ID0gdGhpcy50b2tlbml6ZXIudG9rZW5pemUoY29udGVudCk7XG4gICAgICAgIGNvbnN0IGZpZWxkTGVuZ3RoID0gdG9rZW5zLmxlbmd0aCAqIGZpZWxkQm9vc3Q7XG4gICAgICAgIGN1cnJlbnREb2NMZW5ndGggKz0gZmllbGRMZW5ndGg7XG4gICAgICAgIHRva2Vucy5mb3JFYWNoKCh0ZXJtKSA9PiB7XG4gICAgICAgICAgaWYgKCF0ZXJtVG9JbmRleC5oYXModGVybSkpIHtcbiAgICAgICAgICAgIHRlcm1Ub0luZGV4LnNldCh0ZXJtLCBuZXh0VGVybUluZGV4KyspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0ZXJtSW5kZXhWYWwgPSB0ZXJtVG9JbmRleC5nZXQodGVybSk7XG4gICAgICAgICAgaWYgKCF0ZXJtRG9jcy5oYXModGVybSkpIHtcbiAgICAgICAgICAgIHRlcm1Eb2NzLnNldCh0ZXJtLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGVybURvY3MuZ2V0KHRlcm0pLmFkZChkb2NJbmRleCk7XG4gICAgICAgICAgY29uc3QgY3VycmVudEZyZXEgPSBkb2NUZXJtRnJlcXVlbmNpZXMuZ2V0KHRlcm1JbmRleFZhbCkgfHwgMDtcbiAgICAgICAgICBkb2NUZXJtRnJlcXVlbmNpZXMuc2V0KHRlcm1JbmRleFZhbCwgY3VycmVudEZyZXEgKyBmaWVsZEJvb3N0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGRvY3VtZW50TGVuZ3Roc1tkb2NJbmRleF0gPSBjdXJyZW50RG9jTGVuZ3RoO1xuICAgICAgdG90YWxEb2NMZW5ndGggKz0gY3VycmVudERvY0xlbmd0aDtcbiAgICAgIGRvY1Rlcm1GcmVxdWVuY2llcy5mb3JFYWNoKChmcmVxLCB0ZXJtSW5kZXhWYWwpID0+IHtcbiAgICAgICAgaWYgKCF0ZXJtRnJlcXVlbmNpZXMuaGFzKHRlcm1JbmRleFZhbCkpIHtcbiAgICAgICAgICB0ZXJtRnJlcXVlbmNpZXMuc2V0KHRlcm1JbmRleFZhbCwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybUZyZXF1ZW5jaWVzLmdldCh0ZXJtSW5kZXhWYWwpLnNldChkb2NJbmRleCwgZnJlcSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBkb2N1bWVudEZyZXF1ZW5jeSA9IG5ldyBVaW50MzJBcnJheSh0ZXJtVG9JbmRleC5zaXplKTtcbiAgICB0ZXJtRG9jcy5mb3JFYWNoKChkb2NzU2V0LCB0ZXJtKSA9PiB7XG4gICAgICBjb25zdCB0ZXJtSW5kZXhWYWwgPSB0ZXJtVG9JbmRleC5nZXQodGVybSk7XG4gICAgICBkb2N1bWVudEZyZXF1ZW5jeVt0ZXJtSW5kZXhWYWxdID0gZG9jc1NldC5zaXplO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBkb2N1bWVudExlbmd0aHMsXG4gICAgICB0ZXJtVG9JbmRleCxcbiAgICAgIGRvY3VtZW50RnJlcXVlbmN5LFxuICAgICAgYXZlcmFnZURvY0xlbmd0aDogbnVtRG9jcyA+IDAgPyB0b3RhbERvY0xlbmd0aCAvIG51bURvY3MgOiAwLFxuICAgICAgdGVybUZyZXF1ZW5jaWVzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVjYWxjdWxhdGVzIHRoZSBhdmVyYWdlIGRvY3VtZW50IGxlbmd0aCBiYXNlZCBvbiB0aGUgY3VycmVudCBgZG9jdW1lbnRMZW5ndGhzYC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNhbGN1bGF0ZUF2ZXJhZ2VMZW5ndGgoKSB7XG4gICAgaWYgKHRoaXMuZG9jdW1lbnRMZW5ndGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5hdmVyYWdlRG9jTGVuZ3RoID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdG90YWxMZW5ndGggPSBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwoXG4gICAgICB0aGlzLmRvY3VtZW50TGVuZ3RocyxcbiAgICAgIChzdW0sIGxlbikgPT4gc3VtICsgbGVuLFxuICAgICAgMFxuICAgICk7XG4gICAgdGhpcy5hdmVyYWdlRG9jTGVuZ3RoID0gdG90YWxMZW5ndGggLyB0aGlzLmRvY3VtZW50TGVuZ3Rocy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIFNlYXJjaGVzIHRoZSBpbmRleGVkIGRvY3VtZW50cyBmb3IgYSBnaXZlbiBxdWVyeSBzdHJpbmcgdXNpbmcgdGhlIEJNMjUgcmFua2luZyBmb3JtdWxhLlxuICAgKlxuICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgc2VhcmNoIHF1ZXJ5IHRleHQuXG4gICAqIEBwYXJhbSB0b3BLIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRvcC1zY29yaW5nIHJlc3VsdHMgdG8gcmV0dXJuLiBEZWZhdWx0cyB0byAxMC5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYFNlYXJjaFJlc3VsdGAgb2JqZWN0cywgc29ydGVkIGJ5IGRlc2NlbmRpbmcgQk0yNSBzY29yZS5cbiAgICovXG4gIHNlYXJjaChxdWVyeSwgdG9wSyA9IDEwKSB7XG4gICAgY29uc3QgeyB0b2tlbnM6IHF1ZXJ5VG9rZW5zIH0gPSB0aGlzLnRva2VuaXplci50b2tlbml6ZShxdWVyeSk7XG4gICAgY29uc3Qgc2NvcmVzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmRvY3VtZW50TGVuZ3Rocy5sZW5ndGgpLmZpbGwoMCk7XG4gICAgcXVlcnlUb2tlbnMuZm9yRWFjaCgodGVybSkgPT4ge1xuICAgICAgY29uc3QgdGVybUluZGV4ID0gdGhpcy50ZXJtVG9JbmRleC5nZXQodGVybSk7XG4gICAgICBpZiAodGVybUluZGV4ID09PSB2b2lkIDApIHJldHVybjtcbiAgICAgIGNvbnN0IGlkZiA9IHRoaXMuY2FsY3VsYXRlSWRmKHRlcm1JbmRleCk7XG4gICAgICBpZiAoaWRmIDw9IDApIHJldHVybjtcbiAgICAgIGNvbnN0IHRlcm1GcmVxc0luRG9jcyA9IHRoaXMudGVybUZyZXF1ZW5jaWVzLmdldCh0ZXJtSW5kZXgpO1xuICAgICAgaWYgKCF0ZXJtRnJlcXNJbkRvY3MpIHJldHVybjtcbiAgICAgIHRlcm1GcmVxc0luRG9jcy5mb3JFYWNoKCh0ZiwgZG9jSW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZG9jTGVuZ3RoID0gdGhpcy5kb2N1bWVudExlbmd0aHNbZG9jSW5kZXhdO1xuICAgICAgICBjb25zdCBudW1lcmF0b3IgPSB0ZiAqICh0aGlzLnRlcm1GcmVxdWVuY3lTYXR1cmF0aW9uICsgMSk7XG4gICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gdGYgKyB0aGlzLnRlcm1GcmVxdWVuY3lTYXR1cmF0aW9uICogKDEgLSB0aGlzLmxlbmd0aE5vcm1hbGl6YXRpb25GYWN0b3IgKyB0aGlzLmxlbmd0aE5vcm1hbGl6YXRpb25GYWN0b3IgKiBkb2NMZW5ndGggLyB0aGlzLmF2ZXJhZ2VEb2NMZW5ndGgpO1xuICAgICAgICBzY29yZXNbZG9jSW5kZXhdICs9IGlkZiAqIChudW1lcmF0b3IgLyBkZW5vbWluYXRvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogc2NvcmVzLmxlbmd0aCB9LCAoXywgaSkgPT4gKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgc2NvcmU6IHNjb3Jlc1tpXVxuICAgICAgLy8gT3B0aW9uYWxseSBhZGQ6IGRvYzogdGhpcy5nZXREb2N1bWVudChpKSAvLyBJZiB5b3Ugd2FudCB0aGUgZnVsbCBkb2MgaW4gcmVzdWx0c1xuICAgIH0pKS5maWx0ZXIoKHJlc3VsdCkgPT4gcmVzdWx0LnNjb3JlID4gMCkuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpLnNsaWNlKDAsIHRvcEspO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgYW4gZXhhY3QgcGhyYXNlIHdpdGhpbiB0aGUgaW5kZXhlZCBkb2N1bWVudHMuXG4gICAqIFJhbmtzIGRvY3VtZW50cyBjb250YWluaW5nIHRoZSBleGFjdCBzZXF1ZW5jZSBvZiB0b2tlbnMgaGlnaGVyLlxuICAgKiBOb3RlOiBUaGlzIGlzIGEgYmFzaWMgaW1wbGVtZW50YXRpb24uIE1vcmUgc29waGlzdGljYXRlZCBwaHJhc2Ugc2VhcmNoIG1pZ2h0IGNvbnNpZGVyIHByb3hpbWl0eS5cbiAgICpcbiAgICogQHBhcmFtIHBocmFzZSAtIFRoZSBleGFjdCBwaHJhc2UgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHRvcEsgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVzdWx0cyB0byByZXR1cm4uIERlZmF1bHRzIHRvIDEwLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBgU2VhcmNoUmVzdWx0YCBvYmplY3RzLCBzb3J0ZWQgYnkgc2NvcmUsIGZvciBkb2N1bWVudHMgY29udGFpbmluZyB0aGUgcGhyYXNlLlxuICAgKi9cbiAgc2VhcmNoUGhyYXNlKHBocmFzZSwgdG9wSyA9IDEwKSB7XG4gICAgY29uc3QgeyB0b2tlbnM6IHBocmFzZVRva2VucyB9ID0gdGhpcy50b2tlbml6ZXIudG9rZW5pemUocGhyYXNlKTtcbiAgICBpZiAocGhyYXNlVG9rZW5zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIGxldCBjYW5kaWRhdGVEb2NzID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHRlcm0gb2YgcGhyYXNlVG9rZW5zKSB7XG4gICAgICBjb25zdCB0ZXJtSW5kZXggPSB0aGlzLnRlcm1Ub0luZGV4LmdldCh0ZXJtKTtcbiAgICAgIGlmICh0ZXJtSW5kZXggPT09IHZvaWQgMCkgcmV0dXJuIFtdO1xuICAgICAgY29uc3QgZG9jc0NvbnRhaW5pbmdUZXJtSXRlciA9IHRoaXMudGVybUZyZXF1ZW5jaWVzLmdldCh0ZXJtSW5kZXgpPy5rZXlzKCk7XG4gICAgICBpZiAoIWRvY3NDb250YWluaW5nVGVybUl0ZXIpIHJldHVybiBbXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRUZXJtRG9jcyA9IG5ldyBTZXQoZG9jc0NvbnRhaW5pbmdUZXJtSXRlcik7XG4gICAgICBpZiAoY2FuZGlkYXRlRG9jcyA9PT0gbnVsbCkge1xuICAgICAgICBjYW5kaWRhdGVEb2NzID0gY3VycmVudFRlcm1Eb2NzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuZGlkYXRlRG9jcyA9IG5ldyBTZXQoWy4uLmNhbmRpZGF0ZURvY3NdLmZpbHRlcigoZG9jSWR4KSA9PiBjdXJyZW50VGVybURvY3MuaGFzKGRvY0lkeCkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGVEb2NzLnNpemUgPT09IDApIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGNhbmRpZGF0ZURvY3MgPT09IG51bGwgfHwgY2FuZGlkYXRlRG9jcy5zaXplID09PSAwKSByZXR1cm4gW107XG4gICAgY29uc3Qgc2NvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjYW5kaWRhdGVEb2NzLmZvckVhY2goKGRvY0luZGV4KSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLmdldERvY3VtZW50KGRvY0luZGV4KTtcbiAgICAgIGxldCBwaHJhc2VGb3VuZEluRG9jID0gZmFsc2U7XG4gICAgICBPYmplY3QuZW50cmllcyhkb2MpLmZvckVhY2goKFtmaWVsZCwgY29udGVudF0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSBcInN0cmluZ1wiIHx8IHBocmFzZUZvdW5kSW5Eb2MpIHJldHVybjtcbiAgICAgICAgY29uc3QgZmllbGRCb29zdCA9IHRoaXMuZmllbGRCb29zdHNbZmllbGRdIHx8IDE7XG4gICAgICAgIGNvbnN0IHsgdG9rZW5zOiBkb2NUb2tlbnMgfSA9IHRoaXMudG9rZW5pemVyLnRva2VuaXplKGNvbnRlbnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBkb2NUb2tlbnMubGVuZ3RoIC0gcGhyYXNlVG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBocmFzZVRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGRvY1Rva2Vuc1tpICsgal0gIT09IHBocmFzZVRva2Vuc1tqXSkge1xuICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBwaHJhc2VTY29yZVZhbCA9IHRoaXMuY2FsY3VsYXRlUGhyYXNlU2NvcmUocGhyYXNlVG9rZW5zLCBkb2NJbmRleCkgKiBmaWVsZEJvb3N0O1xuICAgICAgICAgICAgc2NvcmVzLnNldChkb2NJbmRleCwgKHNjb3Jlcy5nZXQoZG9jSW5kZXgpIHx8IDApICsgcGhyYXNlU2NvcmVWYWwpO1xuICAgICAgICAgICAgcGhyYXNlRm91bmRJbkRvYyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHNjb3Jlcy5lbnRyaWVzKCkpLm1hcCgoW2luZGV4LCBzY29yZV0pID0+ICh7IGluZGV4LCBzY29yZSB9KSkuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpLnNsaWNlKDAsIHRvcEspO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGEgQk0yNS1saWtlIHNjb3JlIGZvciBhIHNlcXVlbmNlIG9mIHBocmFzZSB0b2tlbnMgd2l0aGluIGEgc3BlY2lmaWMgZG9jdW1lbnQuXG4gICAqIFN1bXMgdGhlIGluZGl2aWR1YWwgQk0yNSBzY29yZXMgb2YgdGhlIHRlcm1zIGluIHRoZSBwaHJhc2UgZm9yIHRoYXQgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSBwaHJhc2VUb2tlbnMgLSBUaGUgdG9rZW5pemVkIHBocmFzZS5cbiAgICogQHBhcmFtIGRvY0luZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBkb2N1bWVudCB0byBzY29yZSBhZ2FpbnN0LlxuICAgKiBAcmV0dXJucyBUaGUgY2FsY3VsYXRlZCBwaHJhc2Ugc2NvcmUgZm9yIHRoZSBkb2N1bWVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBjYWxjdWxhdGVQaHJhc2VTY29yZShwaHJhc2VUb2tlbnMsIGRvY0luZGV4KSB7XG4gICAgcmV0dXJuIHBocmFzZVRva2Vucy5yZWR1Y2UoKGN1cnJlbnRTY29yZSwgdGVybSkgPT4ge1xuICAgICAgY29uc3QgdGVybUluZGV4ID0gdGhpcy50ZXJtVG9JbmRleC5nZXQodGVybSk7XG4gICAgICBpZiAodGVybUluZGV4ID09PSB2b2lkIDApIHJldHVybiBjdXJyZW50U2NvcmU7XG4gICAgICBjb25zdCBpZGYgPSB0aGlzLmNhbGN1bGF0ZUlkZih0ZXJtSW5kZXgpO1xuICAgICAgY29uc3QgdGYgPSB0aGlzLnRlcm1GcmVxdWVuY2llcy5nZXQodGVybUluZGV4KT8uZ2V0KGRvY0luZGV4KSB8fCAwO1xuICAgICAgY29uc3QgZG9jTGVuZ3RoID0gdGhpcy5kb2N1bWVudExlbmd0aHNbZG9jSW5kZXhdO1xuICAgICAgY29uc3QgbnVtZXJhdG9yID0gdGYgKiAodGhpcy50ZXJtRnJlcXVlbmN5U2F0dXJhdGlvbiArIDEpO1xuICAgICAgY29uc3QgZGVub21pbmF0b3IgPSB0ZiArIHRoaXMudGVybUZyZXF1ZW5jeVNhdHVyYXRpb24gKiAoMSAtIHRoaXMubGVuZ3RoTm9ybWFsaXphdGlvbkZhY3RvciArIHRoaXMubGVuZ3RoTm9ybWFsaXphdGlvbkZhY3RvciAqIGRvY0xlbmd0aCAvIHRoaXMuYXZlcmFnZURvY0xlbmd0aCk7XG4gICAgICByZXR1cm4gY3VycmVudFNjb3JlICsgaWRmICogKG51bWVyYXRvciAvIGRlbm9taW5hdG9yKTtcbiAgICB9LCAwKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHNpbmdsZSBuZXcgZG9jdW1lbnQgdG8gdGhlIGluZGV4LlxuICAgKiBVcGRhdGVzIGFsbCBpbnRlcm5hbCBpbmRleCBzdHJ1Y3R1cmVzIGluY3JlbWVudGFsbHkuXG4gICAqIE5vdGU6IEZvciBhZGRpbmcgbWFueSBkb2N1bWVudHMsIGBhZGREb2N1bWVudHNQYXJhbGxlbGAgaXMgZ2VuZXJhbGx5IG1vcmUgZWZmaWNpZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZG9jIC0gVGhlIGRvY3VtZW50IG9iamVjdCAod2l0aCBzdHJpbmcgZmllbGRzKSB0byBhZGQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZG9jdW1lbnQgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBhc3luYyBhZGREb2N1bWVudChkb2MpIHtcbiAgICBpZiAoIWRvYykgdGhyb3cgbmV3IEVycm9yKFwiRG9jdW1lbnQgY2Fubm90IGJlIG51bGxcIik7XG4gICAgY29uc3QgZG9jSW5kZXggPSB0aGlzLmRvY3VtZW50TGVuZ3Rocy5sZW5ndGg7XG4gICAgdGhpcy5kb2N1bWVudHMucHVzaChkb2MpO1xuICAgIGNvbnN0IG5ld0RvY0xlbmd0aHMgPSBuZXcgVWludDMyQXJyYXkoZG9jSW5kZXggKyAxKTtcbiAgICBuZXdEb2NMZW5ndGhzLnNldCh0aGlzLmRvY3VtZW50TGVuZ3RocywgMCk7XG4gICAgdGhpcy5kb2N1bWVudExlbmd0aHMgPSBuZXdEb2NMZW5ndGhzO1xuICAgIGxldCBjdXJyZW50RG9jTGVuZ3RoID0gMDtcbiAgICBjb25zdCBkb2NUZXJtRnJlcXVlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIE9iamVjdC5lbnRyaWVzKGRvYykuZm9yRWFjaCgoW2ZpZWxkLCBjb250ZW50XSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSBcInN0cmluZ1wiKSByZXR1cm47XG4gICAgICBjb25zdCBmaWVsZEJvb3N0ID0gdGhpcy5maWVsZEJvb3N0c1tmaWVsZF0gfHwgMTtcbiAgICAgIGNvbnN0IHsgdG9rZW5zIH0gPSB0aGlzLnRva2VuaXplci50b2tlbml6ZShjb250ZW50KTtcbiAgICAgIGN1cnJlbnREb2NMZW5ndGggKz0gdG9rZW5zLmxlbmd0aCAqIGZpZWxkQm9vc3Q7XG4gICAgICB0b2tlbnMuZm9yRWFjaCgodGVybSkgPT4ge1xuICAgICAgICBsZXQgdGVybUluZGV4VmFsO1xuICAgICAgICBpZiAoIXRoaXMudGVybVRvSW5kZXguaGFzKHRlcm0pKSB7XG4gICAgICAgICAgdGVybUluZGV4VmFsID0gdGhpcy50ZXJtVG9JbmRleC5zaXplO1xuICAgICAgICAgIHRoaXMudGVybVRvSW5kZXguc2V0KHRlcm0sIHRlcm1JbmRleFZhbCk7XG4gICAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRGcmVxdWVuY3kubGVuZ3RoIDw9IHRlcm1JbmRleFZhbCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkRGYgPSB0aGlzLmRvY3VtZW50RnJlcXVlbmN5O1xuICAgICAgICAgICAgY29uc3QgbmV3U2l6ZSA9IE1hdGgubWF4KHRlcm1JbmRleFZhbCArIDEsIG9sZERmLmxlbmd0aCAqIDIgfHwgMSk7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50RnJlcXVlbmN5ID0gbmV3IFVpbnQzMkFycmF5KG5ld1NpemUpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudEZyZXF1ZW5jeS5zZXQob2xkRGYsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRvY3VtZW50RnJlcXVlbmN5W3Rlcm1JbmRleFZhbF0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlcm1JbmRleFZhbCA9IHRoaXMudGVybVRvSW5kZXguZ2V0KHRlcm0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGcmVxID0gZG9jVGVybUZyZXF1ZW5jaWVzLmdldCh0ZXJtSW5kZXhWYWwpIHx8IDA7XG4gICAgICAgIGRvY1Rlcm1GcmVxdWVuY2llcy5zZXQodGVybUluZGV4VmFsLCBjdXJyZW50RnJlcSArIGZpZWxkQm9vc3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5kb2N1bWVudExlbmd0aHNbZG9jSW5kZXhdID0gY3VycmVudERvY0xlbmd0aDtcbiAgICBkb2NUZXJtRnJlcXVlbmNpZXMuZm9yRWFjaCgoZnJlcSwgdGVybUluZGV4VmFsKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudGVybUZyZXF1ZW5jaWVzLmhhcyh0ZXJtSW5kZXhWYWwpKSB7XG4gICAgICAgIHRoaXMudGVybUZyZXF1ZW5jaWVzLnNldCh0ZXJtSW5kZXhWYWwsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXJtRnJlcXVlbmNpZXMuZ2V0KHRlcm1JbmRleFZhbCkuc2V0KGRvY0luZGV4LCBmcmVxKTtcbiAgICAgIGlmICh0ZXJtSW5kZXhWYWwgPCB0aGlzLmRvY3VtZW50RnJlcXVlbmN5Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50RnJlcXVlbmN5W3Rlcm1JbmRleFZhbF0rKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYEVycm9yOiB0ZXJtSW5kZXhWYWwgJHt0ZXJtSW5kZXhWYWx9IGlzIG91dCBvZiBib3VuZHMgZm9yIGRvY3VtZW50RnJlcXVlbmN5IChsZW5ndGggJHt0aGlzLmRvY3VtZW50RnJlcXVlbmN5Lmxlbmd0aH0pLiBUaGlzIGluZGljYXRlcyBhbiBpc3N1ZSB3aXRoIGFycmF5IHJlc2l6aW5nIG9yIHRlcm0gaW5kZXhpbmcuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVjYWxjdWxhdGVBdmVyYWdlTGVuZ3RoKCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIEludmVyc2UgRG9jdW1lbnQgRnJlcXVlbmN5IChJREYpIGZvciBhIGdpdmVuIHRlcm0gaW5kZXguXG4gICAqIFVzZXMgdGhlIEJNMjUgSURGIGZvcm11bGE6IGxvZygxICsgKE4gLSBuICsgMC41KSAvIChuICsgMC41KSlcbiAgICogd2hlcmUgTiBpcyB0aGUgdG90YWwgbnVtYmVyIG9mIGRvY3VtZW50cyBhbmQgbiBpcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50c1xuICAgKiBjb250YWluaW5nIHRoZSB0ZXJtLiBUaGUgKzEgc21vb3RocyB0aGUgbG9nYXJpdGhtLlxuICAgKlxuICAgKiBAcGFyYW0gdGVybUluZGV4IC0gVGhlIGludGVnZXIgaW5kZXggb2YgdGhlIHRlcm0uXG4gICAqIEByZXR1cm5zIFRoZSBJREYgc2NvcmUgZm9yIHRoZSB0ZXJtLiBSZXR1cm5zIDAgaWYgdGhlIHRlcm0gaXMgbm90IGZvdW5kIG9yIGhhcyAwIERGLlxuICAgKi9cbiAgY2FsY3VsYXRlSWRmKHRlcm1JbmRleCkge1xuICAgIGlmICh0ZXJtSW5kZXggPCAwIHx8IHRlcm1JbmRleCA+PSB0aGlzLmRvY3VtZW50RnJlcXVlbmN5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGRvY0ZyZXEgPSB0aGlzLmRvY3VtZW50RnJlcXVlbmN5W3Rlcm1JbmRleF07XG4gICAgaWYgKGRvY0ZyZXEgPD0gMCB8fCBkb2NGcmVxID4gdGhpcy5kb2N1bWVudExlbmd0aHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgTiA9IHRoaXMuZG9jdW1lbnRMZW5ndGhzLmxlbmd0aDtcbiAgICBjb25zdCBudW1lcmF0b3IgPSBOIC0gZG9jRnJlcSArIDAuNTtcbiAgICBjb25zdCBkZW5vbWluYXRvciA9IGRvY0ZyZXEgKyAwLjU7XG4gICAgcmV0dXJuIE1hdGgubG9nKDEgKyBudW1lcmF0b3IgLyBkZW5vbWluYXRvcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdGVybSBmcmVxdWVuY3kgKFRGKSBmb3IgYSBzcGVjaWZpYyB0ZXJtIGluIGEgc3BlY2lmaWMgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSB0ZXJtSW5kZXggLSBUaGUgaW50ZWdlciBpbmRleCBvZiB0aGUgdGVybS5cbiAgICogQHBhcmFtIGRvY0luZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBkb2N1bWVudC5cbiAgICogQHJldHVybnMgVGhlIHRlcm0gZnJlcXVlbmN5LCBvciAwIGlmIHRoZSB0ZXJtIGlzIG5vdCBpbiB0aGUgZG9jdW1lbnQgb3IgaW5kaWNlcyBhcmUgaW52YWxpZC5cbiAgICovXG4gIGdldFRlcm1GcmVxdWVuY3kodGVybUluZGV4LCBkb2NJbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRlcm1GcmVxdWVuY2llcy5nZXQodGVybUluZGV4KT8uZ2V0KGRvY0luZGV4KSB8fCAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIG9yaWdpbmFsIGRvY3VtZW50IG9iamVjdCBzdG9yZWQgYXQgYSBnaXZlbiBpbmRleC5cbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBkb2N1bWVudCB0byByZXRyaWV2ZS5cbiAgICogQHJldHVybnMgVGhlIGRvY3VtZW50IG9iamVjdC5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzLlxuICAgKi9cbiAgZ2V0RG9jdW1lbnQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuZG9jdW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEb2N1bWVudCBpbmRleCAke2luZGV4fSBvdXQgb2YgYm91bmRzICgwLSR7dGhpcy5kb2N1bWVudHMubGVuZ3RoIC0gMX0pYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRvY3VtZW50c1tpbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgaW5kZXhlZCBkb2N1bWVudHMgYW5kIHJlc2V0cyB0aGUgQk0yNSBpbnN0YW5jZSB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICovXG4gIGNsZWFyRG9jdW1lbnRzKCkge1xuICAgIHRoaXMuZG9jdW1lbnRzID0gW107XG4gICAgdGhpcy5kb2N1bWVudExlbmd0aHMgPSBuZXcgVWludDMyQXJyYXkoMCk7XG4gICAgdGhpcy50ZXJtVG9JbmRleC5jbGVhcigpO1xuICAgIHRoaXMuZG9jdW1lbnRGcmVxdWVuY3kgPSBuZXcgVWludDMyQXJyYXkoMCk7XG4gICAgdGhpcy5hdmVyYWdlRG9jTGVuZ3RoID0gMDtcbiAgICB0aGlzLnRlcm1GcmVxdWVuY2llcy5jbGVhcigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2YgZG9jdW1lbnRzIGN1cnJlbnRseSBpbmRleGVkLlxuICAgKiBAcmV0dXJucyBUaGUgZG9jdW1lbnQgY291bnQuXG4gICAqL1xuICBnZXREb2N1bWVudENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50cy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgbXVsdGlwbGUgZG9jdW1lbnRzIHNlcXVlbnRpYWxseSBieSBjYWxsaW5nIGBhZGREb2N1bWVudGAgZm9yIGVhY2guXG4gICAqIFRoaXMgbWV0aG9kIHByb2Nlc3NlcyBkb2N1bWVudHMgc2VxdWVudGlhbGx5IGluIHRoZSBtYWluIHRocmVhZC5cbiAgICogQHBhcmFtIGRvY3MgLSBBbiBhcnJheSBvZiBkb2N1bWVudHMgdG8gYWRkLlxuICAgKi9cbiAgYXN5bmMgYWRkRG9jdW1lbnRzKGRvY3MpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZG9jcy5tYXAoKGRvYykgPT4gdGhpcy5hZGREb2N1bWVudChkb2MpKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9ydW50aW1lLnRzXG52YXIgZW52aXJvbm1lbnRTZXR0aW5ncyA9IHt9O1xudmFyIFNlbWFwaG9yZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY291bnQpIHtcbiAgICB0aGlzLndhaXRpbmcgPSBbXTtcbiAgICB0aGlzLnBlcm1pdHMgPSBjb3VudDtcbiAgfVxuICBhc3luYyBhY3F1aXJlKCkge1xuICAgIGlmICh0aGlzLnBlcm1pdHMgPiAwKSB7XG4gICAgICB0aGlzLnBlcm1pdHMgLT0gMTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLndhaXRpbmcucHVzaChyZXNvbHZlKTtcbiAgICB9KTtcbiAgfVxuICByZWxlYXNlKCkge1xuICAgIHRoaXMucGVybWl0cyArPSAxO1xuICAgIGNvbnN0IG5leHRSZXNvbHZlID0gdGhpcy53YWl0aW5nLnNoaWZ0KCk7XG4gICAgaWYgKG5leHRSZXNvbHZlICYmIHRoaXMucGVybWl0cyA+IDApIHtcbiAgICAgIHRoaXMucGVybWl0cyAtPSAxO1xuICAgICAgbmV4dFJlc29sdmUoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgQWdlbnRSdW50aW1lID0gY2xhc3Mge1xuICAvLyBEZWZhdWx0IHZhbHVlLCBjYW4gYmUgb3ZlcnJpZGRlblxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy4jY29udmVyc2F0aW9uTGVuZ3RoID0gMzI7XG4gICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgdGhpcy5ldmFsdWF0b3JzID0gW107XG4gICAgdGhpcy5wcm92aWRlcnMgPSBbXTtcbiAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zdGF0ZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gICAgdGhpcy5zZXJ2aWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zZXJ2aWNlVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMubW9kZWxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnJvdXRlcyA9IFtdO1xuICAgIHRoaXMudGFza1dvcmtlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuc2VuZEhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8vIEEgbWFwIG9mIGFsbCBwbHVnaW5zIGF2YWlsYWJsZSB0byB0aGUgcnVudGltZSwga2V5ZWQgYnkgbmFtZSwgZm9yIGRlcGVuZGVuY3kgcmVzb2x1dGlvbi5cbiAgICB0aGlzLmFsbEF2YWlsYWJsZVBsdWdpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8vIFRoZSBpbml0aWFsIGxpc3Qgb2YgcGx1Z2lucyBzcGVjaWZpZWQgYnkgdGhlIGNoYXJhY3RlciBjb25maWd1cmF0aW9uLlxuICAgIHRoaXMuY2hhcmFjdGVyUGx1Z2lucyA9IFtdO1xuICAgIHRoaXMuc2VydmljZXNJbml0UXVldWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMubWF4V29ya2luZ01lbW9yeUVudHJpZXMgPSA1MDtcbiAgICB0aGlzLmFnZW50SWQgPSBvcHRzLmNoYXJhY3Rlcj8uaWQgPz8gb3B0cz8uYWdlbnRJZCA/PyBzdHJpbmdUb1V1aWQob3B0cy5jaGFyYWN0ZXI/Lm5hbWUgPz8gdXVpZHY0KCkgKyBvcHRzLmNoYXJhY3Rlcj8udXNlcm5hbWUpO1xuICAgIHRoaXMuY2hhcmFjdGVyID0gb3B0cy5jaGFyYWN0ZXI7XG4gICAgY29uc3QgbG9nTGV2ZWwgPSBwcm9jZXNzLmVudi5MT0dfTEVWRUwgfHwgXCJpbmZvXCI7XG4gICAgdGhpcy5sb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgYWdlbnROYW1lOiB0aGlzLmNoYXJhY3Rlcj8ubmFtZSxcbiAgICAgIGxvZ0xldmVsXG4gICAgfSk7XG4gICAgdGhpcy4jY29udmVyc2F0aW9uTGVuZ3RoID0gb3B0cy5jb252ZXJzYXRpb25MZW5ndGggPz8gdGhpcy4jY29udmVyc2F0aW9uTGVuZ3RoO1xuICAgIGlmIChvcHRzLmFkYXB0ZXIpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJEYXRhYmFzZUFkYXB0ZXIob3B0cy5hZGFwdGVyKTtcbiAgICB9XG4gICAgdGhpcy5mZXRjaCA9IG9wdHMuZmV0Y2ggPz8gdGhpcy5mZXRjaDtcbiAgICB0aGlzLnNldHRpbmdzID0gb3B0cy5zZXR0aW5ncyA/PyBlbnZpcm9ubWVudFNldHRpbmdzO1xuICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgIHRoaXMuY2hhcmFjdGVyUGx1Z2lucyA9IG9wdHM/LnBsdWdpbnMgPz8gW107XG4gICAgaWYgKG9wdHMuYWxsQXZhaWxhYmxlUGx1Z2lucykge1xuICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2Ygb3B0cy5hbGxBdmFpbGFibGVQbHVnaW5zKSB7XG4gICAgICAgIGlmIChwbHVnaW4/Lm5hbWUpIHtcbiAgICAgICAgICB0aGlzLmFsbEF2YWlsYWJsZVBsdWdpbnMuc2V0KHBsdWdpbi5uYW1lLCBwbHVnaW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBTdWNjZXNzOiBBZ2VudCBJRDogJHt0aGlzLmFnZW50SWR9YCk7XG4gICAgdGhpcy5jdXJyZW50UnVuSWQgPSB2b2lkIDA7XG4gICAgaWYgKG9wdHMuc2V0dGluZ3M/Lk1BWF9XT1JLSU5HX01FTU9SWV9FTlRSSUVTKSB7XG4gICAgICB0aGlzLm1heFdvcmtpbmdNZW1vcnlFbnRyaWVzID0gcGFyc2VJbnQob3B0cy5zZXR0aW5ncy5NQVhfV09SS0lOR19NRU1PUllfRU5UUklFUywgMTApIHx8IDUwO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTUFYX1dPUktJTkdfTUVNT1JZX0VOVFJJRVMpIHtcbiAgICAgIHRoaXMubWF4V29ya2luZ01lbW9yeUVudHJpZXMgPSBwYXJzZUludChwcm9jZXNzLmVudi5NQVhfV09SS0lOR19NRU1PUllfRU5UUklFUywgMTApIHx8IDUwO1xuICAgIH1cbiAgfVxuICAjY29udmVyc2F0aW9uTGVuZ3RoO1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHJ1biBJRCBmb3IgdHJhY2tpbmcgYSBzZXF1ZW5jZSBvZiBtb2RlbCBjYWxsc1xuICAgKi9cbiAgY3JlYXRlUnVuSWQoKSB7XG4gICAgcmV0dXJuIHV1aWR2NCgpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBydW4gZm9yIHRyYWNraW5nIHByb21wdHNcbiAgICovXG4gIHN0YXJ0UnVuKCkge1xuICAgIHRoaXMuY3VycmVudFJ1bklkID0gdGhpcy5jcmVhdGVSdW5JZCgpO1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRSdW5JZDtcbiAgfVxuICAvKipcbiAgICogRW5kIHRoZSBjdXJyZW50IHJ1blxuICAgKi9cbiAgZW5kUnVuKCkge1xuICAgIHRoaXMuY3VycmVudFJ1bklkID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgcnVuIElEIChjcmVhdGVzIG9uZSBpZiBpdCBkb2Vzbid0IGV4aXN0KVxuICAgKi9cbiAgZ2V0Q3VycmVudFJ1bklkKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50UnVuSWQpIHtcbiAgICAgIHRoaXMuY3VycmVudFJ1bklkID0gdGhpcy5jcmVhdGVSdW5JZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50UnVuSWQ7XG4gIH1cbiAgYXN5bmMgcmVnaXN0ZXJQbHVnaW4ocGx1Z2luKSB7XG4gICAgaWYgKCFwbHVnaW4/Lm5hbWUpIHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gXCJQbHVnaW4gb3IgcGx1Z2luIG5hbWUgaXMgdW5kZWZpbmVkXCI7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgKioqIHJlZ2lzdGVyUGx1Z2luOiAke2Vycm9yTXNnfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAqKiogcmVnaXN0ZXJQbHVnaW46ICR7ZXJyb3JNc2d9YCk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nUGx1Z2luID0gdGhpcy5wbHVnaW5zLmZpbmQoKHApID0+IHAubmFtZSA9PT0gcGx1Z2luLm5hbWUpO1xuICAgIGlmIChleGlzdGluZ1BsdWdpbikge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgYCR7dGhpcy5jaGFyYWN0ZXIubmFtZX0oJHt0aGlzLmFnZW50SWR9KSAtIFBsdWdpbiAke3BsdWdpbi5uYW1lfSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuIFNraXBwaW5nIHJlLXJlZ2lzdHJhdGlvbi5gXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgYFN1Y2Nlc3M6IFBsdWdpbiAke3BsdWdpbi5uYW1lfSBhZGRlZCB0byBhY3RpdmUgcGx1Z2lucyBmb3IgJHt0aGlzLmNoYXJhY3Rlci5uYW1lfSgke3RoaXMuYWdlbnRJZH0pLmBcbiAgICApO1xuICAgIGlmIChwbHVnaW4uaW5pdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcGx1Z2luLmluaXQocGx1Z2luLmNvbmZpZyB8fCB7fSwgdGhpcyk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBTdWNjZXNzOiBQbHVnaW4gJHtwbHVnaW4ubmFtZX0gaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCJBUEkga2V5XCIpIHx8IGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcImVudmlyb25tZW50IHZhcmlhYmxlc1wiKSB8fCBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCJJbnZhbGlkIHBsdWdpbiBjb25maWd1cmF0aW9uXCIpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBQbHVnaW4gJHtwbHVnaW4ubmFtZX0gcmVxdWlyZXMgY29uZmlndXJhdGlvbi4gJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJQbGVhc2UgY2hlY2sgeW91ciBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYW5kIGVuc3VyZSBhbGwgcmVxdWlyZWQgQVBJIGtleXMgYXJlIHNldC5cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiWW91IGNhbiBzZXQgdGhlc2UgaW4geW91ciAuZW52IGZpbGUuXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwbHVnaW4uYWRhcHRlcikge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFJlZ2lzdGVyaW5nIGRhdGFiYXNlIGFkYXB0ZXIgZm9yIHBsdWdpbiAke3BsdWdpbi5uYW1lfWApO1xuICAgICAgdGhpcy5yZWdpc3RlckRhdGFiYXNlQWRhcHRlcihwbHVnaW4uYWRhcHRlcik7XG4gICAgfVxuICAgIGlmIChwbHVnaW4uYWN0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2YgcGx1Z2luLmFjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckFjdGlvbihhY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGx1Z2luLmV2YWx1YXRvcnMpIHtcbiAgICAgIGZvciAoY29uc3QgZXZhbHVhdG9yIG9mIHBsdWdpbi5ldmFsdWF0b3JzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmFsdWF0b3IoZXZhbHVhdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBsdWdpbi5wcm92aWRlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgcGx1Z2luLnByb3ZpZGVycykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGx1Z2luLm1vZGVscykge1xuICAgICAgZm9yIChjb25zdCBbbW9kZWxUeXBlLCBoYW5kbGVyXSBvZiBPYmplY3QuZW50cmllcyhwbHVnaW4ubW9kZWxzKSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTW9kZWwoXG4gICAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgcGx1Z2luLm5hbWUsXG4gICAgICAgICAgcGx1Z2luPy5wcmlvcml0eVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGx1Z2luLnJvdXRlcykge1xuICAgICAgZm9yIChjb25zdCByb3V0ZSBvZiBwbHVnaW4ucm91dGVzKSB7XG4gICAgICAgIHRoaXMucm91dGVzLnB1c2gocm91dGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGx1Z2luLmV2ZW50cykge1xuICAgICAgZm9yIChjb25zdCBbZXZlbnROYW1lLCBldmVudEhhbmRsZXJzXSBvZiBPYmplY3QuZW50cmllcyhwbHVnaW4uZXZlbnRzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50SGFuZGxlciBvZiBldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGx1Z2luLnNlcnZpY2VzKSB7XG4gICAgICBmb3IgKGNvbnN0IHNlcnZpY2Ugb2YgcGx1Z2luLnNlcnZpY2VzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlZ2lzdGVyU2VydmljZShzZXJ2aWNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlcnZpY2VzSW5pdFF1ZXVlLmFkZChzZXJ2aWNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRBbGxTZXJ2aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlcztcbiAgfVxuICBhc3luYyBzdG9wKCkge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBydW50aW1lOjpzdG9wIC0gY2hhcmFjdGVyICR7dGhpcy5jaGFyYWN0ZXIubmFtZX1gKTtcbiAgICBmb3IgKGNvbnN0IFtzZXJ2aWNlTmFtZSwgc2VydmljZXNdIG9mIHRoaXMuc2VydmljZXMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBydW50aW1lOjpzdG9wIC0gcmVxdWVzdGluZyBzZXJ2aWNlIHN0b3AgZm9yICR7c2VydmljZU5hbWV9YCk7XG4gICAgICBmb3IgKGNvbnN0IHNlcnZpY2Ugb2Ygc2VydmljZXMpIHtcbiAgICAgICAgYXdhaXQgc2VydmljZS5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcIkFnZW50IGFscmVhZHkgaW5pdGlhbGl6ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBsdWdpblJlZ2lzdHJhdGlvblByb21pc2VzID0gW107XG4gICAgY29uc3QgcGx1Z2luc1RvTG9hZCA9IHRoaXMuY2hhcmFjdGVyUGx1Z2lucztcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zVG9Mb2FkKSB7XG4gICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgIHBsdWdpblJlZ2lzdHJhdGlvblByb21pc2VzLnB1c2godGhpcy5yZWdpc3RlclBsdWdpbihwbHVnaW4pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocGx1Z2luUmVnaXN0cmF0aW9uUHJvbWlzZXMpO1xuICAgIGlmICghdGhpcy5hZGFwdGVyKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgXCJEYXRhYmFzZSBhZGFwdGVyIG5vdCBpbml0aWFsaXplZC4gTWFrZSBzdXJlIEBlbGl6YW9zL3BsdWdpbi1zcWwgaXMgaW5jbHVkZWQgaW4geW91ciBwbHVnaW5zLlwiXG4gICAgICApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkRhdGFiYXNlIGFkYXB0ZXIgbm90IGluaXRpYWxpemVkLiBUaGUgU1FMIHBsdWdpbiAoQGVsaXphb3MvcGx1Z2luLXNxbCkgaXMgcmVxdWlyZWQgZm9yIGFnZW50IGluaXRpYWxpemF0aW9uLiBQbGVhc2UgZW5zdXJlIGl0IGlzIGluY2x1ZGVkIGluIHlvdXIgY2hhcmFjdGVyIGNvbmZpZ3VyYXRpb24uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIuaW5pdCgpO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIlJ1bm5pbmcgcGx1Z2luIG1pZ3JhdGlvbnMuLi5cIik7XG4gICAgICBhd2FpdCB0aGlzLnJ1blBsdWdpbk1pZ3JhdGlvbnMoKTtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJQbHVnaW4gbWlncmF0aW9ucyBjb21wbGV0ZWQuXCIpO1xuICAgICAgY29uc3QgZXhpc3RpbmdBZ2VudCA9IGF3YWl0IHRoaXMuZW5zdXJlQWdlbnRFeGlzdHModGhpcy5jaGFyYWN0ZXIpO1xuICAgICAgaWYgKCFleGlzdGluZ0FnZW50KSB7XG4gICAgICAgIGNvbnN0IGVycm9yTXNnID0gYEFnZW50ICR7dGhpcy5jaGFyYWN0ZXIubmFtZX0gZG9lcyBub3QgZXhpc3QgaW4gZGF0YWJhc2UgYWZ0ZXIgZW5zdXJlQWdlbnRFeGlzdHMgY2FsbGA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICB9XG4gICAgICBsZXQgYWdlbnRFbnRpdHkgPSBhd2FpdCB0aGlzLmdldEVudGl0eUJ5SWQodGhpcy5hZ2VudElkKTtcbiAgICAgIGlmICghYWdlbnRFbnRpdHkpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IHRoaXMuY3JlYXRlRW50aXR5KHtcbiAgICAgICAgICBpZDogdGhpcy5hZ2VudElkLFxuICAgICAgICAgIG5hbWVzOiBbdGhpcy5jaGFyYWN0ZXIubmFtZV0sXG4gICAgICAgICAgbWV0YWRhdGE6IHt9LFxuICAgICAgICAgIGFnZW50SWQ6IGV4aXN0aW5nQWdlbnQuaWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY3JlYXRlZCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yTXNnID0gYEZhaWxlZCB0byBjcmVhdGUgZW50aXR5IGZvciBhZ2VudCAke3RoaXMuYWdlbnRJZH1gO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgYWdlbnRFbnRpdHkgPSBhd2FpdCB0aGlzLmdldEVudGl0eUJ5SWQodGhpcy5hZ2VudElkKTtcbiAgICAgICAgaWYgKCFhZ2VudEVudGl0eSkgdGhyb3cgbmV3IEVycm9yKGBBZ2VudCBlbnRpdHkgbm90IGZvdW5kIGZvciAke3RoaXMuYWdlbnRJZH1gKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFN1Y2Nlc3M6IEFnZW50IGVudGl0eSBjcmVhdGVkIHN1Y2Nlc3NmdWxseSBmb3IgJHt0aGlzLmNoYXJhY3Rlci5uYW1lfWApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1zZyA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGFnZW50IGVudGl0eTogJHtlcnJvck1zZ31gKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgcm9vbSA9IGF3YWl0IHRoaXMuZ2V0Um9vbSh0aGlzLmFnZW50SWQpO1xuICAgICAgaWYgKCFyb29tKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlUm9vbSh7XG4gICAgICAgICAgaWQ6IHRoaXMuYWdlbnRJZCxcbiAgICAgICAgICBuYW1lOiB0aGlzLmNoYXJhY3Rlci5uYW1lLFxuICAgICAgICAgIHNvdXJjZTogXCJlbGl6YW9zXCIsXG4gICAgICAgICAgdHlwZTogXCJTRUxGXCIgLyogU0VMRiAqLyxcbiAgICAgICAgICBjaGFubmVsSWQ6IHRoaXMuYWdlbnRJZCxcbiAgICAgICAgICBzZXJ2ZXJJZDogdGhpcy5hZ2VudElkLFxuICAgICAgICAgIHdvcmxkSWQ6IHRoaXMuYWdlbnRJZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IGF3YWl0IHRoaXMuYWRhcHRlci5nZXRQYXJ0aWNpcGFudHNGb3JSb29tKHRoaXMuYWdlbnRJZCk7XG4gICAgICBpZiAoIXBhcnRpY2lwYW50cy5pbmNsdWRlcyh0aGlzLmFnZW50SWQpKSB7XG4gICAgICAgIGNvbnN0IGFkZGVkID0gYXdhaXQgdGhpcy5hZGRQYXJ0aWNpcGFudCh0aGlzLmFnZW50SWQsIHRoaXMuYWdlbnRJZCk7XG4gICAgICAgIGlmICghYWRkZWQpIHtcbiAgICAgICAgICBjb25zdCBlcnJvck1zZyA9IGBGYWlsZWQgdG8gYWRkIGFnZW50ICR7dGhpcy5hZ2VudElkfSBhcyBwYXJ0aWNpcGFudCB0byBpdHMgb3duIHJvb21gO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEFnZW50ICR7dGhpcy5jaGFyYWN0ZXIubmFtZX0gbGlua2VkIHRvIGl0cyBvd24gcm9vbSBzdWNjZXNzZnVsbHlgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNc2cgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIGFkZCBhZ2VudCBhcyBwYXJ0aWNpcGFudDogJHtlcnJvck1zZ31gKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBlbWJlZGRpbmdNb2RlbCA9IHRoaXMuZ2V0TW9kZWwoTW9kZWxUeXBlLlRFWFRfRU1CRURESU5HKTtcbiAgICBpZiAoIWVtYmVkZGluZ01vZGVsKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICBgW0FnZW50UnVudGltZV1bJHt0aGlzLmNoYXJhY3Rlci5uYW1lfV0gTm8gVEVYVF9FTUJFRERJTkcgbW9kZWwgcmVnaXN0ZXJlZC4gU2tpcHBpbmcgZW1iZWRkaW5nIGRpbWVuc2lvbiBzZXR1cC5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCB0aGlzLmVuc3VyZUVtYmVkZGluZ0RpbWVuc2lvbigpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNlcnZpY2Ugb2YgdGhpcy5zZXJ2aWNlc0luaXRRdWV1ZSkge1xuICAgICAgYXdhaXQgdGhpcy5yZWdpc3RlclNlcnZpY2Uoc2VydmljZSk7XG4gICAgfVxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgYXN5bmMgcnVuUGx1Z2luTWlncmF0aW9ucygpIHtcbiAgICBjb25zdCBkcml6emxlID0gdGhpcy5hZGFwdGVyPy5kYjtcbiAgICBpZiAoIWRyaXp6bGUpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJEcml6emxlIGluc3RhbmNlIG5vdCBmb3VuZCBvbiBhZGFwdGVyLCBza2lwcGluZyBwbHVnaW4gbWlncmF0aW9ucy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBsdWdpbnNXaXRoU2NoZW1hcyA9IHRoaXMucGx1Z2lucy5maWx0ZXIoKHApID0+IHAuc2NoZW1hKTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKGBGb3VuZCAke3BsdWdpbnNXaXRoU2NoZW1hcy5sZW5ndGh9IHBsdWdpbnMgd2l0aCBzY2hlbWFzIHRvIG1pZ3JhdGUuYCk7XG4gICAgZm9yIChjb25zdCBwIG9mIHBsdWdpbnNXaXRoU2NoZW1hcykge1xuICAgICAgaWYgKHAuc2NoZW1hKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFJ1bm5pbmcgbWlncmF0aW9ucyBmb3IgcGx1Z2luOiAke3AubmFtZX1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodGhpcy5hZGFwdGVyICYmIFwicnVuTWlncmF0aW9uc1wiIGluIHRoaXMuYWRhcHRlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGFwdGVyLnJ1bk1pZ3JhdGlvbnMocC5zY2hlbWEsIHAubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBTdWNjZXNzZnVsbHkgbWlncmF0ZWQgcGx1Z2luOiAke3AubmFtZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBtaWdyYXRlIHBsdWdpbiAke3AubmFtZX06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENvbm5lY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIGFkYXB0ZXIgbm90IHJlZ2lzdGVyZWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuZ2V0Q29ubmVjdGlvbigpO1xuICB9XG4gIHNldFNldHRpbmcoa2V5LCB2YWx1ZSwgc2VjcmV0ID0gZmFsc2UpIHtcbiAgICBpZiAoc2VjcmV0KSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcmFjdGVyLnNlY3JldHMpIHtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXIuc2VjcmV0cyA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5jaGFyYWN0ZXIuc2VjcmV0c1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5jaGFyYWN0ZXIuc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXIuc2V0dGluZ3MgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hhcmFjdGVyLnNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0U2V0dGluZyhrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY2hhcmFjdGVyLnNlY3JldHM/LltrZXldIHx8IHRoaXMuY2hhcmFjdGVyLnNldHRpbmdzPy5ba2V5XSB8fCB0aGlzLmNoYXJhY3Rlci5zZXR0aW5ncz8uc2VjcmV0cz8uW2tleV0gfHwgdGhpcy5zZXR0aW5nc1trZXldO1xuICAgIGNvbnN0IGRlY3J5cHRlZFZhbHVlID0gZGVjcnlwdFN0cmluZ1ZhbHVlKHZhbHVlLCBnZXRTYWx0KCkpO1xuICAgIGlmIChkZWNyeXB0ZWRWYWx1ZSA9PT0gXCJ0cnVlXCIpIHJldHVybiB0cnVlO1xuICAgIGlmIChkZWNyeXB0ZWRWYWx1ZSA9PT0gXCJmYWxzZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGRlY3J5cHRlZFZhbHVlIHx8IG51bGw7XG4gIH1cbiAgZ2V0Q29udmVyc2F0aW9uTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNjb252ZXJzYXRpb25MZW5ndGg7XG4gIH1cbiAgcmVnaXN0ZXJEYXRhYmFzZUFkYXB0ZXIoYWRhcHRlcikge1xuICAgIGlmICh0aGlzLmFkYXB0ZXIpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgIFwiRGF0YWJhc2UgYWRhcHRlciBhbHJlYWR5IHJlZ2lzdGVyZWQuIEFkZGl0aW9uYWwgYWRhcHRlcnMgd2lsbCBiZSBpZ25vcmVkLiBUaGlzIG1heSBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXCJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN1Y2Nlc3M6IERhdGFiYXNlIGFkYXB0ZXIgcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHkuXCIpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlclByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgdGhpcy5wcm92aWRlcnMucHVzaChwcm92aWRlcik7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYFN1Y2Nlc3M6IFByb3ZpZGVyICR7cHJvdmlkZXIubmFtZX0gcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHkuYCk7XG4gIH1cbiAgcmVnaXN0ZXJBY3Rpb24oYWN0aW9uKSB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICBgJHt0aGlzLmNoYXJhY3Rlci5uYW1lfSgke3RoaXMuYWdlbnRJZH0pIC0gUmVnaXN0ZXJpbmcgYWN0aW9uOiAke2FjdGlvbi5uYW1lfWBcbiAgICApO1xuICAgIGlmICh0aGlzLmFjdGlvbnMuZmluZCgoYSkgPT4gYS5uYW1lID09PSBhY3Rpb24ubmFtZSkpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgIGAke3RoaXMuY2hhcmFjdGVyLm5hbWV9KCR7dGhpcy5hZ2VudElkfSkgLSBBY3Rpb24gJHthY3Rpb24ubmFtZX0gYWxyZWFkeSBleGlzdHMuIFNraXBwaW5nIHJlZ2lzdHJhdGlvbi5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgIGAke3RoaXMuY2hhcmFjdGVyLm5hbWV9KCR7dGhpcy5hZ2VudElkfSkgLSBBY3Rpb24gJHthY3Rpb24ubmFtZX0gcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHkuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJFdmFsdWF0b3IoZXZhbHVhdG9yKSB7XG4gICAgdGhpcy5ldmFsdWF0b3JzLnB1c2goZXZhbHVhdG9yKTtcbiAgfVxuICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBpbW11dGFibGUgYWN0aW9uIHBsYW4gdXBkYXRlc1xuICB1cGRhdGVBY3Rpb25QbGFuKHBsYW4sIHVwZGF0ZXMpIHtcbiAgICByZXR1cm4geyAuLi5wbGFuLCAuLi51cGRhdGVzIH07XG4gIH1cbiAgdXBkYXRlQWN0aW9uU3RlcChwbGFuLCBpbmRleCwgc3RlcFVwZGF0ZXMpIHtcbiAgICBpZiAoIXBsYW4uc3RlcHMgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IHBsYW4uc3RlcHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICBgSW52YWxpZCBzdGVwIGluZGV4OiAke2luZGV4fSBmb3IgcGxhbiB3aXRoICR7cGxhbi5zdGVwcz8ubGVuZ3RoIHx8IDB9IHN0ZXBzYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBwbGFuO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGxhbixcbiAgICAgIHN0ZXBzOiBwbGFuLnN0ZXBzLm1hcChcbiAgICAgICAgKHN0ZXAsIGkpID0+IGkgPT09IGluZGV4ID8geyAuLi5zdGVwLCAuLi5zdGVwVXBkYXRlcyB9IDogc3RlcFxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0FjdGlvbnMobWVzc2FnZSwgcmVzcG9uc2VzLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBhbGxBY3Rpb25zID0gW107XG4gICAgZm9yIChjb25zdCByZXNwb25zZSBvZiByZXNwb25zZXMpIHtcbiAgICAgIGlmIChyZXNwb25zZS5jb250ZW50Py5hY3Rpb25zICYmIHJlc3BvbnNlLmNvbnRlbnQuYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFsbEFjdGlvbnMucHVzaCguLi5yZXNwb25zZS5jb250ZW50LmFjdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYXNNdWx0aXBsZUFjdGlvbnMgPSBhbGxBY3Rpb25zLmxlbmd0aCA+IDE7XG4gICAgY29uc3QgcnVuSWQgPSB0aGlzLmNyZWF0ZVJ1bklkKCk7XG4gICAgbGV0IGFjdGlvblBsYW4gPSBudWxsO1xuICAgIGlmIChoYXNNdWx0aXBsZUFjdGlvbnMpIHtcbiAgICAgIGNvbnN0IHRob3VnaHQgPSByZXNwb25zZXNbMF0/LmNvbnRlbnQ/LnRob3VnaHQgfHwgYEV4ZWN1dGluZyAke2FsbEFjdGlvbnMubGVuZ3RofSBhY3Rpb25zOiAke2FsbEFjdGlvbnMuam9pbihcIiwgXCIpfWA7XG4gICAgICBhY3Rpb25QbGFuID0ge1xuICAgICAgICBydW5JZCxcbiAgICAgICAgdG90YWxTdGVwczogYWxsQWN0aW9ucy5sZW5ndGgsXG4gICAgICAgIGN1cnJlbnRTdGVwOiAwLFxuICAgICAgICBzdGVwczogYWxsQWN0aW9ucy5tYXAoKGFjdGlvbikgPT4gKHtcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIlxuICAgICAgICB9KSksXG4gICAgICAgIHRob3VnaHQsXG4gICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGFjdGlvbkluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHJlc3BvbnNlcykge1xuICAgICAgbGV0IG5vcm1hbGl6ZUFjdGlvbiA9IGZ1bmN0aW9uKGFjdGlvblN0cmluZykge1xuICAgICAgICByZXR1cm4gYWN0aW9uU3RyaW5nLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXy9nLCBcIlwiKTtcbiAgICAgIH07XG4gICAgICBpZiAoIXJlc3BvbnNlLmNvbnRlbnQ/LmFjdGlvbnMgfHwgcmVzcG9uc2UuY29udGVudC5hY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTm8gYWN0aW9uIGZvdW5kIGluIHRoZSByZXNwb25zZSBjb250ZW50LlwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBhY3Rpb25zID0gcmVzcG9uc2UuY29udGVudC5hY3Rpb25zO1xuICAgICAgY29uc3QgYWN0aW9uUmVzdWx0cyA9IFtdO1xuICAgICAgbGV0IGFjY3VtdWxhdGVkU3RhdGUgPSBzdGF0ZTtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGb3VuZCBhY3Rpb25zOiAke3RoaXMuYWN0aW9ucy5tYXAoKGEpID0+IG5vcm1hbGl6ZUFjdGlvbihhLm5hbWUpKX1gKTtcbiAgICAgIGZvciAoY29uc3QgcmVzcG9uc2VBY3Rpb24gb2YgYWN0aW9ucykge1xuICAgICAgICBpZiAoYWN0aW9uUGxhbikge1xuICAgICAgICAgIGFjdGlvblBsYW4gPSB0aGlzLnVwZGF0ZUFjdGlvblBsYW4oYWN0aW9uUGxhbiwgeyBjdXJyZW50U3RlcDogYWN0aW9uSW5kZXggKyAxIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtdWxhdGVkU3RhdGUgPSBhd2FpdCB0aGlzLmNvbXBvc2VTdGF0ZShtZXNzYWdlLCBbXG4gICAgICAgICAgXCJSRUNFTlRfTUVTU0FHRVNcIixcbiAgICAgICAgICBcIkFDVElPTl9TVEFURVwiXG4gICAgICAgICAgLy8gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIGFjdGlvbiBwbGFuXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoYWN0aW9uUGxhbiAmJiBhY2N1bXVsYXRlZFN0YXRlLmRhdGEpIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFN0YXRlLmRhdGEuYWN0aW9uUGxhbiA9IGFjdGlvblBsYW47XG4gICAgICAgICAgYWNjdW11bGF0ZWRTdGF0ZS5kYXRhLmFjdGlvblJlc3VsdHMgPSBhY3Rpb25SZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBTdWNjZXNzOiBDYWxsaW5nIGFjdGlvbjogJHtyZXNwb25zZUFjdGlvbn1gKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFJlc3BvbnNlQWN0aW9uID0gbm9ybWFsaXplQWN0aW9uKHJlc3BvbnNlQWN0aW9uKTtcbiAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMuYWN0aW9ucy5maW5kKFxuICAgICAgICAgIChhKSA9PiBub3JtYWxpemVBY3Rpb24oYS5uYW1lKSA9PT0gbm9ybWFsaXplZFJlc3BvbnNlQWN0aW9uXG4gICAgICAgICk7XG4gICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgYWN0aW9uID0gdGhpcy5hY3Rpb25zLmZpbmQoXG4gICAgICAgICAgICAoYSkgPT4gbm9ybWFsaXplQWN0aW9uKGEubmFtZSkuaW5jbHVkZXMobm9ybWFsaXplZFJlc3BvbnNlQWN0aW9uKSB8fCBub3JtYWxpemVkUmVzcG9uc2VBY3Rpb24uaW5jbHVkZXMobm9ybWFsaXplQWN0aW9uKGEubmFtZSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFN1Y2Nlc3M6IEZvdW5kIGFjdGlvbjogJHthY3Rpb24/Lm5hbWV9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJBdHRlbXB0aW5nIHRvIGZpbmQgYWN0aW9uIGluIHNpbWlsZXMuXCIpO1xuICAgICAgICAgIGZvciAoY29uc3QgX2FjdGlvbiBvZiB0aGlzLmFjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YWN0U2ltaWxlTWF0Y2ggPSBfYWN0aW9uLnNpbWlsZXM/LmZpbmQoXG4gICAgICAgICAgICAgIChzaW1pbGUpID0+IG5vcm1hbGl6ZUFjdGlvbihzaW1pbGUpID09PSBub3JtYWxpemVkUmVzcG9uc2VBY3Rpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZXhhY3RTaW1pbGVNYXRjaCkge1xuICAgICAgICAgICAgICBhY3Rpb24gPSBfYWN0aW9uO1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2VzczogQWN0aW9uIGZvdW5kIGluIHNpbWlsZXMgKGV4YWN0IG1hdGNoKTogJHthY3Rpb24ubmFtZX1gKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmdXp6eVNpbWlsZU1hdGNoID0gX2FjdGlvbi5zaW1pbGVzPy5maW5kKFxuICAgICAgICAgICAgICAoc2ltaWxlKSA9PiBub3JtYWxpemVBY3Rpb24oc2ltaWxlKS5pbmNsdWRlcyhub3JtYWxpemVkUmVzcG9uc2VBY3Rpb24pIHx8IG5vcm1hbGl6ZWRSZXNwb25zZUFjdGlvbi5pbmNsdWRlcyhub3JtYWxpemVBY3Rpb24oc2ltaWxlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZnV6enlTaW1pbGVNYXRjaCkge1xuICAgICAgICAgICAgICBhY3Rpb24gPSBfYWN0aW9uO1xuICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2VzczogQWN0aW9uIGZvdW5kIGluIHNpbWlsZXMgKGZ1enp5IG1hdGNoKTogJHthY3Rpb24ubmFtZX1gKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBgTm8gYWN0aW9uIGZvdW5kIGZvcjogJHtyZXNwb25zZUFjdGlvbn1gO1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgICBpZiAoYWN0aW9uUGxhbiAmJiBhY3Rpb25QbGFuLnN0ZXBzW2FjdGlvbkluZGV4XSkge1xuICAgICAgICAgICAgYWN0aW9uUGxhbiA9IHRoaXMudXBkYXRlQWN0aW9uU3RlcChhY3Rpb25QbGFuLCBhY3Rpb25JbmRleCwge1xuICAgICAgICAgICAgICBzdGF0dXM6IFwiZmFpbGVkXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvck1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFjdGlvbk1lbW9yeSA9IHtcbiAgICAgICAgICAgIGlkOiB1dWlkdjQoKSxcbiAgICAgICAgICAgIGVudGl0eUlkOiBtZXNzYWdlLmVudGl0eUlkLFxuICAgICAgICAgICAgcm9vbUlkOiBtZXNzYWdlLnJvb21JZCxcbiAgICAgICAgICAgIHdvcmxkSWQ6IG1lc3NhZ2Uud29ybGRJZCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgdGhvdWdodDogZXJyb3JNc2csXG4gICAgICAgICAgICAgIHNvdXJjZTogXCJhdXRvXCIsXG4gICAgICAgICAgICAgIHR5cGU6IFwiYWN0aW9uX3Jlc3VsdFwiLFxuICAgICAgICAgICAgICBhY3Rpb25OYW1lOiByZXNwb25zZUFjdGlvbixcbiAgICAgICAgICAgICAgYWN0aW9uU3RhdHVzOiBcImZhaWxlZFwiLFxuICAgICAgICAgICAgICBydW5JZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVNZW1vcnkoYWN0aW9uTWVtb3J5LCBcIm1lc3NhZ2VzXCIpO1xuICAgICAgICAgIGFjdGlvbkluZGV4Kys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhY3Rpb24uaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBBY3Rpb24gJHthY3Rpb24ubmFtZX0gaGFzIG5vIGhhbmRsZXIuYCk7XG4gICAgICAgICAgaWYgKGFjdGlvblBsYW4gJiYgYWN0aW9uUGxhbi5zdGVwc1thY3Rpb25JbmRleF0pIHtcbiAgICAgICAgICAgIGFjdGlvblBsYW4gPSB0aGlzLnVwZGF0ZUFjdGlvblN0ZXAoYWN0aW9uUGxhbiwgYWN0aW9uSW5kZXgsIHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBcImZhaWxlZFwiLFxuICAgICAgICAgICAgICBlcnJvcjogXCJObyBoYW5kbGVyXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3Rpb25JbmRleCsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEV4ZWN1dGluZyBoYW5kbGVyIGZvciBhY3Rpb246ICR7YWN0aW9uLm5hbWV9YCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9uSWQgPSB1dWlkdjQoKTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0ID0ge1xuICAgICAgICAgICAgYWN0aW9uTmFtZTogYWN0aW9uLm5hbWUsXG4gICAgICAgICAgICBhY3Rpb25JZCxcbiAgICAgICAgICAgIHByb21wdHM6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBhY3Rpb25Db250ZXh0ID0ge1xuICAgICAgICAgICAgcHJldmlvdXNSZXN1bHRzOiBhY3Rpb25SZXN1bHRzLFxuICAgICAgICAgICAgZ2V0UHJldmlvdXNSZXN1bHQ6IChhY3Rpb25OYW1lKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBhY3Rpb25SZXN1bHRzLmZpbmQoKHIpID0+IHIuZGF0YT8uYWN0aW9uTmFtZSA9PT0gYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBvcHRpb25zMiA9IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGFjdGlvbkNvbnRleHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChhY3Rpb25QbGFuKSB7XG4gICAgICAgICAgICBvcHRpb25zMi5hY3Rpb25QbGFuID0ge1xuICAgICAgICAgICAgICB0b3RhbFN0ZXBzOiBhY3Rpb25QbGFuLnRvdGFsU3RlcHMsXG4gICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBhY3Rpb25QbGFuLmN1cnJlbnRTdGVwLFxuICAgICAgICAgICAgICBzdGVwczogYWN0aW9uUGxhbi5zdGVwcyxcbiAgICAgICAgICAgICAgdGhvdWdodDogYWN0aW9uUGxhbi50aG91Z2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpb24uaGFuZGxlcihcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgYWNjdW11bGF0ZWRTdGF0ZSxcbiAgICAgICAgICAgIG9wdGlvbnMyLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICByZXNwb25zZXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGlzTGVnYWN5UmV0dXJuID0gcmVzdWx0ID09PSB2b2lkIDAgfHwgcmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgPT09IFwiYm9vbGVhblwiO1xuICAgICAgICAgIGxldCBhY3Rpb25SZXN1bHQgPSBudWxsO1xuICAgICAgICAgIGlmICghaXNMZWdhY3lSZXR1cm4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiICYmIHJlc3VsdCAhPT0gbnVsbCAmJiAoXCJ2YWx1ZXNcIiBpbiByZXN1bHQgfHwgXCJkYXRhXCIgaW4gcmVzdWx0IHx8IFwidGV4dFwiIGluIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgYWN0aW9uUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0cnVlIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAuLi5yZXN1bHRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFjdGlvblJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgc3VjY2VzcyBmb3IgbGVnYWN5IHJlc3VsdHNcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25OYW1lOiBhY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgIGxlZ2FjeVJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aW9uUmVzdWx0cy5wdXNoKGFjdGlvblJlc3VsdCk7XG4gICAgICAgICAgICBpZiAoYWN0aW9uUmVzdWx0LnZhbHVlcykge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlZFN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLmFjY3VtdWxhdGVkU3RhdGUsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLmFjY3VtdWxhdGVkU3RhdGUudmFsdWVzLCAuLi5hY3Rpb25SZXN1bHQudmFsdWVzIH0sXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgLi4uYWNjdW11bGF0ZWRTdGF0ZS5kYXRhIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgYWN0aW9uUmVzdWx0czogWy4uLmFjY3VtdWxhdGVkU3RhdGUuZGF0YT8uYWN0aW9uUmVzdWx0cyB8fCBbXSwgYWN0aW9uUmVzdWx0XSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvblBsYW5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uUmVzdWx0ICYmIGFjY3VtdWxhdGVkU3RhdGUuZGF0YSkge1xuICAgICAgICAgICAgICBpZiAoIWFjY3VtdWxhdGVkU3RhdGUuZGF0YS53b3JraW5nTWVtb3J5KSBhY2N1bXVsYXRlZFN0YXRlLmRhdGEud29ya2luZ01lbW9yeSA9IHt9O1xuICAgICAgICAgICAgICBjb25zdCBtZW1vcnlLZXkgPSBgYWN0aW9uXyR7cmVzcG9uc2VBY3Rpb259XyR7dXVpZHY0KCl9YDtcbiAgICAgICAgICAgICAgY29uc3QgbWVtb3J5RW50cnkgPSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZTogYWN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBhY3Rpb25SZXN1bHQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGFjY3VtdWxhdGVkU3RhdGUuZGF0YS53b3JraW5nTWVtb3J5W21lbW9yeUtleV0gPSBtZW1vcnlFbnRyeTtcbiAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGFjY3VtdWxhdGVkU3RhdGUuZGF0YS53b3JraW5nTWVtb3J5KTtcbiAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gdGhpcy5tYXhXb3JraW5nTWVtb3J5RW50cmllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZCA9IGVudHJpZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnlBID0gYVsxXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5QiA9IGJbMV07XG4gICAgICAgICAgICAgICAgICBjb25zdCB0aW1lc3RhbXBBID0gZW50cnlBPy50aW1lc3RhbXAgPz8gMDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcEIgPSBlbnRyeUI/LnRpbWVzdGFtcCA/PyAwO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcEIgLSB0aW1lc3RhbXBBO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkU3RhdGUuZGF0YS53b3JraW5nTWVtb3J5ID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICAgICAgc29ydGVkLnNsaWNlKDAsIHRoaXMubWF4V29ya2luZ01lbW9yeUVudHJpZXMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGlvblBsYW4gJiYgYWN0aW9uUGxhbi5zdGVwc1thY3Rpb25JbmRleF0pIHtcbiAgICAgICAgICAgICAgYWN0aW9uUGxhbiA9IHRoaXMudXBkYXRlQWN0aW9uU3RlcChhY3Rpb25QbGFuLCBhY3Rpb25JbmRleCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJjb21wbGV0ZWRcIixcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGFjdGlvblJlc3VsdFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYWN0aW9uTWVtb3J5ID0ge1xuICAgICAgICAgICAgaWQ6IGFjdGlvbklkLFxuICAgICAgICAgICAgZW50aXR5SWQ6IHRoaXMuYWdlbnRJZCxcbiAgICAgICAgICAgIHJvb21JZDogbWVzc2FnZS5yb29tSWQsXG4gICAgICAgICAgICB3b3JsZElkOiBtZXNzYWdlLndvcmxkSWQsXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgIHRleHQ6IGFjdGlvblJlc3VsdD8udGV4dCB8fCBgRXhlY3V0ZWQgYWN0aW9uOiAke2FjdGlvbi5uYW1lfWAsXG4gICAgICAgICAgICAgIHNvdXJjZTogXCJhY3Rpb25cIixcbiAgICAgICAgICAgICAgdHlwZTogXCJhY3Rpb25fcmVzdWx0XCIsXG4gICAgICAgICAgICAgIGFjdGlvbk5hbWU6IGFjdGlvbi5uYW1lLFxuICAgICAgICAgICAgICBhY3Rpb25TdGF0dXM6IGFjdGlvblJlc3VsdD8uc3VjY2VzcyA/IFwiY29tcGxldGVkXCIgOiBcImZhaWxlZFwiLFxuICAgICAgICAgICAgICBhY3Rpb25SZXN1bHQ6IGlzTGVnYWN5UmV0dXJuID8geyBsZWdhY3k6IHJlc3VsdCB9IDogYWN0aW9uUmVzdWx0LFxuICAgICAgICAgICAgICBydW5JZCxcbiAgICAgICAgICAgICAgLi4uYWN0aW9uUGxhbiAmJiB7XG4gICAgICAgICAgICAgICAgcGxhblN0ZXA6IGAke2FjdGlvblBsYW4uY3VycmVudFN0ZXB9LyR7YWN0aW9uUGxhbi50b3RhbFN0ZXBzfWAsXG4gICAgICAgICAgICAgICAgcGxhblRob3VnaHQ6IGFjdGlvblBsYW4udGhvdWdodFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhY3Rpb25fcmVzdWx0XCIsXG4gICAgICAgICAgICAgIGFjdGlvbk5hbWU6IGFjdGlvbi5uYW1lLFxuICAgICAgICAgICAgICBydW5JZCxcbiAgICAgICAgICAgICAgYWN0aW9uSWQsXG4gICAgICAgICAgICAgIC4uLmFjdGlvblBsYW4gJiYge1xuICAgICAgICAgICAgICAgIHRvdGFsU3RlcHM6IGFjdGlvblBsYW4udG90YWxTdGVwcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDogYWN0aW9uUGxhbi5jdXJyZW50U3RlcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZU1lbW9yeShhY3Rpb25NZW1vcnksIFwibWVzc2FnZXNcIik7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEFjdGlvbiAke2FjdGlvbi5uYW1lfSBjb21wbGV0ZWRgLCB7XG4gICAgICAgICAgICBpc0xlZ2FjeVJldHVybixcbiAgICAgICAgICAgIHJlc3VsdDogaXNMZWdhY3lSZXR1cm4gPyByZXN1bHQgOiB2b2lkIDAsXG4gICAgICAgICAgICBoYXNWYWx1ZXM6IGFjdGlvblJlc3VsdCA/ICEhYWN0aW9uUmVzdWx0LnZhbHVlcyA6IGZhbHNlLFxuICAgICAgICAgICAgaGFzRGF0YTogYWN0aW9uUmVzdWx0ID8gISFhY3Rpb25SZXN1bHQuZGF0YSA6IGZhbHNlLFxuICAgICAgICAgICAgaGFzVGV4dDogYWN0aW9uUmVzdWx0ID8gISFhY3Rpb25SZXN1bHQudGV4dCA6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5hZGFwdGVyLmxvZyh7XG4gICAgICAgICAgICBlbnRpdHlJZDogbWVzc2FnZS5lbnRpdHlJZCxcbiAgICAgICAgICAgIHJvb21JZDogbWVzc2FnZS5yb29tSWQsXG4gICAgICAgICAgICB0eXBlOiBcImFjdGlvblwiLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvbi5uYW1lLFxuICAgICAgICAgICAgICBhY3Rpb25JZCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZS5jb250ZW50LnRleHQsXG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZS5pZCxcbiAgICAgICAgICAgICAgc3RhdGU6IGFjY3VtdWxhdGVkU3RhdGUsXG4gICAgICAgICAgICAgIHJlc3BvbnNlcyxcbiAgICAgICAgICAgICAgcmVzdWx0OiBpc0xlZ2FjeVJldHVybiA/IHsgbGVnYWN5OiByZXN1bHQgfSA6IGFjdGlvblJlc3VsdCxcbiAgICAgICAgICAgICAgaXNMZWdhY3lSZXR1cm4sXG4gICAgICAgICAgICAgIHByb21wdHM6IHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQ/LnByb21wdHMgfHwgW10sXG4gICAgICAgICAgICAgIHByb21wdENvdW50OiB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0Py5wcm9tcHRzLmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgICBydW5JZCxcbiAgICAgICAgICAgICAgLi4uYWN0aW9uUGxhbiAmJiB7XG4gICAgICAgICAgICAgICAgcGxhblN0ZXA6IGAke2FjdGlvblBsYW4uY3VycmVudFN0ZXB9LyR7YWN0aW9uUGxhbi50b3RhbFN0ZXBzfWAsXG4gICAgICAgICAgICAgICAgcGxhblRob3VnaHQ6IGFjdGlvblBsYW4udGhvdWdodFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCA9IHZvaWQgMDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIGlmIChhY3Rpb25QbGFuICYmIGFjdGlvblBsYW4uc3RlcHNbYWN0aW9uSW5kZXhdKSB7XG4gICAgICAgICAgICBhY3Rpb25QbGFuID0gdGhpcy51cGRhdGVBY3Rpb25TdGVwKGFjdGlvblBsYW4sIGFjdGlvbkluZGV4LCB7XG4gICAgICAgICAgICAgIHN0YXR1czogXCJmYWlsZWRcIixcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQgPSB2b2lkIDA7XG4gICAgICAgICAgY29uc3QgZXJyb3JSZXN1bHQgPSB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIFJlcXVpcmVkIGZpZWxkXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGFjdGlvbk5hbWU6IGFjdGlvbi5uYW1lLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICBlcnJvck9iamVjdDogZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGFjdGlvblJlc3VsdHMucHVzaChlcnJvclJlc3VsdCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9uTWVtb3J5ID0ge1xuICAgICAgICAgICAgaWQ6IHV1aWR2NCgpLFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICB0aG91Z2h0OiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgIHNvdXJjZTogXCJhdXRvXCIsXG4gICAgICAgICAgICAgIHR5cGU6IFwiYWN0aW9uX3Jlc3VsdFwiLFxuICAgICAgICAgICAgICBhY3Rpb25OYW1lOiBhY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgYWN0aW9uU3RhdHVzOiBcImZhaWxlZFwiLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICBydW5JZCxcbiAgICAgICAgICAgICAgLi4uYWN0aW9uUGxhbiAmJiB7XG4gICAgICAgICAgICAgICAgcGxhblN0ZXA6IGAke2FjdGlvblBsYW4uY3VycmVudFN0ZXB9LyR7YWN0aW9uUGxhbi50b3RhbFN0ZXBzfWAsXG4gICAgICAgICAgICAgICAgcGxhblRob3VnaHQ6IGFjdGlvblBsYW4udGhvdWdodFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW50aXR5SWQ6IHRoaXMuYWdlbnRJZCxcbiAgICAgICAgICAgIHJvb21JZDogbWVzc2FnZS5yb29tSWQsXG4gICAgICAgICAgICB3b3JsZElkOiBtZXNzYWdlLndvcmxkSWQsXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICB0eXBlOiBcImFjdGlvbl9yZXN1bHRcIixcbiAgICAgICAgICAgICAgYWN0aW9uTmFtZTogYWN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgIHJ1bklkLFxuICAgICAgICAgICAgICBlcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4uYWN0aW9uUGxhbiAmJiB7XG4gICAgICAgICAgICAgICAgdG90YWxTdGVwczogYWN0aW9uUGxhbi50b3RhbFN0ZXBzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBhY3Rpb25QbGFuLmN1cnJlbnRTdGVwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlTWVtb3J5KGFjdGlvbk1lbW9yeSwgXCJtZXNzYWdlc1wiKTtcbiAgICAgICAgICBpZiAoZXJyb3I/LmNyaXRpY2FsIHx8IGVycm9yPy5jb2RlID09PSBcIkNSSVRJQ0FMX0VSUk9SXCIpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25JbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UuaWQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZUNhY2hlLnNldChgJHttZXNzYWdlLmlkfV9hY3Rpb25fcmVzdWx0c2AsIHtcbiAgICAgICAgICB2YWx1ZXM6IHsgYWN0aW9uUmVzdWx0cyB9LFxuICAgICAgICAgIGRhdGE6IHsgYWN0aW9uUmVzdWx0cywgYWN0aW9uUGxhbiB9LFxuICAgICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KGFjdGlvblJlc3VsdHMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBldmFsdWF0ZShtZXNzYWdlLCBzdGF0ZSwgZGlkUmVzcG9uZCwgY2FsbGJhY2ssIHJlc3BvbnNlcykge1xuICAgIGNvbnN0IGV2YWx1YXRvclByb21pc2VzID0gdGhpcy5ldmFsdWF0b3JzLm1hcChhc3luYyAoZXZhbHVhdG9yKSA9PiB7XG4gICAgICBpZiAoIWV2YWx1YXRvci5oYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRSZXNwb25kICYmICFldmFsdWF0b3IuYWx3YXlzUnVuKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXZhbHVhdG9yLnZhbGlkYXRlKHRoaXMsIG1lc3NhZ2UsIHN0YXRlKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICAgIGNvbnN0IGV2YWx1YXRvcnMgPSAoYXdhaXQgUHJvbWlzZS5hbGwoZXZhbHVhdG9yUHJvbWlzZXMpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgaWYgKGV2YWx1YXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHN0YXRlID0gYXdhaXQgdGhpcy5jb21wb3NlU3RhdGUobWVzc2FnZSwgW1wiUkVDRU5UX01FU1NBR0VTXCIsIFwiRVZBTFVBVE9SU1wiXSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBldmFsdWF0b3JzLm1hcChhc3luYyAoZXZhbHVhdG9yKSA9PiB7XG4gICAgICAgIGlmIChldmFsdWF0b3IuaGFuZGxlcikge1xuICAgICAgICAgIGF3YWl0IGV2YWx1YXRvci5oYW5kbGVyKHRoaXMsIG1lc3NhZ2UsIHN0YXRlLCB7fSwgY2FsbGJhY2ssIHJlc3BvbnNlcyk7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyLmxvZyh7XG4gICAgICAgICAgICBlbnRpdHlJZDogbWVzc2FnZS5lbnRpdHlJZCxcbiAgICAgICAgICAgIHJvb21JZDogbWVzc2FnZS5yb29tSWQsXG4gICAgICAgICAgICB0eXBlOiBcImV2YWx1YXRvclwiLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICBldmFsdWF0b3I6IGV2YWx1YXRvci5uYW1lLFxuICAgICAgICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UuY29udGVudC50ZXh0LFxuICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGV2YWx1YXRvcnM7XG4gIH1cbiAgLy8gaGlnaGx5IFNRTCBvcHRpbWl6ZWQgcXVlcmllc1xuICBhc3luYyBlbnN1cmVDb25uZWN0aW9ucyhlbnRpdGllcywgcm9vbXMsIHNvdXJjZSwgd29ybGQpIHtcbiAgICBpZiAoIWVudGl0aWVzKSB7XG4gICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcImVuc3VyZUNvbm5lY3Rpb25zIC0gbm8gZW50aXRpZXNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcm9vbXMgfHwgcm9vbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcImVuc3VyZUNvbm5lY3Rpb25zIC0gbm8gcm9vbXNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuZW5zdXJlV29ybGRFeGlzdHMoeyAuLi53b3JsZCwgYWdlbnRJZDogdGhpcy5hZ2VudElkIH0pO1xuICAgIGNvbnN0IGZpcnN0Um9vbSA9IHJvb21zWzBdO1xuICAgIGNvbnN0IGNodW5rQXJyYXkgPSAoYXJyLCBzaXplKSA9PiBhcnIucmVkdWNlKChjaHVua3MsIGl0ZW0sIGkpID0+IHtcbiAgICAgIGlmIChpICUgc2l6ZSA9PT0gMCkgY2h1bmtzLnB1c2goW10pO1xuICAgICAgY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXS5wdXNoKGl0ZW0pO1xuICAgICAgcmV0dXJuIGNodW5rcztcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgcm9vbUlkcyA9IHJvb21zLm1hcCgocjIpID0+IHIyLmlkKTtcbiAgICBjb25zdCByb29tRXhpc3RzQ2hlY2sgPSBhd2FpdCB0aGlzLmdldFJvb21zQnlJZHMocm9vbUlkcyk7XG4gICAgY29uc3Qgcm9vbXNJZEV4aXN0cyA9IHJvb21FeGlzdHNDaGVjay5tYXAoKHIyKSA9PiByMi5pZCk7XG4gICAgY29uc3Qgcm9vbXNUb0NyZWF0ZSA9IHJvb21JZHMuZmlsdGVyKChpZCkgPT4gIXJvb21zSWRFeGlzdHMuaW5jbHVkZXMoaWQpKTtcbiAgICBjb25zdCByZiA9IHtcbiAgICAgIHdvcmxkSWQ6IHdvcmxkLmlkLFxuICAgICAgc2VydmVySWQ6IHdvcmxkLnNlcnZlcklkLFxuICAgICAgc291cmNlLFxuICAgICAgYWdlbnRJZDogdGhpcy5hZ2VudElkXG4gICAgfTtcbiAgICBpZiAocm9vbXNUb0NyZWF0ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBcInJ1bnRpbWUvZW5zdXJlQ29ubmVjdGlvbnMgLSBjcmVhdGVcIixcbiAgICAgICAgcm9vbXNUb0NyZWF0ZS5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgXCJyb29tc1wiXG4gICAgICApO1xuICAgICAgY29uc3Qgcm9vbU9ianNUb0NyZWF0ZSA9IHJvb21zLmZpbHRlcigocjIpID0+IHJvb21zVG9DcmVhdGUuaW5jbHVkZXMocjIuaWQpKS5tYXAoKHIyKSA9PiAoeyAuLi5yMiwgLi4ucmYgfSkpO1xuICAgICAgYXdhaXQgdGhpcy5jcmVhdGVSb29tcyhyb29tT2Jqc1RvQ3JlYXRlKTtcbiAgICB9XG4gICAgY29uc3QgZW50aXR5SWRzID0gZW50aXRpZXMubWFwKChlKSA9PiBlLmlkKTtcbiAgICBjb25zdCBlbnRpdHlFeGlzdHNDaGVjayA9IGF3YWl0IHRoaXMuYWRhcHRlci5nZXRFbnRpdGllc0J5SWRzKGVudGl0eUlkcyk7XG4gICAgY29uc3QgZW50aXRpZXNUb1VwZGF0ZSA9IGVudGl0eUV4aXN0c0NoZWNrLm1hcCgoZSkgPT4gZS5pZCk7XG4gICAgY29uc3QgZW50aXRpZXNUb0NyZWF0ZSA9IGVudGl0aWVzLmZpbHRlcigoZSkgPT4gIWVudGl0aWVzVG9VcGRhdGUuaW5jbHVkZXMoZS5pZCkpO1xuICAgIGNvbnN0IHIgPSB7XG4gICAgICByb29tSWQ6IGZpcnN0Um9vbS5pZCxcbiAgICAgIGNoYW5uZWxJZDogZmlyc3RSb29tLmNoYW5uZWxJZCxcbiAgICAgIHR5cGU6IGZpcnN0Um9vbS50eXBlXG4gICAgfTtcbiAgICBjb25zdCB3ZiA9IHtcbiAgICAgIHdvcmxkSWQ6IHdvcmxkLmlkLFxuICAgICAgc2VydmVySWQ6IHdvcmxkLnNlcnZlcklkXG4gICAgfTtcbiAgICBpZiAoZW50aXRpZXNUb0NyZWF0ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBcInJ1bnRpbWUvZW5zdXJlQ29ubmVjdGlvbnMgLSBjcmVhdGluZ1wiLFxuICAgICAgICBlbnRpdGllc1RvQ3JlYXRlLmxlbmd0aC50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICBcImVudGl0aWVzLi4uXCJcbiAgICAgICk7XG4gICAgICBjb25zdCBlZiA9IHtcbiAgICAgICAgLi4ucixcbiAgICAgICAgLi4ud2YsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgYWdlbnRJZDogdGhpcy5hZ2VudElkXG4gICAgICB9O1xuICAgICAgY29uc3QgZW50aXRpZXNUb0NyZWF0ZVdGaWVsZHMgPSBlbnRpdGllc1RvQ3JlYXRlLm1hcCgoZSkgPT4gKHsgLi4uZSwgLi4uZWYgfSkpO1xuICAgICAgY29uc3QgYmF0Y2hlcyA9IGNodW5rQXJyYXkoZW50aXRpZXNUb0NyZWF0ZVdGaWVsZHMsIDVlMyk7XG4gICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIGJhdGNoZXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVFbnRpdGllcyhiYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuZW5zdXJlUGFydGljaXBhbnRJblJvb20odGhpcy5hZ2VudElkLCBmaXJzdFJvb20uaWQpO1xuICAgIGNvbnN0IGVudGl0eUlkc0luRmlyc3RSb29tID0gYXdhaXQgdGhpcy5nZXRQYXJ0aWNpcGFudHNGb3JSb29tKGZpcnN0Um9vbS5pZCk7XG4gICAgY29uc3QgZW50aXR5SWRzSW5GaXJzdFJvb21GaWx0ZXJlZCA9IGVudGl0eUlkc0luRmlyc3RSb29tLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBtaXNzaW5nSWRzSW5Sb29tID0gZW50aXR5SWRzLmZpbHRlcigoaWQpID0+ICFlbnRpdHlJZHNJbkZpcnN0Um9vbUZpbHRlcmVkLmluY2x1ZGVzKGlkKSk7XG4gICAgaWYgKG1pc3NpbmdJZHNJblJvb20ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgXCJydW50aW1lL2Vuc3VyZUNvbm5lY3Rpb25zIC0gTWlzc2luZ1wiLFxuICAgICAgICBtaXNzaW5nSWRzSW5Sb29tLmxlbmd0aC50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICBcImNvbm5lY3Rpb25zIGluXCIsXG4gICAgICAgIGZpcnN0Um9vbS5pZFxuICAgICAgKTtcbiAgICAgIGF3YWl0IHRoaXMuYWRkUGFydGljaXBhbnRzUm9vbShtaXNzaW5nSWRzSW5Sb29tLCBmaXJzdFJvb20uaWQpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5zdWNjZXNzKGBTdWNjZXNzOiBTdWNjZXNzZnVsbHkgY29ubmVjdGVkIHdvcmxkYCk7XG4gIH1cbiAgYXN5bmMgZW5zdXJlQ29ubmVjdGlvbih7XG4gICAgZW50aXR5SWQsXG4gICAgcm9vbUlkLFxuICAgIHdvcmxkSWQsXG4gICAgd29ybGROYW1lLFxuICAgIHVzZXJOYW1lLFxuICAgIG5hbWUsXG4gICAgc291cmNlLFxuICAgIHR5cGUsXG4gICAgY2hhbm5lbElkLFxuICAgIHNlcnZlcklkLFxuICAgIHVzZXJJZCxcbiAgICBtZXRhZGF0YVxuICB9KSB7XG4gICAgaWYgKCF3b3JsZElkICYmIHNlcnZlcklkKSB7XG4gICAgICB3b3JsZElkID0gY3JlYXRlVW5pcXVlVXVpZCh0aGlzLmFnZW50SWQgKyBzZXJ2ZXJJZCwgc2VydmVySWQpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lczMgPSBbbmFtZSwgdXNlck5hbWVdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBlbnRpdHlNZXRhZGF0YSA9IHtcbiAgICAgIFtzb3VyY2VdOiB7XG4gICAgICAgIGlkOiB1c2VySWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHVzZXJOYW1lXG4gICAgICB9XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW50aXR5ID0gYXdhaXQgdGhpcy5nZXRFbnRpdHlCeUlkKGVudGl0eUlkKTtcbiAgICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMuY3JlYXRlRW50aXR5KHtcbiAgICAgICAgICAgIGlkOiBlbnRpdHlJZCxcbiAgICAgICAgICAgIG5hbWVzOiBuYW1lczMsXG4gICAgICAgICAgICBtZXRhZGF0YTogZW50aXR5TWV0YWRhdGEsXG4gICAgICAgICAgICBhZ2VudElkOiB0aGlzLmFnZW50SWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgICAgICAgIGBDcmVhdGVkIG5ldyBlbnRpdHkgJHtlbnRpdHlJZH0gZm9yIHVzZXIgJHtuYW1lIHx8IHVzZXJOYW1lIHx8IFwidW5rbm93blwifWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBlbnRpdHkgJHtlbnRpdHlJZH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKFwiZHVwbGljYXRlIGtleVwiKSB8fCBlcnJvci5jb2RlID09PSBcIjIzNTA1XCIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgICBgRW50aXR5ICR7ZW50aXR5SWR9IGV4aXN0cyBpbiBkYXRhYmFzZSBidXQgbm90IGZvciB0aGlzIGFnZW50LiBUaGlzIGlzIG5vcm1hbCBpbiBtdWx0aS1hZ2VudCBzZXR1cHMuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIudXBkYXRlRW50aXR5KHtcbiAgICAgICAgICBpZDogZW50aXR5SWQsXG4gICAgICAgICAgbmFtZXM6IFsuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uZW50aXR5Lm5hbWVzIHx8IFtdLCAuLi5uYW1lczNdKV0uZmlsdGVyKEJvb2xlYW4pLFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAuLi5lbnRpdHkubWV0YWRhdGEsXG4gICAgICAgICAgICBbc291cmNlXToge1xuICAgICAgICAgICAgICAuLi5lbnRpdHkubWV0YWRhdGE/Lltzb3VyY2VdLFxuICAgICAgICAgICAgICBpZDogdXNlcklkLFxuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICB1c2VyTmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWdlbnRJZDogdGhpcy5hZ2VudElkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5lbnN1cmVXb3JsZEV4aXN0cyh7XG4gICAgICAgIGlkOiB3b3JsZElkLFxuICAgICAgICBuYW1lOiB3b3JsZE5hbWUgfHwgc2VydmVySWQgPyBgV29ybGQgZm9yIHNlcnZlciAke3NlcnZlcklkfWAgOiBgV29ybGQgZm9yIHJvb20gJHtyb29tSWR9YCxcbiAgICAgICAgYWdlbnRJZDogdGhpcy5hZ2VudElkLFxuICAgICAgICBzZXJ2ZXJJZDogc2VydmVySWQgfHwgXCJkZWZhdWx0XCIsXG4gICAgICAgIG1ldGFkYXRhXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHRoaXMuZW5zdXJlUm9vbUV4aXN0cyh7XG4gICAgICAgIGlkOiByb29tSWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hhbm5lbElkLFxuICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgd29ybGRJZFxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZVBhcnRpY2lwYW50SW5Sb29tKGVudGl0eUlkLCByb29tSWQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKFwibm90IGZvdW5kXCIpKSB7XG4gICAgICAgICAgY29uc3QgYWRkZWQgPSBhd2FpdCB0aGlzLmFkZFBhcnRpY2lwYW50KGVudGl0eUlkLCByb29tSWQpO1xuICAgICAgICAgIGlmICghYWRkZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGFkZCBwYXJ0aWNpcGFudCAke2VudGl0eUlkfSB0byByb29tICR7cm9vbUlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgQWRkZWQgcGFydGljaXBhbnQgJHtlbnRpdHlJZH0gdG8gcm9vbSAke3Jvb21JZH0gZGlyZWN0bHlgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5lbnN1cmVQYXJ0aWNpcGFudEluUm9vbSh0aGlzLmFnZW50SWQsIHJvb21JZCk7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgU3VjY2VzczogU3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCBlbnRpdHkgJHtlbnRpdHlJZH0gaW4gcm9vbSAke3Jvb21JZH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZW5zdXJlIGNvbm5lY3Rpb246ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWBcbiAgICAgICk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZW5zdXJlUGFydGljaXBhbnRJblJvb20oZW50aXR5SWQsIHJvb21JZCkge1xuICAgIGNvbnN0IGVudGl0eSA9IGF3YWl0IHRoaXMuZ2V0RW50aXR5QnlJZChlbnRpdHlJZCk7XG4gICAgaWYgKCFlbnRpdHkgJiYgZW50aXR5SWQgIT09IHRoaXMuYWdlbnRJZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgYEVudGl0eSAke2VudGl0eUlkfSBub3QgZGlyZWN0bHkgYWNjZXNzaWJsZSB0byBhZ2VudCAke3RoaXMuYWdlbnRJZH0uIFdpbGwgYXR0ZW1wdCB0byBhZGQgYXMgcGFydGljaXBhbnQgYW55d2F5LmBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghZW50aXR5ICYmIGVudGl0eUlkID09PSB0aGlzLmFnZW50SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWdlbnQgZW50aXR5ICR7ZW50aXR5SWR9IG5vdCBmb3VuZCwgY2Fubm90IGFkZCBhcyBwYXJ0aWNpcGFudC5gKTtcbiAgICB9IGVsc2UgaWYgKCFlbnRpdHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVXNlciBlbnRpdHkgJHtlbnRpdHlJZH0gbm90IGZvdW5kLCBjYW5ub3QgYWRkIGFzIHBhcnRpY2lwYW50LmApO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWNpcGFudHMgPSBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0UGFydGljaXBhbnRzRm9yUm9vbShyb29tSWQpO1xuICAgIGlmICghcGFydGljaXBhbnRzLmluY2x1ZGVzKGVudGl0eUlkKSkge1xuICAgICAgY29uc3QgYWRkZWQgPSBhd2FpdCB0aGlzLmFkZFBhcnRpY2lwYW50KGVudGl0eUlkLCByb29tSWQpO1xuICAgICAgaWYgKCFhZGRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhZGQgcGFydGljaXBhbnQgJHtlbnRpdHlJZH0gdG8gcm9vbSAke3Jvb21JZH1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbnRpdHlJZCA9PT0gdGhpcy5hZ2VudElkKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBBZ2VudCAke3RoaXMuY2hhcmFjdGVyLm5hbWV9IGxpbmtlZCB0byByb29tICR7cm9vbUlkfSBzdWNjZXNzZnVsbHkuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgVXNlciAke2VudGl0eUlkfSBsaW5rZWQgdG8gcm9vbSAke3Jvb21JZH0gc3VjY2Vzc2Z1bGx5LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyByZW1vdmVQYXJ0aWNpcGFudChlbnRpdHlJZCwgcm9vbUlkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5yZW1vdmVQYXJ0aWNpcGFudChlbnRpdHlJZCwgcm9vbUlkKTtcbiAgfVxuICBhc3luYyBnZXRQYXJ0aWNpcGFudHNGb3JFbnRpdHkoZW50aXR5SWQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldFBhcnRpY2lwYW50c0ZvckVudGl0eShlbnRpdHlJZCk7XG4gIH1cbiAgYXN5bmMgZ2V0UGFydGljaXBhbnRzRm9yUm9vbShyb29tSWQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldFBhcnRpY2lwYW50c0ZvclJvb20ocm9vbUlkKTtcbiAgfVxuICBhc3luYyBhZGRQYXJ0aWNpcGFudChlbnRpdHlJZCwgcm9vbUlkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5hZGRQYXJ0aWNpcGFudHNSb29tKFtlbnRpdHlJZF0sIHJvb21JZCk7XG4gIH1cbiAgYXN5bmMgYWRkUGFydGljaXBhbnRzUm9vbShlbnRpdHlJZHMsIHJvb21JZCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuYWRkUGFydGljaXBhbnRzUm9vbShlbnRpdHlJZHMsIHJvb21JZCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuc3VyZSB0aGUgZXhpc3RlbmNlIG9mIGEgd29ybGQuXG4gICAqL1xuICBhc3luYyBlbnN1cmVXb3JsZEV4aXN0cyh7IGlkLCBuYW1lLCBzZXJ2ZXJJZCwgbWV0YWRhdGEgfSkge1xuICAgIGNvbnN0IHdvcmxkID0gYXdhaXQgdGhpcy5nZXRXb3JsZChpZCk7XG4gICAgaWYgKCF3b3JsZCkge1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJDcmVhdGluZyB3b3JsZDpcIiwge1xuICAgICAgICBpZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc2VydmVySWQsXG4gICAgICAgIGFnZW50SWQ6IHRoaXMuYWdlbnRJZFxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0aGlzLmFkYXB0ZXIuY3JlYXRlV29ybGQoe1xuICAgICAgICBpZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYWdlbnRJZDogdGhpcy5hZ2VudElkLFxuICAgICAgICBzZXJ2ZXJJZDogc2VydmVySWQgfHwgXCJkZWZhdWx0XCIsXG4gICAgICAgIG1ldGFkYXRhXG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBXb3JsZCAke2lkfSBjcmVhdGVkIHN1Y2Nlc3NmdWxseS5gKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZW5zdXJlUm9vbUV4aXN0cyh7IGlkLCBuYW1lLCBzb3VyY2UsIHR5cGUsIGNoYW5uZWxJZCwgc2VydmVySWQsIHdvcmxkSWQsIG1ldGFkYXRhIH0pIHtcbiAgICBpZiAoIXdvcmxkSWQpIHRocm93IG5ldyBFcnJvcihcIndvcmxkSWQgaXMgcmVxdWlyZWRcIik7XG4gICAgY29uc3Qgcm9vbSA9IGF3YWl0IHRoaXMuZ2V0Um9vbShpZCk7XG4gICAgaWYgKCFyb29tKSB7XG4gICAgICBhd2FpdCB0aGlzLmNyZWF0ZVJvb20oe1xuICAgICAgICBpZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYWdlbnRJZDogdGhpcy5hZ2VudElkLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoYW5uZWxJZCxcbiAgICAgICAgc2VydmVySWQsXG4gICAgICAgIHdvcmxkSWQsXG4gICAgICAgIG1ldGFkYXRhXG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBSb29tICR7aWR9IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LmApO1xuICAgIH1cbiAgfVxuICBhc3luYyBjb21wb3NlU3RhdGUobWVzc2FnZSwgaW5jbHVkZUxpc3QgPSBudWxsLCBvbmx5SW5jbHVkZSA9IGZhbHNlLCBza2lwQ2FjaGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGZpbHRlckxpc3QgPSBvbmx5SW5jbHVkZSA/IGluY2x1ZGVMaXN0IDogbnVsbDtcbiAgICBjb25zdCBlbXB0eU9iaiA9IHtcbiAgICAgIHZhbHVlczoge30sXG4gICAgICBkYXRhOiB7fSxcbiAgICAgIHRleHQ6IFwiXCJcbiAgICB9O1xuICAgIGNvbnN0IGNhY2hlZFN0YXRlID0gc2tpcENhY2hlID8gZW1wdHlPYmogOiBhd2FpdCB0aGlzLnN0YXRlQ2FjaGUuZ2V0KG1lc3NhZ2UuaWQpIHx8IGVtcHR5T2JqO1xuICAgIGNvbnN0IHByb3ZpZGVyTmFtZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGlmIChmaWx0ZXJMaXN0ICYmIGZpbHRlckxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgZmlsdGVyTGlzdC5mb3JFYWNoKChuYW1lKSA9PiBwcm92aWRlck5hbWVzLmFkZChuYW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJvdmlkZXJzLmZpbHRlcigocCkgPT4gIXAucHJpdmF0ZSAmJiAhcC5keW5hbWljKS5mb3JFYWNoKChwKSA9PiBwcm92aWRlck5hbWVzLmFkZChwLm5hbWUpKTtcbiAgICB9XG4gICAgaWYgKCFmaWx0ZXJMaXN0ICYmIGluY2x1ZGVMaXN0ICYmIGluY2x1ZGVMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGluY2x1ZGVMaXN0LmZvckVhY2goKG5hbWUpID0+IHByb3ZpZGVyTmFtZXMuYWRkKG5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXJzVG9HZXQgPSBBcnJheS5mcm9tKFxuICAgICAgbmV3IFNldCh0aGlzLnByb3ZpZGVycy5maWx0ZXIoKHApID0+IHByb3ZpZGVyTmFtZXMuaGFzKHAubmFtZSkpKVxuICAgICkuc29ydCgoYSwgYikgPT4gKGEucG9zaXRpb24gfHwgMCkgLSAoYi5wb3NpdGlvbiB8fCAwKSk7XG4gICAgY29uc3QgcHJvdmlkZXJEYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBwcm92aWRlcnNUb0dldC5tYXAoYXN5bmMgKHByb3ZpZGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5nZXQodGhpcywgbWVzc2FnZSwgY2FjaGVkU3RhdGUpO1xuICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGAke3Byb3ZpZGVyLm5hbWV9IFByb3ZpZGVyIHRvb2sgJHtkdXJhdGlvbn1tcyB0byByZXNwb25kYCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgIHByb3ZpZGVyTmFtZTogcHJvdmlkZXIubmFtZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcInByb3ZpZGVyIGVycm9yXCIsIHByb3ZpZGVyLm5hbWUsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZXM6IHt9LCB0ZXh0OiBcIlwiLCBkYXRhOiB7fSwgcHJvdmlkZXJOYW1lOiBwcm92aWRlci5uYW1lIH07XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCBjdXJyZW50UHJvdmlkZXJSZXN1bHRzID0geyAuLi5jYWNoZWRTdGF0ZS5kYXRhPy5wcm92aWRlcnMgfHwge30gfTtcbiAgICBmb3IgKGNvbnN0IGZyZXNoUmVzdWx0IG9mIHByb3ZpZGVyRGF0YSkge1xuICAgICAgY3VycmVudFByb3ZpZGVyUmVzdWx0c1tmcmVzaFJlc3VsdC5wcm92aWRlck5hbWVdID0gZnJlc2hSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IG9yZGVyZWRUZXh0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgcHJvdmlkZXJzVG9HZXQpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGN1cnJlbnRQcm92aWRlclJlc3VsdHNbcHJvdmlkZXIubmFtZV07XG4gICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC50ZXh0ICYmIHJlc3VsdC50ZXh0LnRyaW0oKSAhPT0gXCJcIikge1xuICAgICAgICBvcmRlcmVkVGV4dHMucHVzaChyZXN1bHQudGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyc1RleHQgPSBvcmRlcmVkVGV4dHMuam9pbihcIlxcblwiKTtcbiAgICBjb25zdCBhZ2dyZWdhdGVkU3RhdGVWYWx1ZXMgPSB7IC4uLmNhY2hlZFN0YXRlLnZhbHVlcyB8fCB7fSB9O1xuICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgcHJvdmlkZXJzVG9HZXQpIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyUmVzdWx0ID0gY3VycmVudFByb3ZpZGVyUmVzdWx0c1twcm92aWRlci5uYW1lXTtcbiAgICAgIGlmIChwcm92aWRlclJlc3VsdCAmJiBwcm92aWRlclJlc3VsdC52YWx1ZXMgJiYgdHlwZW9mIHByb3ZpZGVyUmVzdWx0LnZhbHVlcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBPYmplY3QuYXNzaWduKGFnZ3JlZ2F0ZWRTdGF0ZVZhbHVlcywgcHJvdmlkZXJSZXN1bHQudmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm92aWRlck5hbWUgaW4gY3VycmVudFByb3ZpZGVyUmVzdWx0cykge1xuICAgICAgaWYgKCFwcm92aWRlcnNUb0dldC5zb21lKChwKSA9PiBwLm5hbWUgPT09IHByb3ZpZGVyTmFtZSkpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJSZXN1bHQgPSBjdXJyZW50UHJvdmlkZXJSZXN1bHRzW3Byb3ZpZGVyTmFtZV07XG4gICAgICAgIGlmIChwcm92aWRlclJlc3VsdCAmJiBwcm92aWRlclJlc3VsdC52YWx1ZXMgJiYgdHlwZW9mIHByb3ZpZGVyUmVzdWx0LnZhbHVlcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oYWdncmVnYXRlZFN0YXRlVmFsdWVzLCBwcm92aWRlclJlc3VsdC52YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgdmFsdWVzOiB7XG4gICAgICAgIC4uLmFnZ3JlZ2F0ZWRTdGF0ZVZhbHVlcyxcbiAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnNUZXh0XG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICAuLi5jYWNoZWRTdGF0ZS5kYXRhIHx8IHt9LFxuICAgICAgICBwcm92aWRlcnM6IGN1cnJlbnRQcm92aWRlclJlc3VsdHNcbiAgICAgIH0sXG4gICAgICB0ZXh0OiBwcm92aWRlcnNUZXh0XG4gICAgfTtcbiAgICB0aGlzLnN0YXRlQ2FjaGUuc2V0KG1lc3NhZ2UuaWQsIG5ld1N0YXRlKTtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cbiAgZ2V0U2VydmljZShzZXJ2aWNlTmFtZSkge1xuICAgIGNvbnN0IHNlcnZpY2VJbnN0YW5jZXMgPSB0aGlzLnNlcnZpY2VzLmdldChzZXJ2aWNlTmFtZSk7XG4gICAgaWYgKCFzZXJ2aWNlSW5zdGFuY2VzIHx8IHNlcnZpY2VJbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgU2VydmljZSAke3NlcnZpY2VOYW1lfSBub3QgZm91bmRgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc2VydmljZUluc3RhbmNlc1swXTtcbiAgfVxuICAvKipcbiAgICogVHlwZS1zYWZlIHNlcnZpY2UgZ2V0dGVyIHRoYXQgZW5zdXJlcyB0aGUgY29ycmVjdCBzZXJ2aWNlIHR5cGUgaXMgcmV0dXJuZWRcbiAgICogQHRlbXBsYXRlIFQgLSBUaGUgZXhwZWN0ZWQgc2VydmljZSBjbGFzcyB0eXBlXG4gICAqIEBwYXJhbSBzZXJ2aWNlTmFtZSAtIFRoZSBzZXJ2aWNlIHR5cGUgbmFtZVxuICAgKiBAcmV0dXJucyBUaGUgc2VydmljZSBpbnN0YW5jZSB3aXRoIHByb3BlciB0eXBpbmcsIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAqL1xuICBnZXRUeXBlZFNlcnZpY2Uoc2VydmljZU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTZXJ2aWNlKHNlcnZpY2VOYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBzZXJ2aWNlcyBvZiBhIHNwZWNpZmljIHR5cGVcbiAgICogQHRlbXBsYXRlIFQgLSBUaGUgZXhwZWN0ZWQgc2VydmljZSBjbGFzcyB0eXBlXG4gICAqIEBwYXJhbSBzZXJ2aWNlTmFtZSAtIFRoZSBzZXJ2aWNlIHR5cGUgbmFtZVxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBzZXJ2aWNlIGluc3RhbmNlcyB3aXRoIHByb3BlciB0eXBpbmdcbiAgICovXG4gIGdldFNlcnZpY2VzQnlUeXBlKHNlcnZpY2VOYW1lKSB7XG4gICAgY29uc3Qgc2VydmljZUluc3RhbmNlcyA9IHRoaXMuc2VydmljZXMuZ2V0KHNlcnZpY2VOYW1lKTtcbiAgICBpZiAoIXNlcnZpY2VJbnN0YW5jZXMgfHwgc2VydmljZUluc3RhbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBObyBzZXJ2aWNlcyBmb3VuZCBmb3IgdHlwZSAke3NlcnZpY2VOYW1lfWApO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gc2VydmljZUluc3RhbmNlcztcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCByZWdpc3RlcmVkIHNlcnZpY2UgdHlwZXNcbiAgICogQHJldHVybnMgQXJyYXkgb2YgcmVnaXN0ZXJlZCBzZXJ2aWNlIHR5cGUgbmFtZXNcbiAgICovXG4gIGdldFJlZ2lzdGVyZWRTZXJ2aWNlVHlwZXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zZXJ2aWNlcy5rZXlzKCkpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHNlcnZpY2UgdHlwZSBpcyByZWdpc3RlcmVkXG4gICAqIEBwYXJhbSBzZXJ2aWNlVHlwZSAtIFRoZSBzZXJ2aWNlIHR5cGUgdG8gY2hlY2tcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2VydmljZSBpcyByZWdpc3RlcmVkXG4gICAqL1xuICBoYXNTZXJ2aWNlKHNlcnZpY2VUeXBlKSB7XG4gICAgY29uc3Qgc2VydmljZUluc3RhbmNlcyA9IHRoaXMuc2VydmljZXMuZ2V0KHNlcnZpY2VUeXBlKTtcbiAgICByZXR1cm4gc2VydmljZUluc3RhbmNlcyAhPT0gdm9pZCAwICYmIHNlcnZpY2VJbnN0YW5jZXMubGVuZ3RoID4gMDtcbiAgfVxuICBhc3luYyByZWdpc3RlclNlcnZpY2Uoc2VydmljZURlZikge1xuICAgIGNvbnN0IHNlcnZpY2VUeXBlID0gc2VydmljZURlZi5zZXJ2aWNlVHlwZTtcbiAgICBpZiAoIXNlcnZpY2VUeXBlKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICBgU2VydmljZSAke3NlcnZpY2VEZWYubmFtZX0gaXMgbWlzc2luZyBzZXJ2aWNlVHlwZS4gUGxlYXNlIGRlZmluZSBhIHN0YXRpYyBzZXJ2aWNlVHlwZSBwcm9wZXJ0eS5gXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgIGAke3RoaXMuY2hhcmFjdGVyLm5hbWV9KCR7dGhpcy5hZ2VudElkfSkgLSBSZWdpc3RlcmluZyBzZXJ2aWNlOmAsXG4gICAgICBzZXJ2aWNlVHlwZVxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlcnZpY2VJbnN0YW5jZSA9IGF3YWl0IHNlcnZpY2VEZWYuc3RhcnQodGhpcyk7XG4gICAgICBpZiAoIXRoaXMuc2VydmljZXMuaGFzKHNlcnZpY2VUeXBlKSkge1xuICAgICAgICB0aGlzLnNlcnZpY2VzLnNldChzZXJ2aWNlVHlwZSwgW10pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnNlcnZpY2VUeXBlcy5oYXMoc2VydmljZVR5cGUpKSB7XG4gICAgICAgIHRoaXMuc2VydmljZVR5cGVzLnNldChzZXJ2aWNlVHlwZSwgW10pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXJ2aWNlcy5nZXQoc2VydmljZVR5cGUpLnB1c2goc2VydmljZUluc3RhbmNlKTtcbiAgICAgIHRoaXMuc2VydmljZVR5cGVzLmdldChzZXJ2aWNlVHlwZSkucHVzaChzZXJ2aWNlRGVmKTtcbiAgICAgIGlmICh0eXBlb2Ygc2VydmljZURlZi5yZWdpc3RlclNlbmRIYW5kbGVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHNlcnZpY2VEZWYucmVnaXN0ZXJTZW5kSGFuZGxlcnModGhpcywgc2VydmljZUluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgJHt0aGlzLmNoYXJhY3Rlci5uYW1lfSgke3RoaXMuYWdlbnRJZH0pIC0gU2VydmljZSAke3NlcnZpY2VUeXBlfSByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseWBcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBgJHt0aGlzLmNoYXJhY3Rlci5uYW1lfSgke3RoaXMuYWdlbnRJZH0pIC0gRmFpbGVkIHRvIHJlZ2lzdGVyIHNlcnZpY2UgJHtzZXJ2aWNlVHlwZX06ICR7ZXJyb3JNZXNzYWdlfWBcbiAgICAgICk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJNb2RlbChtb2RlbFR5cGUsIGhhbmRsZXIsIHByb3ZpZGVyLCBwcmlvcml0eSkge1xuICAgIGNvbnN0IG1vZGVsS2V5ID0gdHlwZW9mIG1vZGVsVHlwZSA9PT0gXCJzdHJpbmdcIiA/IG1vZGVsVHlwZSA6IE1vZGVsVHlwZVttb2RlbFR5cGVdO1xuICAgIGlmICghdGhpcy5tb2RlbHMuaGFzKG1vZGVsS2V5KSkge1xuICAgICAgdGhpcy5tb2RlbHMuc2V0KG1vZGVsS2V5LCBbXSk7XG4gICAgfVxuICAgIGNvbnN0IHJlZ2lzdHJhdGlvbk9yZGVyID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLm1vZGVscy5nZXQobW9kZWxLZXkpPy5wdXNoKHtcbiAgICAgIGhhbmRsZXIsXG4gICAgICBwcm92aWRlcixcbiAgICAgIHByaW9yaXR5OiBwcmlvcml0eSB8fCAwLFxuICAgICAgcmVnaXN0cmF0aW9uT3JkZXJcbiAgICB9KTtcbiAgICB0aGlzLm1vZGVscy5nZXQobW9kZWxLZXkpPy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoKGIucHJpb3JpdHkgfHwgMCkgIT09IChhLnByaW9yaXR5IHx8IDApKSB7XG4gICAgICAgIHJldHVybiAoYi5wcmlvcml0eSB8fCAwKSAtIChhLnByaW9yaXR5IHx8IDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGEucmVnaXN0cmF0aW9uT3JkZXIgLSBiLnJlZ2lzdHJhdGlvbk9yZGVyO1xuICAgIH0pO1xuICB9XG4gIGdldE1vZGVsKG1vZGVsVHlwZSwgcHJvdmlkZXIpIHtcbiAgICBjb25zdCBtb2RlbEtleSA9IHR5cGVvZiBtb2RlbFR5cGUgPT09IFwic3RyaW5nXCIgPyBtb2RlbFR5cGUgOiBNb2RlbFR5cGVbbW9kZWxUeXBlXTtcbiAgICBjb25zdCBtb2RlbHMgPSB0aGlzLm1vZGVscy5nZXQobW9kZWxLZXkpO1xuICAgIGlmICghbW9kZWxzPy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChwcm92aWRlcikge1xuICAgICAgY29uc3QgbW9kZWxXaXRoUHJvdmlkZXIgPSBtb2RlbHMuZmluZCgobSkgPT4gbS5wcm92aWRlciA9PT0gcHJvdmlkZXIpO1xuICAgICAgaWYgKG1vZGVsV2l0aFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgIGBbQWdlbnRSdW50aW1lXVske3RoaXMuY2hhcmFjdGVyLm5hbWV9XSBVc2luZyBtb2RlbCAke21vZGVsS2V5fSBmcm9tIHByb3ZpZGVyICR7cHJvdmlkZXJ9YFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbW9kZWxXaXRoUHJvdmlkZXIuaGFuZGxlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgICAgYFtBZ2VudFJ1bnRpbWVdWyR7dGhpcy5jaGFyYWN0ZXIubmFtZX1dIE5vIG1vZGVsIGZvdW5kIGZvciBwcm92aWRlciAke3Byb3ZpZGVyfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICBgW0FnZW50UnVudGltZV1bJHt0aGlzLmNoYXJhY3Rlci5uYW1lfV0gVXNpbmcgbW9kZWwgJHttb2RlbEtleX0gZnJvbSBwcm92aWRlciAke21vZGVsc1swXS5wcm92aWRlcn1gXG4gICAgKTtcbiAgICByZXR1cm4gbW9kZWxzWzBdLmhhbmRsZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBtb2RlbCBjb25maWd1cmF0aW9uIHNldHRpbmdzIGZyb20gY2hhcmFjdGVyIHNldHRpbmdzIHdpdGggc3VwcG9ydCBmb3JcbiAgICogbW9kZWwtc3BlY2lmaWMgb3ZlcnJpZGVzIGFuZCBkZWZhdWx0IGZhbGxiYWNrcy5cbiAgICpcbiAgICogUHJlY2VkZW5jZSBvcmRlciAoaGlnaGVzdCB0byBsb3dlc3QpOlxuICAgKiAxLiBNb2RlbC1zcGVjaWZpYyBzZXR0aW5ncyAoZS5nLiwgVEVYVF9TTUFMTF9URU1QRVJBVFVSRSlcbiAgICogMi4gRGVmYXVsdCBzZXR0aW5ncyAoZS5nLiwgREVGQVVMVF9URU1QRVJBVFVSRSlcbiAgICogMy4gTGVnYWN5IHNldHRpbmdzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoZS5nLiwgTU9ERUxfVEVNUEVSQVRVUkUpXG4gICAqXG4gICAqIEBwYXJhbSBtb2RlbFR5cGUgVGhlIHNwZWNpZmljIG1vZGVsIHR5cGUgdG8gZ2V0IHNldHRpbmdzIGZvclxuICAgKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyBtb2RlbCBwYXJhbWV0ZXJzIGlmIHRoZXkgZXhpc3QsIG9yIG51bGwgaWYgbm8gc2V0dGluZ3MgYXJlIGNvbmZpZ3VyZWRcbiAgICovXG4gIGdldE1vZGVsU2V0dGluZ3MobW9kZWxUeXBlKSB7XG4gICAgY29uc3QgbW9kZWxTZXR0aW5ncyA9IHt9O1xuICAgIGNvbnN0IGdldFNldHRpbmdXaXRoRmFsbGJhY2sgPSAocGFyYW0sIGxlZ2FjeUtleSkgPT4ge1xuICAgICAgaWYgKG1vZGVsVHlwZSkge1xuICAgICAgICBjb25zdCBtb2RlbFNwZWNpZmljS2V5ID0gYCR7bW9kZWxUeXBlfV8ke3BhcmFtfWA7XG4gICAgICAgIGNvbnN0IG1vZGVsVmFsdWUgPSB0aGlzLmdldFNldHRpbmcobW9kZWxTcGVjaWZpY0tleSk7XG4gICAgICAgIGlmIChtb2RlbFZhbHVlICE9PSBudWxsICYmIG1vZGVsVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnN0IG51bVZhbHVlID0gTnVtYmVyKG1vZGVsVmFsdWUpO1xuICAgICAgICAgIGlmICghaXNOYU4obnVtVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkZWZhdWx0S2V5ID0gYERFRkFVTFRfJHtwYXJhbX1gO1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5nZXRTZXR0aW5nKGRlZmF1bHRLZXkpO1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBudW1WYWx1ZSA9IE51bWJlcihkZWZhdWx0VmFsdWUpO1xuICAgICAgICBpZiAoIWlzTmFOKG51bVZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBudW1WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbGVnYWN5VmFsdWUgPSB0aGlzLmdldFNldHRpbmcobGVnYWN5S2V5KTtcbiAgICAgIGlmIChsZWdhY3lWYWx1ZSAhPT0gbnVsbCAmJiBsZWdhY3lWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG51bVZhbHVlID0gTnVtYmVyKGxlZ2FjeVZhbHVlKTtcbiAgICAgICAgaWYgKCFpc05hTihudW1WYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVtVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgbWF4VG9rZW5zID0gZ2V0U2V0dGluZ1dpdGhGYWxsYmFjayhcIk1BWF9UT0tFTlNcIiwgTU9ERUxfU0VUVElOR1MuTU9ERUxfTUFYX1RPS0VOKTtcbiAgICBjb25zdCB0ZW1wZXJhdHVyZSA9IGdldFNldHRpbmdXaXRoRmFsbGJhY2soXCJURU1QRVJBVFVSRVwiLCBNT0RFTF9TRVRUSU5HUy5NT0RFTF9URU1QRVJBVFVSRSk7XG4gICAgY29uc3QgZnJlcXVlbmN5UGVuYWx0eSA9IGdldFNldHRpbmdXaXRoRmFsbGJhY2soXG4gICAgICBcIkZSRVFVRU5DWV9QRU5BTFRZXCIsXG4gICAgICBNT0RFTF9TRVRUSU5HUy5NT0RFTF9GUkVRX1BFTkFMVFlcbiAgICApO1xuICAgIGNvbnN0IHByZXNlbmNlUGVuYWx0eSA9IGdldFNldHRpbmdXaXRoRmFsbGJhY2soXG4gICAgICBcIlBSRVNFTkNFX1BFTkFMVFlcIixcbiAgICAgIE1PREVMX1NFVFRJTkdTLk1PREVMX1BSRVNFTkNFX1BFTkFMVFlcbiAgICApO1xuICAgIGlmIChtYXhUb2tlbnMgIT09IG51bGwpIG1vZGVsU2V0dGluZ3MubWF4VG9rZW5zID0gbWF4VG9rZW5zO1xuICAgIGlmICh0ZW1wZXJhdHVyZSAhPT0gbnVsbCkgbW9kZWxTZXR0aW5ncy50ZW1wZXJhdHVyZSA9IHRlbXBlcmF0dXJlO1xuICAgIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9PSBudWxsKSBtb2RlbFNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHkgPSBmcmVxdWVuY3lQZW5hbHR5O1xuICAgIGlmIChwcmVzZW5jZVBlbmFsdHkgIT09IG51bGwpIG1vZGVsU2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5ID0gcHJlc2VuY2VQZW5hbHR5O1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtb2RlbFNldHRpbmdzKS5sZW5ndGggPiAwID8gbW9kZWxTZXR0aW5ncyA6IG51bGw7XG4gIH1cbiAgYXN5bmMgdXNlTW9kZWwobW9kZWxUeXBlLCBwYXJhbXMsIHByb3ZpZGVyKSB7XG4gICAgY29uc3QgbW9kZWxLZXkgPSB0eXBlb2YgbW9kZWxUeXBlID09PSBcInN0cmluZ1wiID8gbW9kZWxUeXBlIDogTW9kZWxUeXBlW21vZGVsVHlwZV07XG4gICAgY29uc3QgcHJvbXB0Q29udGVudCA9IHBhcmFtcz8ucHJvbXB0IHx8IHBhcmFtcz8uaW5wdXQgfHwgKEFycmF5LmlzQXJyYXkocGFyYW1zPy5tZXNzYWdlcykgPyBKU09OLnN0cmluZ2lmeShwYXJhbXMubWVzc2FnZXMpIDogbnVsbCk7XG4gICAgY29uc3QgbW9kZWwgPSB0aGlzLmdldE1vZGVsKG1vZGVsS2V5LCBwcm92aWRlcik7XG4gICAgaWYgKCFtb2RlbCkge1xuICAgICAgY29uc3QgZXJyb3JNc2cgPSBgTm8gaGFuZGxlciBmb3VuZCBmb3IgZGVsZWdhdGUgdHlwZTogJHttb2RlbEtleX1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICBgW3VzZU1vZGVsXSAke21vZGVsS2V5fSBpbnB1dDogYCArIEpTT04uc3RyaW5naWZ5KHBhcmFtcywgc2FmZVJlcGxhY2VyKCksIDIpLnJlcGxhY2UoL1xcXFxuL2csIFwiXFxuXCIpXG4gICAgKTtcbiAgICBsZXQgcGFyYW1zV2l0aFJ1bnRpbWU7XG4gICAgaWYgKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCB8fCB0eXBlb2YgcGFyYW1zICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkocGFyYW1zKSB8fCB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIEJ1ZmZlci5pc0J1ZmZlcihwYXJhbXMpKSB7XG4gICAgICBwYXJhbXNXaXRoUnVudGltZSA9IHBhcmFtcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbW9kZWxTZXR0aW5ncyA9IHRoaXMuZ2V0TW9kZWxTZXR0aW5ncyhtb2RlbEtleSk7XG4gICAgICBpZiAobW9kZWxTZXR0aW5ncykge1xuICAgICAgICBwYXJhbXNXaXRoUnVudGltZSA9IHtcbiAgICAgICAgICAuLi5tb2RlbFNldHRpbmdzLFxuICAgICAgICAgIC8vIEFwcGx5IG1vZGVsIHNldHRpbmdzIGZpcnN0IChpbmNsdWRlcyBkZWZhdWx0cyBhbmQgbW9kZWwtc3BlY2lmaWMpXG4gICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgIC8vIFRoZW4gYXBwbHkgc3BlY2lmaWMgcGFyYW1zIChhbGxvd2luZyBvdmVycmlkZXMpXG4gICAgICAgICAgcnVudGltZTogdGhpc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zV2l0aFJ1bnRpbWUgPSB7XG4gICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgIHJ1bnRpbWU6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbW9kZWwodGhpcywgcGFyYW1zV2l0aFJ1bnRpbWUpO1xuICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgW3VzZU1vZGVsXSAke21vZGVsS2V5fSBvdXRwdXQgKHRvb2sgJHtOdW1iZXIoZWxhcHNlZFRpbWUudG9GaXhlZCgyKSkudG9Mb2NhbGVTdHJpbmcoKX1tcyk6YCxcbiAgICAgICAgQXJyYXkuaXNBcnJheShyZXNwb25zZSkgPyBgJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZS5zbGljZSgwLCA1KSl9Li4uJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZS5zbGljZSgtNSkpfSAoJHtyZXNwb25zZS5sZW5ndGh9IGl0ZW1zKWAgOiBKU09OLnN0cmluZ2lmeShyZXNwb25zZSwgc2FmZVJlcGxhY2VyKCksIDIpLnJlcGxhY2UoL1xcXFxuL2csIFwiXFxuXCIpXG4gICAgICApO1xuICAgICAgaWYgKG1vZGVsS2V5ICE9PSBNb2RlbFR5cGUuVEVYVF9FTUJFRERJTkcgJiYgcHJvbXB0Q29udGVudCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCkge1xuICAgICAgICAgIHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQucHJvbXB0cy5wdXNoKHtcbiAgICAgICAgICAgIG1vZGVsVHlwZTogbW9kZWxLZXksXG4gICAgICAgICAgICBwcm9tcHQ6IHByb21wdENvbnRlbnQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hZGFwdGVyLmxvZyh7XG4gICAgICAgIGVudGl0eUlkOiB0aGlzLmFnZW50SWQsXG4gICAgICAgIHJvb21JZDogdGhpcy5hZ2VudElkLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICAgIG1vZGVsS2V5LFxuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgLi4udHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMpICYmIHBhcmFtcyA/IHBhcmFtcyA6IHt9LFxuICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRDb250ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9tcHQ6IHByb21wdENvbnRlbnQsXG4gICAgICAgICAgcnVuSWQ6IHRoaXMuZ2V0Q3VycmVudFJ1bklkKCksXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIGV4ZWN1dGlvblRpbWU6IGVsYXBzZWRUaW1lLFxuICAgICAgICAgIHByb3ZpZGVyOiBwcm92aWRlciB8fCB0aGlzLm1vZGVscy5nZXQobW9kZWxLZXkpPy5bMF0/LnByb3ZpZGVyIHx8IFwidW5rbm93blwiLFxuICAgICAgICAgIGFjdGlvbkNvbnRleHQ6IHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQgPyB7XG4gICAgICAgICAgICBhY3Rpb25OYW1lOiB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0LmFjdGlvbk5hbWUsXG4gICAgICAgICAgICBhY3Rpb25JZDogdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dC5hY3Rpb25JZFxuICAgICAgICAgIH0gOiB2b2lkIDAsXG4gICAgICAgICAgcmVzcG9uc2U6IEFycmF5LmlzQXJyYXkocmVzcG9uc2UpICYmIHJlc3BvbnNlLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikgPyBcIlthcnJheV1cIiA6IHJlc3BvbnNlXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IGB1c2VNb2RlbDoke21vZGVsS2V5fWBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJFdmVudChldmVudCwgaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5ldmVudHMuaGFzKGV2ZW50KSkge1xuICAgICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50LCBbXSk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzLmdldChldmVudCk/LnB1c2goaGFuZGxlcik7XG4gIH1cbiAgZ2V0RXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudHMuZ2V0KGV2ZW50KTtcbiAgfVxuICBhc3luYyBlbWl0RXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IGV2ZW50cyA9IEFycmF5LmlzQXJyYXkoZXZlbnQpID8gZXZlbnQgOiBbZXZlbnRdO1xuICAgIGZvciAoY29uc3QgZXZlbnROYW1lIG9mIGV2ZW50cykge1xuICAgICAgY29uc3QgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldChldmVudE5hbWUpO1xuICAgICAgaWYgKCFldmVudEhhbmRsZXJzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZXZlbnRIYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGhhbmRsZXIocGFyYW1zKSkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm9yIGR1cmluZyBlbWl0RXZlbnQgZm9yICR7ZXZlbnROYW1lfSAoaGFuZGxlciBleGVjdXRpb24pOmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZW5zdXJlRW1iZWRkaW5nRGltZW5zaW9uKCkge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBbQWdlbnRSdW50aW1lXVske3RoaXMuY2hhcmFjdGVyLm5hbWV9XSBTdGFydGluZyBlbnN1cmVFbWJlZGRpbmdEaW1lbnNpb25gKTtcbiAgICBpZiAoIXRoaXMuYWRhcHRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgW0FnZW50UnVudGltZV1bJHt0aGlzLmNoYXJhY3Rlci5uYW1lfV0gRGF0YWJhc2UgYWRhcHRlciBub3QgaW5pdGlhbGl6ZWQgYmVmb3JlIGVuc3VyZUVtYmVkZGluZ0RpbWVuc2lvbmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBtb2RlbCA9IHRoaXMuZ2V0TW9kZWwoTW9kZWxUeXBlLlRFWFRfRU1CRURESU5HKTtcbiAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBbQWdlbnRSdW50aW1lXVske3RoaXMuY2hhcmFjdGVyLm5hbWV9XSBObyBURVhUX0VNQkVERElORyBtb2RlbCByZWdpc3RlcmVkYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFtBZ2VudFJ1bnRpbWVdWyR7dGhpcy5jaGFyYWN0ZXIubmFtZX1dIEdldHRpbmcgZW1iZWRkaW5nIGRpbWVuc2lvbnNgKTtcbiAgICAgIGNvbnN0IGVtYmVkZGluZyA9IGF3YWl0IHRoaXMudXNlTW9kZWwoTW9kZWxUeXBlLlRFWFRfRU1CRURESU5HLCBudWxsKTtcbiAgICAgIGlmICghZW1iZWRkaW5nIHx8ICFlbWJlZGRpbmcubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW0FnZW50UnVudGltZV1bJHt0aGlzLmNoYXJhY3Rlci5uYW1lfV0gSW52YWxpZCBlbWJlZGRpbmcgcmVjZWl2ZWRgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgW0FnZW50UnVudGltZV1bJHt0aGlzLmNoYXJhY3Rlci5uYW1lfV0gU2V0dGluZyBlbWJlZGRpbmcgZGltZW5zaW9uOiAke2VtYmVkZGluZy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICAgIGF3YWl0IHRoaXMuYWRhcHRlci5lbnN1cmVFbWJlZGRpbmdEaW1lbnNpb24oZW1iZWRkaW5nLmxlbmd0aCk7XG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYFtBZ2VudFJ1bnRpbWVdWyR7dGhpcy5jaGFyYWN0ZXIubmFtZX1dIFN1Y2Nlc3NmdWxseSBzZXQgZW1iZWRkaW5nIGRpbWVuc2lvbmBcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgW0FnZW50UnVudGltZV1bJHt0aGlzLmNoYXJhY3Rlci5uYW1lfV0gRXJyb3IgaW4gZW5zdXJlRW1iZWRkaW5nRGltZW5zaW9uOmAsXG4gICAgICAgIGVycm9yXG4gICAgICApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyVGFza1dvcmtlcih0YXNrSGFuZGxlcikge1xuICAgIGlmICh0aGlzLnRhc2tXb3JrZXJzLmhhcyh0YXNrSGFuZGxlci5uYW1lKSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgYFRhc2sgZGVmaW5pdGlvbiAke3Rhc2tIYW5kbGVyLm5hbWV9IGFscmVhZHkgcmVnaXN0ZXJlZC4gV2lsbCBiZSBvdmVyd3JpdHRlbi5gXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnRhc2tXb3JrZXJzLnNldCh0YXNrSGFuZGxlci5uYW1lLCB0YXNrSGFuZGxlcik7XG4gIH1cbiAgZ2V0VGFza1dvcmtlcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudGFza1dvcmtlcnMuZ2V0KG5hbWUpO1xuICB9XG4gIGdldCBkYigpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyLmRiO1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgYXdhaXQgdGhpcy5hZGFwdGVyLmluaXQoKTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBhd2FpdCB0aGlzLmFkYXB0ZXIuY2xvc2UoKTtcbiAgfVxuICBhc3luYyBnZXRBZ2VudChhZ2VudElkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5nZXRBZ2VudChhZ2VudElkKTtcbiAgfVxuICBhc3luYyBnZXRBZ2VudHMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5nZXRBZ2VudHMoKTtcbiAgfVxuICBhc3luYyBjcmVhdGVBZ2VudChhZ2VudCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuY3JlYXRlQWdlbnQoYWdlbnQpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUFnZW50KGFnZW50SWQsIGFnZW50KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci51cGRhdGVBZ2VudChhZ2VudElkLCBhZ2VudCk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlQWdlbnQoYWdlbnRJZCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZGVsZXRlQWdlbnQoYWdlbnRJZCk7XG4gIH1cbiAgYXN5bmMgZW5zdXJlQWdlbnRFeGlzdHMoYWdlbnQpIHtcbiAgICBpZiAoIWFnZW50Lm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFnZW50IG5hbWUgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGFnZW50cyA9IGF3YWl0IHRoaXMuYWRhcHRlci5nZXRBZ2VudHMoKTtcbiAgICBjb25zdCBleGlzdGluZ0FnZW50SWQgPSBhZ2VudHMuZmluZCgoYSkgPT4gYS5uYW1lID09PSBhZ2VudC5uYW1lKT8uaWQ7XG4gICAgaWYgKGV4aXN0aW5nQWdlbnRJZCkge1xuICAgICAgY29uc3QgdXBkYXRlZEFnZW50ID0ge1xuICAgICAgICAuLi5hZ2VudCxcbiAgICAgICAgaWQ6IGV4aXN0aW5nQWdlbnRJZCxcbiAgICAgICAgdXBkYXRlZEF0OiBEYXRlLm5vdygpXG4gICAgICB9O1xuICAgICAgYXdhaXQgdGhpcy5hZGFwdGVyLnVwZGF0ZUFnZW50KGV4aXN0aW5nQWdlbnRJZCwgdXBkYXRlZEFnZW50KTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nQWdlbnQgPSBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0QWdlbnQoZXhpc3RpbmdBZ2VudElkKTtcbiAgICAgIGlmICghZXhpc3RpbmdBZ2VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZXRyaWV2ZSBhZ2VudCBhZnRlciB1cGRhdGU6ICR7ZXhpc3RpbmdBZ2VudElkfWApO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFVwZGF0ZWQgZXhpc3RpbmcgYWdlbnQgJHthZ2VudC5uYW1lfSBvbiByZXN0YXJ0YCk7XG4gICAgICByZXR1cm4gZXhpc3RpbmdBZ2VudDtcbiAgICB9XG4gICAgY29uc3QgbmV3QWdlbnQgPSB7XG4gICAgICAuLi5hZ2VudCxcbiAgICAgIGlkOiBzdHJpbmdUb1V1aWQoYWdlbnQubmFtZSlcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZWQgPSBhd2FpdCB0aGlzLmFkYXB0ZXIuY3JlYXRlQWdlbnQobmV3QWdlbnQpO1xuICAgIGlmICghY3JlYXRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGFnZW50OiAke2FnZW50Lm5hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBDcmVhdGVkIG5ldyBhZ2VudCAke2FnZW50Lm5hbWV9YCk7XG4gICAgcmV0dXJuIG5ld0FnZW50O1xuICB9XG4gIGFzeW5jIGdldEVudGl0eUJ5SWQoZW50aXR5SWQpIHtcbiAgICBjb25zdCBlbnRpdGllcyA9IGF3YWl0IHRoaXMuYWRhcHRlci5nZXRFbnRpdGllc0J5SWRzKFtlbnRpdHlJZF0pO1xuICAgIGlmICghZW50aXRpZXM/Lmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGVudGl0aWVzWzBdO1xuICB9XG4gIGFzeW5jIGdldEVudGl0aWVzQnlJZHMoZW50aXR5SWRzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5nZXRFbnRpdGllc0J5SWRzKGVudGl0eUlkcyk7XG4gIH1cbiAgYXN5bmMgZ2V0RW50aXRpZXNGb3JSb29tKHJvb21JZCwgaW5jbHVkZUNvbXBvbmVudHMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldEVudGl0aWVzRm9yUm9vbShyb29tSWQsIGluY2x1ZGVDb21wb25lbnRzKTtcbiAgfVxuICBhc3luYyBjcmVhdGVFbnRpdHkoZW50aXR5KSB7XG4gICAgaWYgKCFlbnRpdHkuYWdlbnRJZCkge1xuICAgICAgZW50aXR5LmFnZW50SWQgPSB0aGlzLmFnZW50SWQ7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUVudGl0aWVzKFtlbnRpdHldKTtcbiAgfVxuICBhc3luYyBjcmVhdGVFbnRpdGllcyhlbnRpdGllcykge1xuICAgIGVudGl0aWVzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUuYWdlbnRJZCA9IHRoaXMuYWdlbnRJZDtcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmNyZWF0ZUVudGl0aWVzKGVudGl0aWVzKTtcbiAgfVxuICBhc3luYyB1cGRhdGVFbnRpdHkoZW50aXR5KSB7XG4gICAgYXdhaXQgdGhpcy5hZGFwdGVyLnVwZGF0ZUVudGl0eShlbnRpdHkpO1xuICB9XG4gIGFzeW5jIGdldENvbXBvbmVudChlbnRpdHlJZCwgdHlwZSwgd29ybGRJZCwgc291cmNlRW50aXR5SWQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldENvbXBvbmVudChlbnRpdHlJZCwgdHlwZSwgd29ybGRJZCwgc291cmNlRW50aXR5SWQpO1xuICB9XG4gIGFzeW5jIGdldENvbXBvbmVudHMoZW50aXR5SWQsIHdvcmxkSWQsIHNvdXJjZUVudGl0eUlkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5nZXRDb21wb25lbnRzKGVudGl0eUlkLCB3b3JsZElkLCBzb3VyY2VFbnRpdHlJZCk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGF3YWl0IHRoaXMuYWRhcHRlci51cGRhdGVDb21wb25lbnQoY29tcG9uZW50KTtcbiAgfVxuICBhc3luYyBkZWxldGVDb21wb25lbnQoY29tcG9uZW50SWQpIHtcbiAgICBhd2FpdCB0aGlzLmFkYXB0ZXIuZGVsZXRlQ29tcG9uZW50KGNvbXBvbmVudElkKTtcbiAgfVxuICBhc3luYyBhZGRFbWJlZGRpbmdUb01lbW9yeShtZW1vcnkpIHtcbiAgICBpZiAobWVtb3J5LmVtYmVkZGluZykge1xuICAgICAgcmV0dXJuIG1lbW9yeTtcbiAgICB9XG4gICAgY29uc3QgbWVtb3J5VGV4dCA9IG1lbW9yeS5jb250ZW50LnRleHQ7XG4gICAgaWYgKCFtZW1vcnlUZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2VuZXJhdGUgZW1iZWRkaW5nOiBNZW1vcnkgY29udGVudCBpcyBlbXB0eVwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG1lbW9yeS5lbWJlZGRpbmcgPSBhd2FpdCB0aGlzLnVzZU1vZGVsKE1vZGVsVHlwZS5URVhUX0VNQkVERElORywge1xuICAgICAgICB0ZXh0OiBtZW1vcnlUZXh0XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgZW1iZWRkaW5nOlwiLCBlcnJvcik7XG4gICAgICBtZW1vcnkuZW1iZWRkaW5nID0gYXdhaXQgdGhpcy51c2VNb2RlbChNb2RlbFR5cGUuVEVYVF9FTUJFRERJTkcsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gbWVtb3J5O1xuICB9XG4gIGFzeW5jIGdldE1lbW9yaWVzKHBhcmFtcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0TWVtb3JpZXMocGFyYW1zKTtcbiAgfVxuICBhc3luYyBnZXRBbGxNZW1vcmllcygpIHtcbiAgICBjb25zdCB0YWJsZXMgPSBbXCJtZW1vcmllc1wiLCBcIm1lc3NhZ2VzXCIsIFwiZmFjdHNcIiwgXCJkb2N1bWVudHNcIl07XG4gICAgY29uc3QgYWxsTWVtb3JpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhYmxlTmFtZSBvZiB0YWJsZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1lbW9yaWVzID0gYXdhaXQgdGhpcy5hZGFwdGVyLmdldE1lbW9yaWVzKHtcbiAgICAgICAgICBhZ2VudElkOiB0aGlzLmFnZW50SWQsXG4gICAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICAgIGNvdW50OiAxZTRcbiAgICAgICAgICAvLyBHZXQgYSBsYXJnZSBudW1iZXIgdG8gZmV0Y2ggYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBhbGxNZW1vcmllcy5wdXNoKC4uLm1lbW9yaWVzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGYWlsZWQgdG8gZ2V0IG1lbW9yaWVzIGZyb20gdGFibGUgJHt0YWJsZU5hbWV9OmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1lbW9yaWVzO1xuICB9XG4gIGFzeW5jIGdldE1lbW9yeUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldE1lbW9yeUJ5SWQoaWQpO1xuICB9XG4gIGFzeW5jIGdldE1lbW9yaWVzQnlJZHMoaWRzLCB0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldE1lbW9yaWVzQnlJZHMoaWRzLCB0YWJsZU5hbWUpO1xuICB9XG4gIGFzeW5jIGdldE1lbW9yaWVzQnlSb29tSWRzKHBhcmFtcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0TWVtb3JpZXNCeVJvb21JZHMocGFyYW1zKTtcbiAgfVxuICBhc3luYyBnZXRDYWNoZWRFbWJlZGRpbmdzKHBhcmFtcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0Q2FjaGVkRW1iZWRkaW5ncyhwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGxvZyhwYXJhbXMpIHtcbiAgICBhd2FpdCB0aGlzLmFkYXB0ZXIubG9nKHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgc2VhcmNoTWVtb3JpZXMocGFyYW1zKSB7XG4gICAgY29uc3QgbWVtb3JpZXMgPSBhd2FpdCB0aGlzLmFkYXB0ZXIuc2VhcmNoTWVtb3JpZXMocGFyYW1zKTtcbiAgICBpZiAocGFyYW1zLnF1ZXJ5KSB7XG4gICAgICBjb25zdCByZXJhbmtlZE1lbW9yaWVzID0gYXdhaXQgdGhpcy5yZXJhbmtNZW1vcmllcyhwYXJhbXMucXVlcnksIG1lbW9yaWVzKTtcbiAgICAgIHJldHVybiByZXJhbmtlZE1lbW9yaWVzO1xuICAgIH1cbiAgICByZXR1cm4gbWVtb3JpZXM7XG4gIH1cbiAgYXN5bmMgcmVyYW5rTWVtb3JpZXMocXVlcnksIG1lbW9yaWVzKSB7XG4gICAgY29uc3QgZG9jcyA9IG1lbW9yaWVzLm1hcCgobWVtb3J5KSA9PiAoe1xuICAgICAgdGl0bGU6IG1lbW9yeS5pZCxcbiAgICAgIGNvbnRlbnQ6IG1lbW9yeS5jb250ZW50LnRleHRcbiAgICB9KSk7XG4gICAgY29uc3QgYm0yNSA9IG5ldyBCTTI1KGRvY3MpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBibTI1LnNlYXJjaChxdWVyeSwgbWVtb3JpZXMubGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbWVtb3JpZXNbcmVzdWx0LmluZGV4XSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlTWVtb3J5KG1lbW9yeSwgdGFibGVOYW1lLCB1bmlxdWUpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmNyZWF0ZU1lbW9yeShtZW1vcnksIHRhYmxlTmFtZSwgdW5pcXVlKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNZW1vcnkobWVtb3J5KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci51cGRhdGVNZW1vcnkobWVtb3J5KTtcbiAgfVxuICBhc3luYyBkZWxldGVNZW1vcnkobWVtb3J5SWQpIHtcbiAgICBhd2FpdCB0aGlzLmFkYXB0ZXIuZGVsZXRlTWVtb3J5KG1lbW9yeUlkKTtcbiAgfVxuICBhc3luYyBkZWxldGVNYW55TWVtb3JpZXMobWVtb3J5SWRzKSB7XG4gICAgYXdhaXQgdGhpcy5hZGFwdGVyLmRlbGV0ZU1hbnlNZW1vcmllcyhtZW1vcnlJZHMpO1xuICB9XG4gIGFzeW5jIGNsZWFyQWxsQWdlbnRNZW1vcmllcygpIHtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKGBDbGVhcmluZyBhbGwgbWVtb3JpZXMgZm9yIGFnZW50ICR7dGhpcy5jaGFyYWN0ZXIubmFtZX0gKCR7dGhpcy5hZ2VudElkfSlgKTtcbiAgICBjb25zdCBhbGxNZW1vcmllcyA9IGF3YWl0IHRoaXMuZ2V0QWxsTWVtb3JpZXMoKTtcbiAgICBjb25zdCBtZW1vcnlJZHMgPSBhbGxNZW1vcmllcy5tYXAoKG1lbW9yeSkgPT4gbWVtb3J5LmlkKTtcbiAgICBpZiAobWVtb3J5SWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIk5vIG1lbW9yaWVzIGZvdW5kIHRvIGRlbGV0ZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhgRm91bmQgJHttZW1vcnlJZHMubGVuZ3RofSBtZW1vcmllcyB0byBkZWxldGVgKTtcbiAgICBhd2FpdCB0aGlzLmFkYXB0ZXIuZGVsZXRlTWFueU1lbW9yaWVzKG1lbW9yeUlkcyk7XG4gICAgdGhpcy5sb2dnZXIuaW5mbyhgU3VjY2Vzc2Z1bGx5IGNsZWFyZWQgYWxsICR7bWVtb3J5SWRzLmxlbmd0aH0gbWVtb3JpZXMgZm9yIGFnZW50YCk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlQWxsTWVtb3JpZXMocm9vbUlkLCB0YWJsZU5hbWUpIHtcbiAgICBhd2FpdCB0aGlzLmFkYXB0ZXIuZGVsZXRlQWxsTWVtb3JpZXMocm9vbUlkLCB0YWJsZU5hbWUpO1xuICB9XG4gIGFzeW5jIGNvdW50TWVtb3JpZXMocm9vbUlkLCB1bmlxdWUsIHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuY291bnRNZW1vcmllcyhyb29tSWQsIHVuaXF1ZSwgdGFibGVOYW1lKTtcbiAgfVxuICBhc3luYyBnZXRMb2dzKHBhcmFtcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0TG9ncyhwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGRlbGV0ZUxvZyhsb2dJZCkge1xuICAgIGF3YWl0IHRoaXMuYWRhcHRlci5kZWxldGVMb2cobG9nSWQpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVdvcmxkKHdvcmxkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5jcmVhdGVXb3JsZCh3b3JsZCk7XG4gIH1cbiAgYXN5bmMgZ2V0V29ybGQoaWQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldFdvcmxkKGlkKTtcbiAgfVxuICBhc3luYyByZW1vdmVXb3JsZCh3b3JsZElkKSB7XG4gICAgYXdhaXQgdGhpcy5hZGFwdGVyLnJlbW92ZVdvcmxkKHdvcmxkSWQpO1xuICB9XG4gIGFzeW5jIGdldEFsbFdvcmxkcygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldEFsbFdvcmxkcygpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVdvcmxkKHdvcmxkKSB7XG4gICAgYXdhaXQgdGhpcy5hZGFwdGVyLnVwZGF0ZVdvcmxkKHdvcmxkKTtcbiAgfVxuICBhc3luYyBnZXRSb29tKHJvb21JZCkge1xuICAgIGNvbnN0IHJvb21zID0gYXdhaXQgdGhpcy5hZGFwdGVyLmdldFJvb21zQnlJZHMoW3Jvb21JZF0pO1xuICAgIGlmICghcm9vbXM/Lmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHJvb21zWzBdO1xuICB9XG4gIGFzeW5jIGdldFJvb21zQnlJZHMocm9vbUlkcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0Um9vbXNCeUlkcyhyb29tSWRzKTtcbiAgfVxuICBhc3luYyBjcmVhdGVSb29tKHsgaWQsIG5hbWUsIHNvdXJjZSwgdHlwZSwgY2hhbm5lbElkLCBzZXJ2ZXJJZCwgd29ybGRJZCB9KSB7XG4gICAgaWYgKCF3b3JsZElkKSB0aHJvdyBuZXcgRXJyb3IoXCJ3b3JsZElkIGlzIHJlcXVpcmVkXCIpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuYWRhcHRlci5jcmVhdGVSb29tcyhbXG4gICAgICB7XG4gICAgICAgIGlkLFxuICAgICAgICBuYW1lLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoYW5uZWxJZCxcbiAgICAgICAgc2VydmVySWQsXG4gICAgICAgIHdvcmxkSWRcbiAgICAgIH1cbiAgICBdKTtcbiAgICBpZiAoIXJlcy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIHJldHVybiByZXNbMF07XG4gIH1cbiAgYXN5bmMgY3JlYXRlUm9vbXMocm9vbXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmNyZWF0ZVJvb21zKHJvb21zKTtcbiAgfVxuICBhc3luYyBkZWxldGVSb29tKHJvb21JZCkge1xuICAgIGF3YWl0IHRoaXMuYWRhcHRlci5kZWxldGVSb29tKHJvb21JZCk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlUm9vbXNCeVdvcmxkSWQod29ybGRJZCkge1xuICAgIGF3YWl0IHRoaXMuYWRhcHRlci5kZWxldGVSb29tc0J5V29ybGRJZCh3b3JsZElkKTtcbiAgfVxuICBhc3luYyB1cGRhdGVSb29tKHJvb20pIHtcbiAgICBhd2FpdCB0aGlzLmFkYXB0ZXIudXBkYXRlUm9vbShyb29tKTtcbiAgfVxuICBhc3luYyBnZXRSb29tc0ZvclBhcnRpY2lwYW50KGVudGl0eUlkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5nZXRSb29tc0ZvclBhcnRpY2lwYW50KGVudGl0eUlkKTtcbiAgfVxuICBhc3luYyBnZXRSb29tc0ZvclBhcnRpY2lwYW50cyh1c2VySWRzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5nZXRSb29tc0ZvclBhcnRpY2lwYW50cyh1c2VySWRzKTtcbiAgfVxuICAvLyBkZXByZWNhdGUgdGhpcyBvbmVcbiAgYXN5bmMgZ2V0Um9vbXMod29ybGRJZCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0Um9vbXNCeVdvcmxkKHdvcmxkSWQpO1xuICB9XG4gIGFzeW5jIGdldFJvb21zQnlXb3JsZCh3b3JsZElkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5nZXRSb29tc0J5V29ybGQod29ybGRJZCk7XG4gIH1cbiAgYXN5bmMgZ2V0UGFydGljaXBhbnRVc2VyU3RhdGUocm9vbUlkLCBlbnRpdHlJZCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0UGFydGljaXBhbnRVc2VyU3RhdGUocm9vbUlkLCBlbnRpdHlJZCk7XG4gIH1cbiAgYXN5bmMgc2V0UGFydGljaXBhbnRVc2VyU3RhdGUocm9vbUlkLCBlbnRpdHlJZCwgc3RhdGUpIHtcbiAgICBhd2FpdCB0aGlzLmFkYXB0ZXIuc2V0UGFydGljaXBhbnRVc2VyU3RhdGUocm9vbUlkLCBlbnRpdHlJZCwgc3RhdGUpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVJlbGF0aW9uc2hpcChwYXJhbXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmNyZWF0ZVJlbGF0aW9uc2hpcChwYXJhbXMpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVJlbGF0aW9uc2hpcChyZWxhdGlvbnNoaXApIHtcbiAgICBhd2FpdCB0aGlzLmFkYXB0ZXIudXBkYXRlUmVsYXRpb25zaGlwKHJlbGF0aW9uc2hpcCk7XG4gIH1cbiAgYXN5bmMgZ2V0UmVsYXRpb25zaGlwKHBhcmFtcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0UmVsYXRpb25zaGlwKHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZ2V0UmVsYXRpb25zaGlwcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldFJlbGF0aW9uc2hpcHMocGFyYW1zKTtcbiAgfVxuICBhc3luYyBnZXRDYWNoZShrZXkpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldENhY2hlKGtleSk7XG4gIH1cbiAgYXN5bmMgc2V0Q2FjaGUoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuc2V0Q2FjaGUoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgZGVsZXRlQ2FjaGUoa2V5KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5kZWxldGVDYWNoZShrZXkpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVRhc2sodGFzaykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuY3JlYXRlVGFzayh0YXNrKTtcbiAgfVxuICBhc3luYyBnZXRUYXNrcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldFRhc2tzKHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgZ2V0VGFzayhpZCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0VGFzayhpZCk7XG4gIH1cbiAgYXN5bmMgZ2V0VGFza3NCeU5hbWUobmFtZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYXB0ZXIuZ2V0VGFza3NCeU5hbWUobmFtZSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlVGFzayhpZCwgdGFzaykge1xuICAgIGF3YWl0IHRoaXMuYWRhcHRlci51cGRhdGVUYXNrKGlkLCB0YXNrKTtcbiAgfVxuICBhc3luYyBkZWxldGVUYXNrKGlkKSB7XG4gICAgYXdhaXQgdGhpcy5hZGFwdGVyLmRlbGV0ZVRhc2soaWQpO1xuICB9XG4gIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5ldmVudEhhbmRsZXJzLmhhcyhldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnRIYW5kbGVycy5zZXQoZXZlbnQsIFtdKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudEhhbmRsZXJzLmdldChldmVudCk/LnB1c2goY2FsbGJhY2spO1xuICB9XG4gIG9mZihldmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRIYW5kbGVycy5oYXMoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5ldmVudEhhbmRsZXJzLmdldChldmVudCk7XG4gICAgY29uc3QgaW5kZXggPSBoYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuICBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50SGFuZGxlcnMuaGFzKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgdGhpcy5ldmVudEhhbmRsZXJzLmdldChldmVudCkpIHtcbiAgICAgIGhhbmRsZXIoZGF0YSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNlbmRDb250cm9sTWVzc2FnZShwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyByb29tSWQsIGFjdGlvbiwgdGFyZ2V0IH0gPSBwYXJhbXM7XG4gICAgICBjb25zdCBjb250cm9sTWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogXCJjb250cm9sXCIsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgIH0sXG4gICAgICAgIHJvb21JZFxuICAgICAgfTtcbiAgICAgIGF3YWl0IHRoaXMuZW1pdEV2ZW50KFwiQ09OVFJPTF9NRVNTQUdFXCIsIHtcbiAgICAgICAgcnVudGltZTogdGhpcyxcbiAgICAgICAgbWVzc2FnZTogY29udHJvbE1lc3NhZ2UsXG4gICAgICAgIHNvdXJjZTogXCJhZ2VudFwiXG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBTZW50IGNvbnRyb2wgbWVzc2FnZTogJHthY3Rpb259IHRvIHJvb20gJHtyb29tSWR9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBFcnJvciBzZW5kaW5nIGNvbnRyb2wgbWVzc2FnZTogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJTZW5kSGFuZGxlcihzb3VyY2UsIGhhbmRsZXIpIHtcbiAgICBpZiAodGhpcy5zZW5kSGFuZGxlcnMuaGFzKHNvdXJjZSkpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oYFNlbmQgaGFuZGxlciBmb3Igc291cmNlICcke3NvdXJjZX0nIGFscmVhZHkgcmVnaXN0ZXJlZC4gT3ZlcndyaXRpbmcuYCk7XG4gICAgfVxuICAgIHRoaXMuc2VuZEhhbmRsZXJzLnNldChzb3VyY2UsIGhhbmRsZXIpO1xuICAgIHRoaXMubG9nZ2VyLmluZm8oYFJlZ2lzdGVyZWQgc2VuZCBoYW5kbGVyIGZvciBzb3VyY2U6ICR7c291cmNlfWApO1xuICB9XG4gIGFzeW5jIHNlbmRNZXNzYWdlVG9UYXJnZXQodGFyZ2V0LCBjb250ZW50KSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMuc2VuZEhhbmRsZXJzLmdldCh0YXJnZXQuc291cmNlKTtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gYE5vIHNlbmQgaGFuZGxlciByZWdpc3RlcmVkIGZvciBzb3VyY2U6ICR7dGFyZ2V0LnNvdXJjZX1gO1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3JNc2cpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGhhbmRsZXIodGhpcywgdGFyZ2V0LCBjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYEVycm9yIGV4ZWN1dGluZyBzZW5kIGhhbmRsZXIgZm9yIHNvdXJjZSAke3RhcmdldC5zb3VyY2V9OmAsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRNZW1vcmllc0J5V29ybGRJZChwYXJhbXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGFwdGVyLmdldE1lbW9yaWVzQnlXb3JsZElkKHBhcmFtcyk7XG4gIH1cbiAgYXN5bmMgcnVuTWlncmF0aW9ucyhtaWdyYXRpb25zUGF0aHMpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyICYmIFwicnVuTWlncmF0aW9uc1wiIGluIHRoaXMuYWRhcHRlcikge1xuICAgICAgYXdhaXQgdGhpcy5hZGFwdGVyLnJ1bk1pZ3JhdGlvbnMobWlncmF0aW9uc1BhdGhzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcIkRhdGFiYXNlIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCBtaWdyYXRpb25zLlwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaXNSZWFkeSgpIHtcbiAgICBpZiAoIXRoaXMuYWRhcHRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2UgYWRhcHRlciBub3QgcmVnaXN0ZXJlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRhcHRlci5pc1JlYWR5KCk7XG4gIH1cbn07XG5cbi8vIHNyYy9zZXR0aW5ncy50c1xuaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvLWJyb3dzZXJpZnlcIjtcbmZ1bmN0aW9uIGNyZWF0ZVNldHRpbmdGcm9tQ29uZmlnKGNvbmZpZ1NldHRpbmcpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBjb25maWdTZXR0aW5nLm5hbWUsXG4gICAgZGVzY3JpcHRpb246IGNvbmZpZ1NldHRpbmcuZGVzY3JpcHRpb24sXG4gICAgdXNhZ2VEZXNjcmlwdGlvbjogY29uZmlnU2V0dGluZy51c2FnZURlc2NyaXB0aW9uIHx8IFwiXCIsXG4gICAgdmFsdWU6IG51bGwsXG4gICAgcmVxdWlyZWQ6IGNvbmZpZ1NldHRpbmcucmVxdWlyZWQsXG4gICAgdmFsaWRhdGlvbjogY29uZmlnU2V0dGluZy52YWxpZGF0aW9uIHx8IG51bGwsXG4gICAgcHVibGljOiBjb25maWdTZXR0aW5nLnB1YmxpYyB8fCBmYWxzZSxcbiAgICBzZWNyZXQ6IGNvbmZpZ1NldHRpbmcuc2VjcmV0IHx8IGZhbHNlLFxuICAgIGRlcGVuZHNPbjogY29uZmlnU2V0dGluZy5kZXBlbmRzT24gfHwgW10sXG4gICAgb25TZXRBY3Rpb246IGNvbmZpZ1NldHRpbmcub25TZXRBY3Rpb24gfHwgbnVsbCxcbiAgICB2aXNpYmxlSWY6IGNvbmZpZ1NldHRpbmcudmlzaWJsZUlmIHx8IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNhbHQoKSB7XG4gIGNvbnN0IHNlY3JldFNhbHQgPSAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgPyBwcm9jZXNzLmVudi5TRUNSRVRfU0FMVCA6IGltcG9ydC5tZXRhLmVudi5TRUNSRVRfU0FMVCkgfHwgXCJzZWNyZXRzYWx0XCI7XG4gIGlmICghc2VjcmV0U2FsdCkge1xuICAgIGxvZ2dlci5lcnJvcihcIlNFQ1JFVF9TQUxUIGlzIG5vdCBzZXRcIik7XG4gIH1cbiAgY29uc3Qgc2FsdCA9IHNlY3JldFNhbHQ7XG4gIGxvZ2dlci5kZWJ1ZyhgR2VuZXJhdGVkIHNhbHQgd2l0aCBsZW5ndGg6ICR7c2FsdC5sZW5ndGh9ICh0cnVuY2F0ZWQgZm9yIHNlY3VyaXR5KWApO1xuICByZXR1cm4gc2FsdDtcbn1cbmZ1bmN0aW9uIGVuY3J5cHRTdHJpbmdWYWx1ZSh2YWx1ZSwgc2FsdCkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkF0dGVtcHRlZCB0byBlbmNyeXB0IHVuZGVmaW5lZCBvciBudWxsIHZhbHVlXCIpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBsb2dnZXIuZGVidWcoXCJWYWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVtYmVyLCByZXR1cm5pbmcgYXMgaXNcIik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2dnZXIuZGVidWcoYFZhbHVlIGlzIG5vdCBhIHN0cmluZyAodHlwZTogJHt0eXBlb2YgdmFsdWV9KSwgcmV0dXJuaW5nIGFzIGlzYCk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbnN0IHBhcnRzID0gdmFsdWUuc3BsaXQoXCI6XCIpO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBvc3NpYmxlSXYgPSBCdWZmZXIuZnJvbShwYXJ0c1swXSwgXCJoZXhcIik7XG4gICAgICBpZiAocG9zc2libGVJdi5sZW5ndGggPT09IDE2KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlZhbHVlIGFwcGVhcnMgdG8gYmUgYWxyZWFkeSBlbmNyeXB0ZWQsIHNraXBwaW5nIHJlLWVuY3J5cHRpb25cIik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG4gIGNvbnN0IGtleSA9IGNyeXB0by5jcmVhdGVIYXNoKFwic2hhMjU2XCIpLnVwZGF0ZShzYWx0KS5kaWdlc3QoKS5zbGljZSgwLCAzMik7XG4gIGNvbnN0IGl2ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcbiAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KFwiYWVzLTI1Ni1jYmNcIiwga2V5LCBpdik7XG4gIGxldCBlbmNyeXB0ZWQgPSBjaXBoZXIudXBkYXRlKHZhbHVlLCBcInV0ZjhcIiwgXCJoZXhcIik7XG4gIGVuY3J5cHRlZCArPSBjaXBoZXIuZmluYWwoXCJoZXhcIik7XG4gIHJldHVybiBgJHtpdi50b1N0cmluZyhcImhleFwiKX06JHtlbmNyeXB0ZWR9YDtcbn1cbmZ1bmN0aW9uIGRlY3J5cHRTdHJpbmdWYWx1ZSh2YWx1ZSwgc2FsdCkge1xuICB0cnkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBsb2dnZXIuZGVidWcoYFZhbHVlIGlzIG5vdCBhIHN0cmluZyAodHlwZTogJHt0eXBlb2YgdmFsdWV9KSwgcmV0dXJuaW5nIGFzIGlzYCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gdmFsdWUuc3BsaXQoXCI6XCIpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaXYgPSBCdWZmZXIuZnJvbShwYXJ0c1swXSwgXCJoZXhcIik7XG4gICAgY29uc3QgZW5jcnlwdGVkID0gcGFydHNbMV07XG4gICAgaWYgKGl2Lmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIGlmIChpdi5sZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBJbnZhbGlkIElWIGxlbmd0aCAoJHtpdi5sZW5ndGh9KSAtIGV4cGVjdGVkIDE2IGJ5dGVzYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGNyeXB0by5jcmVhdGVIYXNoKFwic2hhMjU2XCIpLnVwZGF0ZShzYWx0KS5kaWdlc3QoKS5zbGljZSgwLCAzMik7XG4gICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihcImFlcy0yNTYtY2JjXCIsIGtleSwgaXYpO1xuICAgIGxldCBkZWNyeXB0ZWQgPSBkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkLCBcImhleFwiLCBcInV0ZjhcIik7XG4gICAgZGVjcnlwdGVkICs9IGRlY2lwaGVyLmZpbmFsKFwidXRmOFwiKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcihgRXJyb3IgZGVjcnlwdGluZyB2YWx1ZTogJHtlcnJvcn1gKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHNhbHRTZXR0aW5nVmFsdWUoc2V0dGluZywgc2FsdCkge1xuICBjb25zdCBzZXR0aW5nQ29weSA9IHsgLi4uc2V0dGluZyB9O1xuICBpZiAoc2V0dGluZy5zZWNyZXQgPT09IHRydWUgJiYgdHlwZW9mIHNldHRpbmcudmFsdWUgPT09IFwic3RyaW5nXCIgJiYgc2V0dGluZy52YWx1ZSkge1xuICAgIHNldHRpbmdDb3B5LnZhbHVlID0gZW5jcnlwdFN0cmluZ1ZhbHVlKHNldHRpbmcudmFsdWUsIHNhbHQpO1xuICB9XG4gIHJldHVybiBzZXR0aW5nQ29weTtcbn1cbmZ1bmN0aW9uIHVuc2FsdFNldHRpbmdWYWx1ZShzZXR0aW5nLCBzYWx0KSB7XG4gIGNvbnN0IHNldHRpbmdDb3B5ID0geyAuLi5zZXR0aW5nIH07XG4gIGlmIChzZXR0aW5nLnNlY3JldCA9PT0gdHJ1ZSAmJiB0eXBlb2Ygc2V0dGluZy52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBzZXR0aW5nLnZhbHVlKSB7XG4gICAgc2V0dGluZ0NvcHkudmFsdWUgPSBkZWNyeXB0U3RyaW5nVmFsdWUoc2V0dGluZy52YWx1ZSwgc2FsdCk7XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdDb3B5O1xufVxuZnVuY3Rpb24gc2FsdFdvcmxkU2V0dGluZ3Mod29ybGRTZXR0aW5ncywgc2FsdCkge1xuICBjb25zdCBzYWx0ZWRTZXR0aW5ncyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHNldHRpbmddIG9mIE9iamVjdC5lbnRyaWVzKHdvcmxkU2V0dGluZ3MpKSB7XG4gICAgc2FsdGVkU2V0dGluZ3Nba2V5XSA9IHNhbHRTZXR0aW5nVmFsdWUoc2V0dGluZywgc2FsdCk7XG4gIH1cbiAgcmV0dXJuIHNhbHRlZFNldHRpbmdzO1xufVxuZnVuY3Rpb24gdW5zYWx0V29ybGRTZXR0aW5ncyh3b3JsZFNldHRpbmdzLCBzYWx0KSB7XG4gIGNvbnN0IHVuc2FsdGVkU2V0dGluZ3MgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCBzZXR0aW5nXSBvZiBPYmplY3QuZW50cmllcyh3b3JsZFNldHRpbmdzKSkge1xuICAgIHVuc2FsdGVkU2V0dGluZ3Nba2V5XSA9IHVuc2FsdFNldHRpbmdWYWx1ZShzZXR0aW5nLCBzYWx0KTtcbiAgfVxuICByZXR1cm4gdW5zYWx0ZWRTZXR0aW5ncztcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVdvcmxkU2V0dGluZ3MocnVudGltZSwgc2VydmVySWQsIHdvcmxkU2V0dGluZ3MpIHtcbiAgY29uc3Qgd29ybGRJZCA9IGNyZWF0ZVVuaXF1ZVV1aWQocnVudGltZSwgc2VydmVySWQpO1xuICBjb25zdCB3b3JsZCA9IGF3YWl0IHJ1bnRpbWUuZ2V0V29ybGQod29ybGRJZCk7XG4gIGlmICghd29ybGQpIHtcbiAgICBsb2dnZXIuZXJyb3IoYE5vIHdvcmxkIGZvdW5kIGZvciBzZXJ2ZXIgJHtzZXJ2ZXJJZH1gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCF3b3JsZC5tZXRhZGF0YSkge1xuICAgIHdvcmxkLm1ldGFkYXRhID0ge307XG4gIH1cbiAgY29uc3Qgc2FsdCA9IGdldFNhbHQoKTtcbiAgY29uc3Qgc2FsdGVkU2V0dGluZ3MgPSBzYWx0V29ybGRTZXR0aW5ncyh3b3JsZFNldHRpbmdzLCBzYWx0KTtcbiAgd29ybGQubWV0YWRhdGEuc2V0dGluZ3MgPSBzYWx0ZWRTZXR0aW5ncztcbiAgYXdhaXQgcnVudGltZS51cGRhdGVXb3JsZCh3b3JsZCk7XG4gIHJldHVybiB0cnVlO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0V29ybGRTZXR0aW5ncyhydW50aW1lLCBzZXJ2ZXJJZCkge1xuICBjb25zdCB3b3JsZElkID0gY3JlYXRlVW5pcXVlVXVpZChydW50aW1lLCBzZXJ2ZXJJZCk7XG4gIGNvbnN0IHdvcmxkID0gYXdhaXQgcnVudGltZS5nZXRXb3JsZCh3b3JsZElkKTtcbiAgaWYgKCF3b3JsZCB8fCAhd29ybGQubWV0YWRhdGE/LnNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2FsdGVkU2V0dGluZ3MgPSB3b3JsZC5tZXRhZGF0YS5zZXR0aW5ncztcbiAgY29uc3Qgc2FsdCA9IGdldFNhbHQoKTtcbiAgcmV0dXJuIHVuc2FsdFdvcmxkU2V0dGluZ3Moc2FsdGVkU2V0dGluZ3MsIHNhbHQpO1xufVxuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZU9uYm9hcmRpbmcocnVudGltZSwgd29ybGQsIGNvbmZpZykge1xuICBpZiAod29ybGQubWV0YWRhdGE/LnNldHRpbmdzKSB7XG4gICAgbG9nZ2VyLmluZm8oYE9uYm9hcmRpbmcgc3RhdGUgYWxyZWFkeSBleGlzdHMgZm9yIHNlcnZlciAke3dvcmxkLnNlcnZlcklkfWApO1xuICAgIGNvbnN0IHNhbHRlZFNldHRpbmdzID0gd29ybGQubWV0YWRhdGEuc2V0dGluZ3M7XG4gICAgY29uc3Qgc2FsdCA9IGdldFNhbHQoKTtcbiAgICByZXR1cm4gdW5zYWx0V29ybGRTZXR0aW5ncyhzYWx0ZWRTZXR0aW5ncywgc2FsdCk7XG4gIH1cbiAgY29uc3Qgd29ybGRTZXR0aW5ncyA9IHt9O1xuICBpZiAoY29uZmlnLnNldHRpbmdzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCBjb25maWdTZXR0aW5nXSBvZiBPYmplY3QuZW50cmllcyhjb25maWcuc2V0dGluZ3MpKSB7XG4gICAgICB3b3JsZFNldHRpbmdzW2tleV0gPSBjcmVhdGVTZXR0aW5nRnJvbUNvbmZpZyhjb25maWdTZXR0aW5nKTtcbiAgICB9XG4gIH1cbiAgaWYgKCF3b3JsZC5tZXRhZGF0YSkge1xuICAgIHdvcmxkLm1ldGFkYXRhID0ge307XG4gIH1cbiAgd29ybGQubWV0YWRhdGEuc2V0dGluZ3MgPSB3b3JsZFNldHRpbmdzO1xuICBhd2FpdCBydW50aW1lLnVwZGF0ZVdvcmxkKHdvcmxkKTtcbiAgbG9nZ2VyLmluZm8oYEluaXRpYWxpemVkIHNldHRpbmdzIGNvbmZpZyBmb3Igc2VydmVyICR7d29ybGQuc2VydmVySWR9YCk7XG4gIHJldHVybiB3b3JsZFNldHRpbmdzO1xufVxuZnVuY3Rpb24gZW5jcnlwdGVkQ2hhcmFjdGVyKGNoYXJhY3Rlcikge1xuICBjb25zdCBlbmNyeXB0ZWRDaGFyID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaGFyYWN0ZXIpKTtcbiAgY29uc3Qgc2FsdCA9IGdldFNhbHQoKTtcbiAgaWYgKGVuY3J5cHRlZENoYXIuc2V0dGluZ3M/LnNlY3JldHMpIHtcbiAgICBlbmNyeXB0ZWRDaGFyLnNldHRpbmdzLnNlY3JldHMgPSBlbmNyeXB0T2JqZWN0VmFsdWVzKGVuY3J5cHRlZENoYXIuc2V0dGluZ3Muc2VjcmV0cywgc2FsdCk7XG4gIH1cbiAgaWYgKGVuY3J5cHRlZENoYXIuc2VjcmV0cykge1xuICAgIGVuY3J5cHRlZENoYXIuc2VjcmV0cyA9IGVuY3J5cHRPYmplY3RWYWx1ZXMoZW5jcnlwdGVkQ2hhci5zZWNyZXRzLCBzYWx0KTtcbiAgfVxuICByZXR1cm4gZW5jcnlwdGVkQ2hhcjtcbn1cbmZ1bmN0aW9uIGRlY3J5cHRlZENoYXJhY3RlcihjaGFyYWN0ZXIsIF9ydW50aW1lKSB7XG4gIGNvbnN0IGRlY3J5cHRlZENoYXIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNoYXJhY3RlcikpO1xuICBjb25zdCBzYWx0ID0gZ2V0U2FsdCgpO1xuICBpZiAoZGVjcnlwdGVkQ2hhci5zZXR0aW5ncz8uc2VjcmV0cykge1xuICAgIGRlY3J5cHRlZENoYXIuc2V0dGluZ3Muc2VjcmV0cyA9IGRlY3J5cHRPYmplY3RWYWx1ZXMoZGVjcnlwdGVkQ2hhci5zZXR0aW5ncy5zZWNyZXRzLCBzYWx0KTtcbiAgfVxuICBpZiAoZGVjcnlwdGVkQ2hhci5zZWNyZXRzKSB7XG4gICAgZGVjcnlwdGVkQ2hhci5zZWNyZXRzID0gZGVjcnlwdE9iamVjdFZhbHVlcyhkZWNyeXB0ZWRDaGFyLnNlY3JldHMsIHNhbHQpO1xuICB9XG4gIHJldHVybiBkZWNyeXB0ZWRDaGFyO1xufVxuZnVuY3Rpb24gZW5jcnlwdE9iamVjdFZhbHVlcyhvYmosIHNhbHQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGVuY3J5cHRTdHJpbmdWYWx1ZSh2YWx1ZSwgc2FsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkZWNyeXB0T2JqZWN0VmFsdWVzKG9iaiwgc2FsdCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gZGVjcnlwdFN0cmluZ1ZhbHVlKHZhbHVlLCBzYWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3NlcnZpY2VzLnRzXG52YXIgU2VydmljZUJ1aWxkZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNlcnZpY2VUeXBlKSB7XG4gICAgdGhpcy5zZXJ2aWNlVHlwZSA9IHNlcnZpY2VUeXBlO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHNlcnZpY2UgZGVzY3JpcHRpb25cbiAgICovXG4gIHdpdGhEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBzdGFydCBmdW5jdGlvbiBmb3IgdGhlIHNlcnZpY2VcbiAgICovXG4gIHdpdGhTdGFydChzdGFydEZuKSB7XG4gICAgdGhpcy5zdGFydEZuID0gc3RhcnRGbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBzdG9wIGZ1bmN0aW9uIGZvciB0aGUgc2VydmljZVxuICAgKi9cbiAgd2l0aFN0b3Aoc3RvcEZuKSB7XG4gICAgdGhpcy5zdG9wRm4gPSBzdG9wRm47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEJ1aWxkIHRoZSBzZXJ2aWNlIGNsYXNzIHdpdGggYWxsIGNvbmZpZ3VyZWQgcHJvcGVydGllc1xuICAgKi9cbiAgYnVpbGQoKSB7XG4gICAgY29uc3Qgc2VydmljZVR5cGUgPSB0aGlzLnNlcnZpY2VUeXBlO1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5kZXNjcmlwdGlvbjtcbiAgICBjb25zdCBzdGFydEZuID0gdGhpcy5zdGFydEZuO1xuICAgIGNvbnN0IHN0b3BGbiA9IHRoaXMuc3RvcEZuO1xuICAgIHJldHVybiBjbGFzcyBleHRlbmRzIFNlcnZpY2Uge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2FwYWJpbGl0eURlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgICBzdGF0aWMge1xuICAgICAgICB0aGlzLnNlcnZpY2VUeXBlID0gc2VydmljZVR5cGU7XG4gICAgICB9XG4gICAgICBzdGF0aWMgYXN5bmMgc3RhcnQocnVudGltZSkge1xuICAgICAgICBpZiAoIXN0YXJ0Rm4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXJ0IGZ1bmN0aW9uIG5vdCBkZWZpbmVkIGZvciBzZXJ2aWNlICR7c2VydmljZVR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0Rm4ocnVudGltZSk7XG4gICAgICB9XG4gICAgICBhc3luYyBzdG9wKCkge1xuICAgICAgICBpZiAoc3RvcEZuKSB7XG4gICAgICAgICAgYXdhaXQgc3RvcEZuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlU2VydmljZShzZXJ2aWNlVHlwZSkge1xuICByZXR1cm4gbmV3IFNlcnZpY2VCdWlsZGVyKHNlcnZpY2VUeXBlKTtcbn1cbmZ1bmN0aW9uIGRlZmluZVNlcnZpY2UoZGVmaW5pdGlvbikge1xuICByZXR1cm4gY3JlYXRlU2VydmljZShkZWZpbml0aW9uLnNlcnZpY2VUeXBlKS53aXRoRGVzY3JpcHRpb24oZGVmaW5pdGlvbi5kZXNjcmlwdGlvbikud2l0aFN0YXJ0KGRlZmluaXRpb24uc3RhcnQpLndpdGhTdG9wKGRlZmluaXRpb24uc3RvcCB8fCAoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpKS5idWlsZCgpO1xufVxuZXhwb3J0IHtcbiAgQWdlbnRSdW50aW1lLFxuICBBZ2VudFN0YXR1cyxcbiAgQ2FjaGVLZXlQcmVmaXgsXG4gIENoYW5uZWxUeXBlLFxuICBDb250ZW50VHlwZSxcbiAgRGF0YWJhc2VBZGFwdGVyLFxuICBFdmVudFR5cGUsXG4gIElCcm93c2VyU2VydmljZSxcbiAgSUVtYWlsU2VydmljZSxcbiAgSUxwU2VydmljZSxcbiAgSU1lc3NhZ2VTZXJ2aWNlLFxuICBJUGRmU2VydmljZSxcbiAgSVBvc3RTZXJ2aWNlLFxuICBJVG9rZW5EYXRhU2VydmljZSxcbiAgSVRyYW5zY3JpcHRpb25TZXJ2aWNlLFxuICBJVmlkZW9TZXJ2aWNlLFxuICBJV2FsbGV0U2VydmljZSxcbiAgSVdlYlNlYXJjaFNlcnZpY2UsXG4gIEtub3dsZWRnZVNjb3BlLFxuICBNT0RFTF9TRVRUSU5HUyxcbiAgTWVtb3J5VHlwZSxcbiAgTW9kZWxUeXBlLFxuICBQbGF0Zm9ybVByZWZpeCxcbiAgUm9sZSxcbiAgU09DS0VUX01FU1NBR0VfVFlQRSxcbiAgU2VtYXBob3JlLFxuICBTZW50cnksXG4gIFNlcnZpY2UsXG4gIFNlcnZpY2VCdWlsZGVyLFxuICBTZXJ2aWNlVHlwZSxcbiAgVEVFTW9kZSxcbiAgVGVlVHlwZSxcbiAgVkVDVE9SX0RJTVMsXG4gIGFkZEhlYWRlcixcbiAgYXNVVUlELFxuICBib29sZWFuRm9vdGVyLFxuICBjaGFyYWN0ZXJTY2hlbWEsXG4gIGNvbXBvc2VBY3Rpb25FeGFtcGxlcyxcbiAgY29tcG9zZVByb21wdCxcbiAgY29tcG9zZVByb21wdEZyb21TdGF0ZSxcbiAgY3JlYXRlQWN0aW9uUmVzdWx0LFxuICBjcmVhdGVMb2dnZXIsXG4gIGNyZWF0ZU1lc3NhZ2VNZW1vcnksXG4gIGNyZWF0ZVNlcnZpY2UsXG4gIGNyZWF0ZVNlcnZpY2VFcnJvcixcbiAgY3JlYXRlU2V0dGluZ0Zyb21Db25maWcsXG4gIGNyZWF0ZVVuaXF1ZVV1aWQsXG4gIGRlY3J5cHRPYmplY3RWYWx1ZXMsXG4gIGRlY3J5cHRTdHJpbmdWYWx1ZSBhcyBkZWNyeXB0U2VjcmV0LFxuICBkZWNyeXB0U3RyaW5nVmFsdWUsXG4gIGRlY3J5cHRlZENoYXJhY3RlcixcbiAgZGVmaW5lU2VydmljZSxcbiAgZWxpemFMb2dnZXIsXG4gIGVuY3J5cHRPYmplY3RWYWx1ZXMsXG4gIGVuY3J5cHRTdHJpbmdWYWx1ZSxcbiAgZW5jcnlwdGVkQ2hhcmFjdGVyLFxuICBmaW5kRW50aXR5QnlOYW1lLFxuICBmaW5kV29ybGRzRm9yT3duZXIsXG4gIGZvcm1hdEFjdGlvbk5hbWVzLFxuICBmb3JtYXRBY3Rpb25zLFxuICBmb3JtYXRFbnRpdGllcyxcbiAgZm9ybWF0TWVzc2FnZXMsXG4gIGZvcm1hdFBvc3RzLFxuICBmb3JtYXRUaW1lc3RhbXAsXG4gIGdldENvbnRlbnRUeXBlRnJvbU1pbWVUeXBlLFxuICBnZXRFbnRpdHlEZXRhaWxzLFxuICBnZXRMb2NhbFNlcnZlclVybCxcbiAgZ2V0TWVtb3J5VGV4dCxcbiAgZ2V0TW9kZWxTcGVjaWZpY1NldHRpbmdLZXksXG4gIGdldFNhbHQsXG4gIGdldFR5cGVkU2VydmljZSxcbiAgZ2V0VXNlclNlcnZlclJvbGUsXG4gIGdldFdvcmxkU2V0dGluZ3MsXG4gIGltYWdlRGVzY3JpcHRpb25UZW1wbGF0ZSxcbiAgaW5pdGlhbGl6ZU9uYm9hcmRpbmcsXG4gIGlzQ3VzdG9tTWV0YWRhdGEsXG4gIGlzRGVzY3JpcHRpb25NZXRhZGF0YSxcbiAgaXNEb2N1bWVudE1lbW9yeSxcbiAgaXNEb2N1bWVudE1ldGFkYXRhLFxuICBpc0ZyYWdtZW50TWVtb3J5LFxuICBpc0ZyYWdtZW50TWV0YWRhdGEsXG4gIGlzTWVzc2FnZU1ldGFkYXRhLFxuICBpc1ZhbGlkQ2hhcmFjdGVyLFxuICBsb2dnZXIsXG4gIG1lc3NhZ2VIYW5kbGVyVGVtcGxhdGUsXG4gIG5vcm1hbGl6ZUpzb25TdHJpbmcsXG4gIHBhcnNlQW5kVmFsaWRhdGVDaGFyYWN0ZXIsXG4gIHBhcnNlQm9vbGVhbkZyb21UZXh0MiBhcyBwYXJzZUJvb2xlYW5Gcm9tVGV4dCxcbiAgcGFyc2VKU09OT2JqZWN0RnJvbVRleHQsXG4gIHBhcnNlS2V5VmFsdWVYbWwsXG4gIHBvc3RDcmVhdGlvblRlbXBsYXRlLFxuICBzYWZlUmVwbGFjZXIsXG4gIHNhbHRTZXR0aW5nVmFsdWUsXG4gIHNhbHRXb3JsZFNldHRpbmdzLFxuICBzaG91bGRSZXNwb25kVGVtcGxhdGUsXG4gIHNwbGl0Q2h1bmtzLFxuICBzdHJpbmdUb1V1aWQsXG4gIHRyaW1Ub2tlbnMsXG4gIHRydW5jYXRlVG9Db21wbGV0ZVNlbnRlbmNlLFxuICB1bnNhbHRTZXR0aW5nVmFsdWUsXG4gIHVuc2FsdFdvcmxkU2V0dGluZ3MsXG4gIHVwZGF0ZVdvcmxkU2V0dGluZ3MsXG4gIHZhbGlkYXRlQ2hhcmFjdGVyLFxuICB2YWxpZGF0ZVV1aWRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elizaos/core/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/native.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@elizaos/core/node_modules/uuid/dist/esm/native.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ randomUUID: crypto__WEBPACK_IMPORTED_MODULE_0__.randomUUID });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsaXphb3MvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS9uYXRpdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0M7QUFDcEMsaUVBQWUsRUFBRSxVQUFVLGtEQUFFLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL0BlbGl6YW9zL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20vbmF0aXZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJhbmRvbVVVSUQgfSBmcm9tICdjcnlwdG8nO1xuZXhwb3J0IGRlZmF1bHQgeyByYW5kb21VVUlEIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/native.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/regex.js":
/*!************************************************************************!*\
  !*** ./node_modules/@elizaos/core/node_modules/uuid/dist/esm/regex.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsaXphb3MvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS9yZWdleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYyxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxHQUFHLDhFQUE4RSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9AZWxpemFvcy9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtL3JlZ2V4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtOF1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwfGZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZikkL2k7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/rng.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@elizaos/core/node_modules/uuid/dist/esm/rng.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomFillSync)(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsaXphb3MvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS9ybmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0M7QUFDeEM7QUFDQTtBQUNlO0FBQ2Y7QUFDQSxRQUFRLHNEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9AZWxpemFvcy9jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtL3JuZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByYW5kb21GaWxsU3luYyB9IGZyb20gJ2NyeXB0byc7XG5jb25zdCBybmRzOFBvb2wgPSBuZXcgVWludDhBcnJheSgyNTYpO1xubGV0IHBvb2xQdHIgPSBybmRzOFBvb2wubGVuZ3RoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAgIGlmIChwb29sUHRyID4gcm5kczhQb29sLmxlbmd0aCAtIDE2KSB7XG4gICAgICAgIHJhbmRvbUZpbGxTeW5jKHJuZHM4UG9vbCk7XG4gICAgICAgIHBvb2xQdHIgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gcm5kczhQb29sLnNsaWNlKHBvb2xQdHIsIChwb29sUHRyICs9IDE2KSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/stringify.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@elizaos/core/node_modules/uuid/dist/esm/stringify.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/validate.js\");\n\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsaXphb3MvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS9zdHJpbmdpZnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBQ3JDO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0RBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL0BlbGl6YW9zL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20vc3RyaW5naWZ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAgIHJldHVybiAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gK1xuICAgICAgICAnLScgK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArXG4gICAgICAgICctJyArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gK1xuICAgICAgICAnLScgK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7XG4gICAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdXVpZDtcbn1cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/v4.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@elizaos/core/node_modules/uuid/dist/esm/v4.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n    if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n        return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? (0,_rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsaXphb3MvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS92NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlDO0FBQ047QUFDc0I7QUFDakQ7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsZUFBZSxrREFBTTtBQUNyQjtBQUNBO0FBQ0Esc0RBQXNELG1EQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTyxHQUFHLGFBQWE7QUFDM0U7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQWU7QUFDMUI7QUFDQSxpRUFBZSxFQUFFLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL0BlbGl6YW9zL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20vdjQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5hdGl2ZSBmcm9tICcuL25hdGl2ZS5qcyc7XG5pbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZS5yYW5kb21VVUlEKCk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSA/PyBvcHRpb25zLnJuZz8uKCkgPz8gcm5nKCk7XG4gICAgaWYgKHJuZHMubGVuZ3RoIDwgMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYW5kb20gYnl0ZXMgbGVuZ3RoIG11c3QgYmUgPj0gMTYnKTtcbiAgICB9XG4gICAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICAgIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICBpZiAoYnVmKSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxNiA+IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVVUlEIGJ5dGUgcmFuZ2UgJHtvZmZzZXR9OiR7b2Zmc2V0ICsgMTV9IGlzIG91dCBvZiBidWZmZXIgYm91bmRzYCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiB1bnNhZmVTdHJpbmdpZnkocm5kcyk7XG59XG5leHBvcnQgZGVmYXVsdCB2NDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/validate.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@elizaos/core/node_modules/uuid/dist/esm/validate.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/regex.js\");\n\nfunction validate(uuid) {\n    return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsaXphb3MvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS92YWxpZGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjtBQUMvQjtBQUNBLHVDQUF1QyxpREFBSztBQUM1QztBQUNBLGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2phc2h3YW50aHBlZGRpc2V0dHkvRG9jdW1lbnRzL2V0aGdsb2JhbC9jb250ZXh0by9ub2RlX21vZHVsZXMvQGVsaXphb3MvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS92YWxpZGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elizaos/core/node_modules/uuid/dist/esm/validate.js\n");

/***/ })

};
;