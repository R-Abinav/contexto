"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hedera-agent-kit";
exports.ids = ["vendor-chunks/hedera-agent-kit"];
exports.modules = {

/***/ "(rsc)/./node_modules/hedera-agent-kit/dist/esm/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/hedera-agent-kit/dist/esm/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccountResolver: () => (/* binding */ AccountResolver),\n/* harmony export */   AgentMode: () => (/* binding */ AgentMode),\n/* harmony export */   ERC20_FACTORY_ABI: () => (/* binding */ ERC20_FACTORY_ABI),\n/* harmony export */   ERC20_FACTORY_ADDRESSES: () => (/* binding */ ERC20_FACTORY_ADDRESSES),\n/* harmony export */   ERC20_TRANSFER_FUNCTION_ABI: () => (/* binding */ ERC20_TRANSFER_FUNCTION_ABI),\n/* harmony export */   ERC20_TRANSFER_FUNCTION_NAME: () => (/* binding */ ERC20_TRANSFER_FUNCTION_NAME),\n/* harmony export */   ERC721_FACTORY_ABI: () => (/* binding */ ERC721_FACTORY_ABI),\n/* harmony export */   ERC721_FACTORY_ADDRESSES: () => (/* binding */ ERC721_FACTORY_ADDRESSES),\n/* harmony export */   ERC721_MINT_FUNCTION_ABI: () => (/* binding */ ERC721_MINT_FUNCTION_ABI),\n/* harmony export */   ERC721_MINT_FUNCTION_NAME: () => (/* binding */ ERC721_MINT_FUNCTION_NAME),\n/* harmony export */   ERC721_TRANSFER_FUNCTION_ABI: () => (/* binding */ ERC721_TRANSFER_FUNCTION_ABI),\n/* harmony export */   ERC721_TRANSFER_FUNCTION_NAME: () => (/* binding */ ERC721_TRANSFER_FUNCTION_NAME),\n/* harmony export */   ExecuteStrategy: () => (/* binding */ ExecuteStrategy),\n/* harmony export */   HederaAIToolkit: () => (/* binding */ toolkit_default3),\n/* harmony export */   HederaElizaOSToolkit: () => (/* binding */ HederaElizaOSToolkit),\n/* harmony export */   HederaLangchainToolkit: () => (/* binding */ toolkit_default),\n/* harmony export */   HederaMCPToolkit: () => (/* binding */ toolkit_default2),\n/* harmony export */   PluginRegistry: () => (/* binding */ PluginRegistry),\n/* harmony export */   PromptGenerator: () => (/* binding */ PromptGenerator),\n/* harmony export */   coreAccountPlugin: () => (/* binding */ coreAccountPlugin),\n/* harmony export */   coreAccountPluginToolNames: () => (/* binding */ coreAccountPluginToolNames),\n/* harmony export */   coreAccountQueryPlugin: () => (/* binding */ coreAccountQueryPlugin),\n/* harmony export */   coreAccountQueryPluginToolNames: () => (/* binding */ coreAccountQueryPluginToolNames),\n/* harmony export */   coreConsensusPlugin: () => (/* binding */ coreConsensusPlugin),\n/* harmony export */   coreConsensusPluginToolNames: () => (/* binding */ coreConsensusPluginToolNames),\n/* harmony export */   coreConsensusQueryPlugin: () => (/* binding */ coreConsensusQueryPlugin),\n/* harmony export */   coreConsensusQueryPluginToolNames: () => (/* binding */ coreConsensusQueryPluginToolNames),\n/* harmony export */   coreEVMPlugin: () => (/* binding */ coreEVMPlugin),\n/* harmony export */   coreEVMPluginToolNames: () => (/* binding */ coreEVMPluginToolNames),\n/* harmony export */   coreEVMQueryPlugin: () => (/* binding */ coreEVMQueryPlugin),\n/* harmony export */   coreEVMQueryPluginToolNames: () => (/* binding */ coreEVMQueryPluginToolNames),\n/* harmony export */   coreHTSPlugin: () => (/* binding */ coreHTSPlugin),\n/* harmony export */   coreHTSPluginToolNames: () => (/* binding */ coreHTSPluginToolNames),\n/* harmony export */   coreMiscQueriesPlugin: () => (/* binding */ coreMiscQueriesPlugin),\n/* harmony export */   coreMiscQueriesPluginsToolNames: () => (/* binding */ coreMiscQueriesPluginsToolNames),\n/* harmony export */   coreQueriesPlugin: () => (/* binding */ coreQueriesPlugin),\n/* harmony export */   coreQueriesPluginToolNames: () => (/* binding */ coreQueriesPluginToolNames),\n/* harmony export */   coreSCSPlugin: () => (/* binding */ coreSCSPlugin),\n/* harmony export */   coreSCSPluginToolNames: () => (/* binding */ coreSCSPluginToolNames),\n/* harmony export */   coreTokenPlugin: () => (/* binding */ coreTokenPlugin),\n/* harmony export */   coreTokenPluginToolNames: () => (/* binding */ coreTokenPluginToolNames),\n/* harmony export */   coreTokenQueryPlugin: () => (/* binding */ coreTokenQueryPlugin),\n/* harmony export */   coreTokenQueryPluginToolNames: () => (/* binding */ coreTokenQueryPluginToolNames),\n/* harmony export */   coreTransactionQueryPlugin: () => (/* binding */ coreTransactionQueryPlugin),\n/* harmony export */   coreTransactionQueryPluginToolNames: () => (/* binding */ coreTransactionQueryPluginToolNames),\n/* harmony export */   getERC20FactoryAddress: () => (/* binding */ getERC20FactoryAddress),\n/* harmony export */   getERC721FactoryAddress: () => (/* binding */ getERC721FactoryAddress),\n/* harmony export */   handleTransaction: () => (/* binding */ handleTransaction)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hashgraph/sdk */ \"(rsc)/./node_modules/@hashgraph/sdk/lib/index.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bignumber.js */ \"(rsc)/./node_modules/hedera-agent-kit/node_modules/bignumber.js/bignumber.mjs\");\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! long */ \"(rsc)/./node_modules/hedera-agent-kit/node_modules/long/index.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(rsc)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(rsc)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _langchain_core_tools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @langchain/core/tools */ \"(rsc)/./node_modules/@langchain/core/tools.js\");\n/* harmony import */ var _modelcontextprotocol_sdk_server_mcp_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @modelcontextprotocol/sdk/server/mcp.js */ \"(rsc)/./node_modules/@modelcontextprotocol/sdk/dist/esm/server/mcp.js\");\n/* harmony import */ var ai__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ai */ \"(rsc)/./node_modules/ai/dist/index.mjs\");\n/* harmony import */ var _elizaos_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @elizaos/core */ \"(rsc)/./node_modules/@elizaos/core/dist/index.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n// src/shared/api.ts\nvar HederaAgentAPI = class {\n  client;\n  context;\n  tools;\n  constructor(client, context, tools) {\n    this.client = client;\n    if (!this.client.ledgerId) {\n      throw new Error(\"Client must be connected to a network\");\n    }\n    this.context = context || {};\n    this.tools = tools || [];\n  }\n  async run(method, arg) {\n    const tool41 = this.tools.find((t) => t.method === method);\n    if (tool41) {\n      const output = JSON.stringify(await tool41.execute(this.client, this.context, arg));\n      return output;\n    } else {\n      throw new Error(\"Invalid method \" + method);\n    }\n  }\n};\nvar api_default = HederaAgentAPI;\n\n// src/shared/configuration.ts\nvar AgentMode = /* @__PURE__ */ ((AgentMode2) => {\n  AgentMode2[\"AUTONOMOUS\"] = \"autonomous\";\n  AgentMode2[\"RETURN_BYTES\"] = \"returnBytes\";\n  return AgentMode2;\n})(AgentMode || {});\n\n// src/shared/parameter-schemas/token.zod.ts\n\n\nvar createFungibleTokenParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  tokenName: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The name of the token.\"),\n  tokenSymbol: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The symbol of the token.\"),\n  initialSupply: zod__WEBPACK_IMPORTED_MODULE_1__.number().int().optional().default(0).describe(\"The initial supply of the token.\"),\n  supplyType: zod__WEBPACK_IMPORTED_MODULE_1__[\"enum\"]([\"finite\", \"infinite\"]).optional().default(\"finite\").describe(\"Supply type of the token.\"),\n  maxSupply: zod__WEBPACK_IMPORTED_MODULE_1__.number().int().optional().describe(\"The maximum supply of the token.\"),\n  decimals: zod__WEBPACK_IMPORTED_MODULE_1__.number().int().optional().default(0).describe(\"The number of decimals.\"),\n  treasuryAccountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"The treasury account of the token.\"),\n  isSupplyKey: zod__WEBPACK_IMPORTED_MODULE_1__.boolean().optional().describe(\"Determines if the token supply key should be set.\")\n});\nvar createNonFungibleTokenParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  tokenName: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The name of the token.\"),\n  tokenSymbol: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The symbol of the token.\"),\n  maxSupply: zod__WEBPACK_IMPORTED_MODULE_1__.number().int().optional().default(100).describe(\"The maximum supply of the token.\"),\n  treasuryAccountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"The treasury account of the token.\")\n});\nvar AirdropRecipientSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  accountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe('Recipient account ID (e.g., \"0.0.xxxx\").'),\n  amount: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.number(), zod__WEBPACK_IMPORTED_MODULE_1__.string()]).describe(\"Amount in base unit.\")\n});\nvar airdropFungibleTokenParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  tokenId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The id of the token.\"),\n  sourceAccountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"The account to airdrop the token from.\"),\n  recipients: zod__WEBPACK_IMPORTED_MODULE_1__.array(AirdropRecipientSchema).min(1).describe(\"Array of recipient objects, each with accountId and amount.\")\n});\nvar mintFungibleTokenParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  tokenId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The id of the token.\"),\n  amount: zod__WEBPACK_IMPORTED_MODULE_1__.number().describe(\"The amount of tokens to mint.\")\n});\nvar mintNonFungibleTokenParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  tokenId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The id of the NFT class.\"),\n  uris: zod__WEBPACK_IMPORTED_MODULE_1__.array(zod__WEBPACK_IMPORTED_MODULE_1__.string().max(100)).max(10).describe(\"An array of URIs hosting NFT metadata.\")\n});\nvar tokenInfoQueryParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  tokenId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"The token ID to query.\")\n});\nvar updateTokenParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  tokenId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The ID of the token to update (e.g., 0.0.12345).\"),\n  tokenDesc: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Optional description of the token update operation.\"),\n  tokenName: zod__WEBPACK_IMPORTED_MODULE_1__.string().max(100).optional().describe(\"New name for the token. Up to 100 characters.\"),\n  tokenSymbol: zod__WEBPACK_IMPORTED_MODULE_1__.string().max(100).optional().describe(\"New symbol for the token. Up to 100 characters.\"),\n  treasuryAccountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"New treasury account for the token (Hedera account ID).\"),\n  adminKey: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.boolean(), zod__WEBPACK_IMPORTED_MODULE_1__.string()]).optional().describe(\n    \"New admin key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string. Required for most property updates.\"\n  ),\n  kycKey: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.boolean(), zod__WEBPACK_IMPORTED_MODULE_1__.string()]).optional().describe(\n    \"New KYC key. Pass boolean `true` to use the operator/user key, or provide a public key string.\"\n  ),\n  freezeKey: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.boolean(), zod__WEBPACK_IMPORTED_MODULE_1__.string()]).optional().describe(\n    \"New freeze key. Pass boolean `true` to use the operator/user key, or provide a public key string.\"\n  ),\n  wipeKey: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.boolean(), zod__WEBPACK_IMPORTED_MODULE_1__.string()]).optional().describe(\n    \"New wipe key. Pass boolean `true` to use the operator/user key, or provide a public key string.\"\n  ),\n  supplyKey: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.boolean(), zod__WEBPACK_IMPORTED_MODULE_1__.string()]).optional().describe(\n    \"New supply key. Pass boolean `true` to use the operator/user key, or provide a public key string.\"\n  ),\n  feeScheduleKey: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.boolean(), zod__WEBPACK_IMPORTED_MODULE_1__.string()]).optional().describe(\n    \"New fee schedule key. Pass boolean `true` to use the operator/user key, or provide a public key string.\"\n  ),\n  pauseKey: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.boolean(), zod__WEBPACK_IMPORTED_MODULE_1__.string()]).optional().describe(\n    \"New pause key. Pass boolean `true` to use the operator/user key, or provide a public key string.\"\n  ),\n  metadataKey: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.boolean(), zod__WEBPACK_IMPORTED_MODULE_1__.string()]).optional().describe(\n    \"New metadata key. Pass boolean `true` to use the operator/user key, or provide a public key string.\"\n  ),\n  metadata: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"New metadata for the token, in bytes (as base64 or hex).\"),\n  tokenMemo: zod__WEBPACK_IMPORTED_MODULE_1__.string().max(100).optional().describe(\"Short public memo for the token, up to 100 characters.\"),\n  autoRenewAccountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Account to automatically pay for token renewal (Hedera account ID).\")\n});\nvar associateTokenParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  // If not passed, will be injected from context in normalisation\n  accountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\n    \"Account ID to associate tokens with (e.g., 0.0.xxxxx). If not provided, operator account ID will be used\"\n  ),\n  // One or more token IDs to associate\n  tokenIds: zod__WEBPACK_IMPORTED_MODULE_1__.array(zod__WEBPACK_IMPORTED_MODULE_1__.string()).min(1).describe(\"Array of token IDs to associate\")\n});\nvar pendingAirdropQueryParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  accountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"The account ID to query.\")\n});\nvar dissociateTokenParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  tokenIds: zod__WEBPACK_IMPORTED_MODULE_1__.array(zod__WEBPACK_IMPORTED_MODULE_1__.string()).min(1).describe(\"The list of Hedera token IDs (strings) to dissociate. Must provide at least one.\"),\n  accountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\n    \"The account ID from which to dissociate the tokens. Defaults to operator account.\"\n  ),\n  transactionMemo: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Optional memo for the transaction.\")\n});\n\n// src/shared/parameter-schemas/account.zod.ts\n\n\n\n\nvar transferHbarParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  transfers: zod__WEBPACK_IMPORTED_MODULE_1__.array(\n    zod__WEBPACK_IMPORTED_MODULE_1__.object({\n      accountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"Recipient account ID\"),\n      amount: zod__WEBPACK_IMPORTED_MODULE_1__.number().describe(\"Amount of HBAR to transfer\")\n    })\n  ).describe(\"Array of HBAR transfers\"),\n  sourceAccountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Sender account ID\"),\n  transactionMemo: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Memo to include with the transaction\")\n});\nvar createAccountParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  publicKey: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Account public key. If not provided, a public key of the operator will be used\"),\n  accountMemo: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Optional memo for the account\"),\n  initialBalance: zod__WEBPACK_IMPORTED_MODULE_1__.number().optional().default(0).describe(\"Initial HBAR balance to fund the account (defaults to 0)\"),\n  maxAutomaticTokenAssociations: zod__WEBPACK_IMPORTED_MODULE_1__.number().optional().default(-1).describe(\"Max automatic token associations (-1 for unlimited)\")\n});\nvar deleteAccountParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  accountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The account ID to delete.\"),\n  transferAccountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\n    \"The ID of the account to transfer the remaining funds to. If not provided, the operator account ID will be used.\"\n  )\n});\nvar updateAccountParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  // If not passed, will be injected from context in normalisation\n  accountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\n    \"Account ID to update (e.g., 0.0.xxxxx). If not provided, operator account ID will be used\"\n  ),\n  maxAutomaticTokenAssociations: zod__WEBPACK_IMPORTED_MODULE_1__.number().int().optional().describe(\"Max automatic token associations, positive, zero or -1 if unlimited\"),\n  stakedAccountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Staked account ID\"),\n  accountMemo: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Account memo\"),\n  declineStakingReward: zod__WEBPACK_IMPORTED_MODULE_1__.boolean().optional().describe(\"Decline staking rewards\")\n});\nvar accountQueryParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  accountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The account ID to query.\")\n});\nvar accountBalanceQueryParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  accountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"The account ID to query.\")\n});\nvar accountTokenBalancesQueryParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  accountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"The account ID to query. If not provided, this accountId will be used.\"),\n  tokenId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"The token ID to query.\")\n});\nvar signScheduleTransactionParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  scheduleId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The ID of the scheduled transaction to sign\")\n});\nvar scheduleDeleteTransactionParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  scheduleId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The ID of the scheduled transaction to delete\")\n});\nvar approveHbarAllowanceParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  ownerAccountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Owner account ID (defaults to operator account ID if omitted)\"),\n  spenderAccountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"Spender account ID\"),\n  amount: zod__WEBPACK_IMPORTED_MODULE_1__.number().describe(\"Amount of HBAR to approve as allowance (can be decimal, not negative)\"),\n  transactionMemo: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Memo to include with the transaction\")\n});\n\n// src/shared/parameter-schemas/consensus.zod.ts\n\n\nvar getTopicInfoParameters = (_context = {}) => {\n  return zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    topicId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The topic ID to query.\")\n  });\n};\nvar createTopicParameters = (_context = {}) => {\n  return zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    isSubmitKey: zod__WEBPACK_IMPORTED_MODULE_1__.boolean().optional().default(false).describe(\"Whether to set a submit key for the topic (optional)\"),\n    topicMemo: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Memo for the topic (optional)\"),\n    transactionMemo: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"An optional memo to include on the submitted transaction (optional).\")\n  });\n};\nvar submitTopicMessageParameters = (_context = {}) => {\n  return zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    topicId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The ID of the topic to submit the message to\"),\n    message: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The message to submit to the topic\"),\n    transactionMemo: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"An optional memo to include on the submitted transaction (optional).\")\n  });\n};\nvar deleteTopicParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  topicId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The ID of the topic to delete.\")\n});\nvar deleteTopicParametersNormalised = (_context = {}) => deleteTopicParameters(_context).extend({});\nvar topicMessagesQueryParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  topicId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The topic ID to query.\"),\n  startTime: zod__WEBPACK_IMPORTED_MODULE_1__.string().datetime().optional().describe(\n    \"The start time to query. If set, the messages will be returned after this timestamp.\"\n  ),\n  endTime: zod__WEBPACK_IMPORTED_MODULE_1__.string().datetime().optional().describe(\n    \"The end time to query. If set, the messages will be returned before this timestamp.\"\n  ),\n  limit: zod__WEBPACK_IMPORTED_MODULE_1__.number().optional().describe(\"The limit of messages to query. If set, the number of messages to return.\")\n});\nvar updateTopicParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  topicId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The ID of the topic to update (e.g., 0.0.12345).\"),\n  topicMemo: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Optional new memo for the topic.\"),\n  adminKey: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.boolean(), zod__WEBPACK_IMPORTED_MODULE_1__.string()]).optional().describe(\n    \"New admin key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string.\"\n  ),\n  submitKey: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.boolean(), zod__WEBPACK_IMPORTED_MODULE_1__.string()]).optional().describe(\n    \"New submit key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string.\"\n  ),\n  autoRenewAccountId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Account to automatically pay for topic renewal (Hedera account ID).\"),\n  autoRenewPeriod: zod__WEBPACK_IMPORTED_MODULE_1__.number().optional().describe(\"Auto renew period in seconds.\"),\n  expirationTime: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.string(), zod__WEBPACK_IMPORTED_MODULE_1__[\"instanceof\"](Date)]).optional().describe(\"New expiration time for the topic (ISO string or Date).\")\n});\n\n// src/shared/hedera-utils/hedera-parameter-normaliser.ts\n\n\n\n// src/shared/hedera-utils/decimals-utils.ts\n\nfunction toBaseUnit(amount, decimals) {\n  const amountBN = new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](amount);\n  const multiplier = new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](10).pow(decimals);\n  return amountBN.multipliedBy(multiplier).integerValue(bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ROUND_FLOOR);\n}\nfunction toDisplayUnit(baseAmount, decimals) {\n  const baseAmountBN = new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](baseAmount);\n  const divisor = new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](10).pow(decimals);\n  return baseAmountBN.dividedBy(divisor);\n}\n\n// src/shared/hedera-utils/hedera-parameter-normaliser.ts\n\n\n// src/shared/utils/account-resolver.ts\n\nvar AccountResolver = class _AccountResolver {\n  /**\n   * Gets the default account based on the agent mode and context.\n   * In RETURN_BYTES mode, prefers context.accountId (user's account).\n   * In AUTONOMOUS mode or when no context account, uses an operator account.\n   */\n  static getDefaultAccount(context, client) {\n    if (context.accountId) {\n      return context.accountId;\n    }\n    const operatorAccount = client.operatorAccountId?.toString();\n    if (!operatorAccount) {\n      throw new Error(\"No account available: neither context.accountId nor operator account\");\n    }\n    return operatorAccount;\n  }\n  static async getDefaultPublicKey(context, client) {\n    if (context.mode === \"autonomous\" /* AUTONOMOUS */) {\n      return client.operatorPublicKey;\n    }\n    const defaultAccount = this.getDefaultAccount(context, client);\n    const defaultAccountDetails = await context.mirrornodeService?.getAccount(defaultAccount);\n    if (!defaultAccountDetails?.accountPublicKey) {\n      throw new Error(\"No public key available for the default account\");\n    }\n    return _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.PublicKey.fromString(defaultAccountDetails.accountPublicKey);\n  }\n  /**\n   * Resolves an account ID, using the provided account or falling back to the default.\n   */\n  static resolveAccount(providedAccount, context, client) {\n    return providedAccount || this.getDefaultAccount(context, client);\n  }\n  /**\n   * Gets a description of which account will be used as default for prompts.\n   */\n  static getDefaultAccountDescription(context) {\n    if (context.mode === \"returnBytes\" /* RETURN_BYTES */ && context.accountId) {\n      return `user account (${context.accountId})`;\n    }\n    return \"operator account\";\n  }\n  static isHederaAddress(address) {\n    return address.startsWith(\"0.\") || address.startsWith(\"0.0.\");\n  }\n  static async getHederaEVMAddress(address, mirrorNode) {\n    if (!_AccountResolver.isHederaAddress(address)) {\n      return address;\n    }\n    const account = await mirrorNode.getAccount(address);\n    return account.evmAddress;\n  }\n};\n\n// src/shared/hedera-utils/hedera-parameter-normaliser.ts\n\n\n// src/shared/parameter-schemas/evm.zod.ts\n\nvar transferERC20Parameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  contractId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The id of the ERC20 contract.\"),\n  recipientAddress: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"Address to which the tokens will be transferred.\"),\n  amount: zod__WEBPACK_IMPORTED_MODULE_1__.number().describe(\"The amount of tokens to transfer.\")\n});\nvar createERC721Parameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  tokenName: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The name of the token.\"),\n  tokenSymbol: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The symbol of the token.\"),\n  baseURI: zod__WEBPACK_IMPORTED_MODULE_1__.string().default(\"\").describe(\"The base URI for token metadata.\")\n});\nvar createERC20Parameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  tokenName: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The name of the token.\"),\n  tokenSymbol: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The symbol of the token.\"),\n  decimals: zod__WEBPACK_IMPORTED_MODULE_1__.number().int().min(0).optional().default(18).describe(\"The number of decimals the token supports.\"),\n  initialSupply: zod__WEBPACK_IMPORTED_MODULE_1__.number().int().min(0).optional().default(0).describe(\"The initial supply of the token.\")\n});\nvar transferERC721Parameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  contractId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The id of the ERC721 contract.\"),\n  fromAddress: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Address from which the token will be transferred.\"),\n  toAddress: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"Address to which the token will be transferred.\"),\n  tokenId: zod__WEBPACK_IMPORTED_MODULE_1__.number().describe(\"The ID of the token to transfer.\")\n});\nvar mintERC721Parameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  contractId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The id of the ERC721 contract.\"),\n  toAddress: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional().describe(\"Address to which the token will be minted.\")\n});\nvar contractInfoQueryParameters = (_context = {}) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  contractId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"The token ID to query.\")\n});\n\n// src/shared/parameter-schemas/transaction.zod.ts\n\nvar transactionRecordQueryParameters = (_context = {}) => {\n  return zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    transactionId: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\n      'The transaction ID to fetch details for. Should be in format \\\\\"shard.realm.num-sss-nnn\\\\\" format where sss are seconds and nnn are nanoseconds'\n    ),\n    nonce: zod__WEBPACK_IMPORTED_MODULE_1__.number().nonnegative().optional().describe(\"Optional nonnegative nonce value for the transaction\")\n  });\n};\n\n// src/shared/hedera-utils/hedera-parameter-normaliser.ts\nvar HederaParameterNormaliser = class _HederaParameterNormaliser {\n  static parseParamsWithSchema(params, schema, context = {}) {\n    let parsedParams;\n    try {\n      parsedParams = schema(context).parse(params);\n    } catch (e) {\n      if (e instanceof zod__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ZodError) {\n        const issues = this.formatZodIssues(e);\n        throw new Error(`Invalid parameters: ${issues}`);\n      }\n      throw e;\n    }\n    return parsedParams;\n  }\n  static formatZodIssues(error) {\n    return error.errors.map((err) => `Field \"${err.path.join(\".\")}\" - ${err.message}`).join(\"; \");\n  }\n  static async normaliseCreateFungibleTokenParams(params, context, client, mirrorNode) {\n    const parsedParams = this.parseParamsWithSchema(params, createFungibleTokenParameters, context);\n    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);\n    const treasuryAccountId = parsedParams.treasuryAccountId ?? defaultAccountId;\n    if (!treasuryAccountId) throw new Error(\"Must include treasury account ID\");\n    const initialSupply = toBaseUnit(\n      parsedParams.initialSupply ?? 0,\n      parsedParams.decimals\n    ).toNumber();\n    const isFinite = (parsedParams.supplyType ?? \"infinite\") === \"finite\";\n    const supplyType = isFinite ? _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenSupplyType.Finite : _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenSupplyType.Infinite;\n    const maxSupply = isFinite ? toBaseUnit(parsedParams.maxSupply ?? 1e6, parsedParams.decimals).toNumber() : void 0;\n    if (maxSupply !== void 0 && initialSupply > maxSupply) {\n      throw new Error(`Initial supply (${initialSupply}) cannot exceed max supply (${maxSupply})`);\n    }\n    const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();\n    return {\n      ...parsedParams,\n      supplyType,\n      treasuryAccountId,\n      maxSupply,\n      initialSupply,\n      autoRenewAccountId: defaultAccountId,\n      supplyKey: parsedParams.isSupplyKey === true ? _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.PublicKey.fromString(publicKey) : void 0\n    };\n  }\n  static async normaliseCreateNonFungibleTokenParams(params, context, client, mirrorNode) {\n    const parsedParams = this.parseParamsWithSchema(params, createNonFungibleTokenParameters, context);\n    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);\n    const treasuryAccountId = parsedParams.treasuryAccountId ?? defaultAccountId;\n    if (!treasuryAccountId) throw new Error(\"Must include treasury account ID\");\n    const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();\n    if (!publicKey) throw new Error(\"Could not determine public key for supply key\");\n    const maxSupply = parsedParams.maxSupply ?? 100;\n    return {\n      ...parsedParams,\n      treasuryAccountId,\n      maxSupply,\n      supplyKey: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.PublicKey.fromString(publicKey),\n      // the supply key is mandatory in the case of NFT\n      supplyType: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenSupplyType.Finite,\n      // NFTs supply must be finite\n      autoRenewAccountId: defaultAccountId,\n      tokenType: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenType.NonFungibleUnique\n    };\n  }\n  static normaliseTransferHbar(params, context, client) {\n    const parsedParams = this.parseParamsWithSchema(params, transferHbarParameters, context);\n    const sourceAccountId = AccountResolver.resolveAccount(\n      parsedParams.sourceAccountId,\n      context,\n      client\n    );\n    const hbarTransfers = [];\n    let totalTinybars = long__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ZERO;\n    for (const transfer of parsedParams.transfers) {\n      const amount = new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Hbar(transfer.amount);\n      if (amount.isNegative() || amount.toTinybars().equals(long__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ZERO)) {\n        throw new Error(`Invalid transfer amount: ${transfer.amount}`);\n      }\n      totalTinybars = totalTinybars.add(amount.toTinybars());\n      hbarTransfers.push({\n        accountId: transfer.accountId,\n        amount\n      });\n    }\n    hbarTransfers.push({\n      accountId: sourceAccountId,\n      amount: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Hbar.fromTinybars(totalTinybars.negate())\n    });\n    return {\n      hbarTransfers,\n      transactionMemo: parsedParams.transactionMemo\n    };\n  }\n  static normaliseApproveHbarAllowance(params, context, client) {\n    const parsedParams = this.parseParamsWithSchema(params, approveHbarAllowanceParameters, context);\n    const ownerAccountId = AccountResolver.resolveAccount(\n      parsedParams.ownerAccountId,\n      context,\n      client\n    );\n    const spenderAccountId = parsedParams.spenderAccountId;\n    const amount = new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Hbar(parsedParams.amount);\n    if (amount.isNegative()) {\n      throw new Error(`Invalid allowance amount: ${parsedParams.amount}`);\n    }\n    return {\n      hbarApprovals: [\n        new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.HbarAllowance({\n          ownerAccountId: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountId.fromString(ownerAccountId),\n          spenderAccountId: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountId.fromString(spenderAccountId),\n          amount\n        })\n      ],\n      transactionMemo: parsedParams.transactionMemo\n    };\n  }\n  static async normaliseAirdropFungibleTokenParams(params, context, client, mirrorNode) {\n    const parsedParams = this.parseParamsWithSchema(params, airdropFungibleTokenParameters, context);\n    const sourceAccountId = AccountResolver.resolveAccount(\n      parsedParams.sourceAccountId,\n      context,\n      client\n    );\n    const tokenInfo = await mirrorNode.getTokenInfo(parsedParams.tokenId);\n    const tokenDecimals = parseInt(tokenInfo.decimals, 10);\n    if (isNaN(tokenDecimals)) {\n      throw new Error(`Invalid token decimals for token ${parsedParams.tokenId}`);\n    }\n    const tokenTransfers = [];\n    let totalAmount = long__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ZERO;\n    for (const recipient of parsedParams.recipients) {\n      const amountRaw = Number(recipient.amount);\n      if (amountRaw <= 0) {\n        throw new Error(`Invalid recipient amount: ${recipient.amount}`);\n      }\n      const amount = long__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromString(toBaseUnit(amountRaw, tokenDecimals).toNumber().toString());\n      totalAmount = totalAmount.add(amount);\n      tokenTransfers.push({\n        tokenId: parsedParams.tokenId,\n        accountId: recipient.accountId,\n        amount\n      });\n    }\n    tokenTransfers.push({\n      tokenId: parsedParams.tokenId,\n      accountId: sourceAccountId,\n      amount: totalAmount.negate()\n    });\n    return {\n      tokenTransfers\n    };\n  }\n  static normaliseAssociateTokenParams(params, context, client) {\n    const parsedParams = this.parseParamsWithSchema(params, associateTokenParameters, context);\n    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);\n    return {\n      accountId,\n      tokenIds: parsedParams.tokenIds\n    };\n  }\n  static async normaliseDissociateTokenParams(params, context, client) {\n    const parsedParams = this.parseParamsWithSchema(params, dissociateTokenParameters, context);\n    if (parsedParams.accountId === void 0) {\n      parsedParams.accountId = AccountResolver.getDefaultAccount(context, client);\n      if (!parsedParams.accountId) {\n        throw new Error(\"Could not determine default account ID\");\n      }\n    }\n    return {\n      ...parsedParams,\n      accountId: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountId.fromString(parsedParams.accountId),\n      tokenIds: parsedParams.tokenIds.map((id) => _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenId.fromString(id))\n    };\n  }\n  static async normaliseCreateTopicParams(params, context, client, mirrorNode) {\n    const parsedParams = this.parseParamsWithSchema(params, createTopicParameters, context);\n    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);\n    if (!defaultAccountId) throw new Error(\"Could not determine default account ID\");\n    const normalised = {\n      ...parsedParams,\n      autoRenewAccountId: defaultAccountId\n    };\n    if (parsedParams.isSubmitKey) {\n      const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();\n      if (!publicKey) {\n        throw new Error(\"Could not determine public key for submit key\");\n      }\n      normalised.submitKey = _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.PublicKey.fromString(publicKey);\n    }\n    return normalised;\n  }\n  static normaliseDeleteTopic(params, context, _client, _mirrorNode) {\n    const parsedParams = this.parseParamsWithSchema(params, deleteTopicParameters, context);\n    return this.parseParamsWithSchema(parsedParams, deleteTopicParametersNormalised, context);\n  }\n  static normaliseUpdateTopic = async (params, context, client) => {\n    const parsedParams = this.parseParamsWithSchema(params, updateTopicParameters, context);\n    const topicId = _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TopicId.fromString(parsedParams.topicId);\n    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);\n    const normalised = {\n      topicId\n    };\n    const maybeKeys = {\n      adminKey: parsedParams.adminKey,\n      submitKey: parsedParams.submitKey\n    };\n    for (const [field, rawVal] of Object.entries(maybeKeys)) {\n      const resolved = this.resolveKey(rawVal, userPublicKey);\n      if (resolved) {\n        normalised[field] = resolved;\n      }\n    }\n    if (parsedParams.topicMemo) normalised.topicMemo = parsedParams.topicMemo;\n    if (parsedParams.autoRenewAccountId)\n      normalised.autoRenewAccountId = parsedParams.autoRenewAccountId;\n    if (parsedParams.autoRenewPeriod) normalised.autoRenewPeriod = parsedParams.autoRenewPeriod;\n    if (parsedParams.expirationTime) {\n      normalised.expirationTime = parsedParams.expirationTime instanceof Date ? parsedParams.expirationTime : new Date(parsedParams.expirationTime);\n    }\n    return normalised;\n  };\n  static async normaliseCreateAccount(params, context, client, mirrorNode) {\n    const parsedParams = this.parseParamsWithSchema(params, createAccountParameters, context);\n    let publicKey = parsedParams.publicKey ?? client.operatorPublicKey?.toStringDer();\n    if (!publicKey) {\n      const defaultAccountId = AccountResolver.getDefaultAccount(context, client);\n      if (defaultAccountId) {\n        const account = await mirrorNode.getAccount(defaultAccountId);\n        publicKey = account?.accountPublicKey;\n      }\n    }\n    if (!publicKey) {\n      throw new Error(\n        \"Unable to resolve public key: no param, mirror node, or client operator key available.\"\n      );\n    }\n    return {\n      ...parsedParams,\n      key: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.PublicKey.fromString(publicKey)\n    };\n  }\n  static normaliseHbarBalanceParams(params, context, client) {\n    const parsedParams = this.parseParamsWithSchema(params, accountBalanceQueryParameters, context);\n    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);\n    return {\n      ...parsedParams,\n      accountId\n    };\n  }\n  static normaliseAccountTokenBalancesParams(params, context, client) {\n    const parsedParams = this.parseParamsWithSchema(params, accountTokenBalancesQueryParameters, context);\n    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);\n    return {\n      ...parsedParams,\n      accountId\n    };\n  }\n  static normaliseCreateERC20Params(params, factoryContractId, factoryContractAbi, factoryContractFunctionName, context) {\n    const parsedParams = this.parseParamsWithSchema(params, createERC20Parameters, context);\n    const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(factoryContractAbi);\n    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [\n      parsedParams.tokenName,\n      parsedParams.tokenSymbol,\n      parsedParams.decimals,\n      parsedParams.initialSupply\n    ]);\n    const functionParameters = ethers__WEBPACK_IMPORTED_MODULE_6__.getBytes(encodedData);\n    return {\n      ...parsedParams,\n      contractId: factoryContractId,\n      functionParameters,\n      gas: 3e6\n      //TODO: make this configurable\n    };\n  }\n  static normaliseCreateERC721Params(params, factoryContractId, factoryContractAbi, factoryContractFunctionName, context) {\n    const parsedParams = this.parseParamsWithSchema(params, createERC721Parameters, context);\n    const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(factoryContractAbi);\n    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [\n      parsedParams.tokenName,\n      parsedParams.tokenSymbol,\n      parsedParams.baseURI\n    ]);\n    const functionParameters = ethers__WEBPACK_IMPORTED_MODULE_6__.getBytes(encodedData);\n    return {\n      ...parsedParams,\n      contractId: factoryContractId,\n      functionParameters,\n      gas: 3e6\n      //TODO: make this configurable\n    };\n  }\n  static async normaliseMintFungibleTokenParams(params, context, mirrorNode) {\n    const parsedParams = this.parseParamsWithSchema(params, mintFungibleTokenParameters, context);\n    const tokenInfo = await mirrorNode.getTokenInfo(parsedParams.tokenId);\n    const decimals = Number(tokenInfo.decimals);\n    const safeDecimals = Number.isFinite(decimals) ? decimals : 0;\n    const baseAmount = toBaseUnit(parsedParams.amount, safeDecimals).toNumber();\n    return {\n      tokenId: parsedParams.tokenId,\n      amount: baseAmount\n    };\n  }\n  static normaliseMintNonFungibleTokenParams(params, context) {\n    const parsedParams = this.parseParamsWithSchema(params, mintNonFungibleTokenParameters, context);\n    const encoder = new TextEncoder();\n    const metadata = parsedParams.uris.map((uri) => encoder.encode(uri));\n    return {\n      ...parsedParams,\n      metadata\n    };\n  }\n  static async normaliseTransferERC20Params(params, factoryContractAbi, factoryContractFunctionName, context, mirrorNode) {\n    const parsedParams = this.parseParamsWithSchema(params, transferERC20Parameters, context);\n    const recipientAddress = await AccountResolver.getHederaEVMAddress(\n      parsedParams.recipientAddress,\n      mirrorNode\n    );\n    const contractId = await _HederaParameterNormaliser.getHederaAccountId(\n      parsedParams.contractId,\n      mirrorNode\n    );\n    const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(factoryContractAbi);\n    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [\n      recipientAddress,\n      parsedParams.amount\n    ]);\n    const functionParameters = ethers__WEBPACK_IMPORTED_MODULE_6__.getBytes(encodedData);\n    return {\n      contractId,\n      functionParameters,\n      gas: 1e5\n    };\n  }\n  static async normaliseTransferERC721Params(params, factoryContractAbi, factoryContractFunctionName, context, mirrorNode, client) {\n    const parsedParams = this.parseParamsWithSchema(params, transferERC721Parameters, context);\n    const resolvedFromAddress = AccountResolver.resolveAccount(\n      parsedParams.fromAddress,\n      context,\n      client\n    );\n    const fromAddress = await AccountResolver.getHederaEVMAddress(resolvedFromAddress, mirrorNode);\n    const toAddress = await AccountResolver.getHederaEVMAddress(parsedParams.toAddress, mirrorNode);\n    const contractId = await _HederaParameterNormaliser.getHederaAccountId(\n      parsedParams.contractId,\n      mirrorNode\n    );\n    const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(factoryContractAbi);\n    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [\n      fromAddress,\n      toAddress,\n      parsedParams.tokenId\n    ]);\n    const functionParameters = ethers__WEBPACK_IMPORTED_MODULE_6__.getBytes(encodedData);\n    return {\n      contractId,\n      functionParameters,\n      gas: 1e5\n    };\n  }\n  static async normaliseMintERC721Params(params, factoryContractAbi, factoryContractFunctionName, context, mirrorNode, client) {\n    const parsedParams = this.parseParamsWithSchema(params, mintERC721Parameters, context);\n    const resolvedToAddress = AccountResolver.resolveAccount(\n      parsedParams.toAddress,\n      context,\n      client\n    );\n    const toAddress = await AccountResolver.getHederaEVMAddress(resolvedToAddress, mirrorNode);\n    const contractId = await _HederaParameterNormaliser.getHederaAccountId(\n      parsedParams.contractId,\n      mirrorNode\n    );\n    const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(factoryContractAbi);\n    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [toAddress]);\n    const functionParameters = ethers__WEBPACK_IMPORTED_MODULE_6__.getBytes(encodedData);\n    return {\n      contractId,\n      functionParameters,\n      gas: 1e5\n    };\n  }\n  static normaliseDeleteAccount(params, context, client) {\n    const parsedParams = this.parseParamsWithSchema(params, deleteAccountParameters, context);\n    if (!AccountResolver.isHederaAddress(parsedParams.accountId)) {\n      throw new Error(\"Account ID must be a Hedera address\");\n    }\n    const transferAccountId = parsedParams.transferAccountId ?? AccountResolver.getDefaultAccount(context, client);\n    if (!transferAccountId) {\n      throw new Error(\"Could not determine transfer account ID\");\n    }\n    return {\n      accountId: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountId.fromString(parsedParams.accountId),\n      transferAccountId: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountId.fromString(transferAccountId)\n    };\n  }\n  static normaliseUpdateAccount(params, context, client) {\n    const parsedParams = this.parseParamsWithSchema(params, updateAccountParameters, context);\n    const accountId = _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountId.fromString(\n      AccountResolver.resolveAccount(parsedParams.accountId, context, client)\n    );\n    const normalised = {\n      accountId\n    };\n    if (parsedParams.maxAutomaticTokenAssociations !== void 0) {\n      normalised.maxAutomaticTokenAssociations = parsedParams.maxAutomaticTokenAssociations;\n    }\n    if (parsedParams.stakedAccountId !== void 0) {\n      normalised.stakedAccountId = parsedParams.stakedAccountId;\n    }\n    if (parsedParams.accountMemo !== void 0) {\n      normalised.accountMemo = parsedParams.accountMemo;\n    }\n    if (parsedParams.declineStakingReward !== void 0) {\n      normalised.declineStakingReward = parsedParams.declineStakingReward;\n    }\n    return normalised;\n  }\n  static normaliseGetTransactionRecordParams(params, context) {\n    const parsedParams = this.parseParamsWithSchema(params, transactionRecordQueryParameters, context);\n    const normalised = {\n      nonce: parsedParams.nonce\n    };\n    if (!parsedParams.transactionId) {\n      throw new Error(\"transactionId is required\");\n    }\n    const mirrorNodeStyleRegex = /^\\d+\\.\\d+\\.\\d+-\\d+-\\d+$/;\n    const sdkStyleRegex = /^(\\d+\\.\\d+\\.\\d+)@(\\d+)\\.(\\d+)$/;\n    if (mirrorNodeStyleRegex.test(parsedParams.transactionId)) {\n      normalised.transactionId = parsedParams.transactionId;\n    } else {\n      const match = parsedParams.transactionId.match(sdkStyleRegex);\n      if (!match) {\n        throw new Error(`Invalid transactionId format: ${parsedParams.transactionId}`);\n      }\n      const [, accountId, seconds, nanos] = match;\n      normalised.transactionId = `${accountId}-${seconds}-${nanos}`;\n    }\n    return normalised;\n  }\n  static async getHederaAccountId(address, mirrorNode) {\n    if (AccountResolver.isHederaAddress(address)) {\n      return address;\n    }\n    const account = await mirrorNode.getAccount(address);\n    return account.accountId;\n  }\n  static async normaliseUpdateToken(params, context, client) {\n    const parsedParams = this.parseParamsWithSchema(params, updateTokenParameters, context);\n    const tokenId = _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenId.fromString(parsedParams.tokenId);\n    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);\n    const normalised = {\n      tokenId\n    };\n    const maybeKeys = {\n      adminKey: parsedParams.adminKey,\n      supplyKey: parsedParams.supplyKey,\n      wipeKey: parsedParams.wipeKey,\n      freezeKey: parsedParams.freezeKey,\n      kycKey: parsedParams.kycKey,\n      feeScheduleKey: parsedParams.feeScheduleKey,\n      pauseKey: parsedParams.pauseKey,\n      metadataKey: parsedParams.metadataKey\n    };\n    for (const [field, rawVal] of Object.entries(maybeKeys)) {\n      const resolved = this.resolveKey(rawVal, userPublicKey);\n      if (resolved) {\n        normalised[field] = resolved;\n      }\n    }\n    if (parsedParams.tokenName) {\n      normalised.tokenName = parsedParams.tokenName;\n    }\n    if (parsedParams.tokenSymbol) {\n      normalised.tokenSymbol = parsedParams.tokenSymbol;\n    }\n    if (parsedParams.treasuryAccountId) {\n      normalised.treasuryAccountId = parsedParams.treasuryAccountId;\n    }\n    if (parsedParams.tokenMemo) {\n      normalised.tokenMemo = parsedParams.tokenMemo;\n    }\n    if (parsedParams.metadata) {\n      normalised.metadata = new TextEncoder().encode(parsedParams.metadata);\n    }\n    if (parsedParams.autoRenewAccountId) {\n      normalised.autoRenewAccountId = parsedParams.autoRenewAccountId;\n    }\n    return normalised;\n  }\n  static resolveKey(rawValue, userKey) {\n    if (rawValue === void 0) return void 0;\n    if (typeof rawValue === \"string\") {\n      try {\n        return _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.PublicKey.fromStringED25519(rawValue);\n      } catch {\n        return _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.PublicKey.fromStringECDSA(rawValue);\n      }\n    }\n    if (rawValue) {\n      return userKey;\n    }\n    return void 0;\n  }\n};\n\n// src/plugins/core-token-plugin/tools/fungible-token/airdrop-fungible-token.ts\n\n\n// src/shared/strategies/tx-mode-strategy.ts\n\nvar ExecuteStrategy = class {\n  defaultPostProcess(response) {\n    return JSON.stringify(response, null, 2);\n  }\n  async handle(tx, client, _context, postProcess35 = this.defaultPostProcess) {\n    const submit = await tx.execute(client);\n    const receipt = await submit.getReceipt(client);\n    const rawTransactionResponse = {\n      status: receipt.status.toString(),\n      accountId: receipt.accountId,\n      tokenId: receipt.tokenId,\n      transactionId: tx.transactionId?.toString() ?? \"\",\n      topicId: receipt.topicId,\n      scheduleId: receipt.scheduleId\n    };\n    return {\n      raw: rawTransactionResponse,\n      humanMessage: postProcess35(rawTransactionResponse)\n    };\n  }\n};\nvar ReturnBytesStrategy = class {\n  async handle(tx, _client, context) {\n    if (!context.accountId) throw new Error(\"\\u2026\");\n    const id = _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TransactionId.generate(context.accountId);\n    tx.setNodeAccountIds([new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountId(4), new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountId(5)]).setTransactionId(id).freeze();\n    return { bytes: tx.toBytes() };\n  }\n};\nvar getStrategyFromContext = (context) => {\n  if (context.mode === \"returnBytes\" /* RETURN_BYTES */) {\n    return new ReturnBytesStrategy();\n  }\n  return new ExecuteStrategy();\n};\nvar handleTransaction = async (tx, client, context, postProcess35) => {\n  const strategy = getStrategyFromContext(context);\n  return await strategy.handle(tx, client, context, postProcess35);\n};\n\n// src/shared/hedera-utils/hedera-builder.ts\n\nvar HederaBuilder = class {\n  static createScheduleTransaction(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.ScheduleCreateTransaction(params.params).setScheduledTransaction(\n      params.scheduledTransaction\n    );\n  }\n  static createFungibleToken(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenCreateTransaction(params);\n  }\n  static createNonFungibleToken(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenCreateTransaction(params);\n  }\n  static transferHbar(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TransferTransaction(params);\n  }\n  static airdropFungibleToken(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenAirdropTransaction(params);\n  }\n  static updateToken(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenUpdateTransaction(params);\n  }\n  static createTopic(params) {\n    const { transactionMemo, ...rest } = params;\n    const tx = new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TopicCreateTransaction(rest);\n    if (transactionMemo) tx.setTransactionMemo(transactionMemo);\n    return tx;\n  }\n  static submitTopicMessage(params) {\n    const { transactionMemo, ...rest } = params;\n    const tx = new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TopicMessageSubmitTransaction(rest);\n    if (transactionMemo) tx.setTransactionMemo(transactionMemo);\n    return tx;\n  }\n  static updateTopic(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TopicUpdateTransaction(params);\n  }\n  static executeTransaction(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.ContractExecuteTransaction(params);\n  }\n  static mintFungibleToken(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenMintTransaction(params);\n  }\n  static mintNonFungibleToken(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenMintTransaction(params);\n  }\n  static dissociateToken(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenDissociateTransaction(params);\n  }\n  static createAccount(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountCreateTransaction(params);\n  }\n  static deleteAccount(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountDeleteTransaction(params);\n  }\n  static updateAccount(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountUpdateTransaction(params);\n  }\n  static deleteToken(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenDeleteTransaction(params);\n  }\n  static deleteTopic(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TopicDeleteTransaction(params);\n  }\n  static signScheduleTransaction(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.ScheduleSignTransaction(params);\n  }\n  static deleteScheduleTransaction(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.ScheduleDeleteTransaction(params);\n  }\n  static associateToken(params) {\n    return new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenAssociateTransaction({\n      accountId: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountId.fromString(params.accountId),\n      tokenIds: params.tokenIds.map((t) => _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TokenId.fromString(t))\n    });\n  }\n  static approveHbarAllowance(params) {\n    const tx = new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.AccountAllowanceApproveTransaction(params);\n    if (params.transactionMemo) {\n      tx.setTransactionMemo(params.transactionMemo);\n    }\n    return tx;\n  }\n};\n\n// src/shared/hedera-utils/mirrornode/types.ts\n\nvar LedgerIdToBaseUrl = /* @__PURE__ */ new Map([\n  [_hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.LedgerId.MAINNET.toString(), \"https://mainnet-public.mirrornode.hedera.com/api/v1\"],\n  [_hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.LedgerId.TESTNET.toString(), \"https://testnet.mirrornode.hedera.com/api/v1\"]\n]);\n\n// src/shared/hedera-utils/mirrornode/hedera-mirrornode-service-default-impl.ts\n\nvar HederaMirrornodeServiceDefaultImpl = class {\n  constructor(ledgerId) {\n    this.ledgerId = ledgerId;\n    if (!LedgerIdToBaseUrl.has(ledgerId.toString())) {\n      throw new Error(`Network type ${ledgerId} not supported`);\n    }\n    this.baseUrl = LedgerIdToBaseUrl.get(ledgerId.toString());\n  }\n  baseUrl;\n  async getAccount(accountId) {\n    const url = `${this.baseUrl}/accounts/${accountId}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch account ${accountId}: ${response.status} ${response.statusText}`\n      );\n    }\n    const data = await response.json();\n    if (!data.account) {\n      throw new Error(`Account ${accountId} not found`);\n    }\n    return {\n      accountId: data.account,\n      accountPublicKey: data?.key?.key,\n      balance: data.balance,\n      evmAddress: data.evm_address\n    };\n  }\n  async getAccountHBarBalance(accountId) {\n    let account;\n    try {\n      account = await this.getAccount(accountId);\n    } catch (error) {\n      throw Error(`Failed to fetch hbar balance for ${accountId}: ${error}`);\n    }\n    return new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](account.balance.balance);\n  }\n  async getAccountTokenBalances(accountId, tokenId) {\n    const tokenIdParam = tokenId ? `&token.id=${tokenId}` : \"\";\n    const url = `${this.baseUrl}/accounts/${accountId}/tokens?${tokenIdParam}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch balance for an account ${accountId}: ${response.status} ${response.statusText}`\n      );\n    }\n    return await response.json();\n  }\n  async getTopicMessages(queryParams) {\n    const lowerThreshold = queryParams.lowerTimestamp ? `&timestamp=gte:${queryParams.lowerTimestamp}` : \"\";\n    const upperThreshold = queryParams.upperTimestamp ? `&timestamp=lte:${queryParams.upperTimestamp}` : \"\";\n    const baseParams = `&order=desc&limit=100`;\n    let url = `${this.baseUrl}/topics/${queryParams.topicId}/messages?${lowerThreshold}${upperThreshold}${baseParams}`;\n    const arrayOfMessages = [];\n    let fetchedMessages = 0;\n    try {\n      while (url) {\n        fetchedMessages += 1;\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(\n            `Failed to get topic messages for ${queryParams.topicId}: ${response.status} ${response.statusText}`\n          );\n        }\n        const data = await response.json();\n        arrayOfMessages.push(...data.messages);\n        if (fetchedMessages >= 100) {\n          break;\n        }\n        url = data.links.next ? this.baseUrl + data.links.next : null;\n      }\n    } catch (error) {\n      console.error(`Failed to fetch topic messages for ${queryParams.topicId}. Error:`, error);\n      throw error;\n    }\n    return {\n      topicId: queryParams.topicId,\n      messages: arrayOfMessages.slice(0, queryParams.limit)\n    };\n  }\n  async getTokenInfo(tokenId) {\n    const url = `${this.baseUrl}/tokens/${tokenId}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to get token info for a token ${tokenId}: ${response.status} ${response.statusText}`\n      );\n    }\n    return await response.json();\n  }\n  async getTopicInfo(topicId) {\n    const url = `${this.baseUrl}/topics/${topicId}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to get topic info for ${topicId}: ${response.status} ${response.statusText}`\n      );\n    }\n    return await response.json();\n  }\n  async getTransactionRecord(transactionId, nonce) {\n    let url = `${this.baseUrl}/transactions/${transactionId}`;\n    if (nonce !== void 0) {\n      url += `?nonce=${nonce}`;\n    }\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to get transaction record for ${transactionId}: ${response.status} ${response.statusText}`\n      );\n    }\n    return await response.json();\n  }\n  async getContractInfo(contractId) {\n    const url = `${this.baseUrl}/contracts/${contractId}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to get contract info for ${contractId}: ${response.status} ${response.statusText}`\n      );\n    }\n    return await response.json();\n  }\n  async getPendingAirdrops(accountId) {\n    const url = `${this.baseUrl}/accounts/${accountId}/airdrops/pending`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch pending airdrops for an account ${accountId}: ${response.status} ${response.statusText}`\n      );\n    }\n    return await response.json();\n  }\n  async getOutstandingAirdrops(accountId) {\n    const url = `${this.baseUrl}/accounts/${accountId}/airdrops/outstanding`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch outstanding airdrops for an account ${accountId}: ${response.status} ${response.statusText}`\n      );\n    }\n    return await response.json();\n  }\n  async getExchangeRate(timestamp) {\n    const timestampParam = timestamp ? `?timestamp=${encodeURIComponent(timestamp)}` : \"\";\n    const url = `${this.baseUrl}/network/exchangerate${timestampParam}`;\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}. Message: ${response.statusText}`);\n    }\n    return await response.json();\n  }\n};\n\n// src/shared/hedera-utils/mirrornode/hedera-mirrornode-utils.ts\nvar getMirrornodeService = (mirrornodeService, ledgerId) => {\n  if (mirrornodeService) {\n    return mirrornodeService;\n  }\n  return new HederaMirrornodeServiceDefaultImpl(ledgerId);\n};\n\n// src/shared/utils/prompt-generator.ts\nvar PromptGenerator = class {\n  /**\n   * Generates a consistent context snippet for tool prompts.\n   */\n  static getContextSnippet(context) {\n    const lines = [\"Context:\"];\n    if (context.mode === \"returnBytes\" /* RETURN_BYTES */) {\n      lines.push(`- Mode: Return Bytes (preparing transactions for user signing)`);\n      if (context.accountId) {\n        lines.push(`- User Account: ${context.accountId} (default for transaction parameters)`);\n        lines.push(`- When no account is specified, ${context.accountId} will be used`);\n      } else {\n        lines.push(`- User Account: Not specified`);\n        lines.push(`- When no account is specified, the operator account will be used`);\n      }\n    } else if (context.mode === \"autonomous\" /* AUTONOMOUS */) {\n      lines.push(`- Mode: Autonomous (agent executes transactions directly)`);\n      if (context.accountId) {\n        lines.push(`- User Account: ${context.accountId}`);\n      }\n      lines.push(`- When no account is specified, the operator account will be used`);\n    } else {\n      lines.push(`- Mode: ${context.mode || \"Not specified\"}`);\n      if (context.accountId) {\n        lines.push(`- User Account: ${context.accountId}`);\n      }\n      lines.push(`- Default account will be determined at execution time`);\n    }\n    return lines.join(\"\\n\");\n  }\n  static getAnyAddressParameterDescription(paramName, context, isRequired = false) {\n    if (isRequired) {\n      return `${paramName} (str, required): The account address. This can be the EVM address or the Hedera account id`;\n    }\n    return `${paramName} (str, optional): The Hedera account ID or EVM address. If not provided, defaults to the ${AccountResolver.getDefaultAccountDescription(context)}`;\n  }\n  /**\n   * Generates a consistent description for optional account parameters.\n   */\n  static getAccountParameterDescription(paramName, context, isRequired = false) {\n    if (isRequired) {\n      return `${paramName} (str, required): The Hedera account ID`;\n    }\n    const defaultAccountDesc = AccountResolver.getDefaultAccountDescription(context);\n    return `${paramName} (str, optional): The Hedera account ID. If not provided, defaults to the ${defaultAccountDesc}`;\n  }\n  /**\n   * Generates consistent parameter usage instructions.\n   */\n  static getParameterUsageInstructions() {\n    return `\nImportant:\n- Only include optional parameters if explicitly provided by the user\n- Do not generate placeholder values for optional fields\n- Leave optional parameters undefined if not specified by the user`;\n  }\n};\n\n// src/plugins/core-token-plugin/tools/fungible-token/airdrop-fungible-token.ts\nvar airdropFungibleTokenPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(\n    \"sourceAccountId\",\n    context\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will airdrop a fungible token on Hedera.\n\nParameters:\n- tokenId (str, required): The id of the token\n- ${sourceAccountDesc}\n- recipients (array, required): A list of recipient objects, each containing:\n  - accountId (string): The recipient's account ID (e.g., \"0.0.1234\")\n  - amount (number or string): The amount of tokens to send to that recipient (in base units)\n- transactionMemo (str, optional): Optional memo for the transaction\n${usageInstructions}\n\nIf the user specifies multiple recipients in a single request, include them all in **one tool call** as a list of recipients.\n`;\n};\nvar postProcess = (response) => {\n  return `Token successfully airdropped with transaction id ${response.transactionId.toString()}`;\n};\nvar airdropFungibleToken = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const normalisedParams = await HederaParameterNormaliser.normaliseAirdropFungibleTokenParams(\n      params,\n      context,\n      client,\n      mirrornodeService\n    );\n    const tx = HederaBuilder.airdropFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to airdrop fungible token\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[airdrop_fungible_token_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar AIRDROP_FUNGIBLE_TOKEN_TOOL = \"airdrop_fungible_token_tool\";\nvar tool = (context) => ({\n  method: AIRDROP_FUNGIBLE_TOKEN_TOOL,\n  name: \"Airdrop Fungible Token\",\n  description: airdropFungibleTokenPrompt(context),\n  parameters: airdropFungibleTokenParameters(context),\n  execute: airdropFungibleToken\n});\nvar airdrop_fungible_token_default = tool;\n\n// src/plugins/core-token-plugin/tools/fungible-token/create-fungible-token.ts\n\nvar createFungibleTokenPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(\n    \"treasuryAccountId\",\n    context\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool creates a fungible token on Hedera.\n\nParameters:\n- tokenName (str, required): The name of the token\n- tokenSymbol (str, optional): The symbol of the token\n- initialSupply (int, optional): The initial supply of the token, defaults to 0\n- supplyType (str, optional): The supply type of the token. Can be \"finite\" or \"infinite\". Defaults to \"finite\"\n- maxSupply (int, optional): The maximum supply of the token. Only applicable if supplyType is \"finite\". Defaults to 1,000,000 if not specified\n- decimals (int, optional): The number of decimals the token supports. Defaults to 0\n- ${treasuryAccountDesc}\n- isSupplyKey (boolean, optional): If user wants to set supply key set to true, otherwise false\n${usageInstructions}\n`;\n};\nvar postProcess2 = (response) => {\n  return `Token created successfully at address ${response.tokenId?.toString()} with transaction id ${response.transactionId}`;\n};\nvar createFungibleToken = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const normalisedParams = await HederaParameterNormaliser.normaliseCreateFungibleTokenParams(\n      params,\n      context,\n      client,\n      mirrornodeService\n    );\n    const tx = HederaBuilder.createFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess2);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to create fungible token\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[create_fungible_token_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar CREATE_FUNGIBLE_TOKEN_TOOL = \"create_fungible_token_tool\";\nvar tool2 = (context) => ({\n  method: CREATE_FUNGIBLE_TOKEN_TOOL,\n  name: \"Create Fungible Token\",\n  description: createFungibleTokenPrompt(context),\n  parameters: createFungibleTokenParameters(context),\n  execute: createFungibleToken\n});\nvar create_fungible_token_default = tool2;\n\n// src/plugins/core-token-plugin/tools/fungible-token/mint-fungible-token.ts\n\nvar mintFungibleTokenPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will mint a given amount (supply) of an existing fungible token on Hedera.\n\nParameters:\n- tokenId (str, required): The id of the token\n- amount (number, required): The amount to be minted\n${usageInstructions}\n\nExample: \"Mint 1 of 0.0.6458037\" means minting the amount of 1 of the token with id 0.0.6458037.\n`;\n};\nvar postProcess3 = (response) => {\n  return `Tokens successfully minted with transaction id ${response.transactionId.toString()}`;\n};\nvar mintFungibleToken = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const normalisedParams = await HederaParameterNormaliser.normaliseMintFungibleTokenParams(\n      params,\n      context,\n      mirrornodeService\n    );\n    const tx = HederaBuilder.mintFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess3);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to mint fungible token\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[mint_fungible_token_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar MINT_FUNGIBLE_TOKEN_TOOL = \"mint_fungible_token_tool\";\nvar tool3 = (context) => ({\n  method: MINT_FUNGIBLE_TOKEN_TOOL,\n  name: \"Mint Fungible Token\",\n  description: mintFungibleTokenPrompt(context),\n  parameters: mintFungibleTokenParameters(context),\n  execute: mintFungibleToken\n});\nvar mint_fungible_token_default = tool3;\n\n// src/plugins/core-token-plugin/tools/non-fungible-token/create-non-fungible-token.ts\n\nvar createNonFungibleTokenPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(\n    \"treasuryAccountId\",\n    context\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool creates a non-fungible token (NFT) on Hedera.\n\nParameters:\n- tokenName (str, required): Name of the token\n- tokenSymbol (str, required): Symbol of the token\n- maxSupply (int, optional): Maximum NFT supply. Defaults to 100 if not provided\n- ${treasuryAccountDesc}\n${usageInstructions}\n`;\n};\nvar postProcess4 = (response) => {\n  return `Token created successfully at address ${response.tokenId?.toString()} with transaction id ${response.transactionId.toString()}`;\n};\nvar createNonFungibleToken = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const normalisedParams = await HederaParameterNormaliser.normaliseCreateNonFungibleTokenParams(\n      params,\n      context,\n      client,\n      mirrornodeService\n    );\n    const tx = HederaBuilder.createNonFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess4);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to create non-fungible token\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[create_non_fungible_token_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar CREATE_NON_FUNGIBLE_TOKEN_TOOL = \"create_non_fungible_token_tool\";\nvar tool4 = (context) => ({\n  method: CREATE_NON_FUNGIBLE_TOKEN_TOOL,\n  name: \"Create Non-Fungible Token\",\n  description: createNonFungibleTokenPrompt(context),\n  parameters: createNonFungibleTokenParameters(context),\n  execute: createNonFungibleToken\n});\nvar create_non_fungible_token_default = tool4;\n\n// src/plugins/core-token-plugin/tools/non-fungible-token/mint-non-fungible-token.ts\n\nvar mintNonFungibleTokenPrompt = (_context = {}) => {\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n\nThis tool will mint NFTs with its unique metadata for the class of NFTs (non-fungible tokens) defined by the tokenId on Hedera.\n\nParameters:\n- tokenId (str, required): The id of the token\n- uris (array, required): An array of strings (URIs) of maximum size 10 hosting the NFT metadata\n${usageInstructions}\n\nExample: \"Mint 0.0.6465503 with metadata: ipfs://bafyreiao6ajgsfji6qsgbqwdtjdu5gmul7tv2v3pd6kjgcw5o65b2ogst4/metadata.json\" means minting an NFT with the given metadata URI for the class of NFTs defined by the token with id 0.0.6465503.\n`;\n};\nvar postProcess5 = (response) => {\n  return `Token ${response.tokenId?.toString()} successfully minted with transaction id ${response.transactionId.toString()}`;\n};\nvar mintNonFungibleToken = async (client, context, params) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseMintNonFungibleTokenParams(\n      params,\n      context\n    );\n    const tx = HederaBuilder.mintNonFungibleToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess5);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to mint non-fungible token\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[mint_non_fungible_token_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar MINT_NON_FUNGIBLE_TOKEN_TOOL = \"mint_non_fungible_token_tool\";\nvar tool5 = (context) => ({\n  method: MINT_NON_FUNGIBLE_TOKEN_TOOL,\n  name: \"Mint Non-Fungible Token\",\n  description: mintNonFungibleTokenPrompt(context),\n  parameters: mintNonFungibleTokenParameters(context),\n  execute: mintNonFungibleToken\n});\nvar mint_non_fungible_token_default = tool5;\n\n// src/plugins/core-token-plugin/tools/update-token.ts\n\nvar checkValidityOfUpdates = async (params, mirrornode, userPublicKey) => {\n  const tokenDetails = await mirrornode.getTokenInfo(params.tokenId.toString());\n  if (!tokenDetails) {\n    throw new Error(\"Token not found\");\n  }\n  if (tokenDetails.admin_key?.key !== userPublicKey.toStringRaw()) {\n    console.error(\n      `tokenDetails.admin_key.key: ${tokenDetails.admin_key?.key} vs userPublicKey: ${userPublicKey.toStringRaw()}`\n    );\n    throw new Error(\n      \"You do not have permission to update this token. The adminKey does not match your public key.\"\n    );\n  }\n  const keyChecks = {\n    adminKey: \"admin_key\",\n    kycKey: \"kyc_key\",\n    freezeKey: \"freeze_key\",\n    wipeKey: \"wipe_key\",\n    supplyKey: \"supply_key\",\n    feeScheduleKey: \"fee_schedule_key\",\n    pauseKey: \"pause_key\",\n    metadataKey: \"metadata_key\"\n  };\n  for (const [paramKey, tokenField] of Object.entries(keyChecks)) {\n    const userValue = params[paramKey];\n    const tokenKey = tokenDetails[tokenField];\n    if (userValue instanceof _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.PublicKey && !tokenKey) {\n      throw new Error(`Cannot update ${paramKey}: token was created without a ${paramKey}`);\n    }\n  }\n};\nvar updateTokenPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const tokenDesc = PromptGenerator.getAnyAddressParameterDescription(\"tokenId\", context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will update an existing Hedera HTS token. Only the fields provided will be updated.\n\nKey fields (adminKey, kycKey, freezeKey, wipeKey, supplyKey, feeScheduleKey, pauseKey, metadataKey) must contain **Hedera-compatible public keys (as strings) or boolean (true/false)**. You can provide these in one of three ways:\n\n1. **Boolean true** \\u2013 Set this field to use user/operator key. Injecting of the key will be handled automatically.\n2. **Not provided** \\u2013 The field will not be updated.\n3. **String** \\u2013 Provide a Hedera-compatible public key string to set a field explicitly.\n\nParameters:\n- ${tokenDesc}\n- tokenName (string, optional): New name for the token. Up to 100 characters.\n- tokenSymbol (string, optional): New symbol for the token. Up to 100 characters.\n- treasuryAccountId (string, optional): New treasury account for the token (Hedera account ID).\n- adminKey (boolean|string, optional): New admin key. Pass true to use your operator key, or provide a public key string.\n- kycKey (boolean|string, optional): New KYC key. Pass true to use your operator key, or provide a public key string.\n- freezeKey (boolean|string, optional): New freeze key. Pass true to use your operator key, or provide a public key string.\n- wipeKey (boolean|string, optional): New wipe key. Pass true to use your operator key, or provide a public key string.\n- supplyKey (boolean|string, optional): New supply key. Pass true to use your operator key, or provide a public key string.\n- feeScheduleKey (boolean|string, optional): New fee schedule key. Pass true to use your operator key, or provide a public key string.\n- pauseKey (boolean|string, optional): New pause key. Pass true to use your operator key, or provide a public key string.\n- metadataKey (boolean|string, optional): New metadata key. Pass true to use your operator key, or provide a public key string.\n- metadata (string, optional): New metadata for the token, in bytes (hex or base64).\n- tokenMemo (string, optional): Short public memo for the token, up to 100 characters.\n- autoRenewAccountId (string, optional): Account to automatically pay for renewal.\n\nExamples:\n- If the user asks for \"my key\" \\u2192 set the field to \\`true\\`.\n- If the user does not mention the key \\u2192 do not set the field.\n- If the user provides a key \\u2192 set the field to the provided public key string.\n\nIf the user provides multiple fields in a single request, \ncombine them into **one tool call** with all parameters together.\n\n${usageInstructions}\n`;\n};\nvar postProcess6 = (response) => {\n  return `Token successfully updated. Transaction ID: ${response.transactionId}`;\n};\nvar updateToken = async (client, context, params) => {\n  try {\n    const normalisedParams = await HederaParameterNormaliser.normaliseUpdateToken(\n      params,\n      context,\n      client\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);\n    await checkValidityOfUpdates(normalisedParams, mirrornodeService, userPublicKey);\n    const tx = HederaBuilder.updateToken(normalisedParams);\n    return await handleTransaction(tx, client, context, postProcess6);\n  } catch (error) {\n    const desc = \"Failed to update token\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[update_token_tool]\", message);\n    return {\n      raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message },\n      humanMessage: message\n    };\n  }\n};\nvar UPDATE_TOKEN_TOOL = \"update_token_tool\";\nvar tool6 = (context) => ({\n  method: UPDATE_TOKEN_TOOL,\n  name: \"Update Token\",\n  description: updateTokenPrompt(context),\n  parameters: updateTokenParameters(context),\n  execute: updateToken\n});\nvar update_token_default = tool6;\n\n// src/plugins/core-token-plugin/tools/dissociate-token.ts\n\nvar dissociateTokenPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(\"accountId\", context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will airdrop a fungible token on Hedera.\n\nParameters:\n- tokenIds (array of strings, required): A list of Hedera token IDs to dissociate from the account. Example: [\"0.0.1234\", \"0.0.5678\"]\n- ${sourceAccountDesc}, account from which to dissociate the token(s)\n- transactionMemo (str, optional): Optional memo for the transaction\n\nExamples:\n- Dissociate a single token: { \"tokenIds\": [\"0.0.1234\"] }\n- Dissociate multiple tokens from a specific account: { \"tokenIds\": [\"0.0.1234\", \"0.0.5678\"], \"accountId\": \"0.0.4321\" }\n\n${usageInstructions}\n`;\n};\nvar postProcess7 = (response) => {\n  return `Token(s) successfully dissociated with transaction id ${response.transactionId.toString()}`;\n};\nvar dissociateToken = async (client, context, params) => {\n  try {\n    const normalisedParams = await HederaParameterNormaliser.normaliseDissociateTokenParams(\n      params,\n      context,\n      client\n    );\n    const tx = HederaBuilder.dissociateToken(normalisedParams);\n    return await handleTransaction(tx, client, context, postProcess7);\n  } catch (error) {\n    const desc = \"Failed to dissociate token\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[dissociate_token_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar DISSOCIATE_TOKEN_TOOL = \"dissociate_token_tool\";\nvar tool7 = (context) => ({\n  method: DISSOCIATE_TOKEN_TOOL,\n  name: \"Dissociate Token\",\n  description: dissociateTokenPrompt(context),\n  parameters: dissociateTokenParameters(context),\n  execute: dissociateToken\n});\nvar dissociate_token_default = tool7;\n\n// src/plugins/core-token-plugin/tools/associate-token.ts\n\nvar associateTokenPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  const accountToAssociate = PromptGenerator.getAnyAddressParameterDescription(\"accountId\", context);\n  return `\n${contextSnippet}\n\nThis tool will associate one or more tokens with a Hedera account.\n\nParameters:\n${accountToAssociate}\n- tokenIds (string[], required): Array of token IDs to associate\n${usageInstructions}\n\nExample: \"Associate tokens 0.0.123 and 0.0.456 to account 0.0.789\".\n`;\n};\nvar postProcess8 = (response) => {\n  return `Tokens successfully associated with transaction id ${response.transactionId.toString()}`;\n};\nvar associateToken = async (client, context, params) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseAssociateTokenParams(\n      params,\n      context,\n      client\n    );\n    const tx = HederaBuilder.associateToken(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess8);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to associate token(s)\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[associate_token_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar ASSOCIATE_TOKEN_TOOL = \"associate_token_tool\";\nvar tool8 = (context) => ({\n  method: ASSOCIATE_TOKEN_TOOL,\n  name: \"Associate Token(s)\",\n  description: associateTokenPrompt(context),\n  parameters: associateTokenParameters(context),\n  execute: associateToken\n});\nvar associate_token_default = tool8;\n\n// src/plugins/core-token-plugin/index.ts\nvar coreTokenPlugin = {\n  name: \"core-token-plugin\",\n  version: \"1.0.0\",\n  description: \"A plugin for the Hedera Token Service\",\n  tools: (context) => {\n    return [\n      create_fungible_token_default(context),\n      mint_fungible_token_default(context),\n      create_non_fungible_token_default(context),\n      airdrop_fungible_token_default(context),\n      mint_non_fungible_token_default(context),\n      update_token_default(context),\n      dissociate_token_default(context),\n      associate_token_default(context)\n    ];\n  }\n};\nvar coreTokenPluginToolNames = {\n  AIRDROP_FUNGIBLE_TOKEN_TOOL,\n  CREATE_FUNGIBLE_TOKEN_TOOL,\n  MINT_FUNGIBLE_TOKEN_TOOL,\n  CREATE_NON_FUNGIBLE_TOKEN_TOOL,\n  MINT_NON_FUNGIBLE_TOKEN_TOOL,\n  DISSOCIATE_TOKEN_TOOL,\n  ASSOCIATE_TOKEN_TOOL,\n  UPDATE_TOKEN_TOOL\n};\n\n// src/plugins/core-account-plugin/tools/account/transfer-hbar.ts\n\nvar transferHbarPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(\n    \"sourceAccountId\",\n    context\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will transfer HBAR to an account.\n\nParameters:\n- transfers (array of objects, required): List of HBAR transfers. Each object should contain:\n  - accountId (string): Recipient account ID\n  - amount (number): Amount of HBAR to transfer\n- ${sourceAccountDesc}\n- transactionMemo (string, optional): Optional memo for the transaction\n${usageInstructions}\n`;\n};\nvar postProcess9 = (response) => {\n  return `HBAR successfully transferred. Transaction ID: ${response.transactionId}`;\n};\nvar transferHbar = async (client, context, params) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseTransferHbar(\n      params,\n      context,\n      client\n    );\n    const tx = HederaBuilder.transferHbar(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess9);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to transfer HBAR\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[transfer_hbar_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar TRANSFER_HBAR_TOOL = \"transfer_hbar_tool\";\nvar tool9 = (context) => ({\n  method: TRANSFER_HBAR_TOOL,\n  name: \"Transfer HBAR\",\n  description: transferHbarPrompt(context),\n  parameters: transferHbarParameters(context),\n  execute: transferHbar\n});\nvar transfer_hbar_default = tool9;\n\n// src/plugins/core-account-plugin/tools/account/approve-hbar-allowance.ts\nvar approveHbarAllowancePrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const ownerAccountDesc = PromptGenerator.getAccountParameterDescription(\n    \"ownerAccountId\",\n    context\n  );\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool approves an HBAR allowance from the owner to the spender.\n\nParameters:\n- ${ownerAccountDesc}\n- spenderAccountId (string, required): Spender account ID\n- amount (number, required): Amount of HBAR to approve (can be decimal, cannot be negative)\n- transactionMemo (string, optional): Optional memo for the transaction\n${usageInstructions}\n`;\n};\nvar postProcess10 = (response) => {\n  return `HBAR allowance approved successfully. Transaction ID: ${response.transactionId}`;\n};\nvar approveHbarAllowance = async (client, context, params) => {\n  const normalisedParams = HederaParameterNormaliser.normaliseApproveHbarAllowance(\n    params,\n    context,\n    client\n  );\n  const tx = HederaBuilder.approveHbarAllowance(normalisedParams);\n  const result = await handleTransaction(tx, client, context, postProcess10);\n  return result;\n};\nvar APPROVE_HBAR_ALLOWANCE_TOOL = \"approve_hbar_allowance_tool\";\nvar tool10 = (context) => ({\n  method: APPROVE_HBAR_ALLOWANCE_TOOL,\n  name: \"Approve HBAR Allowance\",\n  description: approveHbarAllowancePrompt(context),\n  parameters: approveHbarAllowanceParameters(context),\n  execute: approveHbarAllowance\n});\nvar approve_hbar_allowance_default = tool10;\n\n// src/plugins/core-account-plugin/tools/account/create-account.ts\n\nvar createAccountPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will create a new Hedera account with a passed public key. If not passed, the tool will use operators public key.\n\nParameters:\n- publicKey (string, optional): Public key to use for the account. If not provided, the tool will use the operators public key.\n- accountMemo (string, optional): Optional memo for the account\n- initialBalance (number, optional, default 0): Initial HBAR to fund the account\n- maxAutomaticTokenAssociations (number, optional, default -1): -1 means unlimited\n${usageInstructions}\n`;\n};\nvar postProcess11 = (response) => {\n  const accountIdStr = response.accountId ? response.accountId.toString() : \"unknown\";\n  return `Account created successfully.\nTransaction ID: ${response.transactionId}\nNew Account ID: ${accountIdStr}\n}`;\n};\nvar createAccount = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const normalisedParams = await HederaParameterNormaliser.normaliseCreateAccount(\n      params,\n      context,\n      client,\n      mirrornodeService\n    );\n    const tx = HederaBuilder.createAccount(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess11);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to create account\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[create_account_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar CREATE_ACCOUNT_TOOL = \"create_account_tool\";\nvar tool11 = (context) => ({\n  method: CREATE_ACCOUNT_TOOL,\n  name: \"Create Account\",\n  description: createAccountPrompt(context),\n  parameters: createAccountParameters(context),\n  execute: createAccount\n});\nvar create_account_default = tool11;\n\n// src/plugins/core-account-plugin/tools/account/delete-account.ts\n\nvar deleteAccountPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription(\"accountId\", context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will delete an existing Hedera account. The remaining balance of the account will be transferred to the transferAccountId if provided, otherwise the operator account will be used.\n\nParameters:\n- ${accountDesc}\n- accountId (str, required): The account ID to delete\n- transferAccountId (str, optional): The account ID to transfer the remaining balance to. If not provided, the operator account will be used.\n${usageInstructions}\n`;\n};\nvar postProcess12 = (response) => {\n  return `Account successfully deleted. Transaction ID: ${response.transactionId}`;\n};\nvar deleteAccount = async (client, context, params) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseDeleteAccount(\n      params,\n      context,\n      client\n    );\n    let tx = HederaBuilder.deleteAccount(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess12);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to delete account\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[delete_account_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar DELETE_ACCOUNT_TOOL = \"delete_account_tool\";\nvar tool12 = (context) => ({\n  method: DELETE_ACCOUNT_TOOL,\n  name: \"Delete Account\",\n  description: deleteAccountPrompt(context),\n  parameters: deleteAccountParameters(context),\n  execute: deleteAccount\n});\nvar delete_account_default = tool12;\n\n// src/plugins/core-account-plugin/tools/account/update-account.ts\n\nvar updateAccountPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription(\"accountId\", context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will update an existing Hedera account. Only provided fields will be updated.\n\nParameters:\n- ${accountDesc}\n- accountId (string, optional) Account ID to update (e.g., 0.0.xxxxx). If not provided, operator account ID will be used\n- maxAutomaticTokenAssociations (number, optional)\n- stakedAccountId (string, optional)\n- accountMemo (string, optional)\n- declineStakingReward (boolean, optional)\n${usageInstructions}\n`;\n};\nvar postProcess13 = (response) => {\n  return `Account successfully updated. Transaction ID: ${response.transactionId}`;\n};\nvar updateAccount = async (client, context, params) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseUpdateAccount(\n      params,\n      context,\n      client\n    );\n    let tx = HederaBuilder.updateAccount(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess13);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to update account\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[update_account_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar UPDATE_ACCOUNT_TOOL = \"update_account_tool\";\nvar tool13 = (context) => ({\n  method: UPDATE_ACCOUNT_TOOL,\n  name: \"Update Account\",\n  description: updateAccountPrompt(context),\n  parameters: updateAccountParameters(context),\n  execute: updateAccount\n});\nvar update_account_default = tool13;\n\n// src/plugins/core-account-plugin/tools/account/sign-schedule-transaction.ts\n\nvar signScheduleTransactionPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will sign a scheduled transaction and return the transaction ID.\n\nParameters:\n- scheduleId (string, required): The ID of the scheduled transaction to sign\n${usageInstructions}\n`;\n};\nvar postProcess14 = (response) => {\n  return `Transaction successfully signed. Transaction ID: ${response.transactionId}`;\n};\nvar signScheduleTransaction = async (client, context, params) => {\n  try {\n    const tx = HederaBuilder.signScheduleTransaction(params);\n    const result = await handleTransaction(tx, client, context, postProcess14);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to sign scheduled transaction\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[sign_schedule_transaction_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar SIGN_SCHEDULE_TRANSACTION_TOOL = \"sign_schedule_transaction_tool\";\nvar tool14 = (context) => ({\n  method: SIGN_SCHEDULE_TRANSACTION_TOOL,\n  name: \"Sign Scheduled Transaction\",\n  description: signScheduleTransactionPrompt(context),\n  parameters: signScheduleTransactionParameters(context),\n  execute: signScheduleTransaction\n});\nvar sign_schedule_transaction_default = tool14;\n\n// src/plugins/core-account-plugin/tools/account/schedule-delete.ts\n\nvar scheduleDeletePrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will delete a scheduled transaction (by admin) so it will not execute.\n\nParameters:\n- scheduleId (string, required): The ID of the scheduled transaction to delete\n${usageInstructions}\n`;\n};\nvar postProcess15 = (response) => {\n  return `Scheduled transaction successfully deleted. Transaction ID: ${response.transactionId}`;\n};\nvar scheduleDelete = async (client, context, params) => {\n  try {\n    const tx = HederaBuilder.deleteScheduleTransaction(params);\n    const result = await handleTransaction(tx, client, context, postProcess15);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to delete scheduled transaction\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[schedule_delete_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar SCHEDULE_DELETE_TOOL = \"schedule_delete_tool\";\nvar tool15 = (context) => ({\n  method: SCHEDULE_DELETE_TOOL,\n  name: \"Delete Scheduled Transaction\",\n  description: scheduleDeletePrompt(context),\n  parameters: scheduleDeleteTransactionParameters(context),\n  execute: scheduleDelete\n});\nvar schedule_delete_default = tool15;\n\n// src/plugins/core-account-plugin/index.ts\nvar coreAccountPlugin = {\n  name: \"core-account-plugin\",\n  version: \"1.0.0\",\n  description: \"A plugin for the Hedera Account Service\",\n  tools: (context) => {\n    return [\n      transfer_hbar_default(context),\n      approve_hbar_allowance_default(context),\n      delete_account_default(context),\n      update_account_default(context),\n      create_account_default(context),\n      sign_schedule_transaction_default(context),\n      schedule_delete_default(context)\n    ];\n  }\n};\nvar coreAccountPluginToolNames = {\n  TRANSFER_HBAR_TOOL,\n  APPROVE_HBAR_ALLOWANCE_TOOL,\n  CREATE_ACCOUNT_TOOL,\n  DELETE_ACCOUNT_TOOL,\n  UPDATE_ACCOUNT_TOOL,\n  SIGN_SCHEDULE_TRANSACTION_TOOL,\n  SCHEDULE_DELETE_TOOL\n};\n\n// src/plugins/core-consensus-plugin/tools/consensus/create-topic.ts\n\nvar createTopicPrompt = (_context = {}) => {\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\nThis tool will create a new topic on the Hedera network.\n\nParameters:\n- topicMemo (str, optional): A memo for the topic\n- transactionMemo (str, optional): An optional memo to include on the submitted transaction\n- isSubmitKey (bool, optional): Whether to set a submit key for the topic. Set to true if user wants to set a submit key, otherwise false\n${usageInstructions}\n`;\n};\nvar postProcess16 = (response) => {\n  return `Topic created successfully with topic id ${response.topicId?.toString()} and transaction id ${response.transactionId.toString()}`;\n};\nvar createTopic = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(\n      context.mirrornodeService,\n      client.ledgerId\n    );\n    const normalisedParams = await HederaParameterNormaliser.normaliseCreateTopicParams(\n      params,\n      context,\n      client,\n      mirrornodeService\n    );\n    const tx = HederaBuilder.createTopic(normalisedParams);\n    const result = await handleTransaction(tx, client, context, postProcess16);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to create topic\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[create_topic_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar CREATE_TOPIC_TOOL = \"create_topic_tool\";\nvar tool16 = (context) => ({\n  method: CREATE_TOPIC_TOOL,\n  name: \"Create Topic\",\n  description: createTopicPrompt(context),\n  parameters: createTopicParameters(context),\n  execute: createTopic\n});\nvar create_topic_default = tool16;\n\n// src/plugins/core-consensus-plugin/tools/consensus/delete-topic.ts\n\nvar deleteTopicPrompt = (_context = {}) => {\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\nThis tool will delete a given Hedera network topic.\n\nParameters:\n- topicId (str, required): id of topic to delete\n${usageInstructions}\n`;\n};\nvar postProcess17 = (response) => {\n  return `Topic with id ${response.topicId?.toString()} deleted successfully. Transaction id ${response.transactionId.toString()}`;\n};\nvar deleteTopic = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(\n      context.mirrornodeService,\n      client.ledgerId\n    );\n    const normalisedParams = HederaParameterNormaliser.normaliseDeleteTopic(\n      params,\n      context,\n      client,\n      mirrornodeService\n    );\n    const tx = HederaBuilder.deleteTopic(normalisedParams);\n    return await handleTransaction(tx, client, context, postProcess17);\n  } catch (error) {\n    const desc = \"Failed to delete the topic\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[delete_topic_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar DELETE_TOPIC_TOOL = \"delete_topic_tool\";\nvar tool17 = (context) => ({\n  method: DELETE_TOPIC_TOOL,\n  name: \"Delete Topic\",\n  description: deleteTopicPrompt(context),\n  parameters: deleteTopicParameters(context),\n  execute: deleteTopic\n});\nvar delete_topic_default = tool17;\n\n// src/plugins/core-consensus-plugin/tools/consensus/submit-topic-message.ts\n\nvar submitTopicMessagePrompt = (_context = {}) => {\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\nThis tool will submit a message to a topic on the Hedera network.\n\nParameters:\n- topicId (str, required): The ID of the topic to submit the message to\n- message (str, required): The message to submit to the topic\n- transactionMemo (str, optional): An optional memo to include on the transaction\n${usageInstructions}\n`;\n};\nvar postProcess18 = (response) => {\n  return `Message submitted successfully with transaction id ${response.transactionId.toString()}`;\n};\nvar submitTopicMessage = async (client, context, params) => {\n  try {\n    const tx = HederaBuilder.submitTopicMessage(params);\n    const result = await handleTransaction(tx, client, context, postProcess18);\n    return { ...result, topicId: params.topicId };\n  } catch (error) {\n    const desc = \"Failed to submit message to topic\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[submit_topic_message_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar SUBMIT_TOPIC_MESSAGE_TOOL = \"submit_topic_message_tool\";\nvar tool18 = (context) => ({\n  method: SUBMIT_TOPIC_MESSAGE_TOOL,\n  name: \"Submit Topic Message\",\n  description: submitTopicMessagePrompt(context),\n  parameters: submitTopicMessageParameters(context),\n  execute: submitTopicMessage\n});\nvar submit_topic_message_default = tool18;\n\n// src/plugins/core-consensus-plugin/tools/consensus/update-topic.ts\n\nvar checkValidityOfUpdates2 = async (params, mirrornode, userPublicKey) => {\n  const topicDetails = await mirrornode.getTopicInfo(params.topicId.toString());\n  if (!topicDetails) {\n    throw new Error(\"Topic not found\");\n  }\n  if (topicDetails.admin_key === void 0) {\n    throw new Error(\"Topic does not have an admin key. It cannot be updated.\");\n  }\n  if (topicDetails.admin_key.key !== userPublicKey.toStringRaw()) {\n    console.error(\n      `topicDetails.admin_key.key: ${topicDetails.admin_key?.key} vs userPublicKey: ${userPublicKey.toStringRaw()}`\n    );\n    throw new Error(\n      \"You do not have permission to update this topic. The adminKey does not match your public key.\"\n    );\n  }\n  const keyChecks = {\n    adminKey: \"admin_key\",\n    submitKey: \"submit_key\"\n  };\n  for (const [paramKey, topicField] of Object.entries(keyChecks)) {\n    const userValue = params[paramKey];\n    const topicKey = topicDetails[topicField];\n    if (userValue instanceof _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.PublicKey && !topicKey) {\n      throw new Error(`Cannot update ${paramKey}: topic was created without a ${paramKey}`);\n    }\n  }\n};\nvar updateTopicPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const topicDesc = PromptGenerator.getAnyAddressParameterDescription(\"topicId\", context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\nThis tool will update an existing Hedera Consensus Topic. Only the fields provided will be updated.\nKey fields (adminKey, submitKey) must contain **Hedera-compatible public keys (as strings) or boolean (true/false)**. You can provide these in one of three ways:\n1. **Boolean true** \\u2013 Set this field to use user/operator key. Injecting of the key will be handled automatically.\n2. **Not provided** \\u2013 The field will not be updated.\n3. **String** \\u2013 Provide a Hedera-compatible public key string to set a field explicitly.\n\nParameters:\n- ${topicDesc}\n- topicMemo (string, optional): New memo for the topic.\n- adminKey (boolean|string, optional): New admin key. Pass true to use your operator key, or provide a public key string.\n- submitKey (boolean|string, optional): New submit key. Pass true to use your operator key, or provide a public key string.\n- autoRenewAccountId (string, optional): Account to automatically pay for renewal.\n- autoRenewPeriod (number, optional): Auto renew period in seconds.\n- expirationTime (string|Date, optional): New expiration time for the topic (ISO string or Date).\nExamples:\n- If the user asks for \"my key\" \\u2192 set the field to \\`true\\`.\n- If the user does not mention the key \\u2192 do not set the field.\n- If the user provides a key \\u2192 set the field to the provided public key string.\n\nIf the user provides multiple fields in a single request, \ncombine them into **one tool call** with all parameters together.\n${usageInstructions}\n`;\n};\nvar postProcess19 = (response) => {\n  return `Topic successfully updated. Transaction ID: ${response.transactionId}`;\n};\nvar updateTopic = async (client, context, params) => {\n  try {\n    const normalisedParams = await HederaParameterNormaliser.normaliseUpdateTopic(\n      params,\n      context,\n      client\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);\n    await checkValidityOfUpdates2(normalisedParams, mirrornodeService, userPublicKey);\n    const tx = HederaBuilder.updateTopic(normalisedParams);\n    return await handleTransaction(tx, client, context, postProcess19);\n  } catch (error) {\n    const desc = \"Failed to update topic\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[update_topic_tool]\", message);\n    return {\n      raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message },\n      humanMessage: message\n    };\n  }\n};\nvar UPDATE_TOPIC_TOOL = \"update_topic_tool\";\nvar tool19 = (context) => ({\n  method: UPDATE_TOPIC_TOOL,\n  name: \"Update Topic\",\n  description: updateTopicPrompt(context),\n  parameters: updateTopicParameters(context),\n  execute: updateTopic\n});\nvar update_topic_default = tool19;\n\n// src/plugins/core-consensus-plugin/index.ts\nvar coreConsensusPlugin = {\n  name: \"core-consensus-plugin\",\n  version: \"1.0.0\",\n  description: \"A plugin for the Hedera Consensus Service\",\n  tools: (context) => {\n    return [\n      create_topic_default(context),\n      submit_topic_message_default(context),\n      delete_topic_default(context),\n      update_topic_default(context)\n    ];\n  }\n};\nvar coreConsensusPluginToolNames = {\n  CREATE_TOPIC_TOOL,\n  SUBMIT_TOPIC_MESSAGE_TOOL,\n  DELETE_TOPIC_TOOL,\n  UPDATE_TOPIC_TOOL\n};\n\n// src/shared/hedera-utils/hbar-conversion-utils.ts\nfunction toHBar(tinyBars) {\n  return tinyBars.div(1e8);\n}\n\n// src/plugins/core-queries-plugin/tools/queries/get-hbar-balance-query.ts\nvar getHbarBalanceQueryPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription(\"accountId\", context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the HBAR balance for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n${usageInstructions}\n`;\n};\nvar postProcess20 = (hbarBalance, accountId) => {\n  return `Account ${accountId} has a balance of ${hbarBalance} HBAR`;\n};\nvar getHbarBalanceQuery = async (client, context, params) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseHbarBalanceParams(\n      params,\n      context,\n      client\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const balance = await mirrornodeService.getAccountHBarBalance(\n      normalisedParams.accountId\n    );\n    return {\n      raw: { accountId: normalisedParams.accountId, hbarBalance: toHBar(balance).toString() },\n      humanMessage: postProcess20(toHBar(balance).toString(), normalisedParams.accountId)\n    };\n  } catch (error) {\n    const desc = \"Failed to get HBAR balance\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_hbar_balance_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_HBAR_BALANCE_QUERY_TOOL = \"get_hbar_balance_query_tool\";\nvar tool20 = (context) => ({\n  method: GET_HBAR_BALANCE_QUERY_TOOL,\n  name: \"Get HBAR Balance\",\n  description: getHbarBalanceQueryPrompt(context),\n  parameters: accountBalanceQueryParameters(context),\n  execute: getHbarBalanceQuery\n});\nvar get_hbar_balance_query_default = tool20;\n\n// src/plugins/core-queries-plugin/tools/queries/get-account-query.ts\n\nvar getAccountQueryPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the account information for a given Hedera account.\n\nParameters:\n- accountId (str, required): The account ID to query\n${usageInstructions}\n`;\n};\nvar postProcess21 = (account) => {\n  return `Details for ${account.accountId}\nBalance: ${account.balance.balance.toString()}\nPublic Key: ${account.accountPublicKey},\nEVM address: ${account.evmAddress},\n`;\n};\nvar getAccountQuery = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const account = await mirrornodeService.getAccount(params.accountId);\n    return {\n      raw: { accountId: params.accountId, account },\n      humanMessage: postProcess21(account)\n    };\n  } catch (error) {\n    const desc = \"Failed to get account query\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_account_query_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar GET_ACCOUNT_QUERY_TOOL = \"get_account_query_tool\";\nvar tool21 = (context) => ({\n  method: GET_ACCOUNT_QUERY_TOOL,\n  name: \"Get Account Query\",\n  description: getAccountQueryPrompt(context),\n  parameters: accountQueryParameters(context),\n  execute: getAccountQuery\n});\nvar get_account_query_default = tool21;\n\n// src/plugins/core-queries-plugin/tools/queries/get-account-token-balances-query.ts\nvar getAccountTokenBalancesQueryPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription(\"accountId\", context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the token balances for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n- tokenId (str, optional): The token ID to query for. If not provided, all token balances will be returned\n${usageInstructions}\n`;\n};\nvar postProcess22 = (tokenBalances, accountId) => {\n  const balancesText = tokenBalances.tokens.map(\n    (token) => `  Token: ${token.token_id}, Balance: ${token.balance}, Decimals: ${token.decimals}`\n  ).join(\"\\n\");\n  return `Details for ${accountId}\n--- Token Balances ---\n${balancesText}`;\n};\nvar getAccountTokenBalancesQuery = async (client, context, params) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseAccountTokenBalancesParams(\n      params,\n      context,\n      client\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const tokenBalances = await mirrornodeService.getAccountTokenBalances(\n      normalisedParams.accountId,\n      normalisedParams.tokenId\n    );\n    return {\n      raw: { accountId: normalisedParams.accountId, tokenBalances },\n      humanMessage: postProcess22(tokenBalances, normalisedParams.accountId)\n    };\n  } catch (error) {\n    const desc = \"Failed to get account token balances\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_account_token_balances_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL = \"get_account_token_balances_query_tool\";\nvar tool22 = (context) => ({\n  method: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,\n  name: \"Get Account Token Balances\",\n  description: getAccountTokenBalancesQueryPrompt(context),\n  parameters: accountTokenBalancesQueryParameters(context),\n  execute: getAccountTokenBalancesQuery\n});\nvar get_account_token_balances_query_default = tool22;\n\n// src/plugins/core-queries-plugin/tools/queries/get-topic-messages-query.ts\nvar getTopicMessagesQueryPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the messages for a given Hedera topic.\n\nParameters:\n- topicId (str, required): The topic ID to query\n- startTime (datetime, optional): The start datetime to query. If set, the messages will be returned after this datetime\n- endTime (datetime, optional): The end datetime to query. If set, the messages will be returned before this datetime\n- limit (int, optional): The limit of messages to query. If set, the number of messages to return\n${usageInstructions}\n`;\n};\nvar postProcess23 = (messages, topicId) => {\n  const messagesText = messages.map(\n    (message) => `${Buffer.from(message.message, \"base64\").toString(\"utf-8\")} - posted at: ${message.consensus_timestamp}\n`\n  );\n  return `Messages for topic ${topicId}:\n  --- Messages ---\n  ${messagesText}\n  `;\n};\nvar getTopicMessagesQueryParams = (params) => {\n  return {\n    topicId: params.topicId,\n    lowerTimestamp: params.startTime ? `${Math.floor(new Date(params.startTime).getTime() / 1e3)}.000000000` : \"\",\n    upperTimestamp: params.endTime ? `${Math.floor(new Date(params.endTime).getTime() / 1e3)}.000000000` : \"\",\n    limit: params.limit || 100\n  };\n};\nvar convertMessagesFromBase64ToString = (messages) => {\n  return messages.map((message) => {\n    return {\n      ...message,\n      message: Buffer.from(message.message, \"base64\").toString(\"utf-8\")\n    };\n  });\n};\nvar getTopicMessagesQuery = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const messages = await mirrornodeService.getTopicMessages(getTopicMessagesQueryParams(params));\n    return {\n      raw: {\n        topicId: messages.topicId,\n        messages: convertMessagesFromBase64ToString(messages.messages)\n      },\n      humanMessage: postProcess23(messages.messages, params.topicId)\n    };\n  } catch (error) {\n    const desc = \"Failed to get topic messages\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_topic_messages_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_TOPIC_MESSAGES_QUERY_TOOL = \"get_topic_messages_query_tool\";\nvar tool23 = (context) => ({\n  method: GET_TOPIC_MESSAGES_QUERY_TOOL,\n  name: \"Get Topic Messages\",\n  description: getTopicMessagesQueryPrompt(context),\n  parameters: topicMessagesQueryParameters(context),\n  execute: getTopicMessagesQuery\n});\nvar get_topic_messages_query_default = tool23;\n\n// src/plugins/core-queries-plugin/tools/queries/get-token-info-query.ts\nvar getTokenInfoQueryPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the information for a given Hedera token.\n\nParameters:\n- tokenId (str): The token ID to query for.\n${usageInstructions}\n`;\n};\nvar postProcess24 = (tokenInfo) => {\n  const formatSupply = (supply) => {\n    if (!supply) return \"N/A\";\n    const decimals = Number(tokenInfo.decimals || \"0\");\n    const amount = Number(supply);\n    if (isNaN(amount)) return supply;\n    return (amount / 10 ** decimals).toLocaleString();\n  };\n  const formatKey = (key) => {\n    if (!key) return \"Not Set\";\n    return key._type ? `${key.key}` : \"Present\";\n  };\n  const supplyType = tokenInfo.supply_type === \"INFINITE\" ? \"Infinite\" : tokenInfo.max_supply || \"Finite\";\n  const freezeStatus = tokenInfo.freeze_default ? \"Frozen\" : \"Active\";\n  return `Here are the details for token **${tokenInfo.token_id}**:\n\n- **Token Name**: ${tokenInfo.name}\n- **Token Symbol**: ${tokenInfo.symbol}\n- **Token Type**: ${tokenInfo.type || \"N/A\"}\n- **Decimals**: ${tokenInfo.decimals}\n- **Max Supply**: ${formatSupply(tokenInfo.max_supply)}\n- **Current Supply**: ${formatSupply(tokenInfo.total_supply)}\n- **Supply Type**: ${supplyType}\n- **Treasury Account ID**: ${tokenInfo.treasury_account_id || \"N/A\"}\n- **Status (Deleted/Active)**: ${tokenInfo.deleted ? \"Deleted\" : \"Active\"}\n- **Status (Frozen/Active)**: ${freezeStatus}\n\n**Keys**:\n- Admin Key: ${formatKey(tokenInfo.admin_key)}\n- Supply Key: ${formatKey(tokenInfo.supply_key)}\n- Wipe Key: ${formatKey(tokenInfo.wipe_key)}\n- KYC Key: ${formatKey(tokenInfo.kyc_key)}\n- Freeze Key: ${formatKey(tokenInfo.freeze_key)}\n- Fee Schedule Key: ${formatKey(tokenInfo.fee_schedule_key)}\n- Pause Key: ${formatKey(tokenInfo.pause_key)}\n- Metadata Key: ${formatKey(tokenInfo.metadata_key)}\n\n${tokenInfo.memo ? `**Memo**: ${tokenInfo.memo}` : \"\"}\n`;\n};\nvar getTokenInfoQuery = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const tokenInfo = {\n      ...await mirrornodeService.getTokenInfo(params.tokenId),\n      token_id: params.tokenId\n    };\n    return {\n      raw: { tokenId: params.tokenId, tokenInfo },\n      humanMessage: postProcess24(tokenInfo)\n    };\n  } catch (error) {\n    const desc = \"Failed to get token info\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_token_info_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_TOKEN_INFO_QUERY_TOOL = \"get_token_info_query_tool\";\nvar tool24 = (context) => ({\n  method: GET_TOKEN_INFO_QUERY_TOOL,\n  name: \"Get Token Info\",\n  description: getTokenInfoQueryPrompt(context),\n  parameters: tokenInfoQueryParameters(context),\n  execute: getTokenInfoQuery\n});\nvar get_token_info_query_default = tool24;\n\n// src/plugins/core-queries-plugin/index.ts\nvar coreQueriesPlugin = {\n  name: \"core-queries-plugin\",\n  version: \"1.0.0\",\n  description: \"A plugin for the Hedera Queries Service (DEPRECATED)\",\n  tools: (context) => {\n    return [\n      get_hbar_balance_query_default(context),\n      get_account_query_default(context),\n      get_account_token_balances_query_default(context),\n      get_topic_messages_query_default(context),\n      get_token_info_query_default(context)\n    ];\n  }\n};\nvar coreQueriesPluginToolNames = {\n  GET_HBAR_BALANCE_QUERY_TOOL,\n  GET_ACCOUNT_QUERY_TOOL,\n  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,\n  GET_TOPIC_MESSAGES_QUERY_TOOL,\n  GET_TOKEN_INFO_QUERY_TOOL\n};\n\n// src/shared/parameter-schemas/core-misc.zod.ts\n\nvar exchangeRateQueryParameters = (_context) => zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  timestamp: zod__WEBPACK_IMPORTED_MODULE_1__.string().describe(\"Historical timestamp to query (seconds or nanos since epoch)\").optional()\n});\n\n// src/plugins/core-misc-query-plugin/tools/queries/get-exchange-rate-query.ts\nvar getExchangeRatePrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool returns the Hedera network HBAR exchange rate from the Mirror Node.\n\nParameters:\n- timestamp (str, optional): Historical timestamp to query. Pass seconds or nanos since epoch (e.g., 1726000000.123456789). If omitted, returns the latest rate.\n${usageInstructions}\n`;\n};\nvar calculateUsdPerHBAR = (cent_equivalent, hbar_equivalent) => {\n  return cent_equivalent / 100 / hbar_equivalent;\n};\nvar postProcess25 = (rates) => {\n  const { current_rate, next_rate, timestamp } = rates;\n  const usdPerHBAR = calculateUsdPerHBAR(\n    current_rate.cent_equivalent,\n    current_rate.hbar_equivalent\n  );\n  const nextUsdPerHBAR = calculateUsdPerHBAR(next_rate.cent_equivalent, next_rate.hbar_equivalent);\n  return `\n  Details for timestamp: ${timestamp}\n  \n  Current exchange rate: ${usdPerHBAR}\n  Expires at ${new Date(current_rate.expiration_time * 1e3).toISOString()})\n  \n  Next exchange rate: ${nextUsdPerHBAR}\n  Expires at ${new Date(next_rate.expiration_time * 1e3).toISOString()})`;\n};\nvar getExchangeRateQuery = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const rates = await mirrornodeService.getExchangeRate(params.timestamp);\n    return {\n      raw: rates,\n      humanMessage: postProcess25(rates)\n    };\n  } catch (error) {\n    console.error(\"[GetExchangeRate] Error getting exchange rate\", error);\n    const message = error instanceof Error ? error.message : \"Failed to get exchange rate\";\n    return {\n      raw: { error: message },\n      humanMessage: message\n    };\n  }\n};\nvar GET_EXCHANGE_RATE_TOOL = \"get_exchange_rate_tool\";\nvar tool25 = (context) => ({\n  method: GET_EXCHANGE_RATE_TOOL,\n  name: \"Get Exchange Rate\",\n  description: getExchangeRatePrompt(context),\n  parameters: exchangeRateQueryParameters(context),\n  execute: getExchangeRateQuery\n});\nvar get_exchange_rate_query_default = tool25;\n\n// src/plugins/core-misc-query-plugin/index.ts\nvar coreMiscQueriesPlugin = {\n  name: \"core-misc-queries-plugin\",\n  version: \"1.0.0\",\n  description: \"A plugin for Hedera Misc Queries\",\n  tools: (context) => {\n    return [get_exchange_rate_query_default(context)];\n  }\n};\nvar coreMiscQueriesPluginsToolNames = {\n  GET_EXCHANGE_RATE_TOOL\n};\n\n// src/plugins/core-evm-plugin/tools/erc20/create-erc20.ts\n\n\n// src/shared/constants/contracts.ts\n\nvar TESTNET_ERC20_FACTORY_ADDRESS = \"0.0.6471814\";\nvar TESTNET_ERC721_FACTORY_ADDRESS = \"0.0.6510666\";\nvar ERC20_FACTORY_ADDRESSES = /* @__PURE__ */ new Map([\n  [_hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.LedgerId.TESTNET.toString(), TESTNET_ERC20_FACTORY_ADDRESS]\n  // Current testnet address\n]);\nvar ERC721_FACTORY_ADDRESSES = /* @__PURE__ */ new Map([\n  [_hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.LedgerId.TESTNET.toString(), TESTNET_ERC721_FACTORY_ADDRESS]\n  // Current testnet address\n]);\nvar ERC20_FACTORY_ABI = [\n  \"function deployToken(string memory name_, string memory symbol_, uint8 decimals_, uint256 initialSupply_) external returns (address)\"\n];\nvar ERC721_FACTORY_ABI = [\n  \"function deployToken(string memory name_, string memory symbol_, string memory baseURI_) external returns (address)\"\n];\nvar ERC20_TRANSFER_FUNCTION_NAME = \"transfer\";\nvar ERC20_TRANSFER_FUNCTION_ABI = [\n  \"function transfer(address to, uint256 amount) external returns (bool)\"\n];\nvar ERC721_TRANSFER_FUNCTION_NAME = \"transferFrom\";\nvar ERC721_TRANSFER_FUNCTION_ABI = [\n  \"function transferFrom(address from, address to, uint256 tokenId) external returns (bool)\"\n];\nvar ERC721_MINT_FUNCTION_NAME = \"safeMint\";\nvar ERC721_MINT_FUNCTION_ABI = [\"function safeMint(address to) external returns (bool)\"];\nfunction getERC20FactoryAddress(ledgerId) {\n  const address = ERC20_FACTORY_ADDRESSES.get(ledgerId.toString());\n  if (!address) {\n    throw new Error(`Network type ${ledgerId} not supported for ERC20 factory`);\n  }\n  return address;\n}\nfunction getERC721FactoryAddress(ledgerId) {\n  const address = ERC721_FACTORY_ADDRESSES.get(ledgerId.toString());\n  if (!address) {\n    throw new Error(`Network type ${ledgerId} not supported for ERC721 factory`);\n  }\n  return address;\n}\n\n// src/plugins/core-evm-plugin/tools/erc20/create-erc20.ts\nvar createERC20Prompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool creates an ERC20 token on Hedera by calling the BaseERC20Factory contract.\n\nParameters:\n- tokenName (str, required): The name of the token\n- tokenSymbol (str, required): The symbol of the token\n- decimals (int, optional): The number of decimals the token supports. Defaults to 18\n- initialSupply (int, optional): The initial supply of the token. Defaults to 0\n${usageInstructions}\n`;\n};\nvar getERC20Address = async (client, executeStrategyResult) => {\n  const record = await new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TransactionRecordQuery().setTransactionId(executeStrategyResult.raw.transactionId).execute(client);\n  return \"0x\" + record.contractFunctionResult?.getAddress(0);\n};\nvar createERC20 = async (client, context, params) => {\n  try {\n    const factoryContractAddress = getERC20FactoryAddress(client.ledgerId);\n    const normalisedParams = HederaParameterNormaliser.normaliseCreateERC20Params(\n      params,\n      factoryContractAddress,\n      ERC20_FACTORY_ABI,\n      \"deployToken\",\n      context\n    );\n    const tx = HederaBuilder.executeTransaction(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    if (context.mode == \"autonomous\" /* AUTONOMOUS */) {\n      const erc20Address = await getERC20Address(client, result);\n      return {\n        ...result,\n        erc20Address: erc20Address?.toString(),\n        humanMessage: `ERC20 token created successfully at address ${erc20Address?.toString()}`\n      };\n    }\n    return result;\n  } catch (error) {\n    const desc = \"Failed to create ERC20 token\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[create_erc20_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar CREATE_ERC20_TOOL = \"create_erc20_tool\";\nvar tool26 = (context) => ({\n  method: CREATE_ERC20_TOOL,\n  name: \"Create ERC20 Token\",\n  description: createERC20Prompt(context),\n  parameters: createERC20Parameters(context),\n  execute: createERC20\n});\nvar create_erc20_default = tool26;\n\n// src/plugins/core-evm-plugin/tools/erc20/transfer-erc20.ts\n\nvar transferERC20Prompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will transfer a given amount of an existing ERC20 token on Hedera.\n\nParameters:\n- contractId (str, required): The id of the ERC20 contract. This can be the EVM address or the Hedera account id.\n- recipientAddress (str, required): The EVM or Hedera address to which the tokens will be transferred. This can be the EVM address or the Hedera account id.\n- amount (number, required): The amount to be transferred\n${usageInstructions}\n\nExample: \"Transfer 1 ERC20 token 0.0.6473135 to 0xd94dc7f82f103757f715514e4a37186be6e4580b\" means transferring the amount of 1 of the ERC20 token with contract id 0.0.6473135 to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.\nExample: \"Transfer 1 ERC20 token 0xd94dc7f82f103757f715514e4a37186be6e4580b to 0.0.6473135\" means transferring the amount of 1 of the ERC20 token with contract id 0xd94dc7f82f103757f715514e4a37186be6e4580b to the 0.0.6473135 Hedera account id.\n`;\n};\nvar transferERC20 = async (client, context, params) => {\n  const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n  try {\n    const normalisedParams = await HederaParameterNormaliser.normaliseTransferERC20Params(\n      params,\n      ERC20_TRANSFER_FUNCTION_ABI,\n      ERC20_TRANSFER_FUNCTION_NAME,\n      context,\n      mirrorNode\n    );\n    const tx = HederaBuilder.executeTransaction(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to transfer ERC20\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[transfer_erc20_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar TRANSFER_ERC20_TOOL = \"transfer_erc20_tool\";\nvar tool27 = (context) => ({\n  method: TRANSFER_ERC20_TOOL,\n  name: \"Transfer ERC20\",\n  description: transferERC20Prompt(context),\n  parameters: transferERC20Parameters(context),\n  execute: transferERC20\n});\nvar transfer_erc20_default = tool27;\n\n// src/plugins/core-evm-plugin/tools/erc721/transfer-erc721.ts\n\nvar transferERC721Prompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const fromAddressDesc = PromptGenerator.getAnyAddressParameterDescription(\"fromAddress\", context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will transfer an existing ERC721 token on Hedera.\n\nParameters:\n- contractId (str, required): The id of the ERC721 contract\n- ${fromAddressDesc}\n- toAddress (str, required): The address to which the token will be transferred. This can be the EVM address or the Hedera account id.\n- tokenId (number, required): The ID of the transfered token\n${usageInstructions}\n\nExample: \"Transfer ERC721 token 0.0.6486793 with id 0 from 0xd94dc7f82f103757f715514e4a37186be6e4580b to 0xd94dc7f82f103757f715514e4a37186be6e4580b\" means transfering the ERC721 token (identified by 0) with contract id 0.0.6486793 from the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.\nExample: \"Transfer ERC721 token 0.0.6486793 with id 0 from 0.0.6486793 to 0xd94dc7f82f103757f715514e4a37186be6e4580b\" means transfering the ERC721 token (identified by 0) with contract id 0.0.6486793 from the 0.0.6486793 Hedera account id to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.\n`;\n};\nvar transferERC721 = async (client, context, params) => {\n  try {\n    const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const normalisedParams = await HederaParameterNormaliser.normaliseTransferERC721Params(\n      params,\n      ERC721_TRANSFER_FUNCTION_ABI,\n      ERC721_TRANSFER_FUNCTION_NAME,\n      context,\n      mirrorNode,\n      client\n    );\n    const tx = HederaBuilder.executeTransaction(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to transfer ERC721\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[transfer_erc721_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar TRANSFER_ERC721_TOOL = \"transfer_erc721_tool\";\nvar tool28 = (context) => ({\n  method: TRANSFER_ERC721_TOOL,\n  name: \"Transfer ERC721\",\n  description: transferERC721Prompt(context),\n  parameters: transferERC721Parameters(context),\n  execute: transferERC721\n});\nvar transfer_erc721_default = tool28;\n\n// src/plugins/core-evm-plugin/tools/erc721/mint-erc721.ts\n\nvar mintERC721Prompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  const toAddressDesc = PromptGenerator.getAnyAddressParameterDescription(\"toAddress\", context);\n  return `\n${contextSnippet}\n\nThis tool will mint a new ERC721 token on Hedera.\n\nParameters:\n- contractId (str, required): The id of the ERC721 contract\n- ${toAddressDesc}\n${usageInstructions}\n\nExample: \"Mint ERC721 token 0.0.6486793 to 0xd94dc7f82f103757f715514e4a37186be6e4580b\" means minting the ERC721 token with contract id 0.0.6486793 to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.\nExample: \"Mint ERC721 token 0.0.6486793 to 0.0.6486793\" means minting the ERC721 token with contract id 0.0.6486793 to the 0.0.6486793 Hedera account id.\n`;\n};\nvar mintERC721 = async (client, context, params) => {\n  try {\n    const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const normalisedParams = await HederaParameterNormaliser.normaliseMintERC721Params(\n      params,\n      ERC721_MINT_FUNCTION_ABI,\n      ERC721_MINT_FUNCTION_NAME,\n      context,\n      mirrorNode,\n      client\n    );\n    const tx = HederaBuilder.executeTransaction(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    return result;\n  } catch (error) {\n    const desc = \"Failed to mint ERC721\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[mint_erc721_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar MINT_ERC721_TOOL = \"mint_erc721_tool\";\nvar tool29 = (context) => ({\n  method: MINT_ERC721_TOOL,\n  name: \"Mint ERC721\",\n  description: mintERC721Prompt(context),\n  parameters: mintERC721Parameters(context),\n  execute: mintERC721\n});\nvar mint_erc721_default = tool29;\n\n// src/plugins/core-evm-plugin/tools/erc721/create-erc721.ts\n\nvar createERC721Prompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool creates an ERC721 token on Hedera by calling the BaseERC721Factory contract.\n\nParameters:\n- tokenName (str, required): The name of the token\n- tokenSymbol (str, required): The symbol of the token\n- baseURI (str, required): The base URI for token metadata.\n${usageInstructions}\n\nThe contractId returned by the tool is the address of the ERC721 Factory contract, the address of the ERC721 token is the erc721Address returned by the tool.\n`;\n};\nvar getERC721Address = async (client, executeStrategyResult) => {\n  const record = await new _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.TransactionRecordQuery().setTransactionId(executeStrategyResult.raw.transactionId).execute(client);\n  return \"0x\" + record.contractFunctionResult?.getAddress(0);\n};\nvar createERC721 = async (client, context, params) => {\n  try {\n    const factoryContractAddress = getERC721FactoryAddress(client.ledgerId);\n    const normalisedParams = HederaParameterNormaliser.normaliseCreateERC721Params(\n      params,\n      factoryContractAddress,\n      ERC721_FACTORY_ABI,\n      \"deployToken\",\n      context\n    );\n    const tx = HederaBuilder.executeTransaction(normalisedParams);\n    const result = await handleTransaction(tx, client, context);\n    if (context.mode == \"autonomous\" /* AUTONOMOUS */) {\n      const erc721Address = await getERC721Address(client, result);\n      return {\n        ...result,\n        erc721Address: erc721Address?.toString(),\n        message: `ERC721 token created successfully at address ${erc721Address?.toString()}`\n      };\n    }\n    return result;\n  } catch (error) {\n    const desc = \"Failed to create ERC721 token\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[create_erc721_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar CREATE_ERC721_TOOL = \"create_erc721_tool\";\nvar tool30 = (context) => ({\n  method: CREATE_ERC721_TOOL,\n  name: \"Create ERC721 Token\",\n  description: createERC721Prompt(context),\n  parameters: createERC721Parameters(context),\n  execute: createERC721\n});\nvar create_erc721_default = tool30;\n\n// src/plugins/core-evm-plugin/index.ts\nvar coreEVMPlugin = {\n  name: \"core-evm-plugin\",\n  version: \"1.0.0\",\n  description: \"A plugin for the Hedera EVM\",\n  tools: (context) => {\n    return [\n      create_erc20_default(context),\n      transfer_erc20_default(context),\n      transfer_erc721_default(context),\n      mint_erc721_default(context),\n      create_erc721_default(context)\n    ];\n  }\n};\nvar coreEVMPluginToolNames = {\n  TRANSFER_ERC721_TOOL,\n  MINT_ERC721_TOOL,\n  CREATE_ERC20_TOOL,\n  TRANSFER_ERC20_TOOL,\n  CREATE_ERC721_TOOL\n};\n\n// src/plugins/core-account-query-plugin/tools/queries/get-hbar-balance-query.ts\nvar getHbarBalanceQueryPrompt2 = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription(\"accountId\", context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the HBAR balance for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n${usageInstructions}\n`;\n};\nvar postProcess26 = (hbarBalance, accountId) => {\n  return `Account ${accountId} has a balance of ${hbarBalance} HBAR`;\n};\nvar getHbarBalanceQuery2 = async (client, context, params) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseHbarBalanceParams(\n      params,\n      context,\n      client\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const balance = await mirrornodeService.getAccountHBarBalance(\n      normalisedParams.accountId\n    );\n    return {\n      raw: { accountId: normalisedParams.accountId, hbarBalance: toHBar(balance).toString() },\n      humanMessage: postProcess26(toHBar(balance).toString(), normalisedParams.accountId)\n    };\n  } catch (error) {\n    const desc = \"Failed to get HBAR balance\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_hbar_balance_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_HBAR_BALANCE_QUERY_TOOL2 = \"get_hbar_balance_query_tool\";\nvar tool31 = (context) => ({\n  method: GET_HBAR_BALANCE_QUERY_TOOL2,\n  name: \"Get HBAR Balance\",\n  description: getHbarBalanceQueryPrompt2(context),\n  parameters: accountBalanceQueryParameters(context),\n  execute: getHbarBalanceQuery2\n});\nvar get_hbar_balance_query_default2 = tool31;\n\n// src/plugins/core-account-query-plugin/tools/queries/get-account-query.ts\n\nvar getAccountQueryPrompt2 = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the account information for a given Hedera account.\n\nParameters:\n- accountId (str, required): The account ID to query\n${usageInstructions}\n`;\n};\nvar postProcess27 = (account) => {\n  return `Details for ${account.accountId}\nBalance: ${account.balance.balance.toString()}\nPublic Key: ${account.accountPublicKey},\nEVM address: ${account.evmAddress},\n`;\n};\nvar getAccountQuery2 = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const account = await mirrornodeService.getAccount(params.accountId);\n    return {\n      raw: { accountId: params.accountId, account },\n      humanMessage: postProcess27(account)\n    };\n  } catch (error) {\n    const desc = \"Failed to get account query\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_account_query_tool]\", message);\n    return { raw: { status: _hashgraph_sdk__WEBPACK_IMPORTED_MODULE_0__.Status.InvalidTransaction, error: message }, humanMessage: message };\n  }\n};\nvar GET_ACCOUNT_QUERY_TOOL2 = \"get_account_query_tool\";\nvar tool32 = (context) => ({\n  method: GET_ACCOUNT_QUERY_TOOL2,\n  name: \"Get Account Query\",\n  description: getAccountQueryPrompt2(context),\n  parameters: accountQueryParameters(context),\n  execute: getAccountQuery2\n});\nvar get_account_query_default2 = tool32;\n\n// src/plugins/core-account-query-plugin/tools/queries/get-account-token-balances-query.ts\nvar getAccountTokenBalancesQueryPrompt2 = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription(\"accountId\", context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the token balances for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n- tokenId (str, optional): The token ID to query for. If not provided, all token balances will be returned\n${usageInstructions}\n`;\n};\nvar postProcess28 = (tokenBalances, accountId) => {\n  if (tokenBalances.tokens.length === 0) {\n    return `No token balances found for account ${accountId}`;\n  }\n  const balancesText = tokenBalances.tokens.map(\n    (token) => `  Token: ${token.token_id}, Balance: ${token.balance}, Decimals: ${token.decimals}`\n  ).join(\"\\n\");\n  return `Details for ${accountId}\n--- Token Balances ---\n${balancesText}`;\n};\nvar getAccountTokenBalancesQuery2 = async (client, context, params) => {\n  try {\n    const normalisedParams = HederaParameterNormaliser.normaliseAccountTokenBalancesParams(\n      params,\n      context,\n      client\n    );\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const tokenBalances = await mirrornodeService.getAccountTokenBalances(\n      normalisedParams.accountId,\n      normalisedParams.tokenId\n    );\n    return {\n      raw: { accountId: normalisedParams.accountId, tokenBalances },\n      humanMessage: postProcess28(tokenBalances, normalisedParams.accountId)\n    };\n  } catch (error) {\n    const desc = \"Failed to get account token balances\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_account_token_balances_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL2 = \"get_account_token_balances_query_tool\";\nvar tool33 = (context) => ({\n  method: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL2,\n  name: \"Get Account Token Balances\",\n  description: getAccountTokenBalancesQueryPrompt2(context),\n  parameters: accountTokenBalancesQueryParameters(context),\n  execute: getAccountTokenBalancesQuery2\n});\nvar get_account_token_balances_query_default2 = tool33;\n\n// src/plugins/core-account-query-plugin/index.ts\nvar coreAccountQueryPlugin = {\n  name: \"core-account-query-plugin\",\n  version: \"1.0.0\",\n  description: \"A plugin for Hedera Account Service queries\",\n  tools: (context) => {\n    return [\n      get_hbar_balance_query_default2(context),\n      get_account_query_default2(context),\n      get_account_token_balances_query_default2(context)\n    ];\n  }\n};\nvar coreAccountQueryPluginToolNames = {\n  GET_HBAR_BALANCE_QUERY_TOOL: GET_HBAR_BALANCE_QUERY_TOOL2,\n  GET_ACCOUNT_QUERY_TOOL: GET_ACCOUNT_QUERY_TOOL2,\n  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL2\n};\n\n// src/plugins/core-token-query-plugin/tools/queries/get-token-info-query.ts\nvar getTokenInfoQueryPrompt2 = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the information for a given Hedera token.\n\nParameters:\n- tokenId (str): The token ID to query for.\n${usageInstructions}\n`;\n};\nvar postProcess29 = (tokenInfo) => {\n  const formatSupply = (supply) => {\n    if (!supply) return \"N/A\";\n    const decimals = Number(tokenInfo.decimals || \"0\");\n    const amount = Number(supply);\n    if (isNaN(amount)) return supply;\n    return (amount / 10 ** decimals).toLocaleString();\n  };\n  const formatKey = (key) => {\n    if (!key) return \"Not Set\";\n    return key._type ? `${key.key}` : \"Present\";\n  };\n  const supplyType = tokenInfo.supply_type === \"INFINITE\" ? \"Infinite\" : \"Finite\";\n  const freezeStatus = tokenInfo.freeze_default ? \"Frozen\" : \"Active\";\n  return `Here are the details for token **${tokenInfo.token_id}**:\n\n- **Token Name**: ${tokenInfo.name}\n- **Token Symbol**: ${tokenInfo.symbol}\n- **Token Type**: ${tokenInfo.type || \"N/A\"}\n- **Decimals**: ${tokenInfo.decimals}\n- **Max Supply**: ${formatSupply(tokenInfo.max_supply)}\n- **Current Supply**: ${formatSupply(tokenInfo.total_supply)}\n- **Supply Type**: ${supplyType}\n- **Treasury Account ID**: ${tokenInfo.treasury_account_id || \"N/A\"}\n- **Status (Deleted/Active)**: ${tokenInfo.deleted ? \"Deleted\" : \"Active\"}\n- **Status (Frozen/Active)**: ${freezeStatus}\n\n**Keys**:\n- Admin Key: ${formatKey(tokenInfo.admin_key)}\n- Supply Key: ${formatKey(tokenInfo.supply_key)}\n- Wipe Key: ${formatKey(tokenInfo.wipe_key)}\n- KYC Key: ${formatKey(tokenInfo.kyc_key)}\n- Freeze Key: ${formatKey(tokenInfo.freeze_key)}\n- Fee Schedule Key: ${formatKey(tokenInfo.fee_schedule_key)}\n- Pause Key: ${formatKey(tokenInfo.pause_key)}\n- Metadata Key: ${formatKey(tokenInfo.metadata_key)}\n\n${tokenInfo.memo ? `**Memo**: ${tokenInfo.memo}` : \"\"}\n`;\n};\nvar getTokenInfoQuery2 = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const tokenInfo = {\n      ...await mirrornodeService.getTokenInfo(params.tokenId),\n      token_id: params.tokenId\n    };\n    return {\n      raw: { tokenId: params.tokenId, tokenInfo },\n      humanMessage: postProcess29(tokenInfo)\n    };\n  } catch (error) {\n    const desc = \"Failed to get token info\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_token_info_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_TOKEN_INFO_QUERY_TOOL2 = \"get_token_info_query_tool\";\nvar tool34 = (context) => ({\n  method: GET_TOKEN_INFO_QUERY_TOOL2,\n  name: \"Get Token Info\",\n  description: getTokenInfoQueryPrompt2(context),\n  parameters: tokenInfoQueryParameters(context),\n  execute: getTokenInfoQuery2\n});\nvar get_token_info_query_default2 = tool34;\n\n// src/plugins/core-token-query-plugin/tools/queries/get-pending-airdrop-query.ts\nvar getPendingAirdropQueryPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const accountDesc = PromptGenerator.getAccountParameterDescription(\"accountId\", context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return pending airdrops for a given Hedera account.\n\nParameters:\n- ${accountDesc}\n${usageInstructions}\n`;\n};\nvar formatAirdrop = (airdrop, index) => {\n  const token = airdrop.token_id ?? \"N/A\";\n  const amount = airdrop.amount ?? 0;\n  const serial = airdrop.serial_number ?? \"N/A\";\n  const sender = airdrop.sender_id ?? \"N/A\";\n  const receiver = airdrop.receiver_id ?? \"N/A\";\n  const fromTs = airdrop.timestamp?.from ?? \"N/A\";\n  const toTs = airdrop.timestamp?.to ?? \"N/A\";\n  return `#${index + 1} Token: ${token}, Amount: ${amount}, Serial: ${serial}, Sender: ${sender}, Receiver: ${receiver}, Timestamp: ${fromTs}${toTs ? ` \\u2192 ${toTs}` : \"\"}`;\n};\nvar postProcess30 = (accountId, response) => {\n  const count = response.airdrops?.length ?? 0;\n  if (count === 0) {\n    return `No pending airdrops found for account ${accountId}`;\n  }\n  const details = response.airdrops.map(formatAirdrop).join(\"\\n\");\n  return `Here are the pending airdrops for account **${accountId}** (total: ${count}):\n\n${details}`;\n};\nvar getPendingAirdropQuery = async (client, context, params) => {\n  try {\n    const accountId = params.accountId ?? AccountResolver.getDefaultAccount(context, client);\n    if (!accountId) throw new Error(\"Account ID is required and was not provided\");\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const response = await mirrornodeService.getPendingAirdrops(accountId);\n    return {\n      raw: { accountId, pendingAirdrops: response },\n      humanMessage: postProcess30(accountId, response)\n    };\n  } catch (error) {\n    const desc = \"Failed to get pending airdrops\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_pending_airdrop_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_PENDING_AIRDROP_TOOL = \"get_pending_airdrop_tool\";\nvar tool35 = (context) => ({\n  method: GET_PENDING_AIRDROP_TOOL,\n  name: \"Get Pending Airdrops\",\n  description: getPendingAirdropQueryPrompt(context),\n  parameters: pendingAirdropQueryParameters(context),\n  execute: getPendingAirdropQuery\n});\nvar get_pending_airdrop_query_default = tool35;\n\n// src/plugins/core-token-query-plugin/index.ts\nvar coreTokenQueryPlugin = {\n  name: \"core-token-query-plugin\",\n  version: \"1.0.0\",\n  description: \"A plugin for Hedera Token Service queries\",\n  tools: (context) => {\n    return [get_token_info_query_default2(context), get_pending_airdrop_query_default(context)];\n  }\n};\nvar coreTokenQueryPluginToolNames = {\n  GET_TOKEN_INFO_QUERY_TOOL: GET_TOKEN_INFO_QUERY_TOOL2,\n  GET_PENDING_AIRDROP_TOOL\n};\n\n// src/plugins/core-consensus-query-plugin/tools/queries/get-topic-messages-query.ts\nvar getTopicMessagesQueryPrompt2 = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the messages for a given Hedera topic.\n\nParameters:\n- topicId (str, required): The topic ID to query\n- startTime (datetime, optional): The start datetime to query. If set, the messages will be returned after this datetime\n- endTime (datetime, optional): The end datetime to query. If set, the messages will be returned before this datetime\n- limit (int, optional): The limit of messages to query. If set, the number of messages to return\n${usageInstructions}\n`;\n};\nvar postProcess31 = (messages, topicId) => {\n  if (messages.length === 0) {\n    return `No messages found for topic ${topicId}.`;\n  }\n  const messagesText = messages.map(\n    (message) => `${Buffer.from(message.message, \"base64\").toString(\"utf-8\")} - posted at: ${message.consensus_timestamp}\n`\n  );\n  return `Messages for topic ${topicId}:\n  --- Messages ---\n  ${messagesText}\n  `;\n};\nvar getTopicMessagesQueryParams2 = (params) => {\n  return {\n    topicId: params.topicId,\n    lowerTimestamp: params.startTime ? `${Math.floor(new Date(params.startTime).getTime() / 1e3)}.000000000` : \"\",\n    upperTimestamp: params.endTime ? `${Math.floor(new Date(params.endTime).getTime() / 1e3)}.000000000` : \"\",\n    limit: params.limit || 100\n  };\n};\nvar convertMessagesFromBase64ToString2 = (messages) => {\n  return messages.map((message) => {\n    return {\n      ...message,\n      message: Buffer.from(message.message, \"base64\").toString(\"utf-8\")\n    };\n  });\n};\nvar getTopicMessagesQuery2 = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const messages = await mirrornodeService.getTopicMessages(getTopicMessagesQueryParams2(params));\n    return {\n      raw: {\n        topicId: messages.topicId,\n        messages: convertMessagesFromBase64ToString2(messages.messages)\n      },\n      humanMessage: postProcess31(messages.messages, params.topicId)\n    };\n  } catch (error) {\n    const desc = \"Failed to get topic messages\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_topic_messages_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_TOPIC_MESSAGES_QUERY_TOOL2 = \"get_topic_messages_query_tool\";\nvar tool36 = (context) => ({\n  method: GET_TOPIC_MESSAGES_QUERY_TOOL2,\n  name: \"Get Topic Messages\",\n  description: getTopicMessagesQueryPrompt2(context),\n  parameters: topicMessagesQueryParameters(context),\n  execute: getTopicMessagesQuery2\n});\nvar get_topic_messages_query_default2 = tool36;\n\n// src/plugins/core-consensus-query-plugin/tools/queries/get-topic-info-query.ts\nvar getTopicInfoQueryPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the information for a given Hedera topic (HCS).\n\nParameters:\n- topicId (str): The topic ID to query for.\n${usageInstructions}\n`;\n};\nvar postProcess32 = (topic) => {\n  const formatKey = (key) => {\n    if (!key) return \"Not Set\";\n    return key._type ? key.key || \"Present\" : \"Present\";\n  };\n  const formatTimestamp = (ts) => {\n    if (!ts) return \"N/A\";\n    const [seconds] = ts.split(\".\");\n    const date = new Date(Number(seconds) * 1e3);\n    return date.toISOString();\n  };\n  return `Here are the details for topic **${topic.topic_id || \"N/A\"}**:\n\n- **Memo**: ${topic.memo || \"N/A\"}\n- **Deleted**: ${topic.deleted ? \"Yes\" : \"No\"}\n- **Sequence Number**: ${topic.sequence_number ?? \"N/A\"}\n\n**Timestamps**:\n- Created: ${formatTimestamp(topic.created_timestamp)}\n\n**Entity IDs**:\n- Auto Renew Account: ${topic.auto_renew_account || \"N/A\"}\n- Auto Renew Period: ${topic.auto_renew_period ?? \"N/A\"}\n\n**Keys**:\n- Admin Key: ${formatKey(topic.admin_key)}\n- Submit Key: ${formatKey(topic.submit_key)}\n`;\n};\nvar getTopicInfoQuery = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const topicInfo = {\n      ...await mirrornodeService.getTopicInfo(params.topicId),\n      topic_id: params.topicId\n    };\n    return {\n      raw: { topicId: params.topicId, topicInfo },\n      humanMessage: postProcess32(topicInfo)\n    };\n  } catch (error) {\n    const desc = \"Failed to get topic info\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_topic_info_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_TOPIC_INFO_QUERY_TOOL = \"get_topic_info_query_tool\";\nvar tool37 = (context) => ({\n  method: GET_TOPIC_INFO_QUERY_TOOL,\n  name: \"Get Topic Info\",\n  description: getTopicInfoQueryPrompt(context),\n  parameters: getTopicInfoParameters(context),\n  execute: getTopicInfoQuery\n});\nvar get_topic_info_query_default = tool37;\n\n// src/plugins/core-consensus-query-plugin/index.ts\nvar coreConsensusQueryPlugin = {\n  name: \"core-consensus-query-plugin\",\n  version: \"1.0.0\",\n  description: \"A plugin for Hedera Consensus Service queries\",\n  tools: (context) => {\n    return [get_topic_messages_query_default2(context), get_topic_info_query_default(context)];\n  }\n};\nvar coreConsensusQueryPluginToolNames = {\n  GET_TOPIC_MESSAGES_QUERY_TOOL: GET_TOPIC_MESSAGES_QUERY_TOOL2,\n  GET_TOPIC_INFO_QUERY_TOOL\n};\n\n// src/plugins/core-evm-query-plugin/tools/queries/get-contract-info-query.ts\nvar getContractInfoQueryPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the information for a given Hedera contract.\n\nParameters:\n- contractId (str): The contract ID to query for.\n${usageInstructions}\n`;\n};\nvar postProcess33 = (contract) => {\n  const formatKey = (key) => {\n    if (!key) return \"Not Set\";\n    return key._type ? key.key || \"Present\" : \"Present\";\n  };\n  const formatTimestamp = (ts) => {\n    if (!ts) return \"N/A\";\n    const [seconds, nanos] = ts.split(\".\");\n    const date = new Date(Number(seconds) * 1e3);\n    return date.toISOString() + (nanos ? `.${nanos}` : \"\");\n  };\n  return `Here are the details for contract **${contract.contract_id || \"N/A\"}**:\n\n- **Memo**: ${contract.memo || \"N/A\"}\n- **Deleted**: ${contract.deleted ? \"Yes\" : \"No\"}\n- **Permanent Removal**: ${contract.permanent_removal ? \"Yes\" : \"No\"}\n- **Nonce**: ${contract.nonce ?? \"N/A\"}\n\n**Timestamps**:\n- Created: ${formatTimestamp(contract.created_timestamp)}\n- Expiration: ${formatTimestamp(contract.expiration_timestamp)}\n- Valid From: ${contract.timestamp?.from || \"N/A\"}\n- Valid To: ${contract.timestamp?.to || \"N/A\"}\n\n**Entity IDs**:\n- Auto Renew Account: ${contract.auto_renew_account || \"N/A\"}\n- File ID: ${contract.file_id || \"N/A\"}\n- Obtainer ID: ${contract.obtainer_id || \"N/A\"}\n- Proxy Account ID: ${contract.proxy_account_id || \"N/A\"}\n\n**Keys**:\n- Admin Key: ${formatKey(contract.admin_key)}\n\n**EVM**:\n- Address: ${contract.evm_address || \"N/A\"}\n`;\n};\nvar getContractInfoQuery = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const contractInfo = await mirrornodeService.getContractInfo(params.contractId);\n    return {\n      raw: { contractId: params.contractId, contractInfo },\n      humanMessage: postProcess33(contractInfo)\n    };\n  } catch (error) {\n    const desc = \"Failed to get contract info\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_contract_info_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_CONTRACT_INFO_QUERY_TOOL = \"get_contract_info_query_tool\";\nvar tool38 = (context) => ({\n  method: GET_CONTRACT_INFO_QUERY_TOOL,\n  name: \"Get Contract Info\",\n  description: getContractInfoQueryPrompt(context),\n  parameters: contractInfoQueryParameters(context),\n  execute: getContractInfoQuery\n});\nvar get_contract_info_query_default = tool38;\n\n// src/plugins/core-evm-query-plugin/index.ts\nvar coreEVMQueryPlugin = {\n  name: \"core-evm-query-plugin\",\n  version: \"1.0.0\",\n  description: \"A plugin for Hedera EVM Service queries\",\n  tools: (context) => {\n    return [get_contract_info_query_default(context)];\n  }\n};\nvar coreEVMQueryPluginToolNames = {\n  GET_CONTRACT_INFO_QUERY_TOOL\n};\n\n// src/plugins/core-transactions-query-plugin/tools/queries/get-transaction-record-query.ts\nvar getTransactionRecordQueryPrompt = (context = {}) => {\n  const contextSnippet = PromptGenerator.getContextSnippet(context);\n  const usageInstructions = PromptGenerator.getParameterUsageInstructions();\n  return `\n${contextSnippet}\n\nThis tool will return the transaction record for a given Hedera transaction ID.\n\nParameters:\n- transactionId (str, required): The transaction ID to fetch record for. Should be in format \\\\\"shard.realm.num-sss-nnn\\\\\" format where sss are seconds and nnn are nanoseconds\n- nonce (number, optional): Optional nonce value for the transaction\n${usageInstructions}\n\nAdditional information:\nIf user provides transaction ID in format 0.0.4177806@1755169980.051721264, parse it to 0.0.4177806-1755169980-051721264 and use it as transaction ID. Do not remove the staring zeros.\n`;\n};\nvar postProcess34 = (transactionRecord, transactionId) => {\n  if (!transactionRecord.transactions || transactionRecord.transactions.length === 0) {\n    return `No transaction details found for transaction ID: ${transactionId}`;\n  }\n  const results = transactionRecord.transactions.map((tx, index) => {\n    let transfersInfo = \"\";\n    if (tx.transfers && tx.transfers.length > 0) {\n      transfersInfo = \"\\nTransfers:\\n\" + tx.transfers.map(\n        (transfer) => `  Account: ${transfer.account}, Amount: ${toDisplayUnit(transfer.amount, 8)}\\u210F`\n      ).join(\"\\n\");\n    }\n    const transactionHeader = transactionRecord.transactions.length > 1 ? `Transaction ${index + 1} Details for ${transactionId}` : `Transaction Details for ${transactionId}`;\n    return `${transactionHeader}\nStatus: ${tx.result}\nConsensus Timestamp: ${tx.consensus_timestamp}\nTransaction Hash: ${tx.transaction_hash}\nTransaction Fee: ${tx.charged_tx_fee}\nType: ${tx.name}\nEntity ID: ${tx.entity_id}${transfersInfo}`;\n  });\n  return results.join(\"\\n\\n\" + \"=\".repeat(50) + \"\\n\\n\");\n};\nvar getTransactionRecordQuery = async (client, context, params) => {\n  try {\n    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);\n    const normalisedParams = HederaParameterNormaliser.normaliseGetTransactionRecordParams(\n      params,\n      context\n    );\n    const transactionRecord = await mirrornodeService.getTransactionRecord(\n      normalisedParams.transactionId,\n      normalisedParams.nonce\n    );\n    return {\n      raw: { transactionId: params.transactionId, transactionRecord },\n      humanMessage: postProcess34(transactionRecord, params.transactionId)\n    };\n  } catch (error) {\n    const desc = \"Failed to get transaction record\";\n    const message = desc + (error instanceof Error ? `: ${error.message}` : \"\");\n    console.error(\"[get_transaction_record_query_tool]\", message);\n    return { raw: { error: message }, humanMessage: message };\n  }\n};\nvar GET_TRANSACTION_RECORD_QUERY_TOOL = \"get_transaction_record_query_tool\";\nvar tool39 = (context) => ({\n  method: GET_TRANSACTION_RECORD_QUERY_TOOL,\n  name: \"Get Transaction Record Query\",\n  description: getTransactionRecordQueryPrompt(context),\n  parameters: transactionRecordQueryParameters(context),\n  execute: getTransactionRecordQuery\n});\nvar get_transaction_record_query_default = tool39;\n\n// src/plugins/core-transactions-query-plugin/index.ts\nvar coreTransactionQueryPlugin = {\n  name: \"core-transaction-query-plugin\",\n  version: \"1.0.0\",\n  description: \"A plugin for Hedera Transactions queries\",\n  tools: (context) => {\n    return [get_transaction_record_query_default(context)];\n  }\n};\nvar coreTransactionQueryPluginToolNames = {\n  GET_TRANSACTION_RECORD_QUERY_TOOL\n};\n\n// src/plugins/index.ts\nvar coreHTSPlugin = coreTokenPlugin;\nvar coreHTSPluginToolNames = coreTokenPluginToolNames;\nvar coreSCSPlugin = coreEVMPlugin;\nvar coreSCSPluginToolNames = coreEVMPluginToolNames;\n\n// src/shared/plugin.ts\nvar CORE_PLUGINS = [\n  coreAccountPlugin,\n  coreTokenPlugin,\n  coreConsensusPlugin,\n  coreEVMPlugin,\n  coreAccountQueryPlugin,\n  coreTokenQueryPlugin,\n  coreConsensusQueryPlugin\n];\nvar PluginRegistry = class {\n  plugins = /* @__PURE__ */ new Map();\n  register(plugin) {\n    if (this.plugins.has(plugin.name)) {\n      console.warn(`Plugin \"${plugin.name}\" is already registered. Overwriting.`);\n    }\n    this.plugins.set(plugin.name, plugin);\n  }\n  getPlugins() {\n    return Array.from(this.plugins.values());\n  }\n  loadCorePlugins(context) {\n    const pluginTools = [];\n    for (const plugin of CORE_PLUGINS) {\n      try {\n        const tools = plugin.tools(context);\n        pluginTools.push(...tools);\n      } catch (error) {\n        console.error(`Error loading tools from plugin \"${plugin.name}\":`, error);\n      }\n    }\n    return pluginTools;\n  }\n  loadPlugins(context) {\n    const pluginTools = [];\n    for (const plugin of this.plugins.values()) {\n      try {\n        const tools = plugin.tools(context);\n        pluginTools.push(...tools);\n      } catch (error) {\n        console.error(`Error loading tools from plugin \"${plugin.name}\":`, error);\n      }\n    }\n    return pluginTools;\n  }\n  getTools(context) {\n    if (this.plugins.size === 0) {\n      return this.loadCorePlugins(context);\n    } else {\n      return this.loadPlugins(context);\n    }\n  }\n  clear() {\n    this.plugins.clear();\n  }\n};\n\n// src/langchain/tool.ts\n\nvar HederaAgentKitTool = class extends _langchain_core_tools__WEBPACK_IMPORTED_MODULE_7__.StructuredTool {\n  hederaAPI;\n  method;\n  name;\n  description;\n  schema;\n  constructor(HederaAgentKitAPI, method, description, schema) {\n    super();\n    this.hederaAPI = HederaAgentKitAPI;\n    this.method = method;\n    this.name = method;\n    this.description = description;\n    this.schema = schema;\n  }\n  _call(arg, _runManager, _parentConfig) {\n    return this.hederaAPI.run(this.method, arg);\n  }\n};\nvar tool_default = HederaAgentKitTool;\n\n// src/shared/tool-discovery.ts\nvar ToolDiscovery = class _ToolDiscovery {\n  pluginRegistry = new PluginRegistry();\n  constructor(plugins = []) {\n    plugins.forEach((plugin) => this.pluginRegistry.register(plugin));\n  }\n  getAllTools(context, configuration) {\n    const pluginTools = this.pluginRegistry.getTools(context);\n    const allTools = [];\n    const allToolNames = /* @__PURE__ */ new Set();\n    pluginTools.forEach((pluginTool) => {\n      if (!allToolNames.has(pluginTool.method)) {\n        allTools.push(pluginTool);\n        allToolNames.add(pluginTool.method);\n      } else {\n        console.warn(\n          `Plugin tool \"${pluginTool.method}\" conflicts with core tool. Using core tool.`\n        );\n      }\n    });\n    if (configuration?.tools && configuration.tools.length > 0) {\n      return allTools.filter((tool41) => configuration.tools.includes(tool41.method));\n    }\n    return allTools;\n  }\n  static createFromConfiguration(configuration) {\n    return new _ToolDiscovery(configuration.plugins || []);\n  }\n};\n\n// src/langchain/toolkit.ts\nvar HederaLangchainToolkit = class {\n  _hederaAgentKit;\n  tools;\n  constructor({ client, configuration }) {\n    const context = configuration.context || {};\n    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);\n    const allTools = toolDiscovery.getAllTools(context, configuration);\n    this._hederaAgentKit = new api_default(client, configuration.context, allTools);\n    this.tools = allTools.map(\n      (tool41) => new tool_default(\n        this._hederaAgentKit,\n        tool41.method,\n        tool41.description,\n        tool41.parameters\n      )\n    );\n  }\n  getTools() {\n    return this.tools;\n  }\n  getHederaAgentKitAPI() {\n    return this._hederaAgentKit;\n  }\n};\nvar toolkit_default = HederaLangchainToolkit;\n\n// src/modelcontextprotocol/toolkit.ts\n\nvar HederaMCPToolkit = class extends _modelcontextprotocol_sdk_server_mcp_js__WEBPACK_IMPORTED_MODULE_8__.McpServer {\n  _hederaAgentKit;\n  constructor({ client, configuration }) {\n    super({\n      name: \"Hedera Agent Kit\",\n      version: \"0.1.0\",\n      configuration: {\n        ...configuration,\n        context: {\n          ...configuration.context,\n          mode: \"modelcontextprotocol\"\n        }\n      }\n    });\n    const context = configuration.context || {};\n    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);\n    const allTools = toolDiscovery.getAllTools(context, configuration);\n    this._hederaAgentKit = new api_default(client, configuration.context, allTools);\n    allTools.map((tool41) => {\n      this.tool(\n        tool41.method,\n        tool41.description,\n        tool41.parameters.shape,\n        async (arg, _extra) => {\n          const result = await this._hederaAgentKit.run(tool41.method, arg);\n          return {\n            content: [\n              {\n                type: \"text\",\n                text: String(result)\n              }\n            ]\n          };\n        }\n      );\n    });\n  }\n};\nvar toolkit_default2 = HederaMCPToolkit;\n\n// src/ai-sdk/tool.ts\n\nfunction HederaAgentKitTool2(hederaAPI, method, description, schema) {\n  return (0,ai__WEBPACK_IMPORTED_MODULE_9__.tool)({\n    description,\n    parameters: schema,\n    execute: (arg) => {\n      return hederaAPI.run(method, arg);\n    }\n  });\n}\n\n// src/ai-sdk/toolkit.ts\nvar HederaAIToolkit = class {\n  _hedera;\n  tools;\n  constructor({ client, configuration }) {\n    const context = configuration.context || {};\n    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);\n    const allTools = toolDiscovery.getAllTools(context, configuration);\n    this._hedera = new api_default(client, configuration.context, allTools);\n    this.tools = {};\n    allTools.forEach((tool41) => {\n      this.tools[tool41.method] = HederaAgentKitTool2(\n        this._hedera,\n        tool41.method,\n        tool41.description,\n        tool41.parameters\n      );\n    });\n  }\n  middleware() {\n    return {\n      wrapGenerate: async ({ doGenerate }) => {\n        return doGenerate();\n      },\n      wrapStream: async ({ doStream }) => {\n        return doStream();\n      }\n    };\n  }\n  getTools() {\n    return this.tools;\n  }\n};\nvar toolkit_default3 = HederaAIToolkit;\n\n// src/elizaos/tool.ts\n\n\n// src/elizaos/utils/extraction.ts\n\nfunction generateExtractionTemplate(tool41) {\n  const zodSchema = tool41.parameters;\n  const description = tool41.description;\n  const actionName = tool41.name;\n  const toolParamsJSONSchema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_11__.zodToJsonSchema)(zodSchema, actionName);\n  return `Given the recent messages and Hedera wallet information below:\n{{recentMessages}}\n{{hederaAccountDetails}}\n\nExtract the following parameters based on the tool/action description and json schema below:\n\n### Tool/action description:\n${description}\n\n\\u26A0\\uFE0F Do **not** assume values or apply defaults. Do **not** set a field unless it is clearly specified in the latest user input.\n\\u26A0\\uFE0F **IMPORTANT**: Always ensure numeric values are provided as NUMBERS WITHOUT QUOTES in the JSON response.\n\\u26A0\\uFE0F **IMPORTANT**: Always ensure string values are provided as QUOTED STRINGS in the JSON response.\n\\u26A0\\uFE0F **CRITICAL**: Enum values must be provided as QUOTED STRINGS (e.g., \"finite\", not finite).\n\\u26A0\\uFE0F **CRITICAL**: The returned JSON must be a valid JSON object in markdown format. Don not include comments inside it. If no params is passed return an empty JSON object.\n\n---\n\n### Response format:\nRespond with a JSON markdown block including the fields that were explicitly mentioned in the most recent user message.\n\nResponse JSON schema:\n${JSON.stringify(toolParamsJSONSchema, null, 2)}\n\n---\n\nNumeric values should be numbers without quotes. Enum values must be quoted strings.`;\n}\n\n// src/elizaos/utils/parser.ts\nvar jsonBlockPattern = /```(?:json)?\\s*([\\s\\S]*?)```/;\nfunction customParseJSONObjectFromText(text) {\n  if (!text) return null;\n  let jsonData = null;\n  const jsonBlockMatch = text.match(jsonBlockPattern);\n  try {\n    if (jsonBlockMatch) {\n      const jsonContent = jsonBlockMatch[1].trim().replace(/[\\u0000-\\u001F\\u007F-\\u009F]/g, \"\");\n      jsonData = JSON.parse(jsonContent);\n    } else {\n      try {\n        jsonData = JSON.parse(text.trim());\n      } catch {\n        jsonData = JSON.parse(customNormalizeJsonString(text.trim()));\n      }\n    }\n  } catch (error) {\n    console.warn(\"Could not parse text as JSON:\", error);\n    return null;\n  }\n  if (jsonData && typeof jsonData === \"object\") {\n    return jsonData;\n  }\n  console.warn(\"Parsed result is not a valid object or array\");\n  return null;\n}\nfunction customNormalizeJsonString(str) {\n  if (!str) return str;\n  str = str.replace(/\\{\\s+/, \"{\").replace(/\\s+\\}/, \"}\").trim();\n  str = str.replace(/(\\s*)(\\w+)(\\s*):(\\s*)/g, '$1\"$2\"$3:$4');\n  str = str.replace(/\"([^\"]+)\"\\s*:\\s*'([^']*)'/g, (_, key, value) => `\"${key}\": \"${value}\"`);\n  str = str.replace(/\"([^\"]+)\"\\s*:\\s*([^\",\\{\\[\\]\\}0-9][^\",\\{\\[\\]\\}\\s]*)/g, (match, key, value) => {\n    if (value === \"true\" || value === \"false\" || value === \"null\") {\n      return `\"${key}\": ${value}`;\n    }\n    if (!isNaN(Number(value))) {\n      return `\"${key}\": ${value}`;\n    }\n    return `\"${key}\": \"${value}\"`;\n  });\n  return str;\n}\n\n// src/elizaos/tool.ts\nvar HederaAgentKitTool3 = class {\n  description;\n  handler;\n  similes;\n  examples;\n  name;\n  validate;\n  constructor(client, context, tool41) {\n    const parameterSchema = tool41.parameters;\n    this.description = tool41.description;\n    this.name = tool41.method.toUpperCase();\n    this.similes = [tool41.method.toUpperCase()];\n    this.validate = async (_runtime, _message) => true;\n    this.handler = async (runtime, _message, state, _options, callback) => {\n      _elizaos_core__WEBPACK_IMPORTED_MODULE_10__.logger.log(`Running ${tool41.method} handler...`);\n      if (!state) {\n        throw new Error(\"State is undefined\");\n      }\n      const prompt = (0,_elizaos_core__WEBPACK_IMPORTED_MODULE_10__.composePromptFromState)({\n        state,\n        template: generateExtractionTemplate(tool41)\n      });\n      _elizaos_core__WEBPACK_IMPORTED_MODULE_10__.logger.debug(`prompt: ${prompt}`);\n      const modelOutput = await runtime.useModel(_elizaos_core__WEBPACK_IMPORTED_MODULE_10__.ModelType.TEXT_LARGE, { prompt });\n      _elizaos_core__WEBPACK_IMPORTED_MODULE_10__.logger.debug(`Model extraction output: ${modelOutput}`);\n      const parsedParams = customParseJSONObjectFromText(modelOutput);\n      _elizaos_core__WEBPACK_IMPORTED_MODULE_10__.logger.debug(\"Parsed params object\", parsedParams);\n      const validation = parameterSchema.safeParse(parsedParams);\n      _elizaos_core__WEBPACK_IMPORTED_MODULE_10__.logger.debug(\"Validated params:\" + JSON.stringify(validation, null, 2));\n      if (!validation.success) {\n        const promptText = `given the recent messages {{recent_messages}}, \n        tool description: ${tool41.description}\n        and the error message: ${validation.error.format()}\n        generate a comprehensive message to the user about missing params\n        `;\n        const modelOutput2 = await runtime.useModel(_elizaos_core__WEBPACK_IMPORTED_MODULE_10__.ModelType.TEXT_LARGE, { promptText });\n        if (callback) {\n          await callback({\n            text: modelOutput2,\n            content: { error: validation.error.format() }\n          });\n        }\n        return {\n          success: false,\n          text: modelOutput2,\n          error: validation.error.toString()\n        };\n      }\n      try {\n        const result = await tool41.execute(client, context, validation.data);\n        const responseText = result.humanMessage;\n        if (callback) {\n          await callback({\n            text: responseText,\n            content: result\n          });\n        }\n        return { success: true, text: responseText };\n      } catch (err) {\n        const message = err instanceof Error ? err.message : \"Unknown error\";\n        _elizaos_core__WEBPACK_IMPORTED_MODULE_10__.logger.error(`Error running tool ${tool41.method}:`, err);\n        if (callback) {\n          await callback({\n            text: `Execution failed: ${message}`,\n            content: { error: message }\n          });\n        }\n        return { success: false, text: `Execution failed: ${message}`, error: message };\n      }\n    };\n  }\n};\nvar tool_default2 = HederaAgentKitTool3;\n\n// src/elizaos/toolkit.ts\nvar HederaElizaOSToolkit = class {\n  tools;\n  client;\n  context;\n  constructor({ client, configuration }) {\n    this.client = client;\n    this.context = configuration.context || {};\n    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);\n    const allTools = toolDiscovery.getAllTools(this.context, configuration);\n    this.tools = allTools.map((tool41) => new tool_default2(this.client, this.context, tool41));\n  }\n  /**\n   * Maps hedera-agent-kit tools and returns ElizaOS compatible actions\n   */\n  getTools() {\n    return this.tools;\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaGVkZXJhLWFnZW50LWtpdC9kaXN0L2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCOztBQUVsQjtBQUN3QjtBQUNtRTtBQUMzRixrREFBa0QsS0FBSyx1Q0FBUTtBQUMvRCxhQUFhLHVDQUFRO0FBQ3JCLGVBQWUsdUNBQVE7QUFDdkIsaUJBQWlCLHVDQUFRO0FBQ3pCLGNBQWMsd0NBQU07QUFDcEIsYUFBYSx1Q0FBUTtBQUNyQixZQUFZLHVDQUFRO0FBQ3BCLHFCQUFxQix1Q0FBUTtBQUM3QixlQUFlLHdDQUFTO0FBQ3hCLENBQUM7QUFDRCxxREFBcUQsS0FBSyx1Q0FBUTtBQUNsRSxhQUFhLHVDQUFRO0FBQ3JCLGVBQWUsdUNBQVE7QUFDdkIsYUFBYSx1Q0FBUTtBQUNyQixxQkFBcUIsdUNBQVE7QUFDN0IsQ0FBQztBQUNELDZCQUE2Qix1Q0FBUTtBQUNyQyxhQUFhLHVDQUFRO0FBQ3JCLFVBQVUsc0NBQU8sRUFBRSx1Q0FBUSxJQUFJLHVDQUFRO0FBQ3ZDLENBQUM7QUFDRCxtREFBbUQsS0FBSyx1Q0FBUTtBQUNoRSxXQUFXLHVDQUFRO0FBQ25CLG1CQUFtQix1Q0FBUTtBQUMzQixjQUFjLHNDQUFPO0FBQ3JCLENBQUM7QUFDRCxnREFBZ0QsS0FBSyx1Q0FBUTtBQUM3RCxXQUFXLHVDQUFRO0FBQ25CLFVBQVUsdUNBQVE7QUFDbEIsQ0FBQztBQUNELG1EQUFtRCxLQUFLLHVDQUFRO0FBQ2hFLFdBQVcsdUNBQVE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0RBQU0sZ0JBQWdCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNFQUFzQjtBQUMzQztBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU0sa0RBQU0sa0JBQWtCLE9BQU87QUFDckMsaURBQWlELHFEQUFTLGVBQWUsUUFBUTtBQUNqRixNQUFNLGtEQUFNLG1DQUFtQyxZQUFZO0FBQzNEO0FBQ0EsTUFBTSxrREFBTTtBQUNaO0FBQ0EsTUFBTSxrREFBTTtBQUNaO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RSw0QkFBNEI7QUFDNUIsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxvREFBb0QscURBQVMsZUFBZSxZQUFZO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1I7QUFDQSxRQUFRLGtEQUFNLDZCQUE2QixjQUFjO0FBQ3pEO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQyx1QkFBdUI7QUFDdkIsV0FBVztBQUNYO0FBQ0EsaUJBQWlCLDJDQUEyQyxRQUFRO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrREU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2phc2h3YW50aHBlZGRpc2V0dHkvRG9jdW1lbnRzL2V0aGdsb2JhbC9jb250ZXh0by9ub2RlX21vZHVsZXMvaGVkZXJhLWFnZW50LWtpdC9kaXN0L2VzbS9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3NoYXJlZC9hcGkudHNcbnZhciBIZWRlcmFBZ2VudEFQSSA9IGNsYXNzIHtcbiAgY2xpZW50O1xuICBjb250ZXh0O1xuICB0b29scztcbiAgY29uc3RydWN0b3IoY2xpZW50LCBjb250ZXh0LCB0b29scykge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIGlmICghdGhpcy5jbGllbnQubGVkZ2VySWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsaWVudCBtdXN0IGJlIGNvbm5lY3RlZCB0byBhIG5ldHdvcmtcIik7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwge307XG4gICAgdGhpcy50b29scyA9IHRvb2xzIHx8IFtdO1xuICB9XG4gIGFzeW5jIHJ1bihtZXRob2QsIGFyZykge1xuICAgIGNvbnN0IHRvb2w0MSA9IHRoaXMudG9vbHMuZmluZCgodCkgPT4gdC5tZXRob2QgPT09IG1ldGhvZCk7XG4gICAgaWYgKHRvb2w0MSkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gSlNPTi5zdHJpbmdpZnkoYXdhaXQgdG9vbDQxLmV4ZWN1dGUodGhpcy5jbGllbnQsIHRoaXMuY29udGV4dCwgYXJnKSk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1ldGhvZCBcIiArIG1ldGhvZCk7XG4gICAgfVxuICB9XG59O1xudmFyIGFwaV9kZWZhdWx0ID0gSGVkZXJhQWdlbnRBUEk7XG5cbi8vIHNyYy9zaGFyZWQvY29uZmlndXJhdGlvbi50c1xudmFyIEFnZW50TW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEFnZW50TW9kZTIpID0+IHtcbiAgQWdlbnRNb2RlMltcIkFVVE9OT01PVVNcIl0gPSBcImF1dG9ub21vdXNcIjtcbiAgQWdlbnRNb2RlMltcIlJFVFVSTl9CWVRFU1wiXSA9IFwicmV0dXJuQnl0ZXNcIjtcbiAgcmV0dXJuIEFnZW50TW9kZTI7XG59KShBZ2VudE1vZGUgfHwge30pO1xuXG4vLyBzcmMvc2hhcmVkL3BhcmFtZXRlci1zY2hlbWFzL3Rva2VuLnpvZC50c1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcbmltcG9ydCB7IEFjY291bnRJZCwgUHVibGljS2V5LCBUb2tlbklkLCBUb2tlblN1cHBseVR5cGUsIFRva2VuVHlwZSB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIGNyZWF0ZUZ1bmdpYmxlVG9rZW5QYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHoub2JqZWN0KHtcbiAgdG9rZW5OYW1lOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIG5hbWUgb2YgdGhlIHRva2VuLlwiKSxcbiAgdG9rZW5TeW1ib2w6IHouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgc3ltYm9sIG9mIHRoZSB0b2tlbi5cIiksXG4gIGluaXRpYWxTdXBwbHk6IHoubnVtYmVyKCkuaW50KCkub3B0aW9uYWwoKS5kZWZhdWx0KDApLmRlc2NyaWJlKFwiVGhlIGluaXRpYWwgc3VwcGx5IG9mIHRoZSB0b2tlbi5cIiksXG4gIHN1cHBseVR5cGU6IHouZW51bShbXCJmaW5pdGVcIiwgXCJpbmZpbml0ZVwiXSkub3B0aW9uYWwoKS5kZWZhdWx0KFwiZmluaXRlXCIpLmRlc2NyaWJlKFwiU3VwcGx5IHR5cGUgb2YgdGhlIHRva2VuLlwiKSxcbiAgbWF4U3VwcGx5OiB6Lm51bWJlcigpLmludCgpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJUaGUgbWF4aW11bSBzdXBwbHkgb2YgdGhlIHRva2VuLlwiKSxcbiAgZGVjaW1hbHM6IHoubnVtYmVyKCkuaW50KCkub3B0aW9uYWwoKS5kZWZhdWx0KDApLmRlc2NyaWJlKFwiVGhlIG51bWJlciBvZiBkZWNpbWFscy5cIiksXG4gIHRyZWFzdXJ5QWNjb3VudElkOiB6LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJUaGUgdHJlYXN1cnkgYWNjb3VudCBvZiB0aGUgdG9rZW4uXCIpLFxuICBpc1N1cHBseUtleTogei5ib29sZWFuKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIkRldGVybWluZXMgaWYgdGhlIHRva2VuIHN1cHBseSBrZXkgc2hvdWxkIGJlIHNldC5cIilcbn0pO1xudmFyIGNyZWF0ZU5vbkZ1bmdpYmxlVG9rZW5QYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHoub2JqZWN0KHtcbiAgdG9rZW5OYW1lOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIG5hbWUgb2YgdGhlIHRva2VuLlwiKSxcbiAgdG9rZW5TeW1ib2w6IHouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgc3ltYm9sIG9mIHRoZSB0b2tlbi5cIiksXG4gIG1heFN1cHBseTogei5udW1iZXIoKS5pbnQoKS5vcHRpb25hbCgpLmRlZmF1bHQoMTAwKS5kZXNjcmliZShcIlRoZSBtYXhpbXVtIHN1cHBseSBvZiB0aGUgdG9rZW4uXCIpLFxuICB0cmVhc3VyeUFjY291bnRJZDogei5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVGhlIHRyZWFzdXJ5IGFjY291bnQgb2YgdGhlIHRva2VuLlwiKVxufSk7XG52YXIgQWlyZHJvcFJlY2lwaWVudFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgYWNjb3VudElkOiB6LnN0cmluZygpLmRlc2NyaWJlKCdSZWNpcGllbnQgYWNjb3VudCBJRCAoZS5nLiwgXCIwLjAueHh4eFwiKS4nKSxcbiAgYW1vdW50OiB6LnVuaW9uKFt6Lm51bWJlcigpLCB6LnN0cmluZygpXSkuZGVzY3JpYmUoXCJBbW91bnQgaW4gYmFzZSB1bml0LlwiKVxufSk7XG52YXIgYWlyZHJvcEZ1bmdpYmxlVG9rZW5QYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHoub2JqZWN0KHtcbiAgdG9rZW5JZDogei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBpZCBvZiB0aGUgdG9rZW4uXCIpLFxuICBzb3VyY2VBY2NvdW50SWQ6IHouc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIlRoZSBhY2NvdW50IHRvIGFpcmRyb3AgdGhlIHRva2VuIGZyb20uXCIpLFxuICByZWNpcGllbnRzOiB6LmFycmF5KEFpcmRyb3BSZWNpcGllbnRTY2hlbWEpLm1pbigxKS5kZXNjcmliZShcIkFycmF5IG9mIHJlY2lwaWVudCBvYmplY3RzLCBlYWNoIHdpdGggYWNjb3VudElkIGFuZCBhbW91bnQuXCIpXG59KTtcbnZhciBtaW50RnVuZ2libGVUb2tlblBhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4gei5vYmplY3Qoe1xuICB0b2tlbklkOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGlkIG9mIHRoZSB0b2tlbi5cIiksXG4gIGFtb3VudDogei5udW1iZXIoKS5kZXNjcmliZShcIlRoZSBhbW91bnQgb2YgdG9rZW5zIHRvIG1pbnQuXCIpXG59KTtcbnZhciBtaW50Tm9uRnVuZ2libGVUb2tlblBhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4gei5vYmplY3Qoe1xuICB0b2tlbklkOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGlkIG9mIHRoZSBORlQgY2xhc3MuXCIpLFxuICB1cmlzOiB6LmFycmF5KHouc3RyaW5nKCkubWF4KDEwMCkpLm1heCgxMCkuZGVzY3JpYmUoXCJBbiBhcnJheSBvZiBVUklzIGhvc3RpbmcgTkZUIG1ldGFkYXRhLlwiKVxufSk7XG52YXIgdG9rZW5JbmZvUXVlcnlQYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHoub2JqZWN0KHtcbiAgdG9rZW5JZDogei5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVGhlIHRva2VuIElEIHRvIHF1ZXJ5LlwiKVxufSk7XG52YXIgdXBkYXRlVG9rZW5QYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHoub2JqZWN0KHtcbiAgdG9rZW5JZDogei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBJRCBvZiB0aGUgdG9rZW4gdG8gdXBkYXRlIChlLmcuLCAwLjAuMTIzNDUpLlwiKSxcbiAgdG9rZW5EZXNjOiB6LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJPcHRpb25hbCBkZXNjcmlwdGlvbiBvZiB0aGUgdG9rZW4gdXBkYXRlIG9wZXJhdGlvbi5cIiksXG4gIHRva2VuTmFtZTogei5zdHJpbmcoKS5tYXgoMTAwKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiTmV3IG5hbWUgZm9yIHRoZSB0b2tlbi4gVXAgdG8gMTAwIGNoYXJhY3RlcnMuXCIpLFxuICB0b2tlblN5bWJvbDogei5zdHJpbmcoKS5tYXgoMTAwKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiTmV3IHN5bWJvbCBmb3IgdGhlIHRva2VuLiBVcCB0byAxMDAgY2hhcmFjdGVycy5cIiksXG4gIHRyZWFzdXJ5QWNjb3VudElkOiB6LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJOZXcgdHJlYXN1cnkgYWNjb3VudCBmb3IgdGhlIHRva2VuIChIZWRlcmEgYWNjb3VudCBJRCkuXCIpLFxuICBhZG1pbktleTogei51bmlvbihbei5ib29sZWFuKCksIHouc3RyaW5nKCldKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgIFwiTmV3IGFkbWluIGtleS4gUGFzcyBib29sZWFuIGB0cnVlYCB0byB1c2UgdGhlIG9wZXJhdG9yL3VzZXIga2V5LCBvciBwcm92aWRlIGEgSGVkZXJhLWNvbXBhdGlibGUgcHVibGljIGtleSBzdHJpbmcuIFJlcXVpcmVkIGZvciBtb3N0IHByb3BlcnR5IHVwZGF0ZXMuXCJcbiAgKSxcbiAga3ljS2V5OiB6LnVuaW9uKFt6LmJvb2xlYW4oKSwgei5zdHJpbmcoKV0pLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgXCJOZXcgS1lDIGtleS4gUGFzcyBib29sZWFuIGB0cnVlYCB0byB1c2UgdGhlIG9wZXJhdG9yL3VzZXIga2V5LCBvciBwcm92aWRlIGEgcHVibGljIGtleSBzdHJpbmcuXCJcbiAgKSxcbiAgZnJlZXplS2V5OiB6LnVuaW9uKFt6LmJvb2xlYW4oKSwgei5zdHJpbmcoKV0pLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgXCJOZXcgZnJlZXplIGtleS4gUGFzcyBib29sZWFuIGB0cnVlYCB0byB1c2UgdGhlIG9wZXJhdG9yL3VzZXIga2V5LCBvciBwcm92aWRlIGEgcHVibGljIGtleSBzdHJpbmcuXCJcbiAgKSxcbiAgd2lwZUtleTogei51bmlvbihbei5ib29sZWFuKCksIHouc3RyaW5nKCldKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgIFwiTmV3IHdpcGUga2V5LiBQYXNzIGJvb2xlYW4gYHRydWVgIHRvIHVzZSB0aGUgb3BlcmF0b3IvdXNlciBrZXksIG9yIHByb3ZpZGUgYSBwdWJsaWMga2V5IHN0cmluZy5cIlxuICApLFxuICBzdXBwbHlLZXk6IHoudW5pb24oW3ouYm9vbGVhbigpLCB6LnN0cmluZygpXSkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICBcIk5ldyBzdXBwbHkga2V5LiBQYXNzIGJvb2xlYW4gYHRydWVgIHRvIHVzZSB0aGUgb3BlcmF0b3IvdXNlciBrZXksIG9yIHByb3ZpZGUgYSBwdWJsaWMga2V5IHN0cmluZy5cIlxuICApLFxuICBmZWVTY2hlZHVsZUtleTogei51bmlvbihbei5ib29sZWFuKCksIHouc3RyaW5nKCldKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgIFwiTmV3IGZlZSBzY2hlZHVsZSBrZXkuIFBhc3MgYm9vbGVhbiBgdHJ1ZWAgdG8gdXNlIHRoZSBvcGVyYXRvci91c2VyIGtleSwgb3IgcHJvdmlkZSBhIHB1YmxpYyBrZXkgc3RyaW5nLlwiXG4gICksXG4gIHBhdXNlS2V5OiB6LnVuaW9uKFt6LmJvb2xlYW4oKSwgei5zdHJpbmcoKV0pLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgXCJOZXcgcGF1c2Uga2V5LiBQYXNzIGJvb2xlYW4gYHRydWVgIHRvIHVzZSB0aGUgb3BlcmF0b3IvdXNlciBrZXksIG9yIHByb3ZpZGUgYSBwdWJsaWMga2V5IHN0cmluZy5cIlxuICApLFxuICBtZXRhZGF0YUtleTogei51bmlvbihbei5ib29sZWFuKCksIHouc3RyaW5nKCldKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgIFwiTmV3IG1ldGFkYXRhIGtleS4gUGFzcyBib29sZWFuIGB0cnVlYCB0byB1c2UgdGhlIG9wZXJhdG9yL3VzZXIga2V5LCBvciBwcm92aWRlIGEgcHVibGljIGtleSBzdHJpbmcuXCJcbiAgKSxcbiAgbWV0YWRhdGE6IHouc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIk5ldyBtZXRhZGF0YSBmb3IgdGhlIHRva2VuLCBpbiBieXRlcyAoYXMgYmFzZTY0IG9yIGhleCkuXCIpLFxuICB0b2tlbk1lbW86IHouc3RyaW5nKCkubWF4KDEwMCkub3B0aW9uYWwoKS5kZXNjcmliZShcIlNob3J0IHB1YmxpYyBtZW1vIGZvciB0aGUgdG9rZW4sIHVwIHRvIDEwMCBjaGFyYWN0ZXJzLlwiKSxcbiAgYXV0b1JlbmV3QWNjb3VudElkOiB6LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJBY2NvdW50IHRvIGF1dG9tYXRpY2FsbHkgcGF5IGZvciB0b2tlbiByZW5ld2FsIChIZWRlcmEgYWNjb3VudCBJRCkuXCIpXG59KTtcbnZhciBhc3NvY2lhdGVUb2tlblBhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4gei5vYmplY3Qoe1xuICAvLyBJZiBub3QgcGFzc2VkLCB3aWxsIGJlIGluamVjdGVkIGZyb20gY29udGV4dCBpbiBub3JtYWxpc2F0aW9uXG4gIGFjY291bnRJZDogei5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgIFwiQWNjb3VudCBJRCB0byBhc3NvY2lhdGUgdG9rZW5zIHdpdGggKGUuZy4sIDAuMC54eHh4eCkuIElmIG5vdCBwcm92aWRlZCwgb3BlcmF0b3IgYWNjb3VudCBJRCB3aWxsIGJlIHVzZWRcIlxuICApLFxuICAvLyBPbmUgb3IgbW9yZSB0b2tlbiBJRHMgdG8gYXNzb2NpYXRlXG4gIHRva2VuSWRzOiB6LmFycmF5KHouc3RyaW5nKCkpLm1pbigxKS5kZXNjcmliZShcIkFycmF5IG9mIHRva2VuIElEcyB0byBhc3NvY2lhdGVcIilcbn0pO1xudmFyIHBlbmRpbmdBaXJkcm9wUXVlcnlQYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHoub2JqZWN0KHtcbiAgYWNjb3VudElkOiB6LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJUaGUgYWNjb3VudCBJRCB0byBxdWVyeS5cIilcbn0pO1xudmFyIGRpc3NvY2lhdGVUb2tlblBhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4gei5vYmplY3Qoe1xuICB0b2tlbklkczogei5hcnJheSh6LnN0cmluZygpKS5taW4oMSkuZGVzY3JpYmUoXCJUaGUgbGlzdCBvZiBIZWRlcmEgdG9rZW4gSURzIChzdHJpbmdzKSB0byBkaXNzb2NpYXRlLiBNdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lLlwiKSxcbiAgYWNjb3VudElkOiB6LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgXCJUaGUgYWNjb3VudCBJRCBmcm9tIHdoaWNoIHRvIGRpc3NvY2lhdGUgdGhlIHRva2Vucy4gRGVmYXVsdHMgdG8gb3BlcmF0b3IgYWNjb3VudC5cIlxuICApLFxuICB0cmFuc2FjdGlvbk1lbW86IHouc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIk9wdGlvbmFsIG1lbW8gZm9yIHRoZSB0cmFuc2FjdGlvbi5cIilcbn0pO1xuXG4vLyBzcmMvc2hhcmVkL3BhcmFtZXRlci1zY2hlbWFzL2FjY291bnQuem9kLnRzXG5pbXBvcnQgeyB6IGFzIHoyIH0gZnJvbSBcInpvZFwiO1xuaW1wb3J0IHsgQWNjb3VudElkIGFzIEFjY291bnRJZDIsIEhiYXIsIEtleSwgVHJhbnNhY3Rpb24sIEhiYXJBbGxvd2FuY2UgfSBmcm9tIFwiQGhhc2hncmFwaC9zZGtcIjtcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSBcImJpZ251bWJlci5qc1wiO1xuaW1wb3J0IExvbmcgZnJvbSBcImxvbmdcIjtcbnZhciB0cmFuc2ZlckhiYXJQYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHoyLm9iamVjdCh7XG4gIHRyYW5zZmVyczogejIuYXJyYXkoXG4gICAgejIub2JqZWN0KHtcbiAgICAgIGFjY291bnRJZDogejIuc3RyaW5nKCkuZGVzY3JpYmUoXCJSZWNpcGllbnQgYWNjb3VudCBJRFwiKSxcbiAgICAgIGFtb3VudDogejIubnVtYmVyKCkuZGVzY3JpYmUoXCJBbW91bnQgb2YgSEJBUiB0byB0cmFuc2ZlclwiKVxuICAgIH0pXG4gICkuZGVzY3JpYmUoXCJBcnJheSBvZiBIQkFSIHRyYW5zZmVyc1wiKSxcbiAgc291cmNlQWNjb3VudElkOiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiU2VuZGVyIGFjY291bnQgSURcIiksXG4gIHRyYW5zYWN0aW9uTWVtbzogejIuc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIk1lbW8gdG8gaW5jbHVkZSB3aXRoIHRoZSB0cmFuc2FjdGlvblwiKVxufSk7XG52YXIgY3JlYXRlQWNjb3VudFBhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4gejIub2JqZWN0KHtcbiAgcHVibGljS2V5OiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiQWNjb3VudCBwdWJsaWMga2V5LiBJZiBub3QgcHJvdmlkZWQsIGEgcHVibGljIGtleSBvZiB0aGUgb3BlcmF0b3Igd2lsbCBiZSB1c2VkXCIpLFxuICBhY2NvdW50TWVtbzogejIuc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIk9wdGlvbmFsIG1lbW8gZm9yIHRoZSBhY2NvdW50XCIpLFxuICBpbml0aWFsQmFsYW5jZTogejIubnVtYmVyKCkub3B0aW9uYWwoKS5kZWZhdWx0KDApLmRlc2NyaWJlKFwiSW5pdGlhbCBIQkFSIGJhbGFuY2UgdG8gZnVuZCB0aGUgYWNjb3VudCAoZGVmYXVsdHMgdG8gMClcIiksXG4gIG1heEF1dG9tYXRpY1Rva2VuQXNzb2NpYXRpb25zOiB6Mi5udW1iZXIoKS5vcHRpb25hbCgpLmRlZmF1bHQoLTEpLmRlc2NyaWJlKFwiTWF4IGF1dG9tYXRpYyB0b2tlbiBhc3NvY2lhdGlvbnMgKC0xIGZvciB1bmxpbWl0ZWQpXCIpXG59KTtcbnZhciBkZWxldGVBY2NvdW50UGFyYW1ldGVycyA9IChfY29udGV4dCA9IHt9KSA9PiB6Mi5vYmplY3Qoe1xuICBhY2NvdW50SWQ6IHoyLnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGFjY291bnQgSUQgdG8gZGVsZXRlLlwiKSxcbiAgdHJhbnNmZXJBY2NvdW50SWQ6IHoyLnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgXCJUaGUgSUQgb2YgdGhlIGFjY291bnQgdG8gdHJhbnNmZXIgdGhlIHJlbWFpbmluZyBmdW5kcyB0by4gSWYgbm90IHByb3ZpZGVkLCB0aGUgb3BlcmF0b3IgYWNjb3VudCBJRCB3aWxsIGJlIHVzZWQuXCJcbiAgKVxufSk7XG52YXIgdXBkYXRlQWNjb3VudFBhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4gejIub2JqZWN0KHtcbiAgLy8gSWYgbm90IHBhc3NlZCwgd2lsbCBiZSBpbmplY3RlZCBmcm9tIGNvbnRleHQgaW4gbm9ybWFsaXNhdGlvblxuICBhY2NvdW50SWQ6IHoyLnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgXCJBY2NvdW50IElEIHRvIHVwZGF0ZSAoZS5nLiwgMC4wLnh4eHh4KS4gSWYgbm90IHByb3ZpZGVkLCBvcGVyYXRvciBhY2NvdW50IElEIHdpbGwgYmUgdXNlZFwiXG4gICksXG4gIG1heEF1dG9tYXRpY1Rva2VuQXNzb2NpYXRpb25zOiB6Mi5udW1iZXIoKS5pbnQoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiTWF4IGF1dG9tYXRpYyB0b2tlbiBhc3NvY2lhdGlvbnMsIHBvc2l0aXZlLCB6ZXJvIG9yIC0xIGlmIHVubGltaXRlZFwiKSxcbiAgc3Rha2VkQWNjb3VudElkOiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiU3Rha2VkIGFjY291bnQgSURcIiksXG4gIGFjY291bnRNZW1vOiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiQWNjb3VudCBtZW1vXCIpLFxuICBkZWNsaW5lU3Rha2luZ1Jld2FyZDogejIuYm9vbGVhbigpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJEZWNsaW5lIHN0YWtpbmcgcmV3YXJkc1wiKVxufSk7XG52YXIgYWNjb3VudFF1ZXJ5UGFyYW1ldGVycyA9IChfY29udGV4dCA9IHt9KSA9PiB6Mi5vYmplY3Qoe1xuICBhY2NvdW50SWQ6IHoyLnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGFjY291bnQgSUQgdG8gcXVlcnkuXCIpXG59KTtcbnZhciBhY2NvdW50QmFsYW5jZVF1ZXJ5UGFyYW1ldGVycyA9IChfY29udGV4dCA9IHt9KSA9PiB6Mi5vYmplY3Qoe1xuICBhY2NvdW50SWQ6IHoyLnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJUaGUgYWNjb3VudCBJRCB0byBxdWVyeS5cIilcbn0pO1xudmFyIGFjY291bnRUb2tlbkJhbGFuY2VzUXVlcnlQYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHoyLm9iamVjdCh7XG4gIGFjY291bnRJZDogejIuc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIlRoZSBhY2NvdW50IElEIHRvIHF1ZXJ5LiBJZiBub3QgcHJvdmlkZWQsIHRoaXMgYWNjb3VudElkIHdpbGwgYmUgdXNlZC5cIiksXG4gIHRva2VuSWQ6IHoyLnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJUaGUgdG9rZW4gSUQgdG8gcXVlcnkuXCIpXG59KTtcbnZhciBzaWduU2NoZWR1bGVUcmFuc2FjdGlvblBhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4gejIub2JqZWN0KHtcbiAgc2NoZWR1bGVJZDogejIuc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgSUQgb2YgdGhlIHNjaGVkdWxlZCB0cmFuc2FjdGlvbiB0byBzaWduXCIpXG59KTtcbnZhciBzY2hlZHVsZURlbGV0ZVRyYW5zYWN0aW9uUGFyYW1ldGVycyA9IChfY29udGV4dCA9IHt9KSA9PiB6Mi5vYmplY3Qoe1xuICBzY2hlZHVsZUlkOiB6Mi5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBJRCBvZiB0aGUgc2NoZWR1bGVkIHRyYW5zYWN0aW9uIHRvIGRlbGV0ZVwiKVxufSk7XG52YXIgYXBwcm92ZUhiYXJBbGxvd2FuY2VQYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHoyLm9iamVjdCh7XG4gIG93bmVyQWNjb3VudElkOiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiT3duZXIgYWNjb3VudCBJRCAoZGVmYXVsdHMgdG8gb3BlcmF0b3IgYWNjb3VudCBJRCBpZiBvbWl0dGVkKVwiKSxcbiAgc3BlbmRlckFjY291bnRJZDogejIuc3RyaW5nKCkuZGVzY3JpYmUoXCJTcGVuZGVyIGFjY291bnQgSURcIiksXG4gIGFtb3VudDogejIubnVtYmVyKCkuZGVzY3JpYmUoXCJBbW91bnQgb2YgSEJBUiB0byBhcHByb3ZlIGFzIGFsbG93YW5jZSAoY2FuIGJlIGRlY2ltYWwsIG5vdCBuZWdhdGl2ZSlcIiksXG4gIHRyYW5zYWN0aW9uTWVtbzogejIuc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIk1lbW8gdG8gaW5jbHVkZSB3aXRoIHRoZSB0cmFuc2FjdGlvblwiKVxufSk7XG5cbi8vIHNyYy9zaGFyZWQvcGFyYW1ldGVyLXNjaGVtYXMvY29uc2Vuc3VzLnpvZC50c1xuaW1wb3J0IHsgeiBhcyB6MyB9IGZyb20gXCJ6b2RcIjtcbmltcG9ydCB7IEFjY291bnRJZCBhcyBBY2NvdW50SWQzLCBQdWJsaWNLZXkgYXMgUHVibGljS2V5MiwgVG9waWNJZCB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIGdldFRvcGljSW5mb1BhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4ge1xuICByZXR1cm4gejMub2JqZWN0KHtcbiAgICB0b3BpY0lkOiB6My5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSB0b3BpYyBJRCB0byBxdWVyeS5cIilcbiAgfSk7XG59O1xudmFyIGNyZWF0ZVRvcGljUGFyYW1ldGVycyA9IChfY29udGV4dCA9IHt9KSA9PiB7XG4gIHJldHVybiB6My5vYmplY3Qoe1xuICAgIGlzU3VibWl0S2V5OiB6My5ib29sZWFuKCkub3B0aW9uYWwoKS5kZWZhdWx0KGZhbHNlKS5kZXNjcmliZShcIldoZXRoZXIgdG8gc2V0IGEgc3VibWl0IGtleSBmb3IgdGhlIHRvcGljIChvcHRpb25hbClcIiksXG4gICAgdG9waWNNZW1vOiB6My5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiTWVtbyBmb3IgdGhlIHRvcGljIChvcHRpb25hbClcIiksXG4gICAgdHJhbnNhY3Rpb25NZW1vOiB6My5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiQW4gb3B0aW9uYWwgbWVtbyB0byBpbmNsdWRlIG9uIHRoZSBzdWJtaXR0ZWQgdHJhbnNhY3Rpb24gKG9wdGlvbmFsKS5cIilcbiAgfSk7XG59O1xudmFyIHN1Ym1pdFRvcGljTWVzc2FnZVBhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4ge1xuICByZXR1cm4gejMub2JqZWN0KHtcbiAgICB0b3BpY0lkOiB6My5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBJRCBvZiB0aGUgdG9waWMgdG8gc3VibWl0IHRoZSBtZXNzYWdlIHRvXCIpLFxuICAgIG1lc3NhZ2U6IHozLnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIG1lc3NhZ2UgdG8gc3VibWl0IHRvIHRoZSB0b3BpY1wiKSxcbiAgICB0cmFuc2FjdGlvbk1lbW86IHozLnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJBbiBvcHRpb25hbCBtZW1vIHRvIGluY2x1ZGUgb24gdGhlIHN1Ym1pdHRlZCB0cmFuc2FjdGlvbiAob3B0aW9uYWwpLlwiKVxuICB9KTtcbn07XG52YXIgZGVsZXRlVG9waWNQYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHozLm9iamVjdCh7XG4gIHRvcGljSWQ6IHozLnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIElEIG9mIHRoZSB0b3BpYyB0byBkZWxldGUuXCIpXG59KTtcbnZhciBkZWxldGVUb3BpY1BhcmFtZXRlcnNOb3JtYWxpc2VkID0gKF9jb250ZXh0ID0ge30pID0+IGRlbGV0ZVRvcGljUGFyYW1ldGVycyhfY29udGV4dCkuZXh0ZW5kKHt9KTtcbnZhciB0b3BpY01lc3NhZ2VzUXVlcnlQYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHozLm9iamVjdCh7XG4gIHRvcGljSWQ6IHozLnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIHRvcGljIElEIHRvIHF1ZXJ5LlwiKSxcbiAgc3RhcnRUaW1lOiB6My5zdHJpbmcoKS5kYXRldGltZSgpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgXCJUaGUgc3RhcnQgdGltZSB0byBxdWVyeS4gSWYgc2V0LCB0aGUgbWVzc2FnZXMgd2lsbCBiZSByZXR1cm5lZCBhZnRlciB0aGlzIHRpbWVzdGFtcC5cIlxuICApLFxuICBlbmRUaW1lOiB6My5zdHJpbmcoKS5kYXRldGltZSgpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXG4gICAgXCJUaGUgZW5kIHRpbWUgdG8gcXVlcnkuIElmIHNldCwgdGhlIG1lc3NhZ2VzIHdpbGwgYmUgcmV0dXJuZWQgYmVmb3JlIHRoaXMgdGltZXN0YW1wLlwiXG4gICksXG4gIGxpbWl0OiB6My5udW1iZXIoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVGhlIGxpbWl0IG9mIG1lc3NhZ2VzIHRvIHF1ZXJ5LiBJZiBzZXQsIHRoZSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuLlwiKVxufSk7XG52YXIgdXBkYXRlVG9waWNQYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHozLm9iamVjdCh7XG4gIHRvcGljSWQ6IHozLnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIElEIG9mIHRoZSB0b3BpYyB0byB1cGRhdGUgKGUuZy4sIDAuMC4xMjM0NSkuXCIpLFxuICB0b3BpY01lbW86IHozLnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJPcHRpb25hbCBuZXcgbWVtbyBmb3IgdGhlIHRvcGljLlwiKSxcbiAgYWRtaW5LZXk6IHozLnVuaW9uKFt6My5ib29sZWFuKCksIHozLnN0cmluZygpXSkub3B0aW9uYWwoKS5kZXNjcmliZShcbiAgICBcIk5ldyBhZG1pbiBrZXkuIFBhc3MgYm9vbGVhbiBgdHJ1ZWAgdG8gdXNlIHRoZSBvcGVyYXRvci91c2VyIGtleSwgb3IgcHJvdmlkZSBhIEhlZGVyYS1jb21wYXRpYmxlIHB1YmxpYyBrZXkgc3RyaW5nLlwiXG4gICksXG4gIHN1Ym1pdEtleTogejMudW5pb24oW3ozLmJvb2xlYW4oKSwgejMuc3RyaW5nKCldKS5vcHRpb25hbCgpLmRlc2NyaWJlKFxuICAgIFwiTmV3IHN1Ym1pdCBrZXkuIFBhc3MgYm9vbGVhbiBgdHJ1ZWAgdG8gdXNlIHRoZSBvcGVyYXRvci91c2VyIGtleSwgb3IgcHJvdmlkZSBhIEhlZGVyYS1jb21wYXRpYmxlIHB1YmxpYyBrZXkgc3RyaW5nLlwiXG4gICksXG4gIGF1dG9SZW5ld0FjY291bnRJZDogejMuc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIkFjY291bnQgdG8gYXV0b21hdGljYWxseSBwYXkgZm9yIHRvcGljIHJlbmV3YWwgKEhlZGVyYSBhY2NvdW50IElEKS5cIiksXG4gIGF1dG9SZW5ld1BlcmlvZDogejMubnVtYmVyKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIkF1dG8gcmVuZXcgcGVyaW9kIGluIHNlY29uZHMuXCIpLFxuICBleHBpcmF0aW9uVGltZTogejMudW5pb24oW3ozLnN0cmluZygpLCB6My5pbnN0YW5jZW9mKERhdGUpXSkub3B0aW9uYWwoKS5kZXNjcmliZShcIk5ldyBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSB0b3BpYyAoSVNPIHN0cmluZyBvciBEYXRlKS5cIilcbn0pO1xuXG4vLyBzcmMvc2hhcmVkL2hlZGVyYS11dGlscy9oZWRlcmEtcGFyYW1ldGVyLW5vcm1hbGlzZXIudHNcbmltcG9ydCB7XG4gIEFjY291bnRJZCBhcyBBY2NvdW50SWQ0LFxuICBIYmFyIGFzIEhiYXIyLFxuICBQdWJsaWNLZXkgYXMgUHVibGljS2V5NCxcbiAgVG9rZW5JZCBhcyBUb2tlbklkMixcbiAgVG9rZW5TdXBwbHlUeXBlIGFzIFRva2VuU3VwcGx5VHlwZTIsXG4gIFRva2VuVHlwZSBhcyBUb2tlblR5cGUyLFxuICBUb3BpY0lkIGFzIFRvcGljSWQyLFxuICBIYmFyQWxsb3dhbmNlIGFzIEhiYXJBbGxvd2FuY2UyXG59IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xuaW1wb3J0IHo2IGZyb20gXCJ6b2RcIjtcblxuLy8gc3JjL3NoYXJlZC9oZWRlcmEtdXRpbHMvZGVjaW1hbHMtdXRpbHMudHNcbmltcG9ydCBCaWdOdW1iZXIyIGZyb20gXCJiaWdudW1iZXIuanNcIjtcbmZ1bmN0aW9uIHRvQmFzZVVuaXQoYW1vdW50LCBkZWNpbWFscykge1xuICBjb25zdCBhbW91bnRCTiA9IG5ldyBCaWdOdW1iZXIyKGFtb3VudCk7XG4gIGNvbnN0IG11bHRpcGxpZXIgPSBuZXcgQmlnTnVtYmVyMigxMCkucG93KGRlY2ltYWxzKTtcbiAgcmV0dXJuIGFtb3VudEJOLm11bHRpcGxpZWRCeShtdWx0aXBsaWVyKS5pbnRlZ2VyVmFsdWUoQmlnTnVtYmVyMi5ST1VORF9GTE9PUik7XG59XG5mdW5jdGlvbiB0b0Rpc3BsYXlVbml0KGJhc2VBbW91bnQsIGRlY2ltYWxzKSB7XG4gIGNvbnN0IGJhc2VBbW91bnRCTiA9IG5ldyBCaWdOdW1iZXIyKGJhc2VBbW91bnQpO1xuICBjb25zdCBkaXZpc29yID0gbmV3IEJpZ051bWJlcjIoMTApLnBvdyhkZWNpbWFscyk7XG4gIHJldHVybiBiYXNlQW1vdW50Qk4uZGl2aWRlZEJ5KGRpdmlzb3IpO1xufVxuXG4vLyBzcmMvc2hhcmVkL2hlZGVyYS11dGlscy9oZWRlcmEtcGFyYW1ldGVyLW5vcm1hbGlzZXIudHNcbmltcG9ydCBMb25nMiBmcm9tIFwibG9uZ1wiO1xuXG4vLyBzcmMvc2hhcmVkL3V0aWxzL2FjY291bnQtcmVzb2x2ZXIudHNcbmltcG9ydCB7IFB1YmxpY0tleSBhcyBQdWJsaWNLZXkzIH0gZnJvbSBcIkBoYXNoZ3JhcGgvc2RrXCI7XG52YXIgQWNjb3VudFJlc29sdmVyID0gY2xhc3MgX0FjY291bnRSZXNvbHZlciB7XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkZWZhdWx0IGFjY291bnQgYmFzZWQgb24gdGhlIGFnZW50IG1vZGUgYW5kIGNvbnRleHQuXG4gICAqIEluIFJFVFVSTl9CWVRFUyBtb2RlLCBwcmVmZXJzIGNvbnRleHQuYWNjb3VudElkICh1c2VyJ3MgYWNjb3VudCkuXG4gICAqIEluIEFVVE9OT01PVVMgbW9kZSBvciB3aGVuIG5vIGNvbnRleHQgYWNjb3VudCwgdXNlcyBhbiBvcGVyYXRvciBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGdldERlZmF1bHRBY2NvdW50KGNvbnRleHQsIGNsaWVudCkge1xuICAgIGlmIChjb250ZXh0LmFjY291bnRJZCkge1xuICAgICAgcmV0dXJuIGNvbnRleHQuYWNjb3VudElkO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRvckFjY291bnQgPSBjbGllbnQub3BlcmF0b3JBY2NvdW50SWQ/LnRvU3RyaW5nKCk7XG4gICAgaWYgKCFvcGVyYXRvckFjY291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFjY291bnQgYXZhaWxhYmxlOiBuZWl0aGVyIGNvbnRleHQuYWNjb3VudElkIG5vciBvcGVyYXRvciBhY2NvdW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0b3JBY2NvdW50O1xuICB9XG4gIHN0YXRpYyBhc3luYyBnZXREZWZhdWx0UHVibGljS2V5KGNvbnRleHQsIGNsaWVudCkge1xuICAgIGlmIChjb250ZXh0Lm1vZGUgPT09IFwiYXV0b25vbW91c1wiIC8qIEFVVE9OT01PVVMgKi8pIHtcbiAgICAgIHJldHVybiBjbGllbnQub3BlcmF0b3JQdWJsaWNLZXk7XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRBY2NvdW50ID0gdGhpcy5nZXREZWZhdWx0QWNjb3VudChjb250ZXh0LCBjbGllbnQpO1xuICAgIGNvbnN0IGRlZmF1bHRBY2NvdW50RGV0YWlscyA9IGF3YWl0IGNvbnRleHQubWlycm9ybm9kZVNlcnZpY2U/LmdldEFjY291bnQoZGVmYXVsdEFjY291bnQpO1xuICAgIGlmICghZGVmYXVsdEFjY291bnREZXRhaWxzPy5hY2NvdW50UHVibGljS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwdWJsaWMga2V5IGF2YWlsYWJsZSBmb3IgdGhlIGRlZmF1bHQgYWNjb3VudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFB1YmxpY0tleTMuZnJvbVN0cmluZyhkZWZhdWx0QWNjb3VudERldGFpbHMuYWNjb3VudFB1YmxpY0tleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmVzIGFuIGFjY291bnQgSUQsIHVzaW5nIHRoZSBwcm92aWRlZCBhY2NvdW50IG9yIGZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdC5cbiAgICovXG4gIHN0YXRpYyByZXNvbHZlQWNjb3VudChwcm92aWRlZEFjY291bnQsIGNvbnRleHQsIGNsaWVudCkge1xuICAgIHJldHVybiBwcm92aWRlZEFjY291bnQgfHwgdGhpcy5nZXREZWZhdWx0QWNjb3VudChjb250ZXh0LCBjbGllbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgZGVzY3JpcHRpb24gb2Ygd2hpY2ggYWNjb3VudCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCBmb3IgcHJvbXB0cy5cbiAgICovXG4gIHN0YXRpYyBnZXREZWZhdWx0QWNjb3VudERlc2NyaXB0aW9uKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5tb2RlID09PSBcInJldHVybkJ5dGVzXCIgLyogUkVUVVJOX0JZVEVTICovICYmIGNvbnRleHQuYWNjb3VudElkKSB7XG4gICAgICByZXR1cm4gYHVzZXIgYWNjb3VudCAoJHtjb250ZXh0LmFjY291bnRJZH0pYDtcbiAgICB9XG4gICAgcmV0dXJuIFwib3BlcmF0b3IgYWNjb3VudFwiO1xuICB9XG4gIHN0YXRpYyBpc0hlZGVyYUFkZHJlc3MoYWRkcmVzcykge1xuICAgIHJldHVybiBhZGRyZXNzLnN0YXJ0c1dpdGgoXCIwLlwiKSB8fCBhZGRyZXNzLnN0YXJ0c1dpdGgoXCIwLjAuXCIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBnZXRIZWRlcmFFVk1BZGRyZXNzKGFkZHJlc3MsIG1pcnJvck5vZGUpIHtcbiAgICBpZiAoIV9BY2NvdW50UmVzb2x2ZXIuaXNIZWRlcmFBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG4gICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IG1pcnJvck5vZGUuZ2V0QWNjb3VudChhZGRyZXNzKTtcbiAgICByZXR1cm4gYWNjb3VudC5ldm1BZGRyZXNzO1xuICB9XG59O1xuXG4vLyBzcmMvc2hhcmVkL2hlZGVyYS11dGlscy9oZWRlcmEtcGFyYW1ldGVyLW5vcm1hbGlzZXIudHNcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gXCJldGhlcnNcIjtcblxuLy8gc3JjL3NoYXJlZC9wYXJhbWV0ZXItc2NoZW1hcy9ldm0uem9kLnRzXG5pbXBvcnQgeyB6IGFzIHo0IH0gZnJvbSBcInpvZFwiO1xudmFyIHRyYW5zZmVyRVJDMjBQYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHo0Lm9iamVjdCh7XG4gIGNvbnRyYWN0SWQ6IHo0LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGlkIG9mIHRoZSBFUkMyMCBjb250cmFjdC5cIiksXG4gIHJlY2lwaWVudEFkZHJlc3M6IHo0LnN0cmluZygpLmRlc2NyaWJlKFwiQWRkcmVzcyB0byB3aGljaCB0aGUgdG9rZW5zIHdpbGwgYmUgdHJhbnNmZXJyZWQuXCIpLFxuICBhbW91bnQ6IHo0Lm51bWJlcigpLmRlc2NyaWJlKFwiVGhlIGFtb3VudCBvZiB0b2tlbnMgdG8gdHJhbnNmZXIuXCIpXG59KTtcbnZhciBjcmVhdGVFUkM3MjFQYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHo0Lm9iamVjdCh7XG4gIHRva2VuTmFtZTogejQuc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgbmFtZSBvZiB0aGUgdG9rZW4uXCIpLFxuICB0b2tlblN5bWJvbDogejQuc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgc3ltYm9sIG9mIHRoZSB0b2tlbi5cIiksXG4gIGJhc2VVUkk6IHo0LnN0cmluZygpLmRlZmF1bHQoXCJcIikuZGVzY3JpYmUoXCJUaGUgYmFzZSBVUkkgZm9yIHRva2VuIG1ldGFkYXRhLlwiKVxufSk7XG52YXIgY3JlYXRlRVJDMjBQYXJhbWV0ZXJzID0gKF9jb250ZXh0ID0ge30pID0+IHo0Lm9iamVjdCh7XG4gIHRva2VuTmFtZTogejQuc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgbmFtZSBvZiB0aGUgdG9rZW4uXCIpLFxuICB0b2tlblN5bWJvbDogejQuc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgc3ltYm9sIG9mIHRoZSB0b2tlbi5cIiksXG4gIGRlY2ltYWxzOiB6NC5udW1iZXIoKS5pbnQoKS5taW4oMCkub3B0aW9uYWwoKS5kZWZhdWx0KDE4KS5kZXNjcmliZShcIlRoZSBudW1iZXIgb2YgZGVjaW1hbHMgdGhlIHRva2VuIHN1cHBvcnRzLlwiKSxcbiAgaW5pdGlhbFN1cHBseTogejQubnVtYmVyKCkuaW50KCkubWluKDApLm9wdGlvbmFsKCkuZGVmYXVsdCgwKS5kZXNjcmliZShcIlRoZSBpbml0aWFsIHN1cHBseSBvZiB0aGUgdG9rZW4uXCIpXG59KTtcbnZhciB0cmFuc2ZlckVSQzcyMVBhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4gejQub2JqZWN0KHtcbiAgY29udHJhY3RJZDogejQuc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgaWQgb2YgdGhlIEVSQzcyMSBjb250cmFjdC5cIiksXG4gIGZyb21BZGRyZXNzOiB6NC5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiQWRkcmVzcyBmcm9tIHdoaWNoIHRoZSB0b2tlbiB3aWxsIGJlIHRyYW5zZmVycmVkLlwiKSxcbiAgdG9BZGRyZXNzOiB6NC5zdHJpbmcoKS5kZXNjcmliZShcIkFkZHJlc3MgdG8gd2hpY2ggdGhlIHRva2VuIHdpbGwgYmUgdHJhbnNmZXJyZWQuXCIpLFxuICB0b2tlbklkOiB6NC5udW1iZXIoKS5kZXNjcmliZShcIlRoZSBJRCBvZiB0aGUgdG9rZW4gdG8gdHJhbnNmZXIuXCIpXG59KTtcbnZhciBtaW50RVJDNzIxUGFyYW1ldGVycyA9IChfY29udGV4dCA9IHt9KSA9PiB6NC5vYmplY3Qoe1xuICBjb250cmFjdElkOiB6NC5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBpZCBvZiB0aGUgRVJDNzIxIGNvbnRyYWN0LlwiKSxcbiAgdG9BZGRyZXNzOiB6NC5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiQWRkcmVzcyB0byB3aGljaCB0aGUgdG9rZW4gd2lsbCBiZSBtaW50ZWQuXCIpXG59KTtcbnZhciBjb250cmFjdEluZm9RdWVyeVBhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4gejQub2JqZWN0KHtcbiAgY29udHJhY3RJZDogejQuc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgdG9rZW4gSUQgdG8gcXVlcnkuXCIpXG59KTtcblxuLy8gc3JjL3NoYXJlZC9wYXJhbWV0ZXItc2NoZW1hcy90cmFuc2FjdGlvbi56b2QudHNcbmltcG9ydCB7IHogYXMgejUgfSBmcm9tIFwiem9kXCI7XG52YXIgdHJhbnNhY3Rpb25SZWNvcmRRdWVyeVBhcmFtZXRlcnMgPSAoX2NvbnRleHQgPSB7fSkgPT4ge1xuICByZXR1cm4gejUub2JqZWN0KHtcbiAgICB0cmFuc2FjdGlvbklkOiB6NS5zdHJpbmcoKS5kZXNjcmliZShcbiAgICAgICdUaGUgdHJhbnNhY3Rpb24gSUQgdG8gZmV0Y2ggZGV0YWlscyBmb3IuIFNob3VsZCBiZSBpbiBmb3JtYXQgXFxcXFwic2hhcmQucmVhbG0ubnVtLXNzcy1ubm5cXFxcXCIgZm9ybWF0IHdoZXJlIHNzcyBhcmUgc2Vjb25kcyBhbmQgbm5uIGFyZSBuYW5vc2Vjb25kcydcbiAgICApLFxuICAgIG5vbmNlOiB6NS5udW1iZXIoKS5ub25uZWdhdGl2ZSgpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJPcHRpb25hbCBub25uZWdhdGl2ZSBub25jZSB2YWx1ZSBmb3IgdGhlIHRyYW5zYWN0aW9uXCIpXG4gIH0pO1xufTtcblxuLy8gc3JjL3NoYXJlZC9oZWRlcmEtdXRpbHMvaGVkZXJhLXBhcmFtZXRlci1ub3JtYWxpc2VyLnRzXG52YXIgSGVkZXJhUGFyYW1ldGVyTm9ybWFsaXNlciA9IGNsYXNzIF9IZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyIHtcbiAgc3RhdGljIHBhcnNlUGFyYW1zV2l0aFNjaGVtYShwYXJhbXMsIHNjaGVtYSwgY29udGV4dCA9IHt9KSB7XG4gICAgbGV0IHBhcnNlZFBhcmFtcztcbiAgICB0cnkge1xuICAgICAgcGFyc2VkUGFyYW1zID0gc2NoZW1hKGNvbnRleHQpLnBhcnNlKHBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiB6Ni5ab2RFcnJvcikge1xuICAgICAgICBjb25zdCBpc3N1ZXMgPSB0aGlzLmZvcm1hdFpvZElzc3VlcyhlKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtZXRlcnM6ICR7aXNzdWVzfWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZFBhcmFtcztcbiAgfVxuICBzdGF0aWMgZm9ybWF0Wm9kSXNzdWVzKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLmVycm9ycy5tYXAoKGVycikgPT4gYEZpZWxkIFwiJHtlcnIucGF0aC5qb2luKFwiLlwiKX1cIiAtICR7ZXJyLm1lc3NhZ2V9YCkuam9pbihcIjsgXCIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBub3JtYWxpc2VDcmVhdGVGdW5naWJsZVRva2VuUGFyYW1zKHBhcmFtcywgY29udGV4dCwgY2xpZW50LCBtaXJyb3JOb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkUGFyYW1zID0gdGhpcy5wYXJzZVBhcmFtc1dpdGhTY2hlbWEocGFyYW1zLCBjcmVhdGVGdW5naWJsZVRva2VuUGFyYW1ldGVycywgY29udGV4dCk7XG4gICAgY29uc3QgZGVmYXVsdEFjY291bnRJZCA9IEFjY291bnRSZXNvbHZlci5nZXREZWZhdWx0QWNjb3VudChjb250ZXh0LCBjbGllbnQpO1xuICAgIGNvbnN0IHRyZWFzdXJ5QWNjb3VudElkID0gcGFyc2VkUGFyYW1zLnRyZWFzdXJ5QWNjb3VudElkID8/IGRlZmF1bHRBY2NvdW50SWQ7XG4gICAgaWYgKCF0cmVhc3VyeUFjY291bnRJZCkgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBpbmNsdWRlIHRyZWFzdXJ5IGFjY291bnQgSURcIik7XG4gICAgY29uc3QgaW5pdGlhbFN1cHBseSA9IHRvQmFzZVVuaXQoXG4gICAgICBwYXJzZWRQYXJhbXMuaW5pdGlhbFN1cHBseSA/PyAwLFxuICAgICAgcGFyc2VkUGFyYW1zLmRlY2ltYWxzXG4gICAgKS50b051bWJlcigpO1xuICAgIGNvbnN0IGlzRmluaXRlID0gKHBhcnNlZFBhcmFtcy5zdXBwbHlUeXBlID8/IFwiaW5maW5pdGVcIikgPT09IFwiZmluaXRlXCI7XG4gICAgY29uc3Qgc3VwcGx5VHlwZSA9IGlzRmluaXRlID8gVG9rZW5TdXBwbHlUeXBlMi5GaW5pdGUgOiBUb2tlblN1cHBseVR5cGUyLkluZmluaXRlO1xuICAgIGNvbnN0IG1heFN1cHBseSA9IGlzRmluaXRlID8gdG9CYXNlVW5pdChwYXJzZWRQYXJhbXMubWF4U3VwcGx5ID8/IDFlNiwgcGFyc2VkUGFyYW1zLmRlY2ltYWxzKS50b051bWJlcigpIDogdm9pZCAwO1xuICAgIGlmIChtYXhTdXBwbHkgIT09IHZvaWQgMCAmJiBpbml0aWFsU3VwcGx5ID4gbWF4U3VwcGx5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluaXRpYWwgc3VwcGx5ICgke2luaXRpYWxTdXBwbHl9KSBjYW5ub3QgZXhjZWVkIG1heCBzdXBwbHkgKCR7bWF4U3VwcGx5fSlgKTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgbWlycm9yTm9kZS5nZXRBY2NvdW50KGRlZmF1bHRBY2NvdW50SWQpLnRoZW4oKHIpID0+IHIuYWNjb3VudFB1YmxpY0tleSkgPz8gY2xpZW50Lm9wZXJhdG9yUHVibGljS2V5Py50b1N0cmluZ0RlcigpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wYXJzZWRQYXJhbXMsXG4gICAgICBzdXBwbHlUeXBlLFxuICAgICAgdHJlYXN1cnlBY2NvdW50SWQsXG4gICAgICBtYXhTdXBwbHksXG4gICAgICBpbml0aWFsU3VwcGx5LFxuICAgICAgYXV0b1JlbmV3QWNjb3VudElkOiBkZWZhdWx0QWNjb3VudElkLFxuICAgICAgc3VwcGx5S2V5OiBwYXJzZWRQYXJhbXMuaXNTdXBwbHlLZXkgPT09IHRydWUgPyBQdWJsaWNLZXk0LmZyb21TdHJpbmcocHVibGljS2V5KSA6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIG5vcm1hbGlzZUNyZWF0ZU5vbkZ1bmdpYmxlVG9rZW5QYXJhbXMocGFyYW1zLCBjb250ZXh0LCBjbGllbnQsIG1pcnJvck5vZGUpIHtcbiAgICBjb25zdCBwYXJzZWRQYXJhbXMgPSB0aGlzLnBhcnNlUGFyYW1zV2l0aFNjaGVtYShwYXJhbXMsIGNyZWF0ZU5vbkZ1bmdpYmxlVG9rZW5QYXJhbWV0ZXJzLCBjb250ZXh0KTtcbiAgICBjb25zdCBkZWZhdWx0QWNjb3VudElkID0gQWNjb3VudFJlc29sdmVyLmdldERlZmF1bHRBY2NvdW50KGNvbnRleHQsIGNsaWVudCk7XG4gICAgY29uc3QgdHJlYXN1cnlBY2NvdW50SWQgPSBwYXJzZWRQYXJhbXMudHJlYXN1cnlBY2NvdW50SWQgPz8gZGVmYXVsdEFjY291bnRJZDtcbiAgICBpZiAoIXRyZWFzdXJ5QWNjb3VudElkKSB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IGluY2x1ZGUgdHJlYXN1cnkgYWNjb3VudCBJRFwiKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCBtaXJyb3JOb2RlLmdldEFjY291bnQoZGVmYXVsdEFjY291bnRJZCkudGhlbigocikgPT4gci5hY2NvdW50UHVibGljS2V5KSA/PyBjbGllbnQub3BlcmF0b3JQdWJsaWNLZXk/LnRvU3RyaW5nRGVyKCk7XG4gICAgaWYgKCFwdWJsaWNLZXkpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlcm1pbmUgcHVibGljIGtleSBmb3Igc3VwcGx5IGtleVwiKTtcbiAgICBjb25zdCBtYXhTdXBwbHkgPSBwYXJzZWRQYXJhbXMubWF4U3VwcGx5ID8/IDEwMDtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFyc2VkUGFyYW1zLFxuICAgICAgdHJlYXN1cnlBY2NvdW50SWQsXG4gICAgICBtYXhTdXBwbHksXG4gICAgICBzdXBwbHlLZXk6IFB1YmxpY0tleTQuZnJvbVN0cmluZyhwdWJsaWNLZXkpLFxuICAgICAgLy8gdGhlIHN1cHBseSBrZXkgaXMgbWFuZGF0b3J5IGluIHRoZSBjYXNlIG9mIE5GVFxuICAgICAgc3VwcGx5VHlwZTogVG9rZW5TdXBwbHlUeXBlMi5GaW5pdGUsXG4gICAgICAvLyBORlRzIHN1cHBseSBtdXN0IGJlIGZpbml0ZVxuICAgICAgYXV0b1JlbmV3QWNjb3VudElkOiBkZWZhdWx0QWNjb3VudElkLFxuICAgICAgdG9rZW5UeXBlOiBUb2tlblR5cGUyLk5vbkZ1bmdpYmxlVW5pcXVlXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgbm9ybWFsaXNlVHJhbnNmZXJIYmFyKHBhcmFtcywgY29udGV4dCwgY2xpZW50KSB7XG4gICAgY29uc3QgcGFyc2VkUGFyYW1zID0gdGhpcy5wYXJzZVBhcmFtc1dpdGhTY2hlbWEocGFyYW1zLCB0cmFuc2ZlckhiYXJQYXJhbWV0ZXJzLCBjb250ZXh0KTtcbiAgICBjb25zdCBzb3VyY2VBY2NvdW50SWQgPSBBY2NvdW50UmVzb2x2ZXIucmVzb2x2ZUFjY291bnQoXG4gICAgICBwYXJzZWRQYXJhbXMuc291cmNlQWNjb3VudElkLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNsaWVudFxuICAgICk7XG4gICAgY29uc3QgaGJhclRyYW5zZmVycyA9IFtdO1xuICAgIGxldCB0b3RhbFRpbnliYXJzID0gTG9uZzIuWkVSTztcbiAgICBmb3IgKGNvbnN0IHRyYW5zZmVyIG9mIHBhcnNlZFBhcmFtcy50cmFuc2ZlcnMpIHtcbiAgICAgIGNvbnN0IGFtb3VudCA9IG5ldyBIYmFyMih0cmFuc2Zlci5hbW91bnQpO1xuICAgICAgaWYgKGFtb3VudC5pc05lZ2F0aXZlKCkgfHwgYW1vdW50LnRvVGlueWJhcnMoKS5lcXVhbHMoTG9uZzIuWkVSTykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGFtb3VudDogJHt0cmFuc2Zlci5hbW91bnR9YCk7XG4gICAgICB9XG4gICAgICB0b3RhbFRpbnliYXJzID0gdG90YWxUaW55YmFycy5hZGQoYW1vdW50LnRvVGlueWJhcnMoKSk7XG4gICAgICBoYmFyVHJhbnNmZXJzLnB1c2goe1xuICAgICAgICBhY2NvdW50SWQ6IHRyYW5zZmVyLmFjY291bnRJZCxcbiAgICAgICAgYW1vdW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgaGJhclRyYW5zZmVycy5wdXNoKHtcbiAgICAgIGFjY291bnRJZDogc291cmNlQWNjb3VudElkLFxuICAgICAgYW1vdW50OiBIYmFyMi5mcm9tVGlueWJhcnModG90YWxUaW55YmFycy5uZWdhdGUoKSlcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaGJhclRyYW5zZmVycyxcbiAgICAgIHRyYW5zYWN0aW9uTWVtbzogcGFyc2VkUGFyYW1zLnRyYW5zYWN0aW9uTWVtb1xuICAgIH07XG4gIH1cbiAgc3RhdGljIG5vcm1hbGlzZUFwcHJvdmVIYmFyQWxsb3dhbmNlKHBhcmFtcywgY29udGV4dCwgY2xpZW50KSB7XG4gICAgY29uc3QgcGFyc2VkUGFyYW1zID0gdGhpcy5wYXJzZVBhcmFtc1dpdGhTY2hlbWEocGFyYW1zLCBhcHByb3ZlSGJhckFsbG93YW5jZVBhcmFtZXRlcnMsIGNvbnRleHQpO1xuICAgIGNvbnN0IG93bmVyQWNjb3VudElkID0gQWNjb3VudFJlc29sdmVyLnJlc29sdmVBY2NvdW50KFxuICAgICAgcGFyc2VkUGFyYW1zLm93bmVyQWNjb3VudElkLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNsaWVudFxuICAgICk7XG4gICAgY29uc3Qgc3BlbmRlckFjY291bnRJZCA9IHBhcnNlZFBhcmFtcy5zcGVuZGVyQWNjb3VudElkO1xuICAgIGNvbnN0IGFtb3VudCA9IG5ldyBIYmFyMihwYXJzZWRQYXJhbXMuYW1vdW50KTtcbiAgICBpZiAoYW1vdW50LmlzTmVnYXRpdmUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFsbG93YW5jZSBhbW91bnQ6ICR7cGFyc2VkUGFyYW1zLmFtb3VudH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGhiYXJBcHByb3ZhbHM6IFtcbiAgICAgICAgbmV3IEhiYXJBbGxvd2FuY2UyKHtcbiAgICAgICAgICBvd25lckFjY291bnRJZDogQWNjb3VudElkNC5mcm9tU3RyaW5nKG93bmVyQWNjb3VudElkKSxcbiAgICAgICAgICBzcGVuZGVyQWNjb3VudElkOiBBY2NvdW50SWQ0LmZyb21TdHJpbmcoc3BlbmRlckFjY291bnRJZCksXG4gICAgICAgICAgYW1vdW50XG4gICAgICAgIH0pXG4gICAgICBdLFxuICAgICAgdHJhbnNhY3Rpb25NZW1vOiBwYXJzZWRQYXJhbXMudHJhbnNhY3Rpb25NZW1vXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbm9ybWFsaXNlQWlyZHJvcEZ1bmdpYmxlVG9rZW5QYXJhbXMocGFyYW1zLCBjb250ZXh0LCBjbGllbnQsIG1pcnJvck5vZGUpIHtcbiAgICBjb25zdCBwYXJzZWRQYXJhbXMgPSB0aGlzLnBhcnNlUGFyYW1zV2l0aFNjaGVtYShwYXJhbXMsIGFpcmRyb3BGdW5naWJsZVRva2VuUGFyYW1ldGVycywgY29udGV4dCk7XG4gICAgY29uc3Qgc291cmNlQWNjb3VudElkID0gQWNjb3VudFJlc29sdmVyLnJlc29sdmVBY2NvdW50KFxuICAgICAgcGFyc2VkUGFyYW1zLnNvdXJjZUFjY291bnRJZCxcbiAgICAgIGNvbnRleHQsXG4gICAgICBjbGllbnRcbiAgICApO1xuICAgIGNvbnN0IHRva2VuSW5mbyA9IGF3YWl0IG1pcnJvck5vZGUuZ2V0VG9rZW5JbmZvKHBhcnNlZFBhcmFtcy50b2tlbklkKTtcbiAgICBjb25zdCB0b2tlbkRlY2ltYWxzID0gcGFyc2VJbnQodG9rZW5JbmZvLmRlY2ltYWxzLCAxMCk7XG4gICAgaWYgKGlzTmFOKHRva2VuRGVjaW1hbHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9rZW4gZGVjaW1hbHMgZm9yIHRva2VuICR7cGFyc2VkUGFyYW1zLnRva2VuSWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuVHJhbnNmZXJzID0gW107XG4gICAgbGV0IHRvdGFsQW1vdW50ID0gTG9uZzIuWkVSTztcbiAgICBmb3IgKGNvbnN0IHJlY2lwaWVudCBvZiBwYXJzZWRQYXJhbXMucmVjaXBpZW50cykge1xuICAgICAgY29uc3QgYW1vdW50UmF3ID0gTnVtYmVyKHJlY2lwaWVudC5hbW91bnQpO1xuICAgICAgaWYgKGFtb3VudFJhdyA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZWNpcGllbnQgYW1vdW50OiAke3JlY2lwaWVudC5hbW91bnR9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBhbW91bnQgPSBMb25nMi5mcm9tU3RyaW5nKHRvQmFzZVVuaXQoYW1vdW50UmF3LCB0b2tlbkRlY2ltYWxzKS50b051bWJlcigpLnRvU3RyaW5nKCkpO1xuICAgICAgdG90YWxBbW91bnQgPSB0b3RhbEFtb3VudC5hZGQoYW1vdW50KTtcbiAgICAgIHRva2VuVHJhbnNmZXJzLnB1c2goe1xuICAgICAgICB0b2tlbklkOiBwYXJzZWRQYXJhbXMudG9rZW5JZCxcbiAgICAgICAgYWNjb3VudElkOiByZWNpcGllbnQuYWNjb3VudElkLFxuICAgICAgICBhbW91bnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0b2tlblRyYW5zZmVycy5wdXNoKHtcbiAgICAgIHRva2VuSWQ6IHBhcnNlZFBhcmFtcy50b2tlbklkLFxuICAgICAgYWNjb3VudElkOiBzb3VyY2VBY2NvdW50SWQsXG4gICAgICBhbW91bnQ6IHRvdGFsQW1vdW50Lm5lZ2F0ZSgpXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuVHJhbnNmZXJzXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgbm9ybWFsaXNlQXNzb2NpYXRlVG9rZW5QYXJhbXMocGFyYW1zLCBjb250ZXh0LCBjbGllbnQpIHtcbiAgICBjb25zdCBwYXJzZWRQYXJhbXMgPSB0aGlzLnBhcnNlUGFyYW1zV2l0aFNjaGVtYShwYXJhbXMsIGFzc29jaWF0ZVRva2VuUGFyYW1ldGVycywgY29udGV4dCk7XG4gICAgY29uc3QgYWNjb3VudElkID0gQWNjb3VudFJlc29sdmVyLnJlc29sdmVBY2NvdW50KHBhcnNlZFBhcmFtcy5hY2NvdW50SWQsIGNvbnRleHQsIGNsaWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRJZCxcbiAgICAgIHRva2VuSWRzOiBwYXJzZWRQYXJhbXMudG9rZW5JZHNcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBhc3luYyBub3JtYWxpc2VEaXNzb2NpYXRlVG9rZW5QYXJhbXMocGFyYW1zLCBjb250ZXh0LCBjbGllbnQpIHtcbiAgICBjb25zdCBwYXJzZWRQYXJhbXMgPSB0aGlzLnBhcnNlUGFyYW1zV2l0aFNjaGVtYShwYXJhbXMsIGRpc3NvY2lhdGVUb2tlblBhcmFtZXRlcnMsIGNvbnRleHQpO1xuICAgIGlmIChwYXJzZWRQYXJhbXMuYWNjb3VudElkID09PSB2b2lkIDApIHtcbiAgICAgIHBhcnNlZFBhcmFtcy5hY2NvdW50SWQgPSBBY2NvdW50UmVzb2x2ZXIuZ2V0RGVmYXVsdEFjY291bnQoY29udGV4dCwgY2xpZW50KTtcbiAgICAgIGlmICghcGFyc2VkUGFyYW1zLmFjY291bnRJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIGRlZmF1bHQgYWNjb3VudCBJRFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcnNlZFBhcmFtcyxcbiAgICAgIGFjY291bnRJZDogQWNjb3VudElkNC5mcm9tU3RyaW5nKHBhcnNlZFBhcmFtcy5hY2NvdW50SWQpLFxuICAgICAgdG9rZW5JZHM6IHBhcnNlZFBhcmFtcy50b2tlbklkcy5tYXAoKGlkKSA9PiBUb2tlbklkMi5mcm9tU3RyaW5nKGlkKSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBhc3luYyBub3JtYWxpc2VDcmVhdGVUb3BpY1BhcmFtcyhwYXJhbXMsIGNvbnRleHQsIGNsaWVudCwgbWlycm9yTm9kZSkge1xuICAgIGNvbnN0IHBhcnNlZFBhcmFtcyA9IHRoaXMucGFyc2VQYXJhbXNXaXRoU2NoZW1hKHBhcmFtcywgY3JlYXRlVG9waWNQYXJhbWV0ZXJzLCBjb250ZXh0KTtcbiAgICBjb25zdCBkZWZhdWx0QWNjb3VudElkID0gQWNjb3VudFJlc29sdmVyLmdldERlZmF1bHRBY2NvdW50KGNvbnRleHQsIGNsaWVudCk7XG4gICAgaWYgKCFkZWZhdWx0QWNjb3VudElkKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIGRlZmF1bHQgYWNjb3VudCBJRFwiKTtcbiAgICBjb25zdCBub3JtYWxpc2VkID0ge1xuICAgICAgLi4ucGFyc2VkUGFyYW1zLFxuICAgICAgYXV0b1JlbmV3QWNjb3VudElkOiBkZWZhdWx0QWNjb3VudElkXG4gICAgfTtcbiAgICBpZiAocGFyc2VkUGFyYW1zLmlzU3VibWl0S2V5KSB7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCBtaXJyb3JOb2RlLmdldEFjY291bnQoZGVmYXVsdEFjY291bnRJZCkudGhlbigocikgPT4gci5hY2NvdW50UHVibGljS2V5KSA/PyBjbGllbnQub3BlcmF0b3JQdWJsaWNLZXk/LnRvU3RyaW5nRGVyKCk7XG4gICAgICBpZiAoIXB1YmxpY0tleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIHB1YmxpYyBrZXkgZm9yIHN1Ym1pdCBrZXlcIik7XG4gICAgICB9XG4gICAgICBub3JtYWxpc2VkLnN1Ym1pdEtleSA9IFB1YmxpY0tleTQuZnJvbVN0cmluZyhwdWJsaWNLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXNlZDtcbiAgfVxuICBzdGF0aWMgbm9ybWFsaXNlRGVsZXRlVG9waWMocGFyYW1zLCBjb250ZXh0LCBfY2xpZW50LCBfbWlycm9yTm9kZSkge1xuICAgIGNvbnN0IHBhcnNlZFBhcmFtcyA9IHRoaXMucGFyc2VQYXJhbXNXaXRoU2NoZW1hKHBhcmFtcywgZGVsZXRlVG9waWNQYXJhbWV0ZXJzLCBjb250ZXh0KTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBhcmFtc1dpdGhTY2hlbWEocGFyc2VkUGFyYW1zLCBkZWxldGVUb3BpY1BhcmFtZXRlcnNOb3JtYWxpc2VkLCBjb250ZXh0KTtcbiAgfVxuICBzdGF0aWMgbm9ybWFsaXNlVXBkYXRlVG9waWMgPSBhc3luYyAocGFyYW1zLCBjb250ZXh0LCBjbGllbnQpID0+IHtcbiAgICBjb25zdCBwYXJzZWRQYXJhbXMgPSB0aGlzLnBhcnNlUGFyYW1zV2l0aFNjaGVtYShwYXJhbXMsIHVwZGF0ZVRvcGljUGFyYW1ldGVycywgY29udGV4dCk7XG4gICAgY29uc3QgdG9waWNJZCA9IFRvcGljSWQyLmZyb21TdHJpbmcocGFyc2VkUGFyYW1zLnRvcGljSWQpO1xuICAgIGNvbnN0IHVzZXJQdWJsaWNLZXkgPSBhd2FpdCBBY2NvdW50UmVzb2x2ZXIuZ2V0RGVmYXVsdFB1YmxpY0tleShjb250ZXh0LCBjbGllbnQpO1xuICAgIGNvbnN0IG5vcm1hbGlzZWQgPSB7XG4gICAgICB0b3BpY0lkXG4gICAgfTtcbiAgICBjb25zdCBtYXliZUtleXMgPSB7XG4gICAgICBhZG1pbktleTogcGFyc2VkUGFyYW1zLmFkbWluS2V5LFxuICAgICAgc3VibWl0S2V5OiBwYXJzZWRQYXJhbXMuc3VibWl0S2V5XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZCwgcmF3VmFsXSBvZiBPYmplY3QuZW50cmllcyhtYXliZUtleXMpKSB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZUtleShyYXdWYWwsIHVzZXJQdWJsaWNLZXkpO1xuICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgIG5vcm1hbGlzZWRbZmllbGRdID0gcmVzb2x2ZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzZWRQYXJhbXMudG9waWNNZW1vKSBub3JtYWxpc2VkLnRvcGljTWVtbyA9IHBhcnNlZFBhcmFtcy50b3BpY01lbW87XG4gICAgaWYgKHBhcnNlZFBhcmFtcy5hdXRvUmVuZXdBY2NvdW50SWQpXG4gICAgICBub3JtYWxpc2VkLmF1dG9SZW5ld0FjY291bnRJZCA9IHBhcnNlZFBhcmFtcy5hdXRvUmVuZXdBY2NvdW50SWQ7XG4gICAgaWYgKHBhcnNlZFBhcmFtcy5hdXRvUmVuZXdQZXJpb2QpIG5vcm1hbGlzZWQuYXV0b1JlbmV3UGVyaW9kID0gcGFyc2VkUGFyYW1zLmF1dG9SZW5ld1BlcmlvZDtcbiAgICBpZiAocGFyc2VkUGFyYW1zLmV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBub3JtYWxpc2VkLmV4cGlyYXRpb25UaW1lID0gcGFyc2VkUGFyYW1zLmV4cGlyYXRpb25UaW1lIGluc3RhbmNlb2YgRGF0ZSA/IHBhcnNlZFBhcmFtcy5leHBpcmF0aW9uVGltZSA6IG5ldyBEYXRlKHBhcnNlZFBhcmFtcy5leHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpc2VkO1xuICB9O1xuICBzdGF0aWMgYXN5bmMgbm9ybWFsaXNlQ3JlYXRlQWNjb3VudChwYXJhbXMsIGNvbnRleHQsIGNsaWVudCwgbWlycm9yTm9kZSkge1xuICAgIGNvbnN0IHBhcnNlZFBhcmFtcyA9IHRoaXMucGFyc2VQYXJhbXNXaXRoU2NoZW1hKHBhcmFtcywgY3JlYXRlQWNjb3VudFBhcmFtZXRlcnMsIGNvbnRleHQpO1xuICAgIGxldCBwdWJsaWNLZXkgPSBwYXJzZWRQYXJhbXMucHVibGljS2V5ID8/IGNsaWVudC5vcGVyYXRvclB1YmxpY0tleT8udG9TdHJpbmdEZXIoKTtcbiAgICBpZiAoIXB1YmxpY0tleSkge1xuICAgICAgY29uc3QgZGVmYXVsdEFjY291bnRJZCA9IEFjY291bnRSZXNvbHZlci5nZXREZWZhdWx0QWNjb3VudChjb250ZXh0LCBjbGllbnQpO1xuICAgICAgaWYgKGRlZmF1bHRBY2NvdW50SWQpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IG1pcnJvck5vZGUuZ2V0QWNjb3VudChkZWZhdWx0QWNjb3VudElkKTtcbiAgICAgICAgcHVibGljS2V5ID0gYWNjb3VudD8uYWNjb3VudFB1YmxpY0tleTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFwdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJVbmFibGUgdG8gcmVzb2x2ZSBwdWJsaWMga2V5OiBubyBwYXJhbSwgbWlycm9yIG5vZGUsIG9yIGNsaWVudCBvcGVyYXRvciBrZXkgYXZhaWxhYmxlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFyc2VkUGFyYW1zLFxuICAgICAga2V5OiBQdWJsaWNLZXk0LmZyb21TdHJpbmcocHVibGljS2V5KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIG5vcm1hbGlzZUhiYXJCYWxhbmNlUGFyYW1zKHBhcmFtcywgY29udGV4dCwgY2xpZW50KSB7XG4gICAgY29uc3QgcGFyc2VkUGFyYW1zID0gdGhpcy5wYXJzZVBhcmFtc1dpdGhTY2hlbWEocGFyYW1zLCBhY2NvdW50QmFsYW5jZVF1ZXJ5UGFyYW1ldGVycywgY29udGV4dCk7XG4gICAgY29uc3QgYWNjb3VudElkID0gQWNjb3VudFJlc29sdmVyLnJlc29sdmVBY2NvdW50KHBhcnNlZFBhcmFtcy5hY2NvdW50SWQsIGNvbnRleHQsIGNsaWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcnNlZFBhcmFtcyxcbiAgICAgIGFjY291bnRJZFxuICAgIH07XG4gIH1cbiAgc3RhdGljIG5vcm1hbGlzZUFjY291bnRUb2tlbkJhbGFuY2VzUGFyYW1zKHBhcmFtcywgY29udGV4dCwgY2xpZW50KSB7XG4gICAgY29uc3QgcGFyc2VkUGFyYW1zID0gdGhpcy5wYXJzZVBhcmFtc1dpdGhTY2hlbWEocGFyYW1zLCBhY2NvdW50VG9rZW5CYWxhbmNlc1F1ZXJ5UGFyYW1ldGVycywgY29udGV4dCk7XG4gICAgY29uc3QgYWNjb3VudElkID0gQWNjb3VudFJlc29sdmVyLnJlc29sdmVBY2NvdW50KHBhcnNlZFBhcmFtcy5hY2NvdW50SWQsIGNvbnRleHQsIGNsaWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcnNlZFBhcmFtcyxcbiAgICAgIGFjY291bnRJZFxuICAgIH07XG4gIH1cbiAgc3RhdGljIG5vcm1hbGlzZUNyZWF0ZUVSQzIwUGFyYW1zKHBhcmFtcywgZmFjdG9yeUNvbnRyYWN0SWQsIGZhY3RvcnlDb250cmFjdEFiaSwgZmFjdG9yeUNvbnRyYWN0RnVuY3Rpb25OYW1lLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcGFyc2VkUGFyYW1zID0gdGhpcy5wYXJzZVBhcmFtc1dpdGhTY2hlbWEocGFyYW1zLCBjcmVhdGVFUkMyMFBhcmFtZXRlcnMsIGNvbnRleHQpO1xuICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoZmFjdG9yeUNvbnRyYWN0QWJpKTtcbiAgICBjb25zdCBlbmNvZGVkRGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmYWN0b3J5Q29udHJhY3RGdW5jdGlvbk5hbWUsIFtcbiAgICAgIHBhcnNlZFBhcmFtcy50b2tlbk5hbWUsXG4gICAgICBwYXJzZWRQYXJhbXMudG9rZW5TeW1ib2wsXG4gICAgICBwYXJzZWRQYXJhbXMuZGVjaW1hbHMsXG4gICAgICBwYXJzZWRQYXJhbXMuaW5pdGlhbFN1cHBseVxuICAgIF0pO1xuICAgIGNvbnN0IGZ1bmN0aW9uUGFyYW1ldGVycyA9IGV0aGVycy5nZXRCeXRlcyhlbmNvZGVkRGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcnNlZFBhcmFtcyxcbiAgICAgIGNvbnRyYWN0SWQ6IGZhY3RvcnlDb250cmFjdElkLFxuICAgICAgZnVuY3Rpb25QYXJhbWV0ZXJzLFxuICAgICAgZ2FzOiAzZTZcbiAgICAgIC8vVE9ETzogbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuICAgIH07XG4gIH1cbiAgc3RhdGljIG5vcm1hbGlzZUNyZWF0ZUVSQzcyMVBhcmFtcyhwYXJhbXMsIGZhY3RvcnlDb250cmFjdElkLCBmYWN0b3J5Q29udHJhY3RBYmksIGZhY3RvcnlDb250cmFjdEZ1bmN0aW9uTmFtZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHBhcnNlZFBhcmFtcyA9IHRoaXMucGFyc2VQYXJhbXNXaXRoU2NoZW1hKHBhcmFtcywgY3JlYXRlRVJDNzIxUGFyYW1ldGVycywgY29udGV4dCk7XG4gICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShmYWN0b3J5Q29udHJhY3RBYmkpO1xuICAgIGNvbnN0IGVuY29kZWREYXRhID0gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZhY3RvcnlDb250cmFjdEZ1bmN0aW9uTmFtZSwgW1xuICAgICAgcGFyc2VkUGFyYW1zLnRva2VuTmFtZSxcbiAgICAgIHBhcnNlZFBhcmFtcy50b2tlblN5bWJvbCxcbiAgICAgIHBhcnNlZFBhcmFtcy5iYXNlVVJJXG4gICAgXSk7XG4gICAgY29uc3QgZnVuY3Rpb25QYXJhbWV0ZXJzID0gZXRoZXJzLmdldEJ5dGVzKGVuY29kZWREYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFyc2VkUGFyYW1zLFxuICAgICAgY29udHJhY3RJZDogZmFjdG9yeUNvbnRyYWN0SWQsXG4gICAgICBmdW5jdGlvblBhcmFtZXRlcnMsXG4gICAgICBnYXM6IDNlNlxuICAgICAgLy9UT0RPOiBtYWtlIHRoaXMgY29uZmlndXJhYmxlXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbm9ybWFsaXNlTWludEZ1bmdpYmxlVG9rZW5QYXJhbXMocGFyYW1zLCBjb250ZXh0LCBtaXJyb3JOb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkUGFyYW1zID0gdGhpcy5wYXJzZVBhcmFtc1dpdGhTY2hlbWEocGFyYW1zLCBtaW50RnVuZ2libGVUb2tlblBhcmFtZXRlcnMsIGNvbnRleHQpO1xuICAgIGNvbnN0IHRva2VuSW5mbyA9IGF3YWl0IG1pcnJvck5vZGUuZ2V0VG9rZW5JbmZvKHBhcnNlZFBhcmFtcy50b2tlbklkKTtcbiAgICBjb25zdCBkZWNpbWFscyA9IE51bWJlcih0b2tlbkluZm8uZGVjaW1hbHMpO1xuICAgIGNvbnN0IHNhZmVEZWNpbWFscyA9IE51bWJlci5pc0Zpbml0ZShkZWNpbWFscykgPyBkZWNpbWFscyA6IDA7XG4gICAgY29uc3QgYmFzZUFtb3VudCA9IHRvQmFzZVVuaXQocGFyc2VkUGFyYW1zLmFtb3VudCwgc2FmZURlY2ltYWxzKS50b051bWJlcigpO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbklkOiBwYXJzZWRQYXJhbXMudG9rZW5JZCxcbiAgICAgIGFtb3VudDogYmFzZUFtb3VudFxuICAgIH07XG4gIH1cbiAgc3RhdGljIG5vcm1hbGlzZU1pbnROb25GdW5naWJsZVRva2VuUGFyYW1zKHBhcmFtcywgY29udGV4dCkge1xuICAgIGNvbnN0IHBhcnNlZFBhcmFtcyA9IHRoaXMucGFyc2VQYXJhbXNXaXRoU2NoZW1hKHBhcmFtcywgbWludE5vbkZ1bmdpYmxlVG9rZW5QYXJhbWV0ZXJzLCBjb250ZXh0KTtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBwYXJzZWRQYXJhbXMudXJpcy5tYXAoKHVyaSkgPT4gZW5jb2Rlci5lbmNvZGUodXJpKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcnNlZFBhcmFtcyxcbiAgICAgIG1ldGFkYXRhXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbm9ybWFsaXNlVHJhbnNmZXJFUkMyMFBhcmFtcyhwYXJhbXMsIGZhY3RvcnlDb250cmFjdEFiaSwgZmFjdG9yeUNvbnRyYWN0RnVuY3Rpb25OYW1lLCBjb250ZXh0LCBtaXJyb3JOb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkUGFyYW1zID0gdGhpcy5wYXJzZVBhcmFtc1dpdGhTY2hlbWEocGFyYW1zLCB0cmFuc2ZlckVSQzIwUGFyYW1ldGVycywgY29udGV4dCk7XG4gICAgY29uc3QgcmVjaXBpZW50QWRkcmVzcyA9IGF3YWl0IEFjY291bnRSZXNvbHZlci5nZXRIZWRlcmFFVk1BZGRyZXNzKFxuICAgICAgcGFyc2VkUGFyYW1zLnJlY2lwaWVudEFkZHJlc3MsXG4gICAgICBtaXJyb3JOb2RlXG4gICAgKTtcbiAgICBjb25zdCBjb250cmFjdElkID0gYXdhaXQgX0hlZGVyYVBhcmFtZXRlck5vcm1hbGlzZXIuZ2V0SGVkZXJhQWNjb3VudElkKFxuICAgICAgcGFyc2VkUGFyYW1zLmNvbnRyYWN0SWQsXG4gICAgICBtaXJyb3JOb2RlXG4gICAgKTtcbiAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKGZhY3RvcnlDb250cmFjdEFiaSk7XG4gICAgY29uc3QgZW5jb2RlZERhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZmFjdG9yeUNvbnRyYWN0RnVuY3Rpb25OYW1lLCBbXG4gICAgICByZWNpcGllbnRBZGRyZXNzLFxuICAgICAgcGFyc2VkUGFyYW1zLmFtb3VudFxuICAgIF0pO1xuICAgIGNvbnN0IGZ1bmN0aW9uUGFyYW1ldGVycyA9IGV0aGVycy5nZXRCeXRlcyhlbmNvZGVkRGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0SWQsXG4gICAgICBmdW5jdGlvblBhcmFtZXRlcnMsXG4gICAgICBnYXM6IDFlNVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIG5vcm1hbGlzZVRyYW5zZmVyRVJDNzIxUGFyYW1zKHBhcmFtcywgZmFjdG9yeUNvbnRyYWN0QWJpLCBmYWN0b3J5Q29udHJhY3RGdW5jdGlvbk5hbWUsIGNvbnRleHQsIG1pcnJvck5vZGUsIGNsaWVudCkge1xuICAgIGNvbnN0IHBhcnNlZFBhcmFtcyA9IHRoaXMucGFyc2VQYXJhbXNXaXRoU2NoZW1hKHBhcmFtcywgdHJhbnNmZXJFUkM3MjFQYXJhbWV0ZXJzLCBjb250ZXh0KTtcbiAgICBjb25zdCByZXNvbHZlZEZyb21BZGRyZXNzID0gQWNjb3VudFJlc29sdmVyLnJlc29sdmVBY2NvdW50KFxuICAgICAgcGFyc2VkUGFyYW1zLmZyb21BZGRyZXNzLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNsaWVudFxuICAgICk7XG4gICAgY29uc3QgZnJvbUFkZHJlc3MgPSBhd2FpdCBBY2NvdW50UmVzb2x2ZXIuZ2V0SGVkZXJhRVZNQWRkcmVzcyhyZXNvbHZlZEZyb21BZGRyZXNzLCBtaXJyb3JOb2RlKTtcbiAgICBjb25zdCB0b0FkZHJlc3MgPSBhd2FpdCBBY2NvdW50UmVzb2x2ZXIuZ2V0SGVkZXJhRVZNQWRkcmVzcyhwYXJzZWRQYXJhbXMudG9BZGRyZXNzLCBtaXJyb3JOb2RlKTtcbiAgICBjb25zdCBjb250cmFjdElkID0gYXdhaXQgX0hlZGVyYVBhcmFtZXRlck5vcm1hbGlzZXIuZ2V0SGVkZXJhQWNjb3VudElkKFxuICAgICAgcGFyc2VkUGFyYW1zLmNvbnRyYWN0SWQsXG4gICAgICBtaXJyb3JOb2RlXG4gICAgKTtcbiAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKGZhY3RvcnlDb250cmFjdEFiaSk7XG4gICAgY29uc3QgZW5jb2RlZERhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZmFjdG9yeUNvbnRyYWN0RnVuY3Rpb25OYW1lLCBbXG4gICAgICBmcm9tQWRkcmVzcyxcbiAgICAgIHRvQWRkcmVzcyxcbiAgICAgIHBhcnNlZFBhcmFtcy50b2tlbklkXG4gICAgXSk7XG4gICAgY29uc3QgZnVuY3Rpb25QYXJhbWV0ZXJzID0gZXRoZXJzLmdldEJ5dGVzKGVuY29kZWREYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udHJhY3RJZCxcbiAgICAgIGZ1bmN0aW9uUGFyYW1ldGVycyxcbiAgICAgIGdhczogMWU1XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbm9ybWFsaXNlTWludEVSQzcyMVBhcmFtcyhwYXJhbXMsIGZhY3RvcnlDb250cmFjdEFiaSwgZmFjdG9yeUNvbnRyYWN0RnVuY3Rpb25OYW1lLCBjb250ZXh0LCBtaXJyb3JOb2RlLCBjbGllbnQpIHtcbiAgICBjb25zdCBwYXJzZWRQYXJhbXMgPSB0aGlzLnBhcnNlUGFyYW1zV2l0aFNjaGVtYShwYXJhbXMsIG1pbnRFUkM3MjFQYXJhbWV0ZXJzLCBjb250ZXh0KTtcbiAgICBjb25zdCByZXNvbHZlZFRvQWRkcmVzcyA9IEFjY291bnRSZXNvbHZlci5yZXNvbHZlQWNjb3VudChcbiAgICAgIHBhcnNlZFBhcmFtcy50b0FkZHJlc3MsXG4gICAgICBjb250ZXh0LFxuICAgICAgY2xpZW50XG4gICAgKTtcbiAgICBjb25zdCB0b0FkZHJlc3MgPSBhd2FpdCBBY2NvdW50UmVzb2x2ZXIuZ2V0SGVkZXJhRVZNQWRkcmVzcyhyZXNvbHZlZFRvQWRkcmVzcywgbWlycm9yTm9kZSk7XG4gICAgY29uc3QgY29udHJhY3RJZCA9IGF3YWl0IF9IZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLmdldEhlZGVyYUFjY291bnRJZChcbiAgICAgIHBhcnNlZFBhcmFtcy5jb250cmFjdElkLFxuICAgICAgbWlycm9yTm9kZVxuICAgICk7XG4gICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShmYWN0b3J5Q29udHJhY3RBYmkpO1xuICAgIGNvbnN0IGVuY29kZWREYXRhID0gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZhY3RvcnlDb250cmFjdEZ1bmN0aW9uTmFtZSwgW3RvQWRkcmVzc10pO1xuICAgIGNvbnN0IGZ1bmN0aW9uUGFyYW1ldGVycyA9IGV0aGVycy5nZXRCeXRlcyhlbmNvZGVkRGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0SWQsXG4gICAgICBmdW5jdGlvblBhcmFtZXRlcnMsXG4gICAgICBnYXM6IDFlNVxuICAgIH07XG4gIH1cbiAgc3RhdGljIG5vcm1hbGlzZURlbGV0ZUFjY291bnQocGFyYW1zLCBjb250ZXh0LCBjbGllbnQpIHtcbiAgICBjb25zdCBwYXJzZWRQYXJhbXMgPSB0aGlzLnBhcnNlUGFyYW1zV2l0aFNjaGVtYShwYXJhbXMsIGRlbGV0ZUFjY291bnRQYXJhbWV0ZXJzLCBjb250ZXh0KTtcbiAgICBpZiAoIUFjY291bnRSZXNvbHZlci5pc0hlZGVyYUFkZHJlc3MocGFyc2VkUGFyYW1zLmFjY291bnRJZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY291bnQgSUQgbXVzdCBiZSBhIEhlZGVyYSBhZGRyZXNzXCIpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2ZlckFjY291bnRJZCA9IHBhcnNlZFBhcmFtcy50cmFuc2ZlckFjY291bnRJZCA/PyBBY2NvdW50UmVzb2x2ZXIuZ2V0RGVmYXVsdEFjY291bnQoY29udGV4dCwgY2xpZW50KTtcbiAgICBpZiAoIXRyYW5zZmVyQWNjb3VudElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIHRyYW5zZmVyIGFjY291bnQgSURcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50SWQ6IEFjY291bnRJZDQuZnJvbVN0cmluZyhwYXJzZWRQYXJhbXMuYWNjb3VudElkKSxcbiAgICAgIHRyYW5zZmVyQWNjb3VudElkOiBBY2NvdW50SWQ0LmZyb21TdHJpbmcodHJhbnNmZXJBY2NvdW50SWQpXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgbm9ybWFsaXNlVXBkYXRlQWNjb3VudChwYXJhbXMsIGNvbnRleHQsIGNsaWVudCkge1xuICAgIGNvbnN0IHBhcnNlZFBhcmFtcyA9IHRoaXMucGFyc2VQYXJhbXNXaXRoU2NoZW1hKHBhcmFtcywgdXBkYXRlQWNjb3VudFBhcmFtZXRlcnMsIGNvbnRleHQpO1xuICAgIGNvbnN0IGFjY291bnRJZCA9IEFjY291bnRJZDQuZnJvbVN0cmluZyhcbiAgICAgIEFjY291bnRSZXNvbHZlci5yZXNvbHZlQWNjb3VudChwYXJzZWRQYXJhbXMuYWNjb3VudElkLCBjb250ZXh0LCBjbGllbnQpXG4gICAgKTtcbiAgICBjb25zdCBub3JtYWxpc2VkID0ge1xuICAgICAgYWNjb3VudElkXG4gICAgfTtcbiAgICBpZiAocGFyc2VkUGFyYW1zLm1heEF1dG9tYXRpY1Rva2VuQXNzb2NpYXRpb25zICE9PSB2b2lkIDApIHtcbiAgICAgIG5vcm1hbGlzZWQubWF4QXV0b21hdGljVG9rZW5Bc3NvY2lhdGlvbnMgPSBwYXJzZWRQYXJhbXMubWF4QXV0b21hdGljVG9rZW5Bc3NvY2lhdGlvbnM7XG4gICAgfVxuICAgIGlmIChwYXJzZWRQYXJhbXMuc3Rha2VkQWNjb3VudElkICE9PSB2b2lkIDApIHtcbiAgICAgIG5vcm1hbGlzZWQuc3Rha2VkQWNjb3VudElkID0gcGFyc2VkUGFyYW1zLnN0YWtlZEFjY291bnRJZDtcbiAgICB9XG4gICAgaWYgKHBhcnNlZFBhcmFtcy5hY2NvdW50TWVtbyAhPT0gdm9pZCAwKSB7XG4gICAgICBub3JtYWxpc2VkLmFjY291bnRNZW1vID0gcGFyc2VkUGFyYW1zLmFjY291bnRNZW1vO1xuICAgIH1cbiAgICBpZiAocGFyc2VkUGFyYW1zLmRlY2xpbmVTdGFraW5nUmV3YXJkICE9PSB2b2lkIDApIHtcbiAgICAgIG5vcm1hbGlzZWQuZGVjbGluZVN0YWtpbmdSZXdhcmQgPSBwYXJzZWRQYXJhbXMuZGVjbGluZVN0YWtpbmdSZXdhcmQ7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpc2VkO1xuICB9XG4gIHN0YXRpYyBub3JtYWxpc2VHZXRUcmFuc2FjdGlvblJlY29yZFBhcmFtcyhwYXJhbXMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXJzZWRQYXJhbXMgPSB0aGlzLnBhcnNlUGFyYW1zV2l0aFNjaGVtYShwYXJhbXMsIHRyYW5zYWN0aW9uUmVjb3JkUXVlcnlQYXJhbWV0ZXJzLCBjb250ZXh0KTtcbiAgICBjb25zdCBub3JtYWxpc2VkID0ge1xuICAgICAgbm9uY2U6IHBhcnNlZFBhcmFtcy5ub25jZVxuICAgIH07XG4gICAgaWYgKCFwYXJzZWRQYXJhbXMudHJhbnNhY3Rpb25JZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNhY3Rpb25JZCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgbWlycm9yTm9kZVN0eWxlUmVnZXggPSAvXlxcZCtcXC5cXGQrXFwuXFxkKy1cXGQrLVxcZCskLztcbiAgICBjb25zdCBzZGtTdHlsZVJlZ2V4ID0gL14oXFxkK1xcLlxcZCtcXC5cXGQrKUAoXFxkKylcXC4oXFxkKykkLztcbiAgICBpZiAobWlycm9yTm9kZVN0eWxlUmVnZXgudGVzdChwYXJzZWRQYXJhbXMudHJhbnNhY3Rpb25JZCkpIHtcbiAgICAgIG5vcm1hbGlzZWQudHJhbnNhY3Rpb25JZCA9IHBhcnNlZFBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHBhcnNlZFBhcmFtcy50cmFuc2FjdGlvbklkLm1hdGNoKHNka1N0eWxlUmVnZXgpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHJhbnNhY3Rpb25JZCBmb3JtYXQ6ICR7cGFyc2VkUGFyYW1zLnRyYW5zYWN0aW9uSWR9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBbLCBhY2NvdW50SWQsIHNlY29uZHMsIG5hbm9zXSA9IG1hdGNoO1xuICAgICAgbm9ybWFsaXNlZC50cmFuc2FjdGlvbklkID0gYCR7YWNjb3VudElkfS0ke3NlY29uZHN9LSR7bmFub3N9YDtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGlzZWQ7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldEhlZGVyYUFjY291bnRJZChhZGRyZXNzLCBtaXJyb3JOb2RlKSB7XG4gICAgaWYgKEFjY291bnRSZXNvbHZlci5pc0hlZGVyYUFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgbWlycm9yTm9kZS5nZXRBY2NvdW50KGFkZHJlc3MpO1xuICAgIHJldHVybiBhY2NvdW50LmFjY291bnRJZDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbm9ybWFsaXNlVXBkYXRlVG9rZW4ocGFyYW1zLCBjb250ZXh0LCBjbGllbnQpIHtcbiAgICBjb25zdCBwYXJzZWRQYXJhbXMgPSB0aGlzLnBhcnNlUGFyYW1zV2l0aFNjaGVtYShwYXJhbXMsIHVwZGF0ZVRva2VuUGFyYW1ldGVycywgY29udGV4dCk7XG4gICAgY29uc3QgdG9rZW5JZCA9IFRva2VuSWQyLmZyb21TdHJpbmcocGFyc2VkUGFyYW1zLnRva2VuSWQpO1xuICAgIGNvbnN0IHVzZXJQdWJsaWNLZXkgPSBhd2FpdCBBY2NvdW50UmVzb2x2ZXIuZ2V0RGVmYXVsdFB1YmxpY0tleShjb250ZXh0LCBjbGllbnQpO1xuICAgIGNvbnN0IG5vcm1hbGlzZWQgPSB7XG4gICAgICB0b2tlbklkXG4gICAgfTtcbiAgICBjb25zdCBtYXliZUtleXMgPSB7XG4gICAgICBhZG1pbktleTogcGFyc2VkUGFyYW1zLmFkbWluS2V5LFxuICAgICAgc3VwcGx5S2V5OiBwYXJzZWRQYXJhbXMuc3VwcGx5S2V5LFxuICAgICAgd2lwZUtleTogcGFyc2VkUGFyYW1zLndpcGVLZXksXG4gICAgICBmcmVlemVLZXk6IHBhcnNlZFBhcmFtcy5mcmVlemVLZXksXG4gICAgICBreWNLZXk6IHBhcnNlZFBhcmFtcy5reWNLZXksXG4gICAgICBmZWVTY2hlZHVsZUtleTogcGFyc2VkUGFyYW1zLmZlZVNjaGVkdWxlS2V5LFxuICAgICAgcGF1c2VLZXk6IHBhcnNlZFBhcmFtcy5wYXVzZUtleSxcbiAgICAgIG1ldGFkYXRhS2V5OiBwYXJzZWRQYXJhbXMubWV0YWRhdGFLZXlcbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkLCByYXdWYWxdIG9mIE9iamVjdC5lbnRyaWVzKG1heWJlS2V5cykpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlS2V5KHJhd1ZhbCwgdXNlclB1YmxpY0tleSk7XG4gICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgbm9ybWFsaXNlZFtmaWVsZF0gPSByZXNvbHZlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnNlZFBhcmFtcy50b2tlbk5hbWUpIHtcbiAgICAgIG5vcm1hbGlzZWQudG9rZW5OYW1lID0gcGFyc2VkUGFyYW1zLnRva2VuTmFtZTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZFBhcmFtcy50b2tlblN5bWJvbCkge1xuICAgICAgbm9ybWFsaXNlZC50b2tlblN5bWJvbCA9IHBhcnNlZFBhcmFtcy50b2tlblN5bWJvbDtcbiAgICB9XG4gICAgaWYgKHBhcnNlZFBhcmFtcy50cmVhc3VyeUFjY291bnRJZCkge1xuICAgICAgbm9ybWFsaXNlZC50cmVhc3VyeUFjY291bnRJZCA9IHBhcnNlZFBhcmFtcy50cmVhc3VyeUFjY291bnRJZDtcbiAgICB9XG4gICAgaWYgKHBhcnNlZFBhcmFtcy50b2tlbk1lbW8pIHtcbiAgICAgIG5vcm1hbGlzZWQudG9rZW5NZW1vID0gcGFyc2VkUGFyYW1zLnRva2VuTWVtbztcbiAgICB9XG4gICAgaWYgKHBhcnNlZFBhcmFtcy5tZXRhZGF0YSkge1xuICAgICAgbm9ybWFsaXNlZC5tZXRhZGF0YSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwYXJzZWRQYXJhbXMubWV0YWRhdGEpO1xuICAgIH1cbiAgICBpZiAocGFyc2VkUGFyYW1zLmF1dG9SZW5ld0FjY291bnRJZCkge1xuICAgICAgbm9ybWFsaXNlZC5hdXRvUmVuZXdBY2NvdW50SWQgPSBwYXJzZWRQYXJhbXMuYXV0b1JlbmV3QWNjb3VudElkO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXNlZDtcbiAgfVxuICBzdGF0aWMgcmVzb2x2ZUtleShyYXdWYWx1ZSwgdXNlcktleSkge1xuICAgIGlmIChyYXdWYWx1ZSA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmICh0eXBlb2YgcmF3VmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBQdWJsaWNLZXk0LmZyb21TdHJpbmdFRDI1NTE5KHJhd1ZhbHVlKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gUHVibGljS2V5NC5mcm9tU3RyaW5nRUNEU0EocmF3VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmF3VmFsdWUpIHtcbiAgICAgIHJldHVybiB1c2VyS2V5O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLXRva2VuLXBsdWdpbi90b29scy9mdW5naWJsZS10b2tlbi9haXJkcm9wLWZ1bmdpYmxlLXRva2VuLnRzXG5pbXBvcnQgeyBTdGF0dXMgfSBmcm9tIFwiQGhhc2hncmFwaC9zZGtcIjtcblxuLy8gc3JjL3NoYXJlZC9zdHJhdGVnaWVzL3R4LW1vZGUtc3RyYXRlZ3kudHNcbmltcG9ydCB7IEFjY291bnRJZCBhcyBBY2NvdW50SWQ1LCBUcmFuc2FjdGlvbklkIH0gZnJvbSBcIkBoYXNoZ3JhcGgvc2RrXCI7XG52YXIgRXhlY3V0ZVN0cmF0ZWd5ID0gY2xhc3Mge1xuICBkZWZhdWx0UG9zdFByb2Nlc3MocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UsIG51bGwsIDIpO1xuICB9XG4gIGFzeW5jIGhhbmRsZSh0eCwgY2xpZW50LCBfY29udGV4dCwgcG9zdFByb2Nlc3MzNSA9IHRoaXMuZGVmYXVsdFBvc3RQcm9jZXNzKSB7XG4gICAgY29uc3Qgc3VibWl0ID0gYXdhaXQgdHguZXhlY3V0ZShjbGllbnQpO1xuICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBzdWJtaXQuZ2V0UmVjZWlwdChjbGllbnQpO1xuICAgIGNvbnN0IHJhd1RyYW5zYWN0aW9uUmVzcG9uc2UgPSB7XG4gICAgICBzdGF0dXM6IHJlY2VpcHQuc3RhdHVzLnRvU3RyaW5nKCksXG4gICAgICBhY2NvdW50SWQ6IHJlY2VpcHQuYWNjb3VudElkLFxuICAgICAgdG9rZW5JZDogcmVjZWlwdC50b2tlbklkLFxuICAgICAgdHJhbnNhY3Rpb25JZDogdHgudHJhbnNhY3Rpb25JZD8udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgICAgdG9waWNJZDogcmVjZWlwdC50b3BpY0lkLFxuICAgICAgc2NoZWR1bGVJZDogcmVjZWlwdC5zY2hlZHVsZUlkXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcmF3OiByYXdUcmFuc2FjdGlvblJlc3BvbnNlLFxuICAgICAgaHVtYW5NZXNzYWdlOiBwb3N0UHJvY2VzczM1KHJhd1RyYW5zYWN0aW9uUmVzcG9uc2UpXG4gICAgfTtcbiAgfVxufTtcbnZhciBSZXR1cm5CeXRlc1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUodHgsIF9jbGllbnQsIGNvbnRleHQpIHtcbiAgICBpZiAoIWNvbnRleHQuYWNjb3VudElkKSB0aHJvdyBuZXcgRXJyb3IoXCJcXHUyMDI2XCIpO1xuICAgIGNvbnN0IGlkID0gVHJhbnNhY3Rpb25JZC5nZW5lcmF0ZShjb250ZXh0LmFjY291bnRJZCk7XG4gICAgdHguc2V0Tm9kZUFjY291bnRJZHMoW25ldyBBY2NvdW50SWQ1KDQpLCBuZXcgQWNjb3VudElkNSg1KV0pLnNldFRyYW5zYWN0aW9uSWQoaWQpLmZyZWV6ZSgpO1xuICAgIHJldHVybiB7IGJ5dGVzOiB0eC50b0J5dGVzKCkgfTtcbiAgfVxufTtcbnZhciBnZXRTdHJhdGVneUZyb21Db250ZXh0ID0gKGNvbnRleHQpID0+IHtcbiAgaWYgKGNvbnRleHQubW9kZSA9PT0gXCJyZXR1cm5CeXRlc1wiIC8qIFJFVFVSTl9CWVRFUyAqLykge1xuICAgIHJldHVybiBuZXcgUmV0dXJuQnl0ZXNTdHJhdGVneSgpO1xuICB9XG4gIHJldHVybiBuZXcgRXhlY3V0ZVN0cmF0ZWd5KCk7XG59O1xudmFyIGhhbmRsZVRyYW5zYWN0aW9uID0gYXN5bmMgKHR4LCBjbGllbnQsIGNvbnRleHQsIHBvc3RQcm9jZXNzMzUpID0+IHtcbiAgY29uc3Qgc3RyYXRlZ3kgPSBnZXRTdHJhdGVneUZyb21Db250ZXh0KGNvbnRleHQpO1xuICByZXR1cm4gYXdhaXQgc3RyYXRlZ3kuaGFuZGxlKHR4LCBjbGllbnQsIGNvbnRleHQsIHBvc3RQcm9jZXNzMzUpO1xufTtcblxuLy8gc3JjL3NoYXJlZC9oZWRlcmEtdXRpbHMvaGVkZXJhLWJ1aWxkZXIudHNcbmltcG9ydCB7XG4gIFRva2VuQWlyZHJvcFRyYW5zYWN0aW9uLFxuICBUb2tlbkNyZWF0ZVRyYW5zYWN0aW9uLFxuICBUb2tlbkRlbGV0ZVRyYW5zYWN0aW9uLFxuICBUb3BpY0NyZWF0ZVRyYW5zYWN0aW9uLFxuICBUb3BpY0RlbGV0ZVRyYW5zYWN0aW9uLFxuICBUb3BpY01lc3NhZ2VTdWJtaXRUcmFuc2FjdGlvbixcbiAgVHJhbnNmZXJUcmFuc2FjdGlvbixcbiAgQ29udHJhY3RFeGVjdXRlVHJhbnNhY3Rpb24sXG4gIFRva2VuTWludFRyYW5zYWN0aW9uLFxuICBUb2tlbkFzc29jaWF0ZVRyYW5zYWN0aW9uLFxuICBBY2NvdW50Q3JlYXRlVHJhbnNhY3Rpb24sXG4gIEFjY291bnREZWxldGVUcmFuc2FjdGlvbixcbiAgQWNjb3VudFVwZGF0ZVRyYW5zYWN0aW9uLFxuICBTY2hlZHVsZVNpZ25UcmFuc2FjdGlvbixcbiAgU2NoZWR1bGVDcmVhdGVUcmFuc2FjdGlvbixcbiAgVG9rZW5VcGRhdGVUcmFuc2FjdGlvbixcbiAgU2NoZWR1bGVEZWxldGVUcmFuc2FjdGlvbixcbiAgVG9rZW5EaXNzb2NpYXRlVHJhbnNhY3Rpb24sXG4gIFRvcGljVXBkYXRlVHJhbnNhY3Rpb24sXG4gIEFjY291bnRJZCBhcyBBY2NvdW50SWQ2LFxuICBUb2tlbklkIGFzIFRva2VuSWQ0LFxuICBBY2NvdW50QWxsb3dhbmNlQXBwcm92ZVRyYW5zYWN0aW9uXG59IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIEhlZGVyYUJ1aWxkZXIgPSBjbGFzcyB7XG4gIHN0YXRpYyBjcmVhdGVTY2hlZHVsZVRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgU2NoZWR1bGVDcmVhdGVUcmFuc2FjdGlvbihwYXJhbXMucGFyYW1zKS5zZXRTY2hlZHVsZWRUcmFuc2FjdGlvbihcbiAgICAgIHBhcmFtcy5zY2hlZHVsZWRUcmFuc2FjdGlvblxuICAgICk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUZ1bmdpYmxlVG9rZW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbkNyZWF0ZVRyYW5zYWN0aW9uKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZU5vbkZ1bmdpYmxlVG9rZW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbkNyZWF0ZVRyYW5zYWN0aW9uKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIHRyYW5zZmVySGJhcihwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZmVyVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgYWlyZHJvcEZ1bmdpYmxlVG9rZW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbkFpcmRyb3BUcmFuc2FjdGlvbihwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVUb2tlbihwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuVXBkYXRlVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlVG9waWMocGFyYW1zKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbk1lbW8sIC4uLnJlc3QgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eCA9IG5ldyBUb3BpY0NyZWF0ZVRyYW5zYWN0aW9uKHJlc3QpO1xuICAgIGlmICh0cmFuc2FjdGlvbk1lbW8pIHR4LnNldFRyYW5zYWN0aW9uTWVtbyh0cmFuc2FjdGlvbk1lbW8pO1xuICAgIHJldHVybiB0eDtcbiAgfVxuICBzdGF0aWMgc3VibWl0VG9waWNNZXNzYWdlKHBhcmFtcykge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25NZW1vLCAuLi5yZXN0IH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHggPSBuZXcgVG9waWNNZXNzYWdlU3VibWl0VHJhbnNhY3Rpb24ocmVzdCk7XG4gICAgaWYgKHRyYW5zYWN0aW9uTWVtbykgdHguc2V0VHJhbnNhY3Rpb25NZW1vKHRyYW5zYWN0aW9uTWVtbyk7XG4gICAgcmV0dXJuIHR4O1xuICB9XG4gIHN0YXRpYyB1cGRhdGVUb3BpYyhwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFRvcGljVXBkYXRlVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgZXhlY3V0ZVRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ29udHJhY3RFeGVjdXRlVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgbWludEZ1bmdpYmxlVG9rZW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbk1pbnRUcmFuc2FjdGlvbihwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBtaW50Tm9uRnVuZ2libGVUb2tlbihwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuTWludFRyYW5zYWN0aW9uKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGRpc3NvY2lhdGVUb2tlbihwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuRGlzc29jaWF0ZVRyYW5zYWN0aW9uKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBBY2NvdW50Q3JlYXRlVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgZGVsZXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IEFjY291bnREZWxldGVUcmFuc2FjdGlvbihwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQWNjb3VudFVwZGF0ZVRyYW5zYWN0aW9uKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGRlbGV0ZVRva2VuKHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgVG9rZW5EZWxldGVUcmFuc2FjdGlvbihwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBkZWxldGVUb3BpYyhwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFRvcGljRGVsZXRlVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgc2lnblNjaGVkdWxlVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBTY2hlZHVsZVNpZ25UcmFuc2FjdGlvbihwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBkZWxldGVTY2hlZHVsZVRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgU2NoZWR1bGVEZWxldGVUcmFuc2FjdGlvbihwYXJhbXMpO1xuICB9XG4gIHN0YXRpYyBhc3NvY2lhdGVUb2tlbihwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuQXNzb2NpYXRlVHJhbnNhY3Rpb24oe1xuICAgICAgYWNjb3VudElkOiBBY2NvdW50SWQ2LmZyb21TdHJpbmcocGFyYW1zLmFjY291bnRJZCksXG4gICAgICB0b2tlbklkczogcGFyYW1zLnRva2VuSWRzLm1hcCgodCkgPT4gVG9rZW5JZDQuZnJvbVN0cmluZyh0KSlcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgYXBwcm92ZUhiYXJBbGxvd2FuY2UocGFyYW1zKSB7XG4gICAgY29uc3QgdHggPSBuZXcgQWNjb3VudEFsbG93YW5jZUFwcHJvdmVUcmFuc2FjdGlvbihwYXJhbXMpO1xuICAgIGlmIChwYXJhbXMudHJhbnNhY3Rpb25NZW1vKSB7XG4gICAgICB0eC5zZXRUcmFuc2FjdGlvbk1lbW8ocGFyYW1zLnRyYW5zYWN0aW9uTWVtbyk7XG4gICAgfVxuICAgIHJldHVybiB0eDtcbiAgfVxufTtcblxuLy8gc3JjL3NoYXJlZC9oZWRlcmEtdXRpbHMvbWlycm9ybm9kZS90eXBlcy50c1xuaW1wb3J0IHsgTGVkZ2VySWQgfSBmcm9tIFwiQGhhc2hncmFwaC9zZGtcIjtcbnZhciBMZWRnZXJJZFRvQmFzZVVybCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW0xlZGdlcklkLk1BSU5ORVQudG9TdHJpbmcoKSwgXCJodHRwczovL21haW5uZXQtcHVibGljLm1pcnJvcm5vZGUuaGVkZXJhLmNvbS9hcGkvdjFcIl0sXG4gIFtMZWRnZXJJZC5URVNUTkVULnRvU3RyaW5nKCksIFwiaHR0cHM6Ly90ZXN0bmV0Lm1pcnJvcm5vZGUuaGVkZXJhLmNvbS9hcGkvdjFcIl1cbl0pO1xuXG4vLyBzcmMvc2hhcmVkL2hlZGVyYS11dGlscy9taXJyb3Jub2RlL2hlZGVyYS1taXJyb3Jub2RlLXNlcnZpY2UtZGVmYXVsdC1pbXBsLnRzXG5pbXBvcnQgQmlnTnVtYmVyMyBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XG52YXIgSGVkZXJhTWlycm9ybm9kZVNlcnZpY2VEZWZhdWx0SW1wbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobGVkZ2VySWQpIHtcbiAgICB0aGlzLmxlZGdlcklkID0gbGVkZ2VySWQ7XG4gICAgaWYgKCFMZWRnZXJJZFRvQmFzZVVybC5oYXMobGVkZ2VySWQudG9TdHJpbmcoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB0eXBlICR7bGVkZ2VySWR9IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlVXJsID0gTGVkZ2VySWRUb0Jhc2VVcmwuZ2V0KGxlZGdlcklkLnRvU3RyaW5nKCkpO1xuICB9XG4gIGJhc2VVcmw7XG4gIGFzeW5jIGdldEFjY291bnQoYWNjb3VudElkKSB7XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS9hY2NvdW50cy8ke2FjY291bnRJZH1gO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggYWNjb3VudCAke2FjY291bnRJZH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBpZiAoIWRhdGEuYWNjb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY2NvdW50ICR7YWNjb3VudElkfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRJZDogZGF0YS5hY2NvdW50LFxuICAgICAgYWNjb3VudFB1YmxpY0tleTogZGF0YT8ua2V5Py5rZXksXG4gICAgICBiYWxhbmNlOiBkYXRhLmJhbGFuY2UsXG4gICAgICBldm1BZGRyZXNzOiBkYXRhLmV2bV9hZGRyZXNzXG4gICAgfTtcbiAgfVxuICBhc3luYyBnZXRBY2NvdW50SEJhckJhbGFuY2UoYWNjb3VudElkKSB7XG4gICAgbGV0IGFjY291bnQ7XG4gICAgdHJ5IHtcbiAgICAgIGFjY291bnQgPSBhd2FpdCB0aGlzLmdldEFjY291bnQoYWNjb3VudElkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBoYmFyIGJhbGFuY2UgZm9yICR7YWNjb3VudElkfTogJHtlcnJvcn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIzKGFjY291bnQuYmFsYW5jZS5iYWxhbmNlKTtcbiAgfVxuICBhc3luYyBnZXRBY2NvdW50VG9rZW5CYWxhbmNlcyhhY2NvdW50SWQsIHRva2VuSWQpIHtcbiAgICBjb25zdCB0b2tlbklkUGFyYW0gPSB0b2tlbklkID8gYCZ0b2tlbi5pZD0ke3Rva2VuSWR9YCA6IFwiXCI7XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS9hY2NvdW50cy8ke2FjY291bnRJZH0vdG9rZW5zPyR7dG9rZW5JZFBhcmFtfWA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBmZXRjaCBiYWxhbmNlIGZvciBhbiBhY2NvdW50ICR7YWNjb3VudElkfTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIGFzeW5jIGdldFRvcGljTWVzc2FnZXMocXVlcnlQYXJhbXMpIHtcbiAgICBjb25zdCBsb3dlclRocmVzaG9sZCA9IHF1ZXJ5UGFyYW1zLmxvd2VyVGltZXN0YW1wID8gYCZ0aW1lc3RhbXA9Z3RlOiR7cXVlcnlQYXJhbXMubG93ZXJUaW1lc3RhbXB9YCA6IFwiXCI7XG4gICAgY29uc3QgdXBwZXJUaHJlc2hvbGQgPSBxdWVyeVBhcmFtcy51cHBlclRpbWVzdGFtcCA/IGAmdGltZXN0YW1wPWx0ZToke3F1ZXJ5UGFyYW1zLnVwcGVyVGltZXN0YW1wfWAgOiBcIlwiO1xuICAgIGNvbnN0IGJhc2VQYXJhbXMgPSBgJm9yZGVyPWRlc2MmbGltaXQ9MTAwYDtcbiAgICBsZXQgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS90b3BpY3MvJHtxdWVyeVBhcmFtcy50b3BpY0lkfS9tZXNzYWdlcz8ke2xvd2VyVGhyZXNob2xkfSR7dXBwZXJUaHJlc2hvbGR9JHtiYXNlUGFyYW1zfWA7XG4gICAgY29uc3QgYXJyYXlPZk1lc3NhZ2VzID0gW107XG4gICAgbGV0IGZldGNoZWRNZXNzYWdlcyA9IDA7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICh1cmwpIHtcbiAgICAgICAgZmV0Y2hlZE1lc3NhZ2VzICs9IDE7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZ2V0IHRvcGljIG1lc3NhZ2VzIGZvciAke3F1ZXJ5UGFyYW1zLnRvcGljSWR9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGFycmF5T2ZNZXNzYWdlcy5wdXNoKC4uLmRhdGEubWVzc2FnZXMpO1xuICAgICAgICBpZiAoZmV0Y2hlZE1lc3NhZ2VzID49IDEwMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IGRhdGEubGlua3MubmV4dCA/IHRoaXMuYmFzZVVybCArIGRhdGEubGlua3MubmV4dCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBmZXRjaCB0b3BpYyBtZXNzYWdlcyBmb3IgJHtxdWVyeVBhcmFtcy50b3BpY0lkfS4gRXJyb3I6YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0b3BpY0lkOiBxdWVyeVBhcmFtcy50b3BpY0lkLFxuICAgICAgbWVzc2FnZXM6IGFycmF5T2ZNZXNzYWdlcy5zbGljZSgwLCBxdWVyeVBhcmFtcy5saW1pdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGdldFRva2VuSW5mbyh0b2tlbklkKSB7XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS90b2tlbnMvJHt0b2tlbklkfWA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgdG9rZW4gaW5mbyBmb3IgYSB0b2tlbiAke3Rva2VuSWR9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgYXN5bmMgZ2V0VG9waWNJbmZvKHRvcGljSWQpIHtcbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9L3RvcGljcy8ke3RvcGljSWR9YDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGdldCB0b3BpYyBpbmZvIGZvciAke3RvcGljSWR9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNvcmQodHJhbnNhY3Rpb25JZCwgbm9uY2UpIHtcbiAgICBsZXQgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS90cmFuc2FjdGlvbnMvJHt0cmFuc2FjdGlvbklkfWA7XG4gICAgaWYgKG5vbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHVybCArPSBgP25vbmNlPSR7bm9uY2V9YDtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24gcmVjb3JkIGZvciAke3RyYW5zYWN0aW9uSWR9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgYXN5bmMgZ2V0Q29udHJhY3RJbmZvKGNvbnRyYWN0SWQpIHtcbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9L2NvbnRyYWN0cy8ke2NvbnRyYWN0SWR9YDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGdldCBjb250cmFjdCBpbmZvIGZvciAke2NvbnRyYWN0SWR9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgYXN5bmMgZ2V0UGVuZGluZ0FpcmRyb3BzKGFjY291bnRJZCkge1xuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0vYWNjb3VudHMvJHthY2NvdW50SWR9L2FpcmRyb3BzL3BlbmRpbmdgO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggcGVuZGluZyBhaXJkcm9wcyBmb3IgYW4gYWNjb3VudCAke2FjY291bnRJZH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICBhc3luYyBnZXRPdXRzdGFuZGluZ0FpcmRyb3BzKGFjY291bnRJZCkge1xuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0vYWNjb3VudHMvJHthY2NvdW50SWR9L2FpcmRyb3BzL291dHN0YW5kaW5nYDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGZldGNoIG91dHN0YW5kaW5nIGFpcmRyb3BzIGZvciBhbiBhY2NvdW50ICR7YWNjb3VudElkfTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIGFzeW5jIGdldEV4Y2hhbmdlUmF0ZSh0aW1lc3RhbXApIHtcbiAgICBjb25zdCB0aW1lc3RhbXBQYXJhbSA9IHRpbWVzdGFtcCA/IGA/dGltZXN0YW1wPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRpbWVzdGFtcCl9YCA6IFwiXCI7XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS9uZXR3b3JrL2V4Y2hhbmdlcmF0ZSR7dGltZXN0YW1wUGFyYW19YDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfS4gTWVzc2FnZTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG59O1xuXG4vLyBzcmMvc2hhcmVkL2hlZGVyYS11dGlscy9taXJyb3Jub2RlL2hlZGVyYS1taXJyb3Jub2RlLXV0aWxzLnRzXG52YXIgZ2V0TWlycm9ybm9kZVNlcnZpY2UgPSAobWlycm9ybm9kZVNlcnZpY2UsIGxlZGdlcklkKSA9PiB7XG4gIGlmIChtaXJyb3Jub2RlU2VydmljZSkge1xuICAgIHJldHVybiBtaXJyb3Jub2RlU2VydmljZTtcbiAgfVxuICByZXR1cm4gbmV3IEhlZGVyYU1pcnJvcm5vZGVTZXJ2aWNlRGVmYXVsdEltcGwobGVkZ2VySWQpO1xufTtcblxuLy8gc3JjL3NoYXJlZC91dGlscy9wcm9tcHQtZ2VuZXJhdG9yLnRzXG52YXIgUHJvbXB0R2VuZXJhdG9yID0gY2xhc3Mge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgY29uc2lzdGVudCBjb250ZXh0IHNuaXBwZXQgZm9yIHRvb2wgcHJvbXB0cy5cbiAgICovXG4gIHN0YXRpYyBnZXRDb250ZXh0U25pcHBldChjb250ZXh0KSB7XG4gICAgY29uc3QgbGluZXMgPSBbXCJDb250ZXh0OlwiXTtcbiAgICBpZiAoY29udGV4dC5tb2RlID09PSBcInJldHVybkJ5dGVzXCIgLyogUkVUVVJOX0JZVEVTICovKSB7XG4gICAgICBsaW5lcy5wdXNoKGAtIE1vZGU6IFJldHVybiBCeXRlcyAocHJlcGFyaW5nIHRyYW5zYWN0aW9ucyBmb3IgdXNlciBzaWduaW5nKWApO1xuICAgICAgaWYgKGNvbnRleHQuYWNjb3VudElkKSB7XG4gICAgICAgIGxpbmVzLnB1c2goYC0gVXNlciBBY2NvdW50OiAke2NvbnRleHQuYWNjb3VudElkfSAoZGVmYXVsdCBmb3IgdHJhbnNhY3Rpb24gcGFyYW1ldGVycylgKTtcbiAgICAgICAgbGluZXMucHVzaChgLSBXaGVuIG5vIGFjY291bnQgaXMgc3BlY2lmaWVkLCAke2NvbnRleHQuYWNjb3VudElkfSB3aWxsIGJlIHVzZWRgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVzLnB1c2goYC0gVXNlciBBY2NvdW50OiBOb3Qgc3BlY2lmaWVkYCk7XG4gICAgICAgIGxpbmVzLnB1c2goYC0gV2hlbiBubyBhY2NvdW50IGlzIHNwZWNpZmllZCwgdGhlIG9wZXJhdG9yIGFjY291bnQgd2lsbCBiZSB1c2VkYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250ZXh0Lm1vZGUgPT09IFwiYXV0b25vbW91c1wiIC8qIEFVVE9OT01PVVMgKi8pIHtcbiAgICAgIGxpbmVzLnB1c2goYC0gTW9kZTogQXV0b25vbW91cyAoYWdlbnQgZXhlY3V0ZXMgdHJhbnNhY3Rpb25zIGRpcmVjdGx5KWApO1xuICAgICAgaWYgKGNvbnRleHQuYWNjb3VudElkKSB7XG4gICAgICAgIGxpbmVzLnB1c2goYC0gVXNlciBBY2NvdW50OiAke2NvbnRleHQuYWNjb3VudElkfWApO1xuICAgICAgfVxuICAgICAgbGluZXMucHVzaChgLSBXaGVuIG5vIGFjY291bnQgaXMgc3BlY2lmaWVkLCB0aGUgb3BlcmF0b3IgYWNjb3VudCB3aWxsIGJlIHVzZWRgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZXMucHVzaChgLSBNb2RlOiAke2NvbnRleHQubW9kZSB8fCBcIk5vdCBzcGVjaWZpZWRcIn1gKTtcbiAgICAgIGlmIChjb250ZXh0LmFjY291bnRJZCkge1xuICAgICAgICBsaW5lcy5wdXNoKGAtIFVzZXIgQWNjb3VudDogJHtjb250ZXh0LmFjY291bnRJZH1gKTtcbiAgICAgIH1cbiAgICAgIGxpbmVzLnB1c2goYC0gRGVmYXVsdCBhY2NvdW50IHdpbGwgYmUgZGV0ZXJtaW5lZCBhdCBleGVjdXRpb24gdGltZWApO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0QW55QWRkcmVzc1BhcmFtZXRlckRlc2NyaXB0aW9uKHBhcmFtTmFtZSwgY29udGV4dCwgaXNSZXF1aXJlZCA9IGZhbHNlKSB7XG4gICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBgJHtwYXJhbU5hbWV9IChzdHIsIHJlcXVpcmVkKTogVGhlIGFjY291bnQgYWRkcmVzcy4gVGhpcyBjYW4gYmUgdGhlIEVWTSBhZGRyZXNzIG9yIHRoZSBIZWRlcmEgYWNjb3VudCBpZGA7XG4gICAgfVxuICAgIHJldHVybiBgJHtwYXJhbU5hbWV9IChzdHIsIG9wdGlvbmFsKTogVGhlIEhlZGVyYSBhY2NvdW50IElEIG9yIEVWTSBhZGRyZXNzLiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIHRoZSAke0FjY291bnRSZXNvbHZlci5nZXREZWZhdWx0QWNjb3VudERlc2NyaXB0aW9uKGNvbnRleHQpfWA7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGNvbnNpc3RlbnQgZGVzY3JpcHRpb24gZm9yIG9wdGlvbmFsIGFjY291bnQgcGFyYW1ldGVycy5cbiAgICovXG4gIHN0YXRpYyBnZXRBY2NvdW50UGFyYW1ldGVyRGVzY3JpcHRpb24ocGFyYW1OYW1lLCBjb250ZXh0LCBpc1JlcXVpcmVkID0gZmFsc2UpIHtcbiAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGAke3BhcmFtTmFtZX0gKHN0ciwgcmVxdWlyZWQpOiBUaGUgSGVkZXJhIGFjY291bnQgSURgO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0QWNjb3VudERlc2MgPSBBY2NvdW50UmVzb2x2ZXIuZ2V0RGVmYXVsdEFjY291bnREZXNjcmlwdGlvbihjb250ZXh0KTtcbiAgICByZXR1cm4gYCR7cGFyYW1OYW1lfSAoc3RyLCBvcHRpb25hbCk6IFRoZSBIZWRlcmEgYWNjb3VudCBJRC4gSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byB0aGUgJHtkZWZhdWx0QWNjb3VudERlc2N9YDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnNpc3RlbnQgcGFyYW1ldGVyIHVzYWdlIGluc3RydWN0aW9ucy5cbiAgICovXG4gIHN0YXRpYyBnZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpIHtcbiAgICByZXR1cm4gYFxuSW1wb3J0YW50OlxuLSBPbmx5IGluY2x1ZGUgb3B0aW9uYWwgcGFyYW1ldGVycyBpZiBleHBsaWNpdGx5IHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4tIERvIG5vdCBnZW5lcmF0ZSBwbGFjZWhvbGRlciB2YWx1ZXMgZm9yIG9wdGlvbmFsIGZpZWxkc1xuLSBMZWF2ZSBvcHRpb25hbCBwYXJhbWV0ZXJzIHVuZGVmaW5lZCBpZiBub3Qgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyYDtcbiAgfVxufTtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS10b2tlbi1wbHVnaW4vdG9vbHMvZnVuZ2libGUtdG9rZW4vYWlyZHJvcC1mdW5naWJsZS10b2tlbi50c1xudmFyIGFpcmRyb3BGdW5naWJsZVRva2VuUHJvbXB0ID0gKGNvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCBjb250ZXh0U25pcHBldCA9IFByb21wdEdlbmVyYXRvci5nZXRDb250ZXh0U25pcHBldChjb250ZXh0KTtcbiAgY29uc3Qgc291cmNlQWNjb3VudERlc2MgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0QWNjb3VudFBhcmFtZXRlckRlc2NyaXB0aW9uKFxuICAgIFwic291cmNlQWNjb3VudElkXCIsXG4gICAgY29udGV4dFxuICApO1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuJHtjb250ZXh0U25pcHBldH1cblxuVGhpcyB0b29sIHdpbGwgYWlyZHJvcCBhIGZ1bmdpYmxlIHRva2VuIG9uIEhlZGVyYS5cblxuUGFyYW1ldGVyczpcbi0gdG9rZW5JZCAoc3RyLCByZXF1aXJlZCk6IFRoZSBpZCBvZiB0aGUgdG9rZW5cbi0gJHtzb3VyY2VBY2NvdW50RGVzY31cbi0gcmVjaXBpZW50cyAoYXJyYXksIHJlcXVpcmVkKTogQSBsaXN0IG9mIHJlY2lwaWVudCBvYmplY3RzLCBlYWNoIGNvbnRhaW5pbmc6XG4gIC0gYWNjb3VudElkIChzdHJpbmcpOiBUaGUgcmVjaXBpZW50J3MgYWNjb3VudCBJRCAoZS5nLiwgXCIwLjAuMTIzNFwiKVxuICAtIGFtb3VudCAobnVtYmVyIG9yIHN0cmluZyk6IFRoZSBhbW91bnQgb2YgdG9rZW5zIHRvIHNlbmQgdG8gdGhhdCByZWNpcGllbnQgKGluIGJhc2UgdW5pdHMpXG4tIHRyYW5zYWN0aW9uTWVtbyAoc3RyLCBvcHRpb25hbCk6IE9wdGlvbmFsIG1lbW8gZm9yIHRoZSB0cmFuc2FjdGlvblxuJHt1c2FnZUluc3RydWN0aW9uc31cblxuSWYgdGhlIHVzZXIgc3BlY2lmaWVzIG11bHRpcGxlIHJlY2lwaWVudHMgaW4gYSBzaW5nbGUgcmVxdWVzdCwgaW5jbHVkZSB0aGVtIGFsbCBpbiAqKm9uZSB0b29sIGNhbGwqKiBhcyBhIGxpc3Qgb2YgcmVjaXBpZW50cy5cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzID0gKHJlc3BvbnNlKSA9PiB7XG4gIHJldHVybiBgVG9rZW4gc3VjY2Vzc2Z1bGx5IGFpcmRyb3BwZWQgd2l0aCB0cmFuc2FjdGlvbiBpZCAke3Jlc3BvbnNlLnRyYW5zYWN0aW9uSWQudG9TdHJpbmcoKX1gO1xufTtcbnZhciBhaXJkcm9wRnVuZ2libGVUb2tlbiA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG1pcnJvcm5vZGVTZXJ2aWNlID0gZ2V0TWlycm9ybm9kZVNlcnZpY2UoY29udGV4dC5taXJyb3Jub2RlU2VydmljZSwgY2xpZW50LmxlZGdlcklkKTtcbiAgICBjb25zdCBub3JtYWxpc2VkUGFyYW1zID0gYXdhaXQgSGVkZXJhUGFyYW1ldGVyTm9ybWFsaXNlci5ub3JtYWxpc2VBaXJkcm9wRnVuZ2libGVUb2tlblBhcmFtcyhcbiAgICAgIHBhcmFtcyxcbiAgICAgIGNvbnRleHQsXG4gICAgICBjbGllbnQsXG4gICAgICBtaXJyb3Jub2RlU2VydmljZVxuICAgICk7XG4gICAgY29uc3QgdHggPSBIZWRlcmFCdWlsZGVyLmFpcmRyb3BGdW5naWJsZVRva2VuKG5vcm1hbGlzZWRQYXJhbXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZVRyYW5zYWN0aW9uKHR4LCBjbGllbnQsIGNvbnRleHQsIHBvc3RQcm9jZXNzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBhaXJkcm9wIGZ1bmdpYmxlIHRva2VuXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIlthaXJkcm9wX2Z1bmdpYmxlX3Rva2VuX3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBzdGF0dXM6IFN0YXR1cy5JbnZhbGlkVHJhbnNhY3Rpb24sIGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIEFJUkRST1BfRlVOR0lCTEVfVE9LRU5fVE9PTCA9IFwiYWlyZHJvcF9mdW5naWJsZV90b2tlbl90b29sXCI7XG52YXIgdG9vbCA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IEFJUkRST1BfRlVOR0lCTEVfVE9LRU5fVE9PTCxcbiAgbmFtZTogXCJBaXJkcm9wIEZ1bmdpYmxlIFRva2VuXCIsXG4gIGRlc2NyaXB0aW9uOiBhaXJkcm9wRnVuZ2libGVUb2tlblByb21wdChjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogYWlyZHJvcEZ1bmdpYmxlVG9rZW5QYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBhaXJkcm9wRnVuZ2libGVUb2tlblxufSk7XG52YXIgYWlyZHJvcF9mdW5naWJsZV90b2tlbl9kZWZhdWx0ID0gdG9vbDtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS10b2tlbi1wbHVnaW4vdG9vbHMvZnVuZ2libGUtdG9rZW4vY3JlYXRlLWZ1bmdpYmxlLXRva2VuLnRzXG5pbXBvcnQgeyBTdGF0dXMgYXMgU3RhdHVzMiB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIGNyZWF0ZUZ1bmdpYmxlVG9rZW5Qcm9tcHQgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCB0cmVhc3VyeUFjY291bnREZXNjID0gUHJvbXB0R2VuZXJhdG9yLmdldEFjY291bnRQYXJhbWV0ZXJEZXNjcmlwdGlvbihcbiAgICBcInRyZWFzdXJ5QWNjb3VudElkXCIsXG4gICAgY29udGV4dFxuICApO1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuJHtjb250ZXh0U25pcHBldH1cblxuVGhpcyB0b29sIGNyZWF0ZXMgYSBmdW5naWJsZSB0b2tlbiBvbiBIZWRlcmEuXG5cblBhcmFtZXRlcnM6XG4tIHRva2VuTmFtZSAoc3RyLCByZXF1aXJlZCk6IFRoZSBuYW1lIG9mIHRoZSB0b2tlblxuLSB0b2tlblN5bWJvbCAoc3RyLCBvcHRpb25hbCk6IFRoZSBzeW1ib2wgb2YgdGhlIHRva2VuXG4tIGluaXRpYWxTdXBwbHkgKGludCwgb3B0aW9uYWwpOiBUaGUgaW5pdGlhbCBzdXBwbHkgb2YgdGhlIHRva2VuLCBkZWZhdWx0cyB0byAwXG4tIHN1cHBseVR5cGUgKHN0ciwgb3B0aW9uYWwpOiBUaGUgc3VwcGx5IHR5cGUgb2YgdGhlIHRva2VuLiBDYW4gYmUgXCJmaW5pdGVcIiBvciBcImluZmluaXRlXCIuIERlZmF1bHRzIHRvIFwiZmluaXRlXCJcbi0gbWF4U3VwcGx5IChpbnQsIG9wdGlvbmFsKTogVGhlIG1heGltdW0gc3VwcGx5IG9mIHRoZSB0b2tlbi4gT25seSBhcHBsaWNhYmxlIGlmIHN1cHBseVR5cGUgaXMgXCJmaW5pdGVcIi4gRGVmYXVsdHMgdG8gMSwwMDAsMDAwIGlmIG5vdCBzcGVjaWZpZWRcbi0gZGVjaW1hbHMgKGludCwgb3B0aW9uYWwpOiBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzIHRoZSB0b2tlbiBzdXBwb3J0cy4gRGVmYXVsdHMgdG8gMFxuLSAke3RyZWFzdXJ5QWNjb3VudERlc2N9XG4tIGlzU3VwcGx5S2V5IChib29sZWFuLCBvcHRpb25hbCk6IElmIHVzZXIgd2FudHMgdG8gc2V0IHN1cHBseSBrZXkgc2V0IHRvIHRydWUsIG90aGVyd2lzZSBmYWxzZVxuJHt1c2FnZUluc3RydWN0aW9uc31cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzMiA9IChyZXNwb25zZSkgPT4ge1xuICByZXR1cm4gYFRva2VuIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IGF0IGFkZHJlc3MgJHtyZXNwb25zZS50b2tlbklkPy50b1N0cmluZygpfSB3aXRoIHRyYW5zYWN0aW9uIGlkICR7cmVzcG9uc2UudHJhbnNhY3Rpb25JZH1gO1xufTtcbnZhciBjcmVhdGVGdW5naWJsZVRva2VuID0gYXN5bmMgKGNsaWVudCwgY29udGV4dCwgcGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWlycm9ybm9kZVNlcnZpY2UgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IG5vcm1hbGlzZWRQYXJhbXMgPSBhd2FpdCBIZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLm5vcm1hbGlzZUNyZWF0ZUZ1bmdpYmxlVG9rZW5QYXJhbXMoXG4gICAgICBwYXJhbXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgY2xpZW50LFxuICAgICAgbWlycm9ybm9kZVNlcnZpY2VcbiAgICApO1xuICAgIGNvbnN0IHR4ID0gSGVkZXJhQnVpbGRlci5jcmVhdGVGdW5naWJsZVRva2VuKG5vcm1hbGlzZWRQYXJhbXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZVRyYW5zYWN0aW9uKHR4LCBjbGllbnQsIGNvbnRleHQsIHBvc3RQcm9jZXNzMik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gY3JlYXRlIGZ1bmdpYmxlIHRva2VuXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIltjcmVhdGVfZnVuZ2libGVfdG9rZW5fdG9vbF1cIiwgbWVzc2FnZSk7XG4gICAgcmV0dXJuIHsgcmF3OiB7IHN0YXR1czogU3RhdHVzMi5JbnZhbGlkVHJhbnNhY3Rpb24sIGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIENSRUFURV9GVU5HSUJMRV9UT0tFTl9UT09MID0gXCJjcmVhdGVfZnVuZ2libGVfdG9rZW5fdG9vbFwiO1xudmFyIHRvb2wyID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogQ1JFQVRFX0ZVTkdJQkxFX1RPS0VOX1RPT0wsXG4gIG5hbWU6IFwiQ3JlYXRlIEZ1bmdpYmxlIFRva2VuXCIsXG4gIGRlc2NyaXB0aW9uOiBjcmVhdGVGdW5naWJsZVRva2VuUHJvbXB0KGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiBjcmVhdGVGdW5naWJsZVRva2VuUGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogY3JlYXRlRnVuZ2libGVUb2tlblxufSk7XG52YXIgY3JlYXRlX2Z1bmdpYmxlX3Rva2VuX2RlZmF1bHQgPSB0b29sMjtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS10b2tlbi1wbHVnaW4vdG9vbHMvZnVuZ2libGUtdG9rZW4vbWludC1mdW5naWJsZS10b2tlbi50c1xuaW1wb3J0IHsgU3RhdHVzIGFzIFN0YXR1czMgfSBmcm9tIFwiQGhhc2hncmFwaC9zZGtcIjtcbnZhciBtaW50RnVuZ2libGVUb2tlblByb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCBtaW50IGEgZ2l2ZW4gYW1vdW50IChzdXBwbHkpIG9mIGFuIGV4aXN0aW5nIGZ1bmdpYmxlIHRva2VuIG9uIEhlZGVyYS5cblxuUGFyYW1ldGVyczpcbi0gdG9rZW5JZCAoc3RyLCByZXF1aXJlZCk6IFRoZSBpZCBvZiB0aGUgdG9rZW5cbi0gYW1vdW50IChudW1iZXIsIHJlcXVpcmVkKTogVGhlIGFtb3VudCB0byBiZSBtaW50ZWRcbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5cbkV4YW1wbGU6IFwiTWludCAxIG9mIDAuMC42NDU4MDM3XCIgbWVhbnMgbWludGluZyB0aGUgYW1vdW50IG9mIDEgb2YgdGhlIHRva2VuIHdpdGggaWQgMC4wLjY0NTgwMzcuXG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczMgPSAocmVzcG9uc2UpID0+IHtcbiAgcmV0dXJuIGBUb2tlbnMgc3VjY2Vzc2Z1bGx5IG1pbnRlZCB3aXRoIHRyYW5zYWN0aW9uIGlkICR7cmVzcG9uc2UudHJhbnNhY3Rpb25JZC50b1N0cmluZygpfWA7XG59O1xudmFyIG1pbnRGdW5naWJsZVRva2VuID0gYXN5bmMgKGNsaWVudCwgY29udGV4dCwgcGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWlycm9ybm9kZVNlcnZpY2UgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IG5vcm1hbGlzZWRQYXJhbXMgPSBhd2FpdCBIZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLm5vcm1hbGlzZU1pbnRGdW5naWJsZVRva2VuUGFyYW1zKFxuICAgICAgcGFyYW1zLFxuICAgICAgY29udGV4dCxcbiAgICAgIG1pcnJvcm5vZGVTZXJ2aWNlXG4gICAgKTtcbiAgICBjb25zdCB0eCA9IEhlZGVyYUJ1aWxkZXIubWludEZ1bmdpYmxlVG9rZW4obm9ybWFsaXNlZFBhcmFtcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlVHJhbnNhY3Rpb24odHgsIGNsaWVudCwgY29udGV4dCwgcG9zdFByb2Nlc3MzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBtaW50IGZ1bmdpYmxlIHRva2VuXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIlttaW50X2Z1bmdpYmxlX3Rva2VuX3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBzdGF0dXM6IFN0YXR1czMuSW52YWxpZFRyYW5zYWN0aW9uLCBlcnJvcjogbWVzc2FnZSB9LCBodW1hbk1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgfVxufTtcbnZhciBNSU5UX0ZVTkdJQkxFX1RPS0VOX1RPT0wgPSBcIm1pbnRfZnVuZ2libGVfdG9rZW5fdG9vbFwiO1xudmFyIHRvb2wzID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogTUlOVF9GVU5HSUJMRV9UT0tFTl9UT09MLFxuICBuYW1lOiBcIk1pbnQgRnVuZ2libGUgVG9rZW5cIixcbiAgZGVzY3JpcHRpb246IG1pbnRGdW5naWJsZVRva2VuUHJvbXB0KGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiBtaW50RnVuZ2libGVUb2tlblBhcmFtZXRlcnMoY29udGV4dCksXG4gIGV4ZWN1dGU6IG1pbnRGdW5naWJsZVRva2VuXG59KTtcbnZhciBtaW50X2Z1bmdpYmxlX3Rva2VuX2RlZmF1bHQgPSB0b29sMztcblxuLy8gc3JjL3BsdWdpbnMvY29yZS10b2tlbi1wbHVnaW4vdG9vbHMvbm9uLWZ1bmdpYmxlLXRva2VuL2NyZWF0ZS1ub24tZnVuZ2libGUtdG9rZW4udHNcbmltcG9ydCB7IFN0YXR1cyBhcyBTdGF0dXM0IH0gZnJvbSBcIkBoYXNoZ3JhcGgvc2RrXCI7XG52YXIgY3JlYXRlTm9uRnVuZ2libGVUb2tlblByb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IHRyZWFzdXJ5QWNjb3VudERlc2MgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0QWNjb3VudFBhcmFtZXRlckRlc2NyaXB0aW9uKFxuICAgIFwidHJlYXN1cnlBY2NvdW50SWRcIixcbiAgICBjb250ZXh0XG4gICk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgY3JlYXRlcyBhIG5vbi1mdW5naWJsZSB0b2tlbiAoTkZUKSBvbiBIZWRlcmEuXG5cblBhcmFtZXRlcnM6XG4tIHRva2VuTmFtZSAoc3RyLCByZXF1aXJlZCk6IE5hbWUgb2YgdGhlIHRva2VuXG4tIHRva2VuU3ltYm9sIChzdHIsIHJlcXVpcmVkKTogU3ltYm9sIG9mIHRoZSB0b2tlblxuLSBtYXhTdXBwbHkgKGludCwgb3B0aW9uYWwpOiBNYXhpbXVtIE5GVCBzdXBwbHkuIERlZmF1bHRzIHRvIDEwMCBpZiBub3QgcHJvdmlkZWRcbi0gJHt0cmVhc3VyeUFjY291bnREZXNjfVxuJHt1c2FnZUluc3RydWN0aW9uc31cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzNCA9IChyZXNwb25zZSkgPT4ge1xuICByZXR1cm4gYFRva2VuIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IGF0IGFkZHJlc3MgJHtyZXNwb25zZS50b2tlbklkPy50b1N0cmluZygpfSB3aXRoIHRyYW5zYWN0aW9uIGlkICR7cmVzcG9uc2UudHJhbnNhY3Rpb25JZC50b1N0cmluZygpfWA7XG59O1xudmFyIGNyZWF0ZU5vbkZ1bmdpYmxlVG9rZW4gPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBtaXJyb3Jub2RlU2VydmljZSA9IGdldE1pcnJvcm5vZGVTZXJ2aWNlKGNvbnRleHQubWlycm9ybm9kZVNlcnZpY2UsIGNsaWVudC5sZWRnZXJJZCk7XG4gICAgY29uc3Qgbm9ybWFsaXNlZFBhcmFtcyA9IGF3YWl0IEhlZGVyYVBhcmFtZXRlck5vcm1hbGlzZXIubm9ybWFsaXNlQ3JlYXRlTm9uRnVuZ2libGVUb2tlblBhcmFtcyhcbiAgICAgIHBhcmFtcyxcbiAgICAgIGNvbnRleHQsXG4gICAgICBjbGllbnQsXG4gICAgICBtaXJyb3Jub2RlU2VydmljZVxuICAgICk7XG4gICAgY29uc3QgdHggPSBIZWRlcmFCdWlsZGVyLmNyZWF0ZU5vbkZ1bmdpYmxlVG9rZW4obm9ybWFsaXNlZFBhcmFtcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlVHJhbnNhY3Rpb24odHgsIGNsaWVudCwgY29udGV4dCwgcG9zdFByb2Nlc3M0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBjcmVhdGUgbm9uLWZ1bmdpYmxlIHRva2VuXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIltjcmVhdGVfbm9uX2Z1bmdpYmxlX3Rva2VuX3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBzdGF0dXM6IFN0YXR1czQuSW52YWxpZFRyYW5zYWN0aW9uLCBlcnJvcjogbWVzc2FnZSB9LCBodW1hbk1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgfVxufTtcbnZhciBDUkVBVEVfTk9OX0ZVTkdJQkxFX1RPS0VOX1RPT0wgPSBcImNyZWF0ZV9ub25fZnVuZ2libGVfdG9rZW5fdG9vbFwiO1xudmFyIHRvb2w0ID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogQ1JFQVRFX05PTl9GVU5HSUJMRV9UT0tFTl9UT09MLFxuICBuYW1lOiBcIkNyZWF0ZSBOb24tRnVuZ2libGUgVG9rZW5cIixcbiAgZGVzY3JpcHRpb246IGNyZWF0ZU5vbkZ1bmdpYmxlVG9rZW5Qcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IGNyZWF0ZU5vbkZ1bmdpYmxlVG9rZW5QYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBjcmVhdGVOb25GdW5naWJsZVRva2VuXG59KTtcbnZhciBjcmVhdGVfbm9uX2Z1bmdpYmxlX3Rva2VuX2RlZmF1bHQgPSB0b29sNDtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS10b2tlbi1wbHVnaW4vdG9vbHMvbm9uLWZ1bmdpYmxlLXRva2VuL21pbnQtbm9uLWZ1bmdpYmxlLXRva2VuLnRzXG5pbXBvcnQgeyBTdGF0dXMgYXMgU3RhdHVzNSB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIG1pbnROb25GdW5naWJsZVRva2VuUHJvbXB0ID0gKF9jb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgdXNhZ2VJbnN0cnVjdGlvbnMgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0UGFyYW1ldGVyVXNhZ2VJbnN0cnVjdGlvbnMoKTtcbiAgcmV0dXJuIGBcblxuVGhpcyB0b29sIHdpbGwgbWludCBORlRzIHdpdGggaXRzIHVuaXF1ZSBtZXRhZGF0YSBmb3IgdGhlIGNsYXNzIG9mIE5GVHMgKG5vbi1mdW5naWJsZSB0b2tlbnMpIGRlZmluZWQgYnkgdGhlIHRva2VuSWQgb24gSGVkZXJhLlxuXG5QYXJhbWV0ZXJzOlxuLSB0b2tlbklkIChzdHIsIHJlcXVpcmVkKTogVGhlIGlkIG9mIHRoZSB0b2tlblxuLSB1cmlzIChhcnJheSwgcmVxdWlyZWQpOiBBbiBhcnJheSBvZiBzdHJpbmdzIChVUklzKSBvZiBtYXhpbXVtIHNpemUgMTAgaG9zdGluZyB0aGUgTkZUIG1ldGFkYXRhXG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuXG5FeGFtcGxlOiBcIk1pbnQgMC4wLjY0NjU1MDMgd2l0aCBtZXRhZGF0YTogaXBmczovL2JhZnlyZWlhbzZhamdzZmppNnFzZ2Jxd2R0amR1NWdtdWw3dHYydjNwZDZramdjdzVvNjViMm9nc3Q0L21ldGFkYXRhLmpzb25cIiBtZWFucyBtaW50aW5nIGFuIE5GVCB3aXRoIHRoZSBnaXZlbiBtZXRhZGF0YSBVUkkgZm9yIHRoZSBjbGFzcyBvZiBORlRzIGRlZmluZWQgYnkgdGhlIHRva2VuIHdpdGggaWQgMC4wLjY0NjU1MDMuXG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczUgPSAocmVzcG9uc2UpID0+IHtcbiAgcmV0dXJuIGBUb2tlbiAke3Jlc3BvbnNlLnRva2VuSWQ/LnRvU3RyaW5nKCl9IHN1Y2Nlc3NmdWxseSBtaW50ZWQgd2l0aCB0cmFuc2FjdGlvbiBpZCAke3Jlc3BvbnNlLnRyYW5zYWN0aW9uSWQudG9TdHJpbmcoKX1gO1xufTtcbnZhciBtaW50Tm9uRnVuZ2libGVUb2tlbiA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG5vcm1hbGlzZWRQYXJhbXMgPSBIZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLm5vcm1hbGlzZU1pbnROb25GdW5naWJsZVRva2VuUGFyYW1zKFxuICAgICAgcGFyYW1zLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgY29uc3QgdHggPSBIZWRlcmFCdWlsZGVyLm1pbnROb25GdW5naWJsZVRva2VuKG5vcm1hbGlzZWRQYXJhbXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZVRyYW5zYWN0aW9uKHR4LCBjbGllbnQsIGNvbnRleHQsIHBvc3RQcm9jZXNzNSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gbWludCBub24tZnVuZ2libGUgdG9rZW5cIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW21pbnRfbm9uX2Z1bmdpYmxlX3Rva2VuX3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBzdGF0dXM6IFN0YXR1czUuSW52YWxpZFRyYW5zYWN0aW9uLCBlcnJvcjogbWVzc2FnZSB9LCBodW1hbk1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgfVxufTtcbnZhciBNSU5UX05PTl9GVU5HSUJMRV9UT0tFTl9UT09MID0gXCJtaW50X25vbl9mdW5naWJsZV90b2tlbl90b29sXCI7XG52YXIgdG9vbDUgPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBNSU5UX05PTl9GVU5HSUJMRV9UT0tFTl9UT09MLFxuICBuYW1lOiBcIk1pbnQgTm9uLUZ1bmdpYmxlIFRva2VuXCIsXG4gIGRlc2NyaXB0aW9uOiBtaW50Tm9uRnVuZ2libGVUb2tlblByb21wdChjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogbWludE5vbkZ1bmdpYmxlVG9rZW5QYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBtaW50Tm9uRnVuZ2libGVUb2tlblxufSk7XG52YXIgbWludF9ub25fZnVuZ2libGVfdG9rZW5fZGVmYXVsdCA9IHRvb2w1O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLXRva2VuLXBsdWdpbi90b29scy91cGRhdGUtdG9rZW4udHNcbmltcG9ydCB7IFB1YmxpY0tleSBhcyBQdWJsaWNLZXk1LCBTdGF0dXMgYXMgU3RhdHVzNiB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIGNoZWNrVmFsaWRpdHlPZlVwZGF0ZXMgPSBhc3luYyAocGFyYW1zLCBtaXJyb3Jub2RlLCB1c2VyUHVibGljS2V5KSA9PiB7XG4gIGNvbnN0IHRva2VuRGV0YWlscyA9IGF3YWl0IG1pcnJvcm5vZGUuZ2V0VG9rZW5JbmZvKHBhcmFtcy50b2tlbklkLnRvU3RyaW5nKCkpO1xuICBpZiAoIXRva2VuRGV0YWlscykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRva2VuIG5vdCBmb3VuZFwiKTtcbiAgfVxuICBpZiAodG9rZW5EZXRhaWxzLmFkbWluX2tleT8ua2V5ICE9PSB1c2VyUHVibGljS2V5LnRvU3RyaW5nUmF3KCkpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYHRva2VuRGV0YWlscy5hZG1pbl9rZXkua2V5OiAke3Rva2VuRGV0YWlscy5hZG1pbl9rZXk/LmtleX0gdnMgdXNlclB1YmxpY0tleTogJHt1c2VyUHVibGljS2V5LnRvU3RyaW5nUmF3KCl9YFxuICAgICk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byB1cGRhdGUgdGhpcyB0b2tlbi4gVGhlIGFkbWluS2V5IGRvZXMgbm90IG1hdGNoIHlvdXIgcHVibGljIGtleS5cIlxuICAgICk7XG4gIH1cbiAgY29uc3Qga2V5Q2hlY2tzID0ge1xuICAgIGFkbWluS2V5OiBcImFkbWluX2tleVwiLFxuICAgIGt5Y0tleTogXCJreWNfa2V5XCIsXG4gICAgZnJlZXplS2V5OiBcImZyZWV6ZV9rZXlcIixcbiAgICB3aXBlS2V5OiBcIndpcGVfa2V5XCIsXG4gICAgc3VwcGx5S2V5OiBcInN1cHBseV9rZXlcIixcbiAgICBmZWVTY2hlZHVsZUtleTogXCJmZWVfc2NoZWR1bGVfa2V5XCIsXG4gICAgcGF1c2VLZXk6IFwicGF1c2Vfa2V5XCIsXG4gICAgbWV0YWRhdGFLZXk6IFwibWV0YWRhdGFfa2V5XCJcbiAgfTtcbiAgZm9yIChjb25zdCBbcGFyYW1LZXksIHRva2VuRmllbGRdIG9mIE9iamVjdC5lbnRyaWVzKGtleUNoZWNrcykpIHtcbiAgICBjb25zdCB1c2VyVmFsdWUgPSBwYXJhbXNbcGFyYW1LZXldO1xuICAgIGNvbnN0IHRva2VuS2V5ID0gdG9rZW5EZXRhaWxzW3Rva2VuRmllbGRdO1xuICAgIGlmICh1c2VyVmFsdWUgaW5zdGFuY2VvZiBQdWJsaWNLZXk1ICYmICF0b2tlbktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXBkYXRlICR7cGFyYW1LZXl9OiB0b2tlbiB3YXMgY3JlYXRlZCB3aXRob3V0IGEgJHtwYXJhbUtleX1gKTtcbiAgICB9XG4gIH1cbn07XG52YXIgdXBkYXRlVG9rZW5Qcm9tcHQgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCB0b2tlbkRlc2MgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0QW55QWRkcmVzc1BhcmFtZXRlckRlc2NyaXB0aW9uKFwidG9rZW5JZFwiLCBjb250ZXh0KTtcbiAgY29uc3QgdXNhZ2VJbnN0cnVjdGlvbnMgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0UGFyYW1ldGVyVXNhZ2VJbnN0cnVjdGlvbnMoKTtcbiAgcmV0dXJuIGBcbiR7Y29udGV4dFNuaXBwZXR9XG5cblRoaXMgdG9vbCB3aWxsIHVwZGF0ZSBhbiBleGlzdGluZyBIZWRlcmEgSFRTIHRva2VuLiBPbmx5IHRoZSBmaWVsZHMgcHJvdmlkZWQgd2lsbCBiZSB1cGRhdGVkLlxuXG5LZXkgZmllbGRzIChhZG1pbktleSwga3ljS2V5LCBmcmVlemVLZXksIHdpcGVLZXksIHN1cHBseUtleSwgZmVlU2NoZWR1bGVLZXksIHBhdXNlS2V5LCBtZXRhZGF0YUtleSkgbXVzdCBjb250YWluICoqSGVkZXJhLWNvbXBhdGlibGUgcHVibGljIGtleXMgKGFzIHN0cmluZ3MpIG9yIGJvb2xlYW4gKHRydWUvZmFsc2UpKiouIFlvdSBjYW4gcHJvdmlkZSB0aGVzZSBpbiBvbmUgb2YgdGhyZWUgd2F5czpcblxuMS4gKipCb29sZWFuIHRydWUqKiBcXHUyMDEzIFNldCB0aGlzIGZpZWxkIHRvIHVzZSB1c2VyL29wZXJhdG9yIGtleS4gSW5qZWN0aW5nIG9mIHRoZSBrZXkgd2lsbCBiZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHkuXG4yLiAqKk5vdCBwcm92aWRlZCoqIFxcdTIwMTMgVGhlIGZpZWxkIHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4zLiAqKlN0cmluZyoqIFxcdTIwMTMgUHJvdmlkZSBhIEhlZGVyYS1jb21wYXRpYmxlIHB1YmxpYyBrZXkgc3RyaW5nIHRvIHNldCBhIGZpZWxkIGV4cGxpY2l0bHkuXG5cblBhcmFtZXRlcnM6XG4tICR7dG9rZW5EZXNjfVxuLSB0b2tlbk5hbWUgKHN0cmluZywgb3B0aW9uYWwpOiBOZXcgbmFtZSBmb3IgdGhlIHRva2VuLiBVcCB0byAxMDAgY2hhcmFjdGVycy5cbi0gdG9rZW5TeW1ib2wgKHN0cmluZywgb3B0aW9uYWwpOiBOZXcgc3ltYm9sIGZvciB0aGUgdG9rZW4uIFVwIHRvIDEwMCBjaGFyYWN0ZXJzLlxuLSB0cmVhc3VyeUFjY291bnRJZCAoc3RyaW5nLCBvcHRpb25hbCk6IE5ldyB0cmVhc3VyeSBhY2NvdW50IGZvciB0aGUgdG9rZW4gKEhlZGVyYSBhY2NvdW50IElEKS5cbi0gYWRtaW5LZXkgKGJvb2xlYW58c3RyaW5nLCBvcHRpb25hbCk6IE5ldyBhZG1pbiBrZXkuIFBhc3MgdHJ1ZSB0byB1c2UgeW91ciBvcGVyYXRvciBrZXksIG9yIHByb3ZpZGUgYSBwdWJsaWMga2V5IHN0cmluZy5cbi0ga3ljS2V5IChib29sZWFufHN0cmluZywgb3B0aW9uYWwpOiBOZXcgS1lDIGtleS4gUGFzcyB0cnVlIHRvIHVzZSB5b3VyIG9wZXJhdG9yIGtleSwgb3IgcHJvdmlkZSBhIHB1YmxpYyBrZXkgc3RyaW5nLlxuLSBmcmVlemVLZXkgKGJvb2xlYW58c3RyaW5nLCBvcHRpb25hbCk6IE5ldyBmcmVlemUga2V5LiBQYXNzIHRydWUgdG8gdXNlIHlvdXIgb3BlcmF0b3Iga2V5LCBvciBwcm92aWRlIGEgcHVibGljIGtleSBzdHJpbmcuXG4tIHdpcGVLZXkgKGJvb2xlYW58c3RyaW5nLCBvcHRpb25hbCk6IE5ldyB3aXBlIGtleS4gUGFzcyB0cnVlIHRvIHVzZSB5b3VyIG9wZXJhdG9yIGtleSwgb3IgcHJvdmlkZSBhIHB1YmxpYyBrZXkgc3RyaW5nLlxuLSBzdXBwbHlLZXkgKGJvb2xlYW58c3RyaW5nLCBvcHRpb25hbCk6IE5ldyBzdXBwbHkga2V5LiBQYXNzIHRydWUgdG8gdXNlIHlvdXIgb3BlcmF0b3Iga2V5LCBvciBwcm92aWRlIGEgcHVibGljIGtleSBzdHJpbmcuXG4tIGZlZVNjaGVkdWxlS2V5IChib29sZWFufHN0cmluZywgb3B0aW9uYWwpOiBOZXcgZmVlIHNjaGVkdWxlIGtleS4gUGFzcyB0cnVlIHRvIHVzZSB5b3VyIG9wZXJhdG9yIGtleSwgb3IgcHJvdmlkZSBhIHB1YmxpYyBrZXkgc3RyaW5nLlxuLSBwYXVzZUtleSAoYm9vbGVhbnxzdHJpbmcsIG9wdGlvbmFsKTogTmV3IHBhdXNlIGtleS4gUGFzcyB0cnVlIHRvIHVzZSB5b3VyIG9wZXJhdG9yIGtleSwgb3IgcHJvdmlkZSBhIHB1YmxpYyBrZXkgc3RyaW5nLlxuLSBtZXRhZGF0YUtleSAoYm9vbGVhbnxzdHJpbmcsIG9wdGlvbmFsKTogTmV3IG1ldGFkYXRhIGtleS4gUGFzcyB0cnVlIHRvIHVzZSB5b3VyIG9wZXJhdG9yIGtleSwgb3IgcHJvdmlkZSBhIHB1YmxpYyBrZXkgc3RyaW5nLlxuLSBtZXRhZGF0YSAoc3RyaW5nLCBvcHRpb25hbCk6IE5ldyBtZXRhZGF0YSBmb3IgdGhlIHRva2VuLCBpbiBieXRlcyAoaGV4IG9yIGJhc2U2NCkuXG4tIHRva2VuTWVtbyAoc3RyaW5nLCBvcHRpb25hbCk6IFNob3J0IHB1YmxpYyBtZW1vIGZvciB0aGUgdG9rZW4sIHVwIHRvIDEwMCBjaGFyYWN0ZXJzLlxuLSBhdXRvUmVuZXdBY2NvdW50SWQgKHN0cmluZywgb3B0aW9uYWwpOiBBY2NvdW50IHRvIGF1dG9tYXRpY2FsbHkgcGF5IGZvciByZW5ld2FsLlxuXG5FeGFtcGxlczpcbi0gSWYgdGhlIHVzZXIgYXNrcyBmb3IgXCJteSBrZXlcIiBcXHUyMTkyIHNldCB0aGUgZmllbGQgdG8gXFxgdHJ1ZVxcYC5cbi0gSWYgdGhlIHVzZXIgZG9lcyBub3QgbWVudGlvbiB0aGUga2V5IFxcdTIxOTIgZG8gbm90IHNldCB0aGUgZmllbGQuXG4tIElmIHRoZSB1c2VyIHByb3ZpZGVzIGEga2V5IFxcdTIxOTIgc2V0IHRoZSBmaWVsZCB0byB0aGUgcHJvdmlkZWQgcHVibGljIGtleSBzdHJpbmcuXG5cbklmIHRoZSB1c2VyIHByb3ZpZGVzIG11bHRpcGxlIGZpZWxkcyBpbiBhIHNpbmdsZSByZXF1ZXN0LCBcbmNvbWJpbmUgdGhlbSBpbnRvICoqb25lIHRvb2wgY2FsbCoqIHdpdGggYWxsIHBhcmFtZXRlcnMgdG9nZXRoZXIuXG5cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczYgPSAocmVzcG9uc2UpID0+IHtcbiAgcmV0dXJuIGBUb2tlbiBzdWNjZXNzZnVsbHkgdXBkYXRlZC4gVHJhbnNhY3Rpb24gSUQ6ICR7cmVzcG9uc2UudHJhbnNhY3Rpb25JZH1gO1xufTtcbnZhciB1cGRhdGVUb2tlbiA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG5vcm1hbGlzZWRQYXJhbXMgPSBhd2FpdCBIZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLm5vcm1hbGlzZVVwZGF0ZVRva2VuKFxuICAgICAgcGFyYW1zLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNsaWVudFxuICAgICk7XG4gICAgY29uc3QgbWlycm9ybm9kZVNlcnZpY2UgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IHVzZXJQdWJsaWNLZXkgPSBhd2FpdCBBY2NvdW50UmVzb2x2ZXIuZ2V0RGVmYXVsdFB1YmxpY0tleShjb250ZXh0LCBjbGllbnQpO1xuICAgIGF3YWl0IGNoZWNrVmFsaWRpdHlPZlVwZGF0ZXMobm9ybWFsaXNlZFBhcmFtcywgbWlycm9ybm9kZVNlcnZpY2UsIHVzZXJQdWJsaWNLZXkpO1xuICAgIGNvbnN0IHR4ID0gSGVkZXJhQnVpbGRlci51cGRhdGVUb2tlbihub3JtYWxpc2VkUGFyYW1zKTtcbiAgICByZXR1cm4gYXdhaXQgaGFuZGxlVHJhbnNhY3Rpb24odHgsIGNsaWVudCwgY29udGV4dCwgcG9zdFByb2Nlc3M2KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gdXBkYXRlIHRva2VuXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIlt1cGRhdGVfdG9rZW5fdG9vbF1cIiwgbWVzc2FnZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhdzogeyBzdGF0dXM6IFN0YXR1czYuSW52YWxpZFRyYW5zYWN0aW9uLCBlcnJvcjogbWVzc2FnZSB9LFxuICAgICAgaHVtYW5NZXNzYWdlOiBtZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcbnZhciBVUERBVEVfVE9LRU5fVE9PTCA9IFwidXBkYXRlX3Rva2VuX3Rvb2xcIjtcbnZhciB0b29sNiA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IFVQREFURV9UT0tFTl9UT09MLFxuICBuYW1lOiBcIlVwZGF0ZSBUb2tlblwiLFxuICBkZXNjcmlwdGlvbjogdXBkYXRlVG9rZW5Qcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IHVwZGF0ZVRva2VuUGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogdXBkYXRlVG9rZW5cbn0pO1xudmFyIHVwZGF0ZV90b2tlbl9kZWZhdWx0ID0gdG9vbDY7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtdG9rZW4tcGx1Z2luL3Rvb2xzL2Rpc3NvY2lhdGUtdG9rZW4udHNcbmltcG9ydCB7IFN0YXR1cyBhcyBTdGF0dXM3IH0gZnJvbSBcIkBoYXNoZ3JhcGgvc2RrXCI7XG52YXIgZGlzc29jaWF0ZVRva2VuUHJvbXB0ID0gKGNvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCBjb250ZXh0U25pcHBldCA9IFByb21wdEdlbmVyYXRvci5nZXRDb250ZXh0U25pcHBldChjb250ZXh0KTtcbiAgY29uc3Qgc291cmNlQWNjb3VudERlc2MgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0QWNjb3VudFBhcmFtZXRlckRlc2NyaXB0aW9uKFwiYWNjb3VudElkXCIsIGNvbnRleHQpO1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuJHtjb250ZXh0U25pcHBldH1cblxuVGhpcyB0b29sIHdpbGwgYWlyZHJvcCBhIGZ1bmdpYmxlIHRva2VuIG9uIEhlZGVyYS5cblxuUGFyYW1ldGVyczpcbi0gdG9rZW5JZHMgKGFycmF5IG9mIHN0cmluZ3MsIHJlcXVpcmVkKTogQSBsaXN0IG9mIEhlZGVyYSB0b2tlbiBJRHMgdG8gZGlzc29jaWF0ZSBmcm9tIHRoZSBhY2NvdW50LiBFeGFtcGxlOiBbXCIwLjAuMTIzNFwiLCBcIjAuMC41Njc4XCJdXG4tICR7c291cmNlQWNjb3VudERlc2N9LCBhY2NvdW50IGZyb20gd2hpY2ggdG8gZGlzc29jaWF0ZSB0aGUgdG9rZW4ocylcbi0gdHJhbnNhY3Rpb25NZW1vIChzdHIsIG9wdGlvbmFsKTogT3B0aW9uYWwgbWVtbyBmb3IgdGhlIHRyYW5zYWN0aW9uXG5cbkV4YW1wbGVzOlxuLSBEaXNzb2NpYXRlIGEgc2luZ2xlIHRva2VuOiB7IFwidG9rZW5JZHNcIjogW1wiMC4wLjEyMzRcIl0gfVxuLSBEaXNzb2NpYXRlIG11bHRpcGxlIHRva2VucyBmcm9tIGEgc3BlY2lmaWMgYWNjb3VudDogeyBcInRva2VuSWRzXCI6IFtcIjAuMC4xMjM0XCIsIFwiMC4wLjU2NzhcIl0sIFwiYWNjb3VudElkXCI6IFwiMC4wLjQzMjFcIiB9XG5cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczcgPSAocmVzcG9uc2UpID0+IHtcbiAgcmV0dXJuIGBUb2tlbihzKSBzdWNjZXNzZnVsbHkgZGlzc29jaWF0ZWQgd2l0aCB0cmFuc2FjdGlvbiBpZCAke3Jlc3BvbnNlLnRyYW5zYWN0aW9uSWQudG9TdHJpbmcoKX1gO1xufTtcbnZhciBkaXNzb2NpYXRlVG9rZW4gPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBub3JtYWxpc2VkUGFyYW1zID0gYXdhaXQgSGVkZXJhUGFyYW1ldGVyTm9ybWFsaXNlci5ub3JtYWxpc2VEaXNzb2NpYXRlVG9rZW5QYXJhbXMoXG4gICAgICBwYXJhbXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgY2xpZW50XG4gICAgKTtcbiAgICBjb25zdCB0eCA9IEhlZGVyYUJ1aWxkZXIuZGlzc29jaWF0ZVRva2VuKG5vcm1hbGlzZWRQYXJhbXMpO1xuICAgIHJldHVybiBhd2FpdCBoYW5kbGVUcmFuc2FjdGlvbih0eCwgY2xpZW50LCBjb250ZXh0LCBwb3N0UHJvY2VzczcpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBkaXNzb2NpYXRlIHRva2VuXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIltkaXNzb2NpYXRlX3Rva2VuX3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBzdGF0dXM6IFN0YXR1czcuSW52YWxpZFRyYW5zYWN0aW9uLCBlcnJvcjogbWVzc2FnZSB9LCBodW1hbk1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgfVxufTtcbnZhciBESVNTT0NJQVRFX1RPS0VOX1RPT0wgPSBcImRpc3NvY2lhdGVfdG9rZW5fdG9vbFwiO1xudmFyIHRvb2w3ID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogRElTU09DSUFURV9UT0tFTl9UT09MLFxuICBuYW1lOiBcIkRpc3NvY2lhdGUgVG9rZW5cIixcbiAgZGVzY3JpcHRpb246IGRpc3NvY2lhdGVUb2tlblByb21wdChjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogZGlzc29jaWF0ZVRva2VuUGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogZGlzc29jaWF0ZVRva2VuXG59KTtcbnZhciBkaXNzb2NpYXRlX3Rva2VuX2RlZmF1bHQgPSB0b29sNztcblxuLy8gc3JjL3BsdWdpbnMvY29yZS10b2tlbi1wbHVnaW4vdG9vbHMvYXNzb2NpYXRlLXRva2VuLnRzXG5pbXBvcnQgeyBTdGF0dXMgYXMgU3RhdHVzOCB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIGFzc29jaWF0ZVRva2VuUHJvbXB0ID0gKGNvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCBjb250ZXh0U25pcHBldCA9IFByb21wdEdlbmVyYXRvci5nZXRDb250ZXh0U25pcHBldChjb250ZXh0KTtcbiAgY29uc3QgdXNhZ2VJbnN0cnVjdGlvbnMgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0UGFyYW1ldGVyVXNhZ2VJbnN0cnVjdGlvbnMoKTtcbiAgY29uc3QgYWNjb3VudFRvQXNzb2NpYXRlID0gUHJvbXB0R2VuZXJhdG9yLmdldEFueUFkZHJlc3NQYXJhbWV0ZXJEZXNjcmlwdGlvbihcImFjY291bnRJZFwiLCBjb250ZXh0KTtcbiAgcmV0dXJuIGBcbiR7Y29udGV4dFNuaXBwZXR9XG5cblRoaXMgdG9vbCB3aWxsIGFzc29jaWF0ZSBvbmUgb3IgbW9yZSB0b2tlbnMgd2l0aCBhIEhlZGVyYSBhY2NvdW50LlxuXG5QYXJhbWV0ZXJzOlxuJHthY2NvdW50VG9Bc3NvY2lhdGV9XG4tIHRva2VuSWRzIChzdHJpbmdbXSwgcmVxdWlyZWQpOiBBcnJheSBvZiB0b2tlbiBJRHMgdG8gYXNzb2NpYXRlXG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuXG5FeGFtcGxlOiBcIkFzc29jaWF0ZSB0b2tlbnMgMC4wLjEyMyBhbmQgMC4wLjQ1NiB0byBhY2NvdW50IDAuMC43ODlcIi5cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzOCA9IChyZXNwb25zZSkgPT4ge1xuICByZXR1cm4gYFRva2VucyBzdWNjZXNzZnVsbHkgYXNzb2NpYXRlZCB3aXRoIHRyYW5zYWN0aW9uIGlkICR7cmVzcG9uc2UudHJhbnNhY3Rpb25JZC50b1N0cmluZygpfWA7XG59O1xudmFyIGFzc29jaWF0ZVRva2VuID0gYXN5bmMgKGNsaWVudCwgY29udGV4dCwgcGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgbm9ybWFsaXNlZFBhcmFtcyA9IEhlZGVyYVBhcmFtZXRlck5vcm1hbGlzZXIubm9ybWFsaXNlQXNzb2NpYXRlVG9rZW5QYXJhbXMoXG4gICAgICBwYXJhbXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgY2xpZW50XG4gICAgKTtcbiAgICBjb25zdCB0eCA9IEhlZGVyYUJ1aWxkZXIuYXNzb2NpYXRlVG9rZW4obm9ybWFsaXNlZFBhcmFtcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlVHJhbnNhY3Rpb24odHgsIGNsaWVudCwgY29udGV4dCwgcG9zdFByb2Nlc3M4KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBhc3NvY2lhdGUgdG9rZW4ocylcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW2Fzc29jaWF0ZV90b2tlbl90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgc3RhdHVzOiBTdGF0dXM4LkludmFsaWRUcmFuc2FjdGlvbiwgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgQVNTT0NJQVRFX1RPS0VOX1RPT0wgPSBcImFzc29jaWF0ZV90b2tlbl90b29sXCI7XG52YXIgdG9vbDggPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBBU1NPQ0lBVEVfVE9LRU5fVE9PTCxcbiAgbmFtZTogXCJBc3NvY2lhdGUgVG9rZW4ocylcIixcbiAgZGVzY3JpcHRpb246IGFzc29jaWF0ZVRva2VuUHJvbXB0KGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiBhc3NvY2lhdGVUb2tlblBhcmFtZXRlcnMoY29udGV4dCksXG4gIGV4ZWN1dGU6IGFzc29jaWF0ZVRva2VuXG59KTtcbnZhciBhc3NvY2lhdGVfdG9rZW5fZGVmYXVsdCA9IHRvb2w4O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLXRva2VuLXBsdWdpbi9pbmRleC50c1xudmFyIGNvcmVUb2tlblBsdWdpbiA9IHtcbiAgbmFtZTogXCJjb3JlLXRva2VuLXBsdWdpblwiLFxuICB2ZXJzaW9uOiBcIjEuMC4wXCIsXG4gIGRlc2NyaXB0aW9uOiBcIkEgcGx1Z2luIGZvciB0aGUgSGVkZXJhIFRva2VuIFNlcnZpY2VcIixcbiAgdG9vbHM6IChjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGNyZWF0ZV9mdW5naWJsZV90b2tlbl9kZWZhdWx0KGNvbnRleHQpLFxuICAgICAgbWludF9mdW5naWJsZV90b2tlbl9kZWZhdWx0KGNvbnRleHQpLFxuICAgICAgY3JlYXRlX25vbl9mdW5naWJsZV90b2tlbl9kZWZhdWx0KGNvbnRleHQpLFxuICAgICAgYWlyZHJvcF9mdW5naWJsZV90b2tlbl9kZWZhdWx0KGNvbnRleHQpLFxuICAgICAgbWludF9ub25fZnVuZ2libGVfdG9rZW5fZGVmYXVsdChjb250ZXh0KSxcbiAgICAgIHVwZGF0ZV90b2tlbl9kZWZhdWx0KGNvbnRleHQpLFxuICAgICAgZGlzc29jaWF0ZV90b2tlbl9kZWZhdWx0KGNvbnRleHQpLFxuICAgICAgYXNzb2NpYXRlX3Rva2VuX2RlZmF1bHQoY29udGV4dClcbiAgICBdO1xuICB9XG59O1xudmFyIGNvcmVUb2tlblBsdWdpblRvb2xOYW1lcyA9IHtcbiAgQUlSRFJPUF9GVU5HSUJMRV9UT0tFTl9UT09MLFxuICBDUkVBVEVfRlVOR0lCTEVfVE9LRU5fVE9PTCxcbiAgTUlOVF9GVU5HSUJMRV9UT0tFTl9UT09MLFxuICBDUkVBVEVfTk9OX0ZVTkdJQkxFX1RPS0VOX1RPT0wsXG4gIE1JTlRfTk9OX0ZVTkdJQkxFX1RPS0VOX1RPT0wsXG4gIERJU1NPQ0lBVEVfVE9LRU5fVE9PTCxcbiAgQVNTT0NJQVRFX1RPS0VOX1RPT0wsXG4gIFVQREFURV9UT0tFTl9UT09MXG59O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLWFjY291bnQtcGx1Z2luL3Rvb2xzL2FjY291bnQvdHJhbnNmZXItaGJhci50c1xuaW1wb3J0IHsgU3RhdHVzIGFzIFN0YXR1czkgfSBmcm9tIFwiQGhhc2hncmFwaC9zZGtcIjtcbnZhciB0cmFuc2ZlckhiYXJQcm9tcHQgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCBzb3VyY2VBY2NvdW50RGVzYyA9IFByb21wdEdlbmVyYXRvci5nZXRBY2NvdW50UGFyYW1ldGVyRGVzY3JpcHRpb24oXG4gICAgXCJzb3VyY2VBY2NvdW50SWRcIixcbiAgICBjb250ZXh0XG4gICk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCB0cmFuc2ZlciBIQkFSIHRvIGFuIGFjY291bnQuXG5cblBhcmFtZXRlcnM6XG4tIHRyYW5zZmVycyAoYXJyYXkgb2Ygb2JqZWN0cywgcmVxdWlyZWQpOiBMaXN0IG9mIEhCQVIgdHJhbnNmZXJzLiBFYWNoIG9iamVjdCBzaG91bGQgY29udGFpbjpcbiAgLSBhY2NvdW50SWQgKHN0cmluZyk6IFJlY2lwaWVudCBhY2NvdW50IElEXG4gIC0gYW1vdW50IChudW1iZXIpOiBBbW91bnQgb2YgSEJBUiB0byB0cmFuc2ZlclxuLSAke3NvdXJjZUFjY291bnREZXNjfVxuLSB0cmFuc2FjdGlvbk1lbW8gKHN0cmluZywgb3B0aW9uYWwpOiBPcHRpb25hbCBtZW1vIGZvciB0aGUgdHJhbnNhY3Rpb25cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczkgPSAocmVzcG9uc2UpID0+IHtcbiAgcmV0dXJuIGBIQkFSIHN1Y2Nlc3NmdWxseSB0cmFuc2ZlcnJlZC4gVHJhbnNhY3Rpb24gSUQ6ICR7cmVzcG9uc2UudHJhbnNhY3Rpb25JZH1gO1xufTtcbnZhciB0cmFuc2ZlckhiYXIgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBub3JtYWxpc2VkUGFyYW1zID0gSGVkZXJhUGFyYW1ldGVyTm9ybWFsaXNlci5ub3JtYWxpc2VUcmFuc2ZlckhiYXIoXG4gICAgICBwYXJhbXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgY2xpZW50XG4gICAgKTtcbiAgICBjb25zdCB0eCA9IEhlZGVyYUJ1aWxkZXIudHJhbnNmZXJIYmFyKG5vcm1hbGlzZWRQYXJhbXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZVRyYW5zYWN0aW9uKHR4LCBjbGllbnQsIGNvbnRleHQsIHBvc3RQcm9jZXNzOSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gdHJhbnNmZXIgSEJBUlwiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXNjICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgOiAke2Vycm9yLm1lc3NhZ2V9YCA6IFwiXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbdHJhbnNmZXJfaGJhcl90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgc3RhdHVzOiBTdGF0dXM5LkludmFsaWRUcmFuc2FjdGlvbiwgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgVFJBTlNGRVJfSEJBUl9UT09MID0gXCJ0cmFuc2Zlcl9oYmFyX3Rvb2xcIjtcbnZhciB0b29sOSA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IFRSQU5TRkVSX0hCQVJfVE9PTCxcbiAgbmFtZTogXCJUcmFuc2ZlciBIQkFSXCIsXG4gIGRlc2NyaXB0aW9uOiB0cmFuc2ZlckhiYXJQcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IHRyYW5zZmVySGJhclBhcmFtZXRlcnMoY29udGV4dCksXG4gIGV4ZWN1dGU6IHRyYW5zZmVySGJhclxufSk7XG52YXIgdHJhbnNmZXJfaGJhcl9kZWZhdWx0ID0gdG9vbDk7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtYWNjb3VudC1wbHVnaW4vdG9vbHMvYWNjb3VudC9hcHByb3ZlLWhiYXItYWxsb3dhbmNlLnRzXG52YXIgYXBwcm92ZUhiYXJBbGxvd2FuY2VQcm9tcHQgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCBvd25lckFjY291bnREZXNjID0gUHJvbXB0R2VuZXJhdG9yLmdldEFjY291bnRQYXJhbWV0ZXJEZXNjcmlwdGlvbihcbiAgICBcIm93bmVyQWNjb3VudElkXCIsXG4gICAgY29udGV4dFxuICApO1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuJHtjb250ZXh0U25pcHBldH1cblxuVGhpcyB0b29sIGFwcHJvdmVzIGFuIEhCQVIgYWxsb3dhbmNlIGZyb20gdGhlIG93bmVyIHRvIHRoZSBzcGVuZGVyLlxuXG5QYXJhbWV0ZXJzOlxuLSAke293bmVyQWNjb3VudERlc2N9XG4tIHNwZW5kZXJBY2NvdW50SWQgKHN0cmluZywgcmVxdWlyZWQpOiBTcGVuZGVyIGFjY291bnQgSURcbi0gYW1vdW50IChudW1iZXIsIHJlcXVpcmVkKTogQW1vdW50IG9mIEhCQVIgdG8gYXBwcm92ZSAoY2FuIGJlIGRlY2ltYWwsIGNhbm5vdCBiZSBuZWdhdGl2ZSlcbi0gdHJhbnNhY3Rpb25NZW1vIChzdHJpbmcsIG9wdGlvbmFsKTogT3B0aW9uYWwgbWVtbyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuYDtcbn07XG52YXIgcG9zdFByb2Nlc3MxMCA9IChyZXNwb25zZSkgPT4ge1xuICByZXR1cm4gYEhCQVIgYWxsb3dhbmNlIGFwcHJvdmVkIHN1Y2Nlc3NmdWxseS4gVHJhbnNhY3Rpb24gSUQ6ICR7cmVzcG9uc2UudHJhbnNhY3Rpb25JZH1gO1xufTtcbnZhciBhcHByb3ZlSGJhckFsbG93YW5jZSA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICBjb25zdCBub3JtYWxpc2VkUGFyYW1zID0gSGVkZXJhUGFyYW1ldGVyTm9ybWFsaXNlci5ub3JtYWxpc2VBcHByb3ZlSGJhckFsbG93YW5jZShcbiAgICBwYXJhbXMsXG4gICAgY29udGV4dCxcbiAgICBjbGllbnRcbiAgKTtcbiAgY29uc3QgdHggPSBIZWRlcmFCdWlsZGVyLmFwcHJvdmVIYmFyQWxsb3dhbmNlKG5vcm1hbGlzZWRQYXJhbXMpO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVUcmFuc2FjdGlvbih0eCwgY2xpZW50LCBjb250ZXh0LCBwb3N0UHJvY2VzczEwKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgQVBQUk9WRV9IQkFSX0FMTE9XQU5DRV9UT09MID0gXCJhcHByb3ZlX2hiYXJfYWxsb3dhbmNlX3Rvb2xcIjtcbnZhciB0b29sMTAgPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBBUFBST1ZFX0hCQVJfQUxMT1dBTkNFX1RPT0wsXG4gIG5hbWU6IFwiQXBwcm92ZSBIQkFSIEFsbG93YW5jZVwiLFxuICBkZXNjcmlwdGlvbjogYXBwcm92ZUhiYXJBbGxvd2FuY2VQcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IGFwcHJvdmVIYmFyQWxsb3dhbmNlUGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogYXBwcm92ZUhiYXJBbGxvd2FuY2Vcbn0pO1xudmFyIGFwcHJvdmVfaGJhcl9hbGxvd2FuY2VfZGVmYXVsdCA9IHRvb2wxMDtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS1hY2NvdW50LXBsdWdpbi90b29scy9hY2NvdW50L2NyZWF0ZS1hY2NvdW50LnRzXG5pbXBvcnQgeyBTdGF0dXMgYXMgU3RhdHVzMTAgfSBmcm9tIFwiQGhhc2hncmFwaC9zZGtcIjtcbnZhciBjcmVhdGVBY2NvdW50UHJvbXB0ID0gKGNvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCBjb250ZXh0U25pcHBldCA9IFByb21wdEdlbmVyYXRvci5nZXRDb250ZXh0U25pcHBldChjb250ZXh0KTtcbiAgY29uc3QgdXNhZ2VJbnN0cnVjdGlvbnMgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0UGFyYW1ldGVyVXNhZ2VJbnN0cnVjdGlvbnMoKTtcbiAgcmV0dXJuIGBcbiR7Y29udGV4dFNuaXBwZXR9XG5cblRoaXMgdG9vbCB3aWxsIGNyZWF0ZSBhIG5ldyBIZWRlcmEgYWNjb3VudCB3aXRoIGEgcGFzc2VkIHB1YmxpYyBrZXkuIElmIG5vdCBwYXNzZWQsIHRoZSB0b29sIHdpbGwgdXNlIG9wZXJhdG9ycyBwdWJsaWMga2V5LlxuXG5QYXJhbWV0ZXJzOlxuLSBwdWJsaWNLZXkgKHN0cmluZywgb3B0aW9uYWwpOiBQdWJsaWMga2V5IHRvIHVzZSBmb3IgdGhlIGFjY291bnQuIElmIG5vdCBwcm92aWRlZCwgdGhlIHRvb2wgd2lsbCB1c2UgdGhlIG9wZXJhdG9ycyBwdWJsaWMga2V5LlxuLSBhY2NvdW50TWVtbyAoc3RyaW5nLCBvcHRpb25hbCk6IE9wdGlvbmFsIG1lbW8gZm9yIHRoZSBhY2NvdW50XG4tIGluaXRpYWxCYWxhbmNlIChudW1iZXIsIG9wdGlvbmFsLCBkZWZhdWx0IDApOiBJbml0aWFsIEhCQVIgdG8gZnVuZCB0aGUgYWNjb3VudFxuLSBtYXhBdXRvbWF0aWNUb2tlbkFzc29jaWF0aW9ucyAobnVtYmVyLCBvcHRpb25hbCwgZGVmYXVsdCAtMSk6IC0xIG1lYW5zIHVubGltaXRlZFxuJHt1c2FnZUluc3RydWN0aW9uc31cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzMTEgPSAocmVzcG9uc2UpID0+IHtcbiAgY29uc3QgYWNjb3VudElkU3RyID0gcmVzcG9uc2UuYWNjb3VudElkID8gcmVzcG9uc2UuYWNjb3VudElkLnRvU3RyaW5nKCkgOiBcInVua25vd25cIjtcbiAgcmV0dXJuIGBBY2NvdW50IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LlxuVHJhbnNhY3Rpb24gSUQ6ICR7cmVzcG9uc2UudHJhbnNhY3Rpb25JZH1cbk5ldyBBY2NvdW50IElEOiAke2FjY291bnRJZFN0cn1cbn1gO1xufTtcbnZhciBjcmVhdGVBY2NvdW50ID0gYXN5bmMgKGNsaWVudCwgY29udGV4dCwgcGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWlycm9ybm9kZVNlcnZpY2UgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IG5vcm1hbGlzZWRQYXJhbXMgPSBhd2FpdCBIZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLm5vcm1hbGlzZUNyZWF0ZUFjY291bnQoXG4gICAgICBwYXJhbXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgY2xpZW50LFxuICAgICAgbWlycm9ybm9kZVNlcnZpY2VcbiAgICApO1xuICAgIGNvbnN0IHR4ID0gSGVkZXJhQnVpbGRlci5jcmVhdGVBY2NvdW50KG5vcm1hbGlzZWRQYXJhbXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZVRyYW5zYWN0aW9uKHR4LCBjbGllbnQsIGNvbnRleHQsIHBvc3RQcm9jZXNzMTEpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZGVzYyA9IFwiRmFpbGVkIHRvIGNyZWF0ZSBhY2NvdW50XCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIltjcmVhdGVfYWNjb3VudF90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgc3RhdHVzOiBTdGF0dXMxMC5JbnZhbGlkVHJhbnNhY3Rpb24sIGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIENSRUFURV9BQ0NPVU5UX1RPT0wgPSBcImNyZWF0ZV9hY2NvdW50X3Rvb2xcIjtcbnZhciB0b29sMTEgPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBDUkVBVEVfQUNDT1VOVF9UT09MLFxuICBuYW1lOiBcIkNyZWF0ZSBBY2NvdW50XCIsXG4gIGRlc2NyaXB0aW9uOiBjcmVhdGVBY2NvdW50UHJvbXB0KGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiBjcmVhdGVBY2NvdW50UGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogY3JlYXRlQWNjb3VudFxufSk7XG52YXIgY3JlYXRlX2FjY291bnRfZGVmYXVsdCA9IHRvb2wxMTtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS1hY2NvdW50LXBsdWdpbi90b29scy9hY2NvdW50L2RlbGV0ZS1hY2NvdW50LnRzXG5pbXBvcnQgeyBTdGF0dXMgYXMgU3RhdHVzMTEgfSBmcm9tIFwiQGhhc2hncmFwaC9zZGtcIjtcbnZhciBkZWxldGVBY2NvdW50UHJvbXB0ID0gKGNvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCBjb250ZXh0U25pcHBldCA9IFByb21wdEdlbmVyYXRvci5nZXRDb250ZXh0U25pcHBldChjb250ZXh0KTtcbiAgY29uc3QgYWNjb3VudERlc2MgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0QWNjb3VudFBhcmFtZXRlckRlc2NyaXB0aW9uKFwiYWNjb3VudElkXCIsIGNvbnRleHQpO1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuJHtjb250ZXh0U25pcHBldH1cblxuVGhpcyB0b29sIHdpbGwgZGVsZXRlIGFuIGV4aXN0aW5nIEhlZGVyYSBhY2NvdW50LiBUaGUgcmVtYWluaW5nIGJhbGFuY2Ugb2YgdGhlIGFjY291bnQgd2lsbCBiZSB0cmFuc2ZlcnJlZCB0byB0aGUgdHJhbnNmZXJBY2NvdW50SWQgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB0aGUgb3BlcmF0b3IgYWNjb3VudCB3aWxsIGJlIHVzZWQuXG5cblBhcmFtZXRlcnM6XG4tICR7YWNjb3VudERlc2N9XG4tIGFjY291bnRJZCAoc3RyLCByZXF1aXJlZCk6IFRoZSBhY2NvdW50IElEIHRvIGRlbGV0ZVxuLSB0cmFuc2ZlckFjY291bnRJZCAoc3RyLCBvcHRpb25hbCk6IFRoZSBhY2NvdW50IElEIHRvIHRyYW5zZmVyIHRoZSByZW1haW5pbmcgYmFsYW5jZSB0by4gSWYgbm90IHByb3ZpZGVkLCB0aGUgb3BlcmF0b3IgYWNjb3VudCB3aWxsIGJlIHVzZWQuXG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuYDtcbn07XG52YXIgcG9zdFByb2Nlc3MxMiA9IChyZXNwb25zZSkgPT4ge1xuICByZXR1cm4gYEFjY291bnQgc3VjY2Vzc2Z1bGx5IGRlbGV0ZWQuIFRyYW5zYWN0aW9uIElEOiAke3Jlc3BvbnNlLnRyYW5zYWN0aW9uSWR9YDtcbn07XG52YXIgZGVsZXRlQWNjb3VudCA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG5vcm1hbGlzZWRQYXJhbXMgPSBIZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLm5vcm1hbGlzZURlbGV0ZUFjY291bnQoXG4gICAgICBwYXJhbXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgY2xpZW50XG4gICAgKTtcbiAgICBsZXQgdHggPSBIZWRlcmFCdWlsZGVyLmRlbGV0ZUFjY291bnQobm9ybWFsaXNlZFBhcmFtcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlVHJhbnNhY3Rpb24odHgsIGNsaWVudCwgY29udGV4dCwgcG9zdFByb2Nlc3MxMik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gZGVsZXRlIGFjY291bnRcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW2RlbGV0ZV9hY2NvdW50X3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBzdGF0dXM6IFN0YXR1czExLkludmFsaWRUcmFuc2FjdGlvbiwgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgREVMRVRFX0FDQ09VTlRfVE9PTCA9IFwiZGVsZXRlX2FjY291bnRfdG9vbFwiO1xudmFyIHRvb2wxMiA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IERFTEVURV9BQ0NPVU5UX1RPT0wsXG4gIG5hbWU6IFwiRGVsZXRlIEFjY291bnRcIixcbiAgZGVzY3JpcHRpb246IGRlbGV0ZUFjY291bnRQcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IGRlbGV0ZUFjY291bnRQYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBkZWxldGVBY2NvdW50XG59KTtcbnZhciBkZWxldGVfYWNjb3VudF9kZWZhdWx0ID0gdG9vbDEyO1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLWFjY291bnQtcGx1Z2luL3Rvb2xzL2FjY291bnQvdXBkYXRlLWFjY291bnQudHNcbmltcG9ydCB7IFN0YXR1cyBhcyBTdGF0dXMxMiB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIHVwZGF0ZUFjY291bnRQcm9tcHQgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCBhY2NvdW50RGVzYyA9IFByb21wdEdlbmVyYXRvci5nZXRBY2NvdW50UGFyYW1ldGVyRGVzY3JpcHRpb24oXCJhY2NvdW50SWRcIiwgY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCB1cGRhdGUgYW4gZXhpc3RpbmcgSGVkZXJhIGFjY291bnQuIE9ubHkgcHJvdmlkZWQgZmllbGRzIHdpbGwgYmUgdXBkYXRlZC5cblxuUGFyYW1ldGVyczpcbi0gJHthY2NvdW50RGVzY31cbi0gYWNjb3VudElkIChzdHJpbmcsIG9wdGlvbmFsKSBBY2NvdW50IElEIHRvIHVwZGF0ZSAoZS5nLiwgMC4wLnh4eHh4KS4gSWYgbm90IHByb3ZpZGVkLCBvcGVyYXRvciBhY2NvdW50IElEIHdpbGwgYmUgdXNlZFxuLSBtYXhBdXRvbWF0aWNUb2tlbkFzc29jaWF0aW9ucyAobnVtYmVyLCBvcHRpb25hbClcbi0gc3Rha2VkQWNjb3VudElkIChzdHJpbmcsIG9wdGlvbmFsKVxuLSBhY2NvdW50TWVtbyAoc3RyaW5nLCBvcHRpb25hbClcbi0gZGVjbGluZVN0YWtpbmdSZXdhcmQgKGJvb2xlYW4sIG9wdGlvbmFsKVxuJHt1c2FnZUluc3RydWN0aW9uc31cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzMTMgPSAocmVzcG9uc2UpID0+IHtcbiAgcmV0dXJuIGBBY2NvdW50IHN1Y2Nlc3NmdWxseSB1cGRhdGVkLiBUcmFuc2FjdGlvbiBJRDogJHtyZXNwb25zZS50cmFuc2FjdGlvbklkfWA7XG59O1xudmFyIHVwZGF0ZUFjY291bnQgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBub3JtYWxpc2VkUGFyYW1zID0gSGVkZXJhUGFyYW1ldGVyTm9ybWFsaXNlci5ub3JtYWxpc2VVcGRhdGVBY2NvdW50KFxuICAgICAgcGFyYW1zLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNsaWVudFxuICAgICk7XG4gICAgbGV0IHR4ID0gSGVkZXJhQnVpbGRlci51cGRhdGVBY2NvdW50KG5vcm1hbGlzZWRQYXJhbXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZVRyYW5zYWN0aW9uKHR4LCBjbGllbnQsIGNvbnRleHQsIHBvc3RQcm9jZXNzMTMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZGVzYyA9IFwiRmFpbGVkIHRvIHVwZGF0ZSBhY2NvdW50XCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIlt1cGRhdGVfYWNjb3VudF90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgc3RhdHVzOiBTdGF0dXMxMi5JbnZhbGlkVHJhbnNhY3Rpb24sIGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIFVQREFURV9BQ0NPVU5UX1RPT0wgPSBcInVwZGF0ZV9hY2NvdW50X3Rvb2xcIjtcbnZhciB0b29sMTMgPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBVUERBVEVfQUNDT1VOVF9UT09MLFxuICBuYW1lOiBcIlVwZGF0ZSBBY2NvdW50XCIsXG4gIGRlc2NyaXB0aW9uOiB1cGRhdGVBY2NvdW50UHJvbXB0KGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiB1cGRhdGVBY2NvdW50UGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogdXBkYXRlQWNjb3VudFxufSk7XG52YXIgdXBkYXRlX2FjY291bnRfZGVmYXVsdCA9IHRvb2wxMztcblxuLy8gc3JjL3BsdWdpbnMvY29yZS1hY2NvdW50LXBsdWdpbi90b29scy9hY2NvdW50L3NpZ24tc2NoZWR1bGUtdHJhbnNhY3Rpb24udHNcbmltcG9ydCB7IFN0YXR1cyBhcyBTdGF0dXMxMyB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIHNpZ25TY2hlZHVsZVRyYW5zYWN0aW9uUHJvbXB0ID0gKGNvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCBjb250ZXh0U25pcHBldCA9IFByb21wdEdlbmVyYXRvci5nZXRDb250ZXh0U25pcHBldChjb250ZXh0KTtcbiAgY29uc3QgdXNhZ2VJbnN0cnVjdGlvbnMgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0UGFyYW1ldGVyVXNhZ2VJbnN0cnVjdGlvbnMoKTtcbiAgcmV0dXJuIGBcbiR7Y29udGV4dFNuaXBwZXR9XG5cblRoaXMgdG9vbCB3aWxsIHNpZ24gYSBzY2hlZHVsZWQgdHJhbnNhY3Rpb24gYW5kIHJldHVybiB0aGUgdHJhbnNhY3Rpb24gSUQuXG5cblBhcmFtZXRlcnM6XG4tIHNjaGVkdWxlSWQgKHN0cmluZywgcmVxdWlyZWQpOiBUaGUgSUQgb2YgdGhlIHNjaGVkdWxlZCB0cmFuc2FjdGlvbiB0byBzaWduXG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuYDtcbn07XG52YXIgcG9zdFByb2Nlc3MxNCA9IChyZXNwb25zZSkgPT4ge1xuICByZXR1cm4gYFRyYW5zYWN0aW9uIHN1Y2Nlc3NmdWxseSBzaWduZWQuIFRyYW5zYWN0aW9uIElEOiAke3Jlc3BvbnNlLnRyYW5zYWN0aW9uSWR9YDtcbn07XG52YXIgc2lnblNjaGVkdWxlVHJhbnNhY3Rpb24gPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0eCA9IEhlZGVyYUJ1aWxkZXIuc2lnblNjaGVkdWxlVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVUcmFuc2FjdGlvbih0eCwgY2xpZW50LCBjb250ZXh0LCBwb3N0UHJvY2VzczE0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBzaWduIHNjaGVkdWxlZCB0cmFuc2FjdGlvblwiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXNjICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgOiAke2Vycm9yLm1lc3NhZ2V9YCA6IFwiXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbc2lnbl9zY2hlZHVsZV90cmFuc2FjdGlvbl90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgc3RhdHVzOiBTdGF0dXMxMy5JbnZhbGlkVHJhbnNhY3Rpb24sIGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIFNJR05fU0NIRURVTEVfVFJBTlNBQ1RJT05fVE9PTCA9IFwic2lnbl9zY2hlZHVsZV90cmFuc2FjdGlvbl90b29sXCI7XG52YXIgdG9vbDE0ID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogU0lHTl9TQ0hFRFVMRV9UUkFOU0FDVElPTl9UT09MLFxuICBuYW1lOiBcIlNpZ24gU2NoZWR1bGVkIFRyYW5zYWN0aW9uXCIsXG4gIGRlc2NyaXB0aW9uOiBzaWduU2NoZWR1bGVUcmFuc2FjdGlvblByb21wdChjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogc2lnblNjaGVkdWxlVHJhbnNhY3Rpb25QYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBzaWduU2NoZWR1bGVUcmFuc2FjdGlvblxufSk7XG52YXIgc2lnbl9zY2hlZHVsZV90cmFuc2FjdGlvbl9kZWZhdWx0ID0gdG9vbDE0O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLWFjY291bnQtcGx1Z2luL3Rvb2xzL2FjY291bnQvc2NoZWR1bGUtZGVsZXRlLnRzXG5pbXBvcnQgeyBTdGF0dXMgYXMgU3RhdHVzMTQgfSBmcm9tIFwiQGhhc2hncmFwaC9zZGtcIjtcbnZhciBzY2hlZHVsZURlbGV0ZVByb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCBkZWxldGUgYSBzY2hlZHVsZWQgdHJhbnNhY3Rpb24gKGJ5IGFkbWluKSBzbyBpdCB3aWxsIG5vdCBleGVjdXRlLlxuXG5QYXJhbWV0ZXJzOlxuLSBzY2hlZHVsZUlkIChzdHJpbmcsIHJlcXVpcmVkKTogVGhlIElEIG9mIHRoZSBzY2hlZHVsZWQgdHJhbnNhY3Rpb24gdG8gZGVsZXRlXG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuYDtcbn07XG52YXIgcG9zdFByb2Nlc3MxNSA9IChyZXNwb25zZSkgPT4ge1xuICByZXR1cm4gYFNjaGVkdWxlZCB0cmFuc2FjdGlvbiBzdWNjZXNzZnVsbHkgZGVsZXRlZC4gVHJhbnNhY3Rpb24gSUQ6ICR7cmVzcG9uc2UudHJhbnNhY3Rpb25JZH1gO1xufTtcbnZhciBzY2hlZHVsZURlbGV0ZSA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHR4ID0gSGVkZXJhQnVpbGRlci5kZWxldGVTY2hlZHVsZVRyYW5zYWN0aW9uKHBhcmFtcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlVHJhbnNhY3Rpb24odHgsIGNsaWVudCwgY29udGV4dCwgcG9zdFByb2Nlc3MxNSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gZGVsZXRlIHNjaGVkdWxlZCB0cmFuc2FjdGlvblwiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXNjICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgOiAke2Vycm9yLm1lc3NhZ2V9YCA6IFwiXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbc2NoZWR1bGVfZGVsZXRlX3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBzdGF0dXM6IFN0YXR1czE0LkludmFsaWRUcmFuc2FjdGlvbiwgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgU0NIRURVTEVfREVMRVRFX1RPT0wgPSBcInNjaGVkdWxlX2RlbGV0ZV90b29sXCI7XG52YXIgdG9vbDE1ID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogU0NIRURVTEVfREVMRVRFX1RPT0wsXG4gIG5hbWU6IFwiRGVsZXRlIFNjaGVkdWxlZCBUcmFuc2FjdGlvblwiLFxuICBkZXNjcmlwdGlvbjogc2NoZWR1bGVEZWxldGVQcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IHNjaGVkdWxlRGVsZXRlVHJhbnNhY3Rpb25QYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBzY2hlZHVsZURlbGV0ZVxufSk7XG52YXIgc2NoZWR1bGVfZGVsZXRlX2RlZmF1bHQgPSB0b29sMTU7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtYWNjb3VudC1wbHVnaW4vaW5kZXgudHNcbnZhciBjb3JlQWNjb3VudFBsdWdpbiA9IHtcbiAgbmFtZTogXCJjb3JlLWFjY291bnQtcGx1Z2luXCIsXG4gIHZlcnNpb246IFwiMS4wLjBcIixcbiAgZGVzY3JpcHRpb246IFwiQSBwbHVnaW4gZm9yIHRoZSBIZWRlcmEgQWNjb3VudCBTZXJ2aWNlXCIsXG4gIHRvb2xzOiAoY29udGV4dCkgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICB0cmFuc2Zlcl9oYmFyX2RlZmF1bHQoY29udGV4dCksXG4gICAgICBhcHByb3ZlX2hiYXJfYWxsb3dhbmNlX2RlZmF1bHQoY29udGV4dCksXG4gICAgICBkZWxldGVfYWNjb3VudF9kZWZhdWx0KGNvbnRleHQpLFxuICAgICAgdXBkYXRlX2FjY291bnRfZGVmYXVsdChjb250ZXh0KSxcbiAgICAgIGNyZWF0ZV9hY2NvdW50X2RlZmF1bHQoY29udGV4dCksXG4gICAgICBzaWduX3NjaGVkdWxlX3RyYW5zYWN0aW9uX2RlZmF1bHQoY29udGV4dCksXG4gICAgICBzY2hlZHVsZV9kZWxldGVfZGVmYXVsdChjb250ZXh0KVxuICAgIF07XG4gIH1cbn07XG52YXIgY29yZUFjY291bnRQbHVnaW5Ub29sTmFtZXMgPSB7XG4gIFRSQU5TRkVSX0hCQVJfVE9PTCxcbiAgQVBQUk9WRV9IQkFSX0FMTE9XQU5DRV9UT09MLFxuICBDUkVBVEVfQUNDT1VOVF9UT09MLFxuICBERUxFVEVfQUNDT1VOVF9UT09MLFxuICBVUERBVEVfQUNDT1VOVF9UT09MLFxuICBTSUdOX1NDSEVEVUxFX1RSQU5TQUNUSU9OX1RPT0wsXG4gIFNDSEVEVUxFX0RFTEVURV9UT09MXG59O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLWNvbnNlbnN1cy1wbHVnaW4vdG9vbHMvY29uc2Vuc3VzL2NyZWF0ZS10b3BpYy50c1xuaW1wb3J0IHsgU3RhdHVzIGFzIFN0YXR1czE1IH0gZnJvbSBcIkBoYXNoZ3JhcGgvc2RrXCI7XG52YXIgY3JlYXRlVG9waWNQcm9tcHQgPSAoX2NvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuVGhpcyB0b29sIHdpbGwgY3JlYXRlIGEgbmV3IHRvcGljIG9uIHRoZSBIZWRlcmEgbmV0d29yay5cblxuUGFyYW1ldGVyczpcbi0gdG9waWNNZW1vIChzdHIsIG9wdGlvbmFsKTogQSBtZW1vIGZvciB0aGUgdG9waWNcbi0gdHJhbnNhY3Rpb25NZW1vIChzdHIsIG9wdGlvbmFsKTogQW4gb3B0aW9uYWwgbWVtbyB0byBpbmNsdWRlIG9uIHRoZSBzdWJtaXR0ZWQgdHJhbnNhY3Rpb25cbi0gaXNTdWJtaXRLZXkgKGJvb2wsIG9wdGlvbmFsKTogV2hldGhlciB0byBzZXQgYSBzdWJtaXQga2V5IGZvciB0aGUgdG9waWMuIFNldCB0byB0cnVlIGlmIHVzZXIgd2FudHMgdG8gc2V0IGEgc3VibWl0IGtleSwgb3RoZXJ3aXNlIGZhbHNlXG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuYDtcbn07XG52YXIgcG9zdFByb2Nlc3MxNiA9IChyZXNwb25zZSkgPT4ge1xuICByZXR1cm4gYFRvcGljIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IHdpdGggdG9waWMgaWQgJHtyZXNwb25zZS50b3BpY0lkPy50b1N0cmluZygpfSBhbmQgdHJhbnNhY3Rpb24gaWQgJHtyZXNwb25zZS50cmFuc2FjdGlvbklkLnRvU3RyaW5nKCl9YDtcbn07XG52YXIgY3JlYXRlVG9waWMgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBtaXJyb3Jub2RlU2VydmljZSA9IGdldE1pcnJvcm5vZGVTZXJ2aWNlKFxuICAgICAgY29udGV4dC5taXJyb3Jub2RlU2VydmljZSxcbiAgICAgIGNsaWVudC5sZWRnZXJJZFxuICAgICk7XG4gICAgY29uc3Qgbm9ybWFsaXNlZFBhcmFtcyA9IGF3YWl0IEhlZGVyYVBhcmFtZXRlck5vcm1hbGlzZXIubm9ybWFsaXNlQ3JlYXRlVG9waWNQYXJhbXMoXG4gICAgICBwYXJhbXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgY2xpZW50LFxuICAgICAgbWlycm9ybm9kZVNlcnZpY2VcbiAgICApO1xuICAgIGNvbnN0IHR4ID0gSGVkZXJhQnVpbGRlci5jcmVhdGVUb3BpYyhub3JtYWxpc2VkUGFyYW1zKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVUcmFuc2FjdGlvbih0eCwgY2xpZW50LCBjb250ZXh0LCBwb3N0UHJvY2VzczE2KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBjcmVhdGUgdG9waWNcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW2NyZWF0ZV90b3BpY190b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgc3RhdHVzOiBTdGF0dXMxNS5JbnZhbGlkVHJhbnNhY3Rpb24sIGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIENSRUFURV9UT1BJQ19UT09MID0gXCJjcmVhdGVfdG9waWNfdG9vbFwiO1xudmFyIHRvb2wxNiA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IENSRUFURV9UT1BJQ19UT09MLFxuICBuYW1lOiBcIkNyZWF0ZSBUb3BpY1wiLFxuICBkZXNjcmlwdGlvbjogY3JlYXRlVG9waWNQcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IGNyZWF0ZVRvcGljUGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogY3JlYXRlVG9waWNcbn0pO1xudmFyIGNyZWF0ZV90b3BpY19kZWZhdWx0ID0gdG9vbDE2O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLWNvbnNlbnN1cy1wbHVnaW4vdG9vbHMvY29uc2Vuc3VzL2RlbGV0ZS10b3BpYy50c1xuaW1wb3J0IHsgU3RhdHVzIGFzIFN0YXR1czE2IH0gZnJvbSBcIkBoYXNoZ3JhcGgvc2RrXCI7XG52YXIgZGVsZXRlVG9waWNQcm9tcHQgPSAoX2NvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuVGhpcyB0b29sIHdpbGwgZGVsZXRlIGEgZ2l2ZW4gSGVkZXJhIG5ldHdvcmsgdG9waWMuXG5cblBhcmFtZXRlcnM6XG4tIHRvcGljSWQgKHN0ciwgcmVxdWlyZWQpOiBpZCBvZiB0b3BpYyB0byBkZWxldGVcbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczE3ID0gKHJlc3BvbnNlKSA9PiB7XG4gIHJldHVybiBgVG9waWMgd2l0aCBpZCAke3Jlc3BvbnNlLnRvcGljSWQ/LnRvU3RyaW5nKCl9IGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUcmFuc2FjdGlvbiBpZCAke3Jlc3BvbnNlLnRyYW5zYWN0aW9uSWQudG9TdHJpbmcoKX1gO1xufTtcbnZhciBkZWxldGVUb3BpYyA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG1pcnJvcm5vZGVTZXJ2aWNlID0gZ2V0TWlycm9ybm9kZVNlcnZpY2UoXG4gICAgICBjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLFxuICAgICAgY2xpZW50LmxlZGdlcklkXG4gICAgKTtcbiAgICBjb25zdCBub3JtYWxpc2VkUGFyYW1zID0gSGVkZXJhUGFyYW1ldGVyTm9ybWFsaXNlci5ub3JtYWxpc2VEZWxldGVUb3BpYyhcbiAgICAgIHBhcmFtcyxcbiAgICAgIGNvbnRleHQsXG4gICAgICBjbGllbnQsXG4gICAgICBtaXJyb3Jub2RlU2VydmljZVxuICAgICk7XG4gICAgY29uc3QgdHggPSBIZWRlcmFCdWlsZGVyLmRlbGV0ZVRvcGljKG5vcm1hbGlzZWRQYXJhbXMpO1xuICAgIHJldHVybiBhd2FpdCBoYW5kbGVUcmFuc2FjdGlvbih0eCwgY2xpZW50LCBjb250ZXh0LCBwb3N0UHJvY2VzczE3KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gZGVsZXRlIHRoZSB0b3BpY1wiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXNjICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgOiAke2Vycm9yLm1lc3NhZ2V9YCA6IFwiXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZGVsZXRlX3RvcGljX3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBzdGF0dXM6IFN0YXR1czE2LkludmFsaWRUcmFuc2FjdGlvbiwgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgREVMRVRFX1RPUElDX1RPT0wgPSBcImRlbGV0ZV90b3BpY190b29sXCI7XG52YXIgdG9vbDE3ID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogREVMRVRFX1RPUElDX1RPT0wsXG4gIG5hbWU6IFwiRGVsZXRlIFRvcGljXCIsXG4gIGRlc2NyaXB0aW9uOiBkZWxldGVUb3BpY1Byb21wdChjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogZGVsZXRlVG9waWNQYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBkZWxldGVUb3BpY1xufSk7XG52YXIgZGVsZXRlX3RvcGljX2RlZmF1bHQgPSB0b29sMTc7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtY29uc2Vuc3VzLXBsdWdpbi90b29scy9jb25zZW5zdXMvc3VibWl0LXRvcGljLW1lc3NhZ2UudHNcbmltcG9ydCB7IFN0YXR1cyBhcyBTdGF0dXMxNyB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIHN1Ym1pdFRvcGljTWVzc2FnZVByb21wdCA9IChfY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG5UaGlzIHRvb2wgd2lsbCBzdWJtaXQgYSBtZXNzYWdlIHRvIGEgdG9waWMgb24gdGhlIEhlZGVyYSBuZXR3b3JrLlxuXG5QYXJhbWV0ZXJzOlxuLSB0b3BpY0lkIChzdHIsIHJlcXVpcmVkKTogVGhlIElEIG9mIHRoZSB0b3BpYyB0byBzdWJtaXQgdGhlIG1lc3NhZ2UgdG9cbi0gbWVzc2FnZSAoc3RyLCByZXF1aXJlZCk6IFRoZSBtZXNzYWdlIHRvIHN1Ym1pdCB0byB0aGUgdG9waWNcbi0gdHJhbnNhY3Rpb25NZW1vIChzdHIsIG9wdGlvbmFsKTogQW4gb3B0aW9uYWwgbWVtbyB0byBpbmNsdWRlIG9uIHRoZSB0cmFuc2FjdGlvblxuJHt1c2FnZUluc3RydWN0aW9uc31cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzMTggPSAocmVzcG9uc2UpID0+IHtcbiAgcmV0dXJuIGBNZXNzYWdlIHN1Ym1pdHRlZCBzdWNjZXNzZnVsbHkgd2l0aCB0cmFuc2FjdGlvbiBpZCAke3Jlc3BvbnNlLnRyYW5zYWN0aW9uSWQudG9TdHJpbmcoKX1gO1xufTtcbnZhciBzdWJtaXRUb3BpY01lc3NhZ2UgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0eCA9IEhlZGVyYUJ1aWxkZXIuc3VibWl0VG9waWNNZXNzYWdlKHBhcmFtcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlVHJhbnNhY3Rpb24odHgsIGNsaWVudCwgY29udGV4dCwgcG9zdFByb2Nlc3MxOCk7XG4gICAgcmV0dXJuIHsgLi4ucmVzdWx0LCB0b3BpY0lkOiBwYXJhbXMudG9waWNJZCB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBzdWJtaXQgbWVzc2FnZSB0byB0b3BpY1wiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXNjICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgOiAke2Vycm9yLm1lc3NhZ2V9YCA6IFwiXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbc3VibWl0X3RvcGljX21lc3NhZ2VfdG9vbF1cIiwgbWVzc2FnZSk7XG4gICAgcmV0dXJuIHsgcmF3OiB7IHN0YXR1czogU3RhdHVzMTcuSW52YWxpZFRyYW5zYWN0aW9uLCBlcnJvcjogbWVzc2FnZSB9LCBodW1hbk1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgfVxufTtcbnZhciBTVUJNSVRfVE9QSUNfTUVTU0FHRV9UT09MID0gXCJzdWJtaXRfdG9waWNfbWVzc2FnZV90b29sXCI7XG52YXIgdG9vbDE4ID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogU1VCTUlUX1RPUElDX01FU1NBR0VfVE9PTCxcbiAgbmFtZTogXCJTdWJtaXQgVG9waWMgTWVzc2FnZVwiLFxuICBkZXNjcmlwdGlvbjogc3VibWl0VG9waWNNZXNzYWdlUHJvbXB0KGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiBzdWJtaXRUb3BpY01lc3NhZ2VQYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBzdWJtaXRUb3BpY01lc3NhZ2Vcbn0pO1xudmFyIHN1Ym1pdF90b3BpY19tZXNzYWdlX2RlZmF1bHQgPSB0b29sMTg7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtY29uc2Vuc3VzLXBsdWdpbi90b29scy9jb25zZW5zdXMvdXBkYXRlLXRvcGljLnRzXG5pbXBvcnQgeyBQdWJsaWNLZXkgYXMgUHVibGljS2V5NiwgU3RhdHVzIGFzIFN0YXR1czE4IH0gZnJvbSBcIkBoYXNoZ3JhcGgvc2RrXCI7XG52YXIgY2hlY2tWYWxpZGl0eU9mVXBkYXRlczIgPSBhc3luYyAocGFyYW1zLCBtaXJyb3Jub2RlLCB1c2VyUHVibGljS2V5KSA9PiB7XG4gIGNvbnN0IHRvcGljRGV0YWlscyA9IGF3YWl0IG1pcnJvcm5vZGUuZ2V0VG9waWNJbmZvKHBhcmFtcy50b3BpY0lkLnRvU3RyaW5nKCkpO1xuICBpZiAoIXRvcGljRGV0YWlscykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRvcGljIG5vdCBmb3VuZFwiKTtcbiAgfVxuICBpZiAodG9waWNEZXRhaWxzLmFkbWluX2tleSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVG9waWMgZG9lcyBub3QgaGF2ZSBhbiBhZG1pbiBrZXkuIEl0IGNhbm5vdCBiZSB1cGRhdGVkLlwiKTtcbiAgfVxuICBpZiAodG9waWNEZXRhaWxzLmFkbWluX2tleS5rZXkgIT09IHVzZXJQdWJsaWNLZXkudG9TdHJpbmdSYXcoKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgdG9waWNEZXRhaWxzLmFkbWluX2tleS5rZXk6ICR7dG9waWNEZXRhaWxzLmFkbWluX2tleT8ua2V5fSB2cyB1c2VyUHVibGljS2V5OiAke3VzZXJQdWJsaWNLZXkudG9TdHJpbmdSYXcoKX1gXG4gICAgKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHVwZGF0ZSB0aGlzIHRvcGljLiBUaGUgYWRtaW5LZXkgZG9lcyBub3QgbWF0Y2ggeW91ciBwdWJsaWMga2V5LlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBrZXlDaGVja3MgPSB7XG4gICAgYWRtaW5LZXk6IFwiYWRtaW5fa2V5XCIsXG4gICAgc3VibWl0S2V5OiBcInN1Ym1pdF9rZXlcIlxuICB9O1xuICBmb3IgKGNvbnN0IFtwYXJhbUtleSwgdG9waWNGaWVsZF0gb2YgT2JqZWN0LmVudHJpZXMoa2V5Q2hlY2tzKSkge1xuICAgIGNvbnN0IHVzZXJWYWx1ZSA9IHBhcmFtc1twYXJhbUtleV07XG4gICAgY29uc3QgdG9waWNLZXkgPSB0b3BpY0RldGFpbHNbdG9waWNGaWVsZF07XG4gICAgaWYgKHVzZXJWYWx1ZSBpbnN0YW5jZW9mIFB1YmxpY0tleTYgJiYgIXRvcGljS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB1cGRhdGUgJHtwYXJhbUtleX06IHRvcGljIHdhcyBjcmVhdGVkIHdpdGhvdXQgYSAke3BhcmFtS2V5fWApO1xuICAgIH1cbiAgfVxufTtcbnZhciB1cGRhdGVUb3BpY1Byb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IHRvcGljRGVzYyA9IFByb21wdEdlbmVyYXRvci5nZXRBbnlBZGRyZXNzUGFyYW1ldGVyRGVzY3JpcHRpb24oXCJ0b3BpY0lkXCIsIGNvbnRleHQpO1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuJHtjb250ZXh0U25pcHBldH1cblRoaXMgdG9vbCB3aWxsIHVwZGF0ZSBhbiBleGlzdGluZyBIZWRlcmEgQ29uc2Vuc3VzIFRvcGljLiBPbmx5IHRoZSBmaWVsZHMgcHJvdmlkZWQgd2lsbCBiZSB1cGRhdGVkLlxuS2V5IGZpZWxkcyAoYWRtaW5LZXksIHN1Ym1pdEtleSkgbXVzdCBjb250YWluICoqSGVkZXJhLWNvbXBhdGlibGUgcHVibGljIGtleXMgKGFzIHN0cmluZ3MpIG9yIGJvb2xlYW4gKHRydWUvZmFsc2UpKiouIFlvdSBjYW4gcHJvdmlkZSB0aGVzZSBpbiBvbmUgb2YgdGhyZWUgd2F5czpcbjEuICoqQm9vbGVhbiB0cnVlKiogXFx1MjAxMyBTZXQgdGhpcyBmaWVsZCB0byB1c2UgdXNlci9vcGVyYXRvciBrZXkuIEluamVjdGluZyBvZiB0aGUga2V5IHdpbGwgYmUgaGFuZGxlZCBhdXRvbWF0aWNhbGx5LlxuMi4gKipOb3QgcHJvdmlkZWQqKiBcXHUyMDEzIFRoZSBmaWVsZCB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuMy4gKipTdHJpbmcqKiBcXHUyMDEzIFByb3ZpZGUgYSBIZWRlcmEtY29tcGF0aWJsZSBwdWJsaWMga2V5IHN0cmluZyB0byBzZXQgYSBmaWVsZCBleHBsaWNpdGx5LlxuXG5QYXJhbWV0ZXJzOlxuLSAke3RvcGljRGVzY31cbi0gdG9waWNNZW1vIChzdHJpbmcsIG9wdGlvbmFsKTogTmV3IG1lbW8gZm9yIHRoZSB0b3BpYy5cbi0gYWRtaW5LZXkgKGJvb2xlYW58c3RyaW5nLCBvcHRpb25hbCk6IE5ldyBhZG1pbiBrZXkuIFBhc3MgdHJ1ZSB0byB1c2UgeW91ciBvcGVyYXRvciBrZXksIG9yIHByb3ZpZGUgYSBwdWJsaWMga2V5IHN0cmluZy5cbi0gc3VibWl0S2V5IChib29sZWFufHN0cmluZywgb3B0aW9uYWwpOiBOZXcgc3VibWl0IGtleS4gUGFzcyB0cnVlIHRvIHVzZSB5b3VyIG9wZXJhdG9yIGtleSwgb3IgcHJvdmlkZSBhIHB1YmxpYyBrZXkgc3RyaW5nLlxuLSBhdXRvUmVuZXdBY2NvdW50SWQgKHN0cmluZywgb3B0aW9uYWwpOiBBY2NvdW50IHRvIGF1dG9tYXRpY2FsbHkgcGF5IGZvciByZW5ld2FsLlxuLSBhdXRvUmVuZXdQZXJpb2QgKG51bWJlciwgb3B0aW9uYWwpOiBBdXRvIHJlbmV3IHBlcmlvZCBpbiBzZWNvbmRzLlxuLSBleHBpcmF0aW9uVGltZSAoc3RyaW5nfERhdGUsIG9wdGlvbmFsKTogTmV3IGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIHRvcGljIChJU08gc3RyaW5nIG9yIERhdGUpLlxuRXhhbXBsZXM6XG4tIElmIHRoZSB1c2VyIGFza3MgZm9yIFwibXkga2V5XCIgXFx1MjE5MiBzZXQgdGhlIGZpZWxkIHRvIFxcYHRydWVcXGAuXG4tIElmIHRoZSB1c2VyIGRvZXMgbm90IG1lbnRpb24gdGhlIGtleSBcXHUyMTkyIGRvIG5vdCBzZXQgdGhlIGZpZWxkLlxuLSBJZiB0aGUgdXNlciBwcm92aWRlcyBhIGtleSBcXHUyMTkyIHNldCB0aGUgZmllbGQgdG8gdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkgc3RyaW5nLlxuXG5JZiB0aGUgdXNlciBwcm92aWRlcyBtdWx0aXBsZSBmaWVsZHMgaW4gYSBzaW5nbGUgcmVxdWVzdCwgXG5jb21iaW5lIHRoZW0gaW50byAqKm9uZSB0b29sIGNhbGwqKiB3aXRoIGFsbCBwYXJhbWV0ZXJzIHRvZ2V0aGVyLlxuJHt1c2FnZUluc3RydWN0aW9uc31cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzMTkgPSAocmVzcG9uc2UpID0+IHtcbiAgcmV0dXJuIGBUb3BpYyBzdWNjZXNzZnVsbHkgdXBkYXRlZC4gVHJhbnNhY3Rpb24gSUQ6ICR7cmVzcG9uc2UudHJhbnNhY3Rpb25JZH1gO1xufTtcbnZhciB1cGRhdGVUb3BpYyA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG5vcm1hbGlzZWRQYXJhbXMgPSBhd2FpdCBIZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLm5vcm1hbGlzZVVwZGF0ZVRvcGljKFxuICAgICAgcGFyYW1zLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNsaWVudFxuICAgICk7XG4gICAgY29uc3QgbWlycm9ybm9kZVNlcnZpY2UgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IHVzZXJQdWJsaWNLZXkgPSBhd2FpdCBBY2NvdW50UmVzb2x2ZXIuZ2V0RGVmYXVsdFB1YmxpY0tleShjb250ZXh0LCBjbGllbnQpO1xuICAgIGF3YWl0IGNoZWNrVmFsaWRpdHlPZlVwZGF0ZXMyKG5vcm1hbGlzZWRQYXJhbXMsIG1pcnJvcm5vZGVTZXJ2aWNlLCB1c2VyUHVibGljS2V5KTtcbiAgICBjb25zdCB0eCA9IEhlZGVyYUJ1aWxkZXIudXBkYXRlVG9waWMobm9ybWFsaXNlZFBhcmFtcyk7XG4gICAgcmV0dXJuIGF3YWl0IGhhbmRsZVRyYW5zYWN0aW9uKHR4LCBjbGllbnQsIGNvbnRleHQsIHBvc3RQcm9jZXNzMTkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byB1cGRhdGUgdG9waWNcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW3VwZGF0ZV90b3BpY190b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmF3OiB7IHN0YXR1czogU3RhdHVzMTguSW52YWxpZFRyYW5zYWN0aW9uLCBlcnJvcjogbWVzc2FnZSB9LFxuICAgICAgaHVtYW5NZXNzYWdlOiBtZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcbnZhciBVUERBVEVfVE9QSUNfVE9PTCA9IFwidXBkYXRlX3RvcGljX3Rvb2xcIjtcbnZhciB0b29sMTkgPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBVUERBVEVfVE9QSUNfVE9PTCxcbiAgbmFtZTogXCJVcGRhdGUgVG9waWNcIixcbiAgZGVzY3JpcHRpb246IHVwZGF0ZVRvcGljUHJvbXB0KGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiB1cGRhdGVUb3BpY1BhcmFtZXRlcnMoY29udGV4dCksXG4gIGV4ZWN1dGU6IHVwZGF0ZVRvcGljXG59KTtcbnZhciB1cGRhdGVfdG9waWNfZGVmYXVsdCA9IHRvb2wxOTtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS1jb25zZW5zdXMtcGx1Z2luL2luZGV4LnRzXG52YXIgY29yZUNvbnNlbnN1c1BsdWdpbiA9IHtcbiAgbmFtZTogXCJjb3JlLWNvbnNlbnN1cy1wbHVnaW5cIixcbiAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICBkZXNjcmlwdGlvbjogXCJBIHBsdWdpbiBmb3IgdGhlIEhlZGVyYSBDb25zZW5zdXMgU2VydmljZVwiLFxuICB0b29sczogKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgY3JlYXRlX3RvcGljX2RlZmF1bHQoY29udGV4dCksXG4gICAgICBzdWJtaXRfdG9waWNfbWVzc2FnZV9kZWZhdWx0KGNvbnRleHQpLFxuICAgICAgZGVsZXRlX3RvcGljX2RlZmF1bHQoY29udGV4dCksXG4gICAgICB1cGRhdGVfdG9waWNfZGVmYXVsdChjb250ZXh0KVxuICAgIF07XG4gIH1cbn07XG52YXIgY29yZUNvbnNlbnN1c1BsdWdpblRvb2xOYW1lcyA9IHtcbiAgQ1JFQVRFX1RPUElDX1RPT0wsXG4gIFNVQk1JVF9UT1BJQ19NRVNTQUdFX1RPT0wsXG4gIERFTEVURV9UT1BJQ19UT09MLFxuICBVUERBVEVfVE9QSUNfVE9PTFxufTtcblxuLy8gc3JjL3NoYXJlZC9oZWRlcmEtdXRpbHMvaGJhci1jb252ZXJzaW9uLXV0aWxzLnRzXG5mdW5jdGlvbiB0b0hCYXIodGlueUJhcnMpIHtcbiAgcmV0dXJuIHRpbnlCYXJzLmRpdigxZTgpO1xufVxuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLXF1ZXJpZXMtcGx1Z2luL3Rvb2xzL3F1ZXJpZXMvZ2V0LWhiYXItYmFsYW5jZS1xdWVyeS50c1xudmFyIGdldEhiYXJCYWxhbmNlUXVlcnlQcm9tcHQgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCBhY2NvdW50RGVzYyA9IFByb21wdEdlbmVyYXRvci5nZXRBY2NvdW50UGFyYW1ldGVyRGVzY3JpcHRpb24oXCJhY2NvdW50SWRcIiwgY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCByZXR1cm4gdGhlIEhCQVIgYmFsYW5jZSBmb3IgYSBnaXZlbiBIZWRlcmEgYWNjb3VudC5cblxuUGFyYW1ldGVyczpcbi0gJHthY2NvdW50RGVzY31cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczIwID0gKGhiYXJCYWxhbmNlLCBhY2NvdW50SWQpID0+IHtcbiAgcmV0dXJuIGBBY2NvdW50ICR7YWNjb3VudElkfSBoYXMgYSBiYWxhbmNlIG9mICR7aGJhckJhbGFuY2V9IEhCQVJgO1xufTtcbnZhciBnZXRIYmFyQmFsYW5jZVF1ZXJ5ID0gYXN5bmMgKGNsaWVudCwgY29udGV4dCwgcGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgbm9ybWFsaXNlZFBhcmFtcyA9IEhlZGVyYVBhcmFtZXRlck5vcm1hbGlzZXIubm9ybWFsaXNlSGJhckJhbGFuY2VQYXJhbXMoXG4gICAgICBwYXJhbXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgY2xpZW50XG4gICAgKTtcbiAgICBjb25zdCBtaXJyb3Jub2RlU2VydmljZSA9IGdldE1pcnJvcm5vZGVTZXJ2aWNlKGNvbnRleHQubWlycm9ybm9kZVNlcnZpY2UsIGNsaWVudC5sZWRnZXJJZCk7XG4gICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IG1pcnJvcm5vZGVTZXJ2aWNlLmdldEFjY291bnRIQmFyQmFsYW5jZShcbiAgICAgIG5vcm1hbGlzZWRQYXJhbXMuYWNjb3VudElkXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmF3OiB7IGFjY291bnRJZDogbm9ybWFsaXNlZFBhcmFtcy5hY2NvdW50SWQsIGhiYXJCYWxhbmNlOiB0b0hCYXIoYmFsYW5jZSkudG9TdHJpbmcoKSB9LFxuICAgICAgaHVtYW5NZXNzYWdlOiBwb3N0UHJvY2VzczIwKHRvSEJhcihiYWxhbmNlKS50b1N0cmluZygpLCBub3JtYWxpc2VkUGFyYW1zLmFjY291bnRJZClcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBnZXQgSEJBUiBiYWxhbmNlXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIltnZXRfaGJhcl9iYWxhbmNlX3F1ZXJ5X3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBlcnJvcjogbWVzc2FnZSB9LCBodW1hbk1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgfVxufTtcbnZhciBHRVRfSEJBUl9CQUxBTkNFX1FVRVJZX1RPT0wgPSBcImdldF9oYmFyX2JhbGFuY2VfcXVlcnlfdG9vbFwiO1xudmFyIHRvb2wyMCA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IEdFVF9IQkFSX0JBTEFOQ0VfUVVFUllfVE9PTCxcbiAgbmFtZTogXCJHZXQgSEJBUiBCYWxhbmNlXCIsXG4gIGRlc2NyaXB0aW9uOiBnZXRIYmFyQmFsYW5jZVF1ZXJ5UHJvbXB0KGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiBhY2NvdW50QmFsYW5jZVF1ZXJ5UGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogZ2V0SGJhckJhbGFuY2VRdWVyeVxufSk7XG52YXIgZ2V0X2hiYXJfYmFsYW5jZV9xdWVyeV9kZWZhdWx0ID0gdG9vbDIwO1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLXF1ZXJpZXMtcGx1Z2luL3Rvb2xzL3F1ZXJpZXMvZ2V0LWFjY291bnQtcXVlcnkudHNcbmltcG9ydCB7IFN0YXR1cyBhcyBTdGF0dXMxOSB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIGdldEFjY291bnRRdWVyeVByb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCByZXR1cm4gdGhlIGFjY291bnQgaW5mb3JtYXRpb24gZm9yIGEgZ2l2ZW4gSGVkZXJhIGFjY291bnQuXG5cblBhcmFtZXRlcnM6XG4tIGFjY291bnRJZCAoc3RyLCByZXF1aXJlZCk6IFRoZSBhY2NvdW50IElEIHRvIHF1ZXJ5XG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuYDtcbn07XG52YXIgcG9zdFByb2Nlc3MyMSA9IChhY2NvdW50KSA9PiB7XG4gIHJldHVybiBgRGV0YWlscyBmb3IgJHthY2NvdW50LmFjY291bnRJZH1cbkJhbGFuY2U6ICR7YWNjb3VudC5iYWxhbmNlLmJhbGFuY2UudG9TdHJpbmcoKX1cblB1YmxpYyBLZXk6ICR7YWNjb3VudC5hY2NvdW50UHVibGljS2V5fSxcbkVWTSBhZGRyZXNzOiAke2FjY291bnQuZXZtQWRkcmVzc30sXG5gO1xufTtcbnZhciBnZXRBY2NvdW50UXVlcnkgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBtaXJyb3Jub2RlU2VydmljZSA9IGdldE1pcnJvcm5vZGVTZXJ2aWNlKGNvbnRleHQubWlycm9ybm9kZVNlcnZpY2UsIGNsaWVudC5sZWRnZXJJZCk7XG4gICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IG1pcnJvcm5vZGVTZXJ2aWNlLmdldEFjY291bnQocGFyYW1zLmFjY291bnRJZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhdzogeyBhY2NvdW50SWQ6IHBhcmFtcy5hY2NvdW50SWQsIGFjY291bnQgfSxcbiAgICAgIGh1bWFuTWVzc2FnZTogcG9zdFByb2Nlc3MyMShhY2NvdW50KVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZGVzYyA9IFwiRmFpbGVkIHRvIGdldCBhY2NvdW50IHF1ZXJ5XCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIltnZXRfYWNjb3VudF9xdWVyeV90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgc3RhdHVzOiBTdGF0dXMxOS5JbnZhbGlkVHJhbnNhY3Rpb24sIGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIEdFVF9BQ0NPVU5UX1FVRVJZX1RPT0wgPSBcImdldF9hY2NvdW50X3F1ZXJ5X3Rvb2xcIjtcbnZhciB0b29sMjEgPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBHRVRfQUNDT1VOVF9RVUVSWV9UT09MLFxuICBuYW1lOiBcIkdldCBBY2NvdW50IFF1ZXJ5XCIsXG4gIGRlc2NyaXB0aW9uOiBnZXRBY2NvdW50UXVlcnlQcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IGFjY291bnRRdWVyeVBhcmFtZXRlcnMoY29udGV4dCksXG4gIGV4ZWN1dGU6IGdldEFjY291bnRRdWVyeVxufSk7XG52YXIgZ2V0X2FjY291bnRfcXVlcnlfZGVmYXVsdCA9IHRvb2wyMTtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS1xdWVyaWVzLXBsdWdpbi90b29scy9xdWVyaWVzL2dldC1hY2NvdW50LXRva2VuLWJhbGFuY2VzLXF1ZXJ5LnRzXG52YXIgZ2V0QWNjb3VudFRva2VuQmFsYW5jZXNRdWVyeVByb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IGFjY291bnREZXNjID0gUHJvbXB0R2VuZXJhdG9yLmdldEFjY291bnRQYXJhbWV0ZXJEZXNjcmlwdGlvbihcImFjY291bnRJZFwiLCBjb250ZXh0KTtcbiAgY29uc3QgdXNhZ2VJbnN0cnVjdGlvbnMgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0UGFyYW1ldGVyVXNhZ2VJbnN0cnVjdGlvbnMoKTtcbiAgcmV0dXJuIGBcbiR7Y29udGV4dFNuaXBwZXR9XG5cblRoaXMgdG9vbCB3aWxsIHJldHVybiB0aGUgdG9rZW4gYmFsYW5jZXMgZm9yIGEgZ2l2ZW4gSGVkZXJhIGFjY291bnQuXG5cblBhcmFtZXRlcnM6XG4tICR7YWNjb3VudERlc2N9XG4tIHRva2VuSWQgKHN0ciwgb3B0aW9uYWwpOiBUaGUgdG9rZW4gSUQgdG8gcXVlcnkgZm9yLiBJZiBub3QgcHJvdmlkZWQsIGFsbCB0b2tlbiBiYWxhbmNlcyB3aWxsIGJlIHJldHVybmVkXG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuYDtcbn07XG52YXIgcG9zdFByb2Nlc3MyMiA9ICh0b2tlbkJhbGFuY2VzLCBhY2NvdW50SWQpID0+IHtcbiAgY29uc3QgYmFsYW5jZXNUZXh0ID0gdG9rZW5CYWxhbmNlcy50b2tlbnMubWFwKFxuICAgICh0b2tlbikgPT4gYCAgVG9rZW46ICR7dG9rZW4udG9rZW5faWR9LCBCYWxhbmNlOiAke3Rva2VuLmJhbGFuY2V9LCBEZWNpbWFsczogJHt0b2tlbi5kZWNpbWFsc31gXG4gICkuam9pbihcIlxcblwiKTtcbiAgcmV0dXJuIGBEZXRhaWxzIGZvciAke2FjY291bnRJZH1cbi0tLSBUb2tlbiBCYWxhbmNlcyAtLS1cbiR7YmFsYW5jZXNUZXh0fWA7XG59O1xudmFyIGdldEFjY291bnRUb2tlbkJhbGFuY2VzUXVlcnkgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBub3JtYWxpc2VkUGFyYW1zID0gSGVkZXJhUGFyYW1ldGVyTm9ybWFsaXNlci5ub3JtYWxpc2VBY2NvdW50VG9rZW5CYWxhbmNlc1BhcmFtcyhcbiAgICAgIHBhcmFtcyxcbiAgICAgIGNvbnRleHQsXG4gICAgICBjbGllbnRcbiAgICApO1xuICAgIGNvbnN0IG1pcnJvcm5vZGVTZXJ2aWNlID0gZ2V0TWlycm9ybm9kZVNlcnZpY2UoY29udGV4dC5taXJyb3Jub2RlU2VydmljZSwgY2xpZW50LmxlZGdlcklkKTtcbiAgICBjb25zdCB0b2tlbkJhbGFuY2VzID0gYXdhaXQgbWlycm9ybm9kZVNlcnZpY2UuZ2V0QWNjb3VudFRva2VuQmFsYW5jZXMoXG4gICAgICBub3JtYWxpc2VkUGFyYW1zLmFjY291bnRJZCxcbiAgICAgIG5vcm1hbGlzZWRQYXJhbXMudG9rZW5JZFxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhdzogeyBhY2NvdW50SWQ6IG5vcm1hbGlzZWRQYXJhbXMuYWNjb3VudElkLCB0b2tlbkJhbGFuY2VzIH0sXG4gICAgICBodW1hbk1lc3NhZ2U6IHBvc3RQcm9jZXNzMjIodG9rZW5CYWxhbmNlcywgbm9ybWFsaXNlZFBhcmFtcy5hY2NvdW50SWQpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gZ2V0IGFjY291bnQgdG9rZW4gYmFsYW5jZXNcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW2dldF9hY2NvdW50X3Rva2VuX2JhbGFuY2VzX3F1ZXJ5X3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBlcnJvcjogbWVzc2FnZSB9LCBodW1hbk1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgfVxufTtcbnZhciBHRVRfQUNDT1VOVF9UT0tFTl9CQUxBTkNFU19RVUVSWV9UT09MID0gXCJnZXRfYWNjb3VudF90b2tlbl9iYWxhbmNlc19xdWVyeV90b29sXCI7XG52YXIgdG9vbDIyID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogR0VUX0FDQ09VTlRfVE9LRU5fQkFMQU5DRVNfUVVFUllfVE9PTCxcbiAgbmFtZTogXCJHZXQgQWNjb3VudCBUb2tlbiBCYWxhbmNlc1wiLFxuICBkZXNjcmlwdGlvbjogZ2V0QWNjb3VudFRva2VuQmFsYW5jZXNRdWVyeVByb21wdChjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogYWNjb3VudFRva2VuQmFsYW5jZXNRdWVyeVBhcmFtZXRlcnMoY29udGV4dCksXG4gIGV4ZWN1dGU6IGdldEFjY291bnRUb2tlbkJhbGFuY2VzUXVlcnlcbn0pO1xudmFyIGdldF9hY2NvdW50X3Rva2VuX2JhbGFuY2VzX3F1ZXJ5X2RlZmF1bHQgPSB0b29sMjI7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtcXVlcmllcy1wbHVnaW4vdG9vbHMvcXVlcmllcy9nZXQtdG9waWMtbWVzc2FnZXMtcXVlcnkudHNcbnZhciBnZXRUb3BpY01lc3NhZ2VzUXVlcnlQcm9tcHQgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuJHtjb250ZXh0U25pcHBldH1cblxuVGhpcyB0b29sIHdpbGwgcmV0dXJuIHRoZSBtZXNzYWdlcyBmb3IgYSBnaXZlbiBIZWRlcmEgdG9waWMuXG5cblBhcmFtZXRlcnM6XG4tIHRvcGljSWQgKHN0ciwgcmVxdWlyZWQpOiBUaGUgdG9waWMgSUQgdG8gcXVlcnlcbi0gc3RhcnRUaW1lIChkYXRldGltZSwgb3B0aW9uYWwpOiBUaGUgc3RhcnQgZGF0ZXRpbWUgdG8gcXVlcnkuIElmIHNldCwgdGhlIG1lc3NhZ2VzIHdpbGwgYmUgcmV0dXJuZWQgYWZ0ZXIgdGhpcyBkYXRldGltZVxuLSBlbmRUaW1lIChkYXRldGltZSwgb3B0aW9uYWwpOiBUaGUgZW5kIGRhdGV0aW1lIHRvIHF1ZXJ5LiBJZiBzZXQsIHRoZSBtZXNzYWdlcyB3aWxsIGJlIHJldHVybmVkIGJlZm9yZSB0aGlzIGRhdGV0aW1lXG4tIGxpbWl0IChpbnQsIG9wdGlvbmFsKTogVGhlIGxpbWl0IG9mIG1lc3NhZ2VzIHRvIHF1ZXJ5LiBJZiBzZXQsIHRoZSBudW1iZXIgb2YgbWVzc2FnZXMgdG8gcmV0dXJuXG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuYDtcbn07XG52YXIgcG9zdFByb2Nlc3MyMyA9IChtZXNzYWdlcywgdG9waWNJZCkgPT4ge1xuICBjb25zdCBtZXNzYWdlc1RleHQgPSBtZXNzYWdlcy5tYXAoXG4gICAgKG1lc3NhZ2UpID0+IGAke0J1ZmZlci5mcm9tKG1lc3NhZ2UubWVzc2FnZSwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJ1dGYtOFwiKX0gLSBwb3N0ZWQgYXQ6ICR7bWVzc2FnZS5jb25zZW5zdXNfdGltZXN0YW1wfVxuYFxuICApO1xuICByZXR1cm4gYE1lc3NhZ2VzIGZvciB0b3BpYyAke3RvcGljSWR9OlxuICAtLS0gTWVzc2FnZXMgLS0tXG4gICR7bWVzc2FnZXNUZXh0fVxuICBgO1xufTtcbnZhciBnZXRUb3BpY01lc3NhZ2VzUXVlcnlQYXJhbXMgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiB7XG4gICAgdG9waWNJZDogcGFyYW1zLnRvcGljSWQsXG4gICAgbG93ZXJUaW1lc3RhbXA6IHBhcmFtcy5zdGFydFRpbWUgPyBgJHtNYXRoLmZsb29yKG5ldyBEYXRlKHBhcmFtcy5zdGFydFRpbWUpLmdldFRpbWUoKSAvIDFlMyl9LjAwMDAwMDAwMGAgOiBcIlwiLFxuICAgIHVwcGVyVGltZXN0YW1wOiBwYXJhbXMuZW5kVGltZSA/IGAke01hdGguZmxvb3IobmV3IERhdGUocGFyYW1zLmVuZFRpbWUpLmdldFRpbWUoKSAvIDFlMyl9LjAwMDAwMDAwMGAgOiBcIlwiLFxuICAgIGxpbWl0OiBwYXJhbXMubGltaXQgfHwgMTAwXG4gIH07XG59O1xudmFyIGNvbnZlcnRNZXNzYWdlc0Zyb21CYXNlNjRUb1N0cmluZyA9IChtZXNzYWdlcykgPT4ge1xuICByZXR1cm4gbWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICBtZXNzYWdlOiBCdWZmZXIuZnJvbShtZXNzYWdlLm1lc3NhZ2UsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwidXRmLThcIilcbiAgICB9O1xuICB9KTtcbn07XG52YXIgZ2V0VG9waWNNZXNzYWdlc1F1ZXJ5ID0gYXN5bmMgKGNsaWVudCwgY29udGV4dCwgcGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWlycm9ybm9kZVNlcnZpY2UgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgbWlycm9ybm9kZVNlcnZpY2UuZ2V0VG9waWNNZXNzYWdlcyhnZXRUb3BpY01lc3NhZ2VzUXVlcnlQYXJhbXMocGFyYW1zKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhdzoge1xuICAgICAgICB0b3BpY0lkOiBtZXNzYWdlcy50b3BpY0lkLFxuICAgICAgICBtZXNzYWdlczogY29udmVydE1lc3NhZ2VzRnJvbUJhc2U2NFRvU3RyaW5nKG1lc3NhZ2VzLm1lc3NhZ2VzKVxuICAgICAgfSxcbiAgICAgIGh1bWFuTWVzc2FnZTogcG9zdFByb2Nlc3MyMyhtZXNzYWdlcy5tZXNzYWdlcywgcGFyYW1zLnRvcGljSWQpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gZ2V0IHRvcGljIG1lc3NhZ2VzXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIltnZXRfdG9waWNfbWVzc2FnZXNfcXVlcnlfdG9vbF1cIiwgbWVzc2FnZSk7XG4gICAgcmV0dXJuIHsgcmF3OiB7IGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIEdFVF9UT1BJQ19NRVNTQUdFU19RVUVSWV9UT09MID0gXCJnZXRfdG9waWNfbWVzc2FnZXNfcXVlcnlfdG9vbFwiO1xudmFyIHRvb2wyMyA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IEdFVF9UT1BJQ19NRVNTQUdFU19RVUVSWV9UT09MLFxuICBuYW1lOiBcIkdldCBUb3BpYyBNZXNzYWdlc1wiLFxuICBkZXNjcmlwdGlvbjogZ2V0VG9waWNNZXNzYWdlc1F1ZXJ5UHJvbXB0KGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiB0b3BpY01lc3NhZ2VzUXVlcnlQYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBnZXRUb3BpY01lc3NhZ2VzUXVlcnlcbn0pO1xudmFyIGdldF90b3BpY19tZXNzYWdlc19xdWVyeV9kZWZhdWx0ID0gdG9vbDIzO1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLXF1ZXJpZXMtcGx1Z2luL3Rvb2xzL3F1ZXJpZXMvZ2V0LXRva2VuLWluZm8tcXVlcnkudHNcbnZhciBnZXRUb2tlbkluZm9RdWVyeVByb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCByZXR1cm4gdGhlIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIEhlZGVyYSB0b2tlbi5cblxuUGFyYW1ldGVyczpcbi0gdG9rZW5JZCAoc3RyKTogVGhlIHRva2VuIElEIHRvIHF1ZXJ5IGZvci5cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczI0ID0gKHRva2VuSW5mbykgPT4ge1xuICBjb25zdCBmb3JtYXRTdXBwbHkgPSAoc3VwcGx5KSA9PiB7XG4gICAgaWYgKCFzdXBwbHkpIHJldHVybiBcIk4vQVwiO1xuICAgIGNvbnN0IGRlY2ltYWxzID0gTnVtYmVyKHRva2VuSW5mby5kZWNpbWFscyB8fCBcIjBcIik7XG4gICAgY29uc3QgYW1vdW50ID0gTnVtYmVyKHN1cHBseSk7XG4gICAgaWYgKGlzTmFOKGFtb3VudCkpIHJldHVybiBzdXBwbHk7XG4gICAgcmV0dXJuIChhbW91bnQgLyAxMCAqKiBkZWNpbWFscykudG9Mb2NhbGVTdHJpbmcoKTtcbiAgfTtcbiAgY29uc3QgZm9ybWF0S2V5ID0gKGtleSkgPT4ge1xuICAgIGlmICgha2V5KSByZXR1cm4gXCJOb3QgU2V0XCI7XG4gICAgcmV0dXJuIGtleS5fdHlwZSA/IGAke2tleS5rZXl9YCA6IFwiUHJlc2VudFwiO1xuICB9O1xuICBjb25zdCBzdXBwbHlUeXBlID0gdG9rZW5JbmZvLnN1cHBseV90eXBlID09PSBcIklORklOSVRFXCIgPyBcIkluZmluaXRlXCIgOiB0b2tlbkluZm8ubWF4X3N1cHBseSB8fCBcIkZpbml0ZVwiO1xuICBjb25zdCBmcmVlemVTdGF0dXMgPSB0b2tlbkluZm8uZnJlZXplX2RlZmF1bHQgPyBcIkZyb3plblwiIDogXCJBY3RpdmVcIjtcbiAgcmV0dXJuIGBIZXJlIGFyZSB0aGUgZGV0YWlscyBmb3IgdG9rZW4gKioke3Rva2VuSW5mby50b2tlbl9pZH0qKjpcblxuLSAqKlRva2VuIE5hbWUqKjogJHt0b2tlbkluZm8ubmFtZX1cbi0gKipUb2tlbiBTeW1ib2wqKjogJHt0b2tlbkluZm8uc3ltYm9sfVxuLSAqKlRva2VuIFR5cGUqKjogJHt0b2tlbkluZm8udHlwZSB8fCBcIk4vQVwifVxuLSAqKkRlY2ltYWxzKio6ICR7dG9rZW5JbmZvLmRlY2ltYWxzfVxuLSAqKk1heCBTdXBwbHkqKjogJHtmb3JtYXRTdXBwbHkodG9rZW5JbmZvLm1heF9zdXBwbHkpfVxuLSAqKkN1cnJlbnQgU3VwcGx5Kio6ICR7Zm9ybWF0U3VwcGx5KHRva2VuSW5mby50b3RhbF9zdXBwbHkpfVxuLSAqKlN1cHBseSBUeXBlKio6ICR7c3VwcGx5VHlwZX1cbi0gKipUcmVhc3VyeSBBY2NvdW50IElEKio6ICR7dG9rZW5JbmZvLnRyZWFzdXJ5X2FjY291bnRfaWQgfHwgXCJOL0FcIn1cbi0gKipTdGF0dXMgKERlbGV0ZWQvQWN0aXZlKSoqOiAke3Rva2VuSW5mby5kZWxldGVkID8gXCJEZWxldGVkXCIgOiBcIkFjdGl2ZVwifVxuLSAqKlN0YXR1cyAoRnJvemVuL0FjdGl2ZSkqKjogJHtmcmVlemVTdGF0dXN9XG5cbioqS2V5cyoqOlxuLSBBZG1pbiBLZXk6ICR7Zm9ybWF0S2V5KHRva2VuSW5mby5hZG1pbl9rZXkpfVxuLSBTdXBwbHkgS2V5OiAke2Zvcm1hdEtleSh0b2tlbkluZm8uc3VwcGx5X2tleSl9XG4tIFdpcGUgS2V5OiAke2Zvcm1hdEtleSh0b2tlbkluZm8ud2lwZV9rZXkpfVxuLSBLWUMgS2V5OiAke2Zvcm1hdEtleSh0b2tlbkluZm8ua3ljX2tleSl9XG4tIEZyZWV6ZSBLZXk6ICR7Zm9ybWF0S2V5KHRva2VuSW5mby5mcmVlemVfa2V5KX1cbi0gRmVlIFNjaGVkdWxlIEtleTogJHtmb3JtYXRLZXkodG9rZW5JbmZvLmZlZV9zY2hlZHVsZV9rZXkpfVxuLSBQYXVzZSBLZXk6ICR7Zm9ybWF0S2V5KHRva2VuSW5mby5wYXVzZV9rZXkpfVxuLSBNZXRhZGF0YSBLZXk6ICR7Zm9ybWF0S2V5KHRva2VuSW5mby5tZXRhZGF0YV9rZXkpfVxuXG4ke3Rva2VuSW5mby5tZW1vID8gYCoqTWVtbyoqOiAke3Rva2VuSW5mby5tZW1vfWAgOiBcIlwifVxuYDtcbn07XG52YXIgZ2V0VG9rZW5JbmZvUXVlcnkgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBtaXJyb3Jub2RlU2VydmljZSA9IGdldE1pcnJvcm5vZGVTZXJ2aWNlKGNvbnRleHQubWlycm9ybm9kZVNlcnZpY2UsIGNsaWVudC5sZWRnZXJJZCk7XG4gICAgY29uc3QgdG9rZW5JbmZvID0ge1xuICAgICAgLi4uYXdhaXQgbWlycm9ybm9kZVNlcnZpY2UuZ2V0VG9rZW5JbmZvKHBhcmFtcy50b2tlbklkKSxcbiAgICAgIHRva2VuX2lkOiBwYXJhbXMudG9rZW5JZFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhdzogeyB0b2tlbklkOiBwYXJhbXMudG9rZW5JZCwgdG9rZW5JbmZvIH0sXG4gICAgICBodW1hbk1lc3NhZ2U6IHBvc3RQcm9jZXNzMjQodG9rZW5JbmZvKVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZGVzYyA9IFwiRmFpbGVkIHRvIGdldCB0b2tlbiBpbmZvXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIltnZXRfdG9rZW5faW5mb19xdWVyeV90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgR0VUX1RPS0VOX0lORk9fUVVFUllfVE9PTCA9IFwiZ2V0X3Rva2VuX2luZm9fcXVlcnlfdG9vbFwiO1xudmFyIHRvb2wyNCA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IEdFVF9UT0tFTl9JTkZPX1FVRVJZX1RPT0wsXG4gIG5hbWU6IFwiR2V0IFRva2VuIEluZm9cIixcbiAgZGVzY3JpcHRpb246IGdldFRva2VuSW5mb1F1ZXJ5UHJvbXB0KGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiB0b2tlbkluZm9RdWVyeVBhcmFtZXRlcnMoY29udGV4dCksXG4gIGV4ZWN1dGU6IGdldFRva2VuSW5mb1F1ZXJ5XG59KTtcbnZhciBnZXRfdG9rZW5faW5mb19xdWVyeV9kZWZhdWx0ID0gdG9vbDI0O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLXF1ZXJpZXMtcGx1Z2luL2luZGV4LnRzXG52YXIgY29yZVF1ZXJpZXNQbHVnaW4gPSB7XG4gIG5hbWU6IFwiY29yZS1xdWVyaWVzLXBsdWdpblwiLFxuICB2ZXJzaW9uOiBcIjEuMC4wXCIsXG4gIGRlc2NyaXB0aW9uOiBcIkEgcGx1Z2luIGZvciB0aGUgSGVkZXJhIFF1ZXJpZXMgU2VydmljZSAoREVQUkVDQVRFRClcIixcbiAgdG9vbHM6IChjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGdldF9oYmFyX2JhbGFuY2VfcXVlcnlfZGVmYXVsdChjb250ZXh0KSxcbiAgICAgIGdldF9hY2NvdW50X3F1ZXJ5X2RlZmF1bHQoY29udGV4dCksXG4gICAgICBnZXRfYWNjb3VudF90b2tlbl9iYWxhbmNlc19xdWVyeV9kZWZhdWx0KGNvbnRleHQpLFxuICAgICAgZ2V0X3RvcGljX21lc3NhZ2VzX3F1ZXJ5X2RlZmF1bHQoY29udGV4dCksXG4gICAgICBnZXRfdG9rZW5faW5mb19xdWVyeV9kZWZhdWx0KGNvbnRleHQpXG4gICAgXTtcbiAgfVxufTtcbnZhciBjb3JlUXVlcmllc1BsdWdpblRvb2xOYW1lcyA9IHtcbiAgR0VUX0hCQVJfQkFMQU5DRV9RVUVSWV9UT09MLFxuICBHRVRfQUNDT1VOVF9RVUVSWV9UT09MLFxuICBHRVRfQUNDT1VOVF9UT0tFTl9CQUxBTkNFU19RVUVSWV9UT09MLFxuICBHRVRfVE9QSUNfTUVTU0FHRVNfUVVFUllfVE9PTCxcbiAgR0VUX1RPS0VOX0lORk9fUVVFUllfVE9PTFxufTtcblxuLy8gc3JjL3NoYXJlZC9wYXJhbWV0ZXItc2NoZW1hcy9jb3JlLW1pc2Muem9kLnRzXG5pbXBvcnQgeyB6IGFzIHo3IH0gZnJvbSBcInpvZFwiO1xudmFyIGV4Y2hhbmdlUmF0ZVF1ZXJ5UGFyYW1ldGVycyA9IChfY29udGV4dCkgPT4gejcub2JqZWN0KHtcbiAgdGltZXN0YW1wOiB6Ny5zdHJpbmcoKS5kZXNjcmliZShcIkhpc3RvcmljYWwgdGltZXN0YW1wIHRvIHF1ZXJ5IChzZWNvbmRzIG9yIG5hbm9zIHNpbmNlIGVwb2NoKVwiKS5vcHRpb25hbCgpXG59KTtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS1taXNjLXF1ZXJ5LXBsdWdpbi90b29scy9xdWVyaWVzL2dldC1leGNoYW5nZS1yYXRlLXF1ZXJ5LnRzXG52YXIgZ2V0RXhjaGFuZ2VSYXRlUHJvbXB0ID0gKGNvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCBjb250ZXh0U25pcHBldCA9IFByb21wdEdlbmVyYXRvci5nZXRDb250ZXh0U25pcHBldChjb250ZXh0KTtcbiAgY29uc3QgdXNhZ2VJbnN0cnVjdGlvbnMgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0UGFyYW1ldGVyVXNhZ2VJbnN0cnVjdGlvbnMoKTtcbiAgcmV0dXJuIGBcbiR7Y29udGV4dFNuaXBwZXR9XG5cblRoaXMgdG9vbCByZXR1cm5zIHRoZSBIZWRlcmEgbmV0d29yayBIQkFSIGV4Y2hhbmdlIHJhdGUgZnJvbSB0aGUgTWlycm9yIE5vZGUuXG5cblBhcmFtZXRlcnM6XG4tIHRpbWVzdGFtcCAoc3RyLCBvcHRpb25hbCk6IEhpc3RvcmljYWwgdGltZXN0YW1wIHRvIHF1ZXJ5LiBQYXNzIHNlY29uZHMgb3IgbmFub3Mgc2luY2UgZXBvY2ggKGUuZy4sIDE3MjYwMDAwMDAuMTIzNDU2Nzg5KS4gSWYgb21pdHRlZCwgcmV0dXJucyB0aGUgbGF0ZXN0IHJhdGUuXG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuYDtcbn07XG52YXIgY2FsY3VsYXRlVXNkUGVySEJBUiA9IChjZW50X2VxdWl2YWxlbnQsIGhiYXJfZXF1aXZhbGVudCkgPT4ge1xuICByZXR1cm4gY2VudF9lcXVpdmFsZW50IC8gMTAwIC8gaGJhcl9lcXVpdmFsZW50O1xufTtcbnZhciBwb3N0UHJvY2VzczI1ID0gKHJhdGVzKSA9PiB7XG4gIGNvbnN0IHsgY3VycmVudF9yYXRlLCBuZXh0X3JhdGUsIHRpbWVzdGFtcCB9ID0gcmF0ZXM7XG4gIGNvbnN0IHVzZFBlckhCQVIgPSBjYWxjdWxhdGVVc2RQZXJIQkFSKFxuICAgIGN1cnJlbnRfcmF0ZS5jZW50X2VxdWl2YWxlbnQsXG4gICAgY3VycmVudF9yYXRlLmhiYXJfZXF1aXZhbGVudFxuICApO1xuICBjb25zdCBuZXh0VXNkUGVySEJBUiA9IGNhbGN1bGF0ZVVzZFBlckhCQVIobmV4dF9yYXRlLmNlbnRfZXF1aXZhbGVudCwgbmV4dF9yYXRlLmhiYXJfZXF1aXZhbGVudCk7XG4gIHJldHVybiBgXG4gIERldGFpbHMgZm9yIHRpbWVzdGFtcDogJHt0aW1lc3RhbXB9XG4gIFxuICBDdXJyZW50IGV4Y2hhbmdlIHJhdGU6ICR7dXNkUGVySEJBUn1cbiAgRXhwaXJlcyBhdCAke25ldyBEYXRlKGN1cnJlbnRfcmF0ZS5leHBpcmF0aW9uX3RpbWUgKiAxZTMpLnRvSVNPU3RyaW5nKCl9KVxuICBcbiAgTmV4dCBleGNoYW5nZSByYXRlOiAke25leHRVc2RQZXJIQkFSfVxuICBFeHBpcmVzIGF0ICR7bmV3IERhdGUobmV4dF9yYXRlLmV4cGlyYXRpb25fdGltZSAqIDFlMykudG9JU09TdHJpbmcoKX0pYDtcbn07XG52YXIgZ2V0RXhjaGFuZ2VSYXRlUXVlcnkgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBtaXJyb3Jub2RlU2VydmljZSA9IGdldE1pcnJvcm5vZGVTZXJ2aWNlKGNvbnRleHQubWlycm9ybm9kZVNlcnZpY2UsIGNsaWVudC5sZWRnZXJJZCk7XG4gICAgY29uc3QgcmF0ZXMgPSBhd2FpdCBtaXJyb3Jub2RlU2VydmljZS5nZXRFeGNoYW5nZVJhdGUocGFyYW1zLnRpbWVzdGFtcCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhdzogcmF0ZXMsXG4gICAgICBodW1hbk1lc3NhZ2U6IHBvc3RQcm9jZXNzMjUocmF0ZXMpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW0dldEV4Y2hhbmdlUmF0ZV0gRXJyb3IgZ2V0dGluZyBleGNoYW5nZSByYXRlXCIsIGVycm9yKTtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBnZXQgZXhjaGFuZ2UgcmF0ZVwiO1xuICAgIHJldHVybiB7XG4gICAgICByYXc6IHsgZXJyb3I6IG1lc3NhZ2UgfSxcbiAgICAgIGh1bWFuTWVzc2FnZTogbWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG52YXIgR0VUX0VYQ0hBTkdFX1JBVEVfVE9PTCA9IFwiZ2V0X2V4Y2hhbmdlX3JhdGVfdG9vbFwiO1xudmFyIHRvb2wyNSA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IEdFVF9FWENIQU5HRV9SQVRFX1RPT0wsXG4gIG5hbWU6IFwiR2V0IEV4Y2hhbmdlIFJhdGVcIixcbiAgZGVzY3JpcHRpb246IGdldEV4Y2hhbmdlUmF0ZVByb21wdChjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogZXhjaGFuZ2VSYXRlUXVlcnlQYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBnZXRFeGNoYW5nZVJhdGVRdWVyeVxufSk7XG52YXIgZ2V0X2V4Y2hhbmdlX3JhdGVfcXVlcnlfZGVmYXVsdCA9IHRvb2wyNTtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS1taXNjLXF1ZXJ5LXBsdWdpbi9pbmRleC50c1xudmFyIGNvcmVNaXNjUXVlcmllc1BsdWdpbiA9IHtcbiAgbmFtZTogXCJjb3JlLW1pc2MtcXVlcmllcy1wbHVnaW5cIixcbiAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICBkZXNjcmlwdGlvbjogXCJBIHBsdWdpbiBmb3IgSGVkZXJhIE1pc2MgUXVlcmllc1wiLFxuICB0b29sczogKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gW2dldF9leGNoYW5nZV9yYXRlX3F1ZXJ5X2RlZmF1bHQoY29udGV4dCldO1xuICB9XG59O1xudmFyIGNvcmVNaXNjUXVlcmllc1BsdWdpbnNUb29sTmFtZXMgPSB7XG4gIEdFVF9FWENIQU5HRV9SQVRFX1RPT0xcbn07XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtZXZtLXBsdWdpbi90b29scy9lcmMyMC9jcmVhdGUtZXJjMjAudHNcbmltcG9ydCB7IFN0YXR1cyBhcyBTdGF0dXMyMCwgVHJhbnNhY3Rpb25SZWNvcmRRdWVyeSB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xuXG4vLyBzcmMvc2hhcmVkL2NvbnN0YW50cy9jb250cmFjdHMudHNcbmltcG9ydCB7IExlZGdlcklkIGFzIExlZGdlcklkMiB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIFRFU1RORVRfRVJDMjBfRkFDVE9SWV9BRERSRVNTID0gXCIwLjAuNjQ3MTgxNFwiO1xudmFyIFRFU1RORVRfRVJDNzIxX0ZBQ1RPUllfQUREUkVTUyA9IFwiMC4wLjY1MTA2NjZcIjtcbnZhciBFUkMyMF9GQUNUT1JZX0FERFJFU1NFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW0xlZGdlcklkMi5URVNUTkVULnRvU3RyaW5nKCksIFRFU1RORVRfRVJDMjBfRkFDVE9SWV9BRERSRVNTXVxuICAvLyBDdXJyZW50IHRlc3RuZXQgYWRkcmVzc1xuXSk7XG52YXIgRVJDNzIxX0ZBQ1RPUllfQUREUkVTU0VTID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbTGVkZ2VySWQyLlRFU1RORVQudG9TdHJpbmcoKSwgVEVTVE5FVF9FUkM3MjFfRkFDVE9SWV9BRERSRVNTXVxuICAvLyBDdXJyZW50IHRlc3RuZXQgYWRkcmVzc1xuXSk7XG52YXIgRVJDMjBfRkFDVE9SWV9BQkkgPSBbXG4gIFwiZnVuY3Rpb24gZGVwbG95VG9rZW4oc3RyaW5nIG1lbW9yeSBuYW1lXywgc3RyaW5nIG1lbW9yeSBzeW1ib2xfLCB1aW50OCBkZWNpbWFsc18sIHVpbnQyNTYgaW5pdGlhbFN1cHBseV8pIGV4dGVybmFsIHJldHVybnMgKGFkZHJlc3MpXCJcbl07XG52YXIgRVJDNzIxX0ZBQ1RPUllfQUJJID0gW1xuICBcImZ1bmN0aW9uIGRlcGxveVRva2VuKHN0cmluZyBtZW1vcnkgbmFtZV8sIHN0cmluZyBtZW1vcnkgc3ltYm9sXywgc3RyaW5nIG1lbW9yeSBiYXNlVVJJXykgZXh0ZXJuYWwgcmV0dXJucyAoYWRkcmVzcylcIlxuXTtcbnZhciBFUkMyMF9UUkFOU0ZFUl9GVU5DVElPTl9OQU1FID0gXCJ0cmFuc2ZlclwiO1xudmFyIEVSQzIwX1RSQU5TRkVSX0ZVTkNUSU9OX0FCSSA9IFtcbiAgXCJmdW5jdGlvbiB0cmFuc2ZlcihhZGRyZXNzIHRvLCB1aW50MjU2IGFtb3VudCkgZXh0ZXJuYWwgcmV0dXJucyAoYm9vbClcIlxuXTtcbnZhciBFUkM3MjFfVFJBTlNGRVJfRlVOQ1RJT05fTkFNRSA9IFwidHJhbnNmZXJGcm9tXCI7XG52YXIgRVJDNzIxX1RSQU5TRkVSX0ZVTkNUSU9OX0FCSSA9IFtcbiAgXCJmdW5jdGlvbiB0cmFuc2ZlckZyb20oYWRkcmVzcyBmcm9tLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpXCJcbl07XG52YXIgRVJDNzIxX01JTlRfRlVOQ1RJT05fTkFNRSA9IFwic2FmZU1pbnRcIjtcbnZhciBFUkM3MjFfTUlOVF9GVU5DVElPTl9BQkkgPSBbXCJmdW5jdGlvbiBzYWZlTWludChhZGRyZXNzIHRvKSBleHRlcm5hbCByZXR1cm5zIChib29sKVwiXTtcbmZ1bmN0aW9uIGdldEVSQzIwRmFjdG9yeUFkZHJlc3MobGVkZ2VySWQpIHtcbiAgY29uc3QgYWRkcmVzcyA9IEVSQzIwX0ZBQ1RPUllfQUREUkVTU0VTLmdldChsZWRnZXJJZC50b1N0cmluZygpKTtcbiAgaWYgKCFhZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrIHR5cGUgJHtsZWRnZXJJZH0gbm90IHN1cHBvcnRlZCBmb3IgRVJDMjAgZmFjdG9yeWApO1xuICB9XG4gIHJldHVybiBhZGRyZXNzO1xufVxuZnVuY3Rpb24gZ2V0RVJDNzIxRmFjdG9yeUFkZHJlc3MobGVkZ2VySWQpIHtcbiAgY29uc3QgYWRkcmVzcyA9IEVSQzcyMV9GQUNUT1JZX0FERFJFU1NFUy5nZXQobGVkZ2VySWQudG9TdHJpbmcoKSk7XG4gIGlmICghYWRkcmVzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayB0eXBlICR7bGVkZ2VySWR9IG5vdCBzdXBwb3J0ZWQgZm9yIEVSQzcyMSBmYWN0b3J5YCk7XG4gIH1cbiAgcmV0dXJuIGFkZHJlc3M7XG59XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtZXZtLXBsdWdpbi90b29scy9lcmMyMC9jcmVhdGUtZXJjMjAudHNcbnZhciBjcmVhdGVFUkMyMFByb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgY3JlYXRlcyBhbiBFUkMyMCB0b2tlbiBvbiBIZWRlcmEgYnkgY2FsbGluZyB0aGUgQmFzZUVSQzIwRmFjdG9yeSBjb250cmFjdC5cblxuUGFyYW1ldGVyczpcbi0gdG9rZW5OYW1lIChzdHIsIHJlcXVpcmVkKTogVGhlIG5hbWUgb2YgdGhlIHRva2VuXG4tIHRva2VuU3ltYm9sIChzdHIsIHJlcXVpcmVkKTogVGhlIHN5bWJvbCBvZiB0aGUgdG9rZW5cbi0gZGVjaW1hbHMgKGludCwgb3B0aW9uYWwpOiBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzIHRoZSB0b2tlbiBzdXBwb3J0cy4gRGVmYXVsdHMgdG8gMThcbi0gaW5pdGlhbFN1cHBseSAoaW50LCBvcHRpb25hbCk6IFRoZSBpbml0aWFsIHN1cHBseSBvZiB0aGUgdG9rZW4uIERlZmF1bHRzIHRvIDBcbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBnZXRFUkMyMEFkZHJlc3MgPSBhc3luYyAoY2xpZW50LCBleGVjdXRlU3RyYXRlZ3lSZXN1bHQpID0+IHtcbiAgY29uc3QgcmVjb3JkID0gYXdhaXQgbmV3IFRyYW5zYWN0aW9uUmVjb3JkUXVlcnkoKS5zZXRUcmFuc2FjdGlvbklkKGV4ZWN1dGVTdHJhdGVneVJlc3VsdC5yYXcudHJhbnNhY3Rpb25JZCkuZXhlY3V0ZShjbGllbnQpO1xuICByZXR1cm4gXCIweFwiICsgcmVjb3JkLmNvbnRyYWN0RnVuY3Rpb25SZXN1bHQ/LmdldEFkZHJlc3MoMCk7XG59O1xudmFyIGNyZWF0ZUVSQzIwID0gYXN5bmMgKGNsaWVudCwgY29udGV4dCwgcGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZmFjdG9yeUNvbnRyYWN0QWRkcmVzcyA9IGdldEVSQzIwRmFjdG9yeUFkZHJlc3MoY2xpZW50LmxlZGdlcklkKTtcbiAgICBjb25zdCBub3JtYWxpc2VkUGFyYW1zID0gSGVkZXJhUGFyYW1ldGVyTm9ybWFsaXNlci5ub3JtYWxpc2VDcmVhdGVFUkMyMFBhcmFtcyhcbiAgICAgIHBhcmFtcyxcbiAgICAgIGZhY3RvcnlDb250cmFjdEFkZHJlc3MsXG4gICAgICBFUkMyMF9GQUNUT1JZX0FCSSxcbiAgICAgIFwiZGVwbG95VG9rZW5cIixcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIGNvbnN0IHR4ID0gSGVkZXJhQnVpbGRlci5leGVjdXRlVHJhbnNhY3Rpb24obm9ybWFsaXNlZFBhcmFtcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlVHJhbnNhY3Rpb24odHgsIGNsaWVudCwgY29udGV4dCk7XG4gICAgaWYgKGNvbnRleHQubW9kZSA9PSBcImF1dG9ub21vdXNcIiAvKiBBVVRPTk9NT1VTICovKSB7XG4gICAgICBjb25zdCBlcmMyMEFkZHJlc3MgPSBhd2FpdCBnZXRFUkMyMEFkZHJlc3MoY2xpZW50LCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICBlcmMyMEFkZHJlc3M6IGVyYzIwQWRkcmVzcz8udG9TdHJpbmcoKSxcbiAgICAgICAgaHVtYW5NZXNzYWdlOiBgRVJDMjAgdG9rZW4gY3JlYXRlZCBzdWNjZXNzZnVsbHkgYXQgYWRkcmVzcyAke2VyYzIwQWRkcmVzcz8udG9TdHJpbmcoKX1gXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBjcmVhdGUgRVJDMjAgdG9rZW5cIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW2NyZWF0ZV9lcmMyMF90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgc3RhdHVzOiBTdGF0dXMyMC5JbnZhbGlkVHJhbnNhY3Rpb24sIGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIENSRUFURV9FUkMyMF9UT09MID0gXCJjcmVhdGVfZXJjMjBfdG9vbFwiO1xudmFyIHRvb2wyNiA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IENSRUFURV9FUkMyMF9UT09MLFxuICBuYW1lOiBcIkNyZWF0ZSBFUkMyMCBUb2tlblwiLFxuICBkZXNjcmlwdGlvbjogY3JlYXRlRVJDMjBQcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IGNyZWF0ZUVSQzIwUGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogY3JlYXRlRVJDMjBcbn0pO1xudmFyIGNyZWF0ZV9lcmMyMF9kZWZhdWx0ID0gdG9vbDI2O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLWV2bS1wbHVnaW4vdG9vbHMvZXJjMjAvdHJhbnNmZXItZXJjMjAudHNcbmltcG9ydCB7IFN0YXR1cyBhcyBTdGF0dXMyMSB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIHRyYW5zZmVyRVJDMjBQcm9tcHQgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuJHtjb250ZXh0U25pcHBldH1cblxuVGhpcyB0b29sIHdpbGwgdHJhbnNmZXIgYSBnaXZlbiBhbW91bnQgb2YgYW4gZXhpc3RpbmcgRVJDMjAgdG9rZW4gb24gSGVkZXJhLlxuXG5QYXJhbWV0ZXJzOlxuLSBjb250cmFjdElkIChzdHIsIHJlcXVpcmVkKTogVGhlIGlkIG9mIHRoZSBFUkMyMCBjb250cmFjdC4gVGhpcyBjYW4gYmUgdGhlIEVWTSBhZGRyZXNzIG9yIHRoZSBIZWRlcmEgYWNjb3VudCBpZC5cbi0gcmVjaXBpZW50QWRkcmVzcyAoc3RyLCByZXF1aXJlZCk6IFRoZSBFVk0gb3IgSGVkZXJhIGFkZHJlc3MgdG8gd2hpY2ggdGhlIHRva2VucyB3aWxsIGJlIHRyYW5zZmVycmVkLiBUaGlzIGNhbiBiZSB0aGUgRVZNIGFkZHJlc3Mgb3IgdGhlIEhlZGVyYSBhY2NvdW50IGlkLlxuLSBhbW91bnQgKG51bWJlciwgcmVxdWlyZWQpOiBUaGUgYW1vdW50IHRvIGJlIHRyYW5zZmVycmVkXG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuXG5FeGFtcGxlOiBcIlRyYW5zZmVyIDEgRVJDMjAgdG9rZW4gMC4wLjY0NzMxMzUgdG8gMHhkOTRkYzdmODJmMTAzNzU3ZjcxNTUxNGU0YTM3MTg2YmU2ZTQ1ODBiXCIgbWVhbnMgdHJhbnNmZXJyaW5nIHRoZSBhbW91bnQgb2YgMSBvZiB0aGUgRVJDMjAgdG9rZW4gd2l0aCBjb250cmFjdCBpZCAwLjAuNjQ3MzEzNSB0byB0aGUgMHhkOTRkYzdmODJmMTAzNzU3ZjcxNTUxNGU0YTM3MTg2YmU2ZTQ1ODBiIEVWTSBhZGRyZXNzLlxuRXhhbXBsZTogXCJUcmFuc2ZlciAxIEVSQzIwIHRva2VuIDB4ZDk0ZGM3ZjgyZjEwMzc1N2Y3MTU1MTRlNGEzNzE4NmJlNmU0NTgwYiB0byAwLjAuNjQ3MzEzNVwiIG1lYW5zIHRyYW5zZmVycmluZyB0aGUgYW1vdW50IG9mIDEgb2YgdGhlIEVSQzIwIHRva2VuIHdpdGggY29udHJhY3QgaWQgMHhkOTRkYzdmODJmMTAzNzU3ZjcxNTUxNGU0YTM3MTg2YmU2ZTQ1ODBiIHRvIHRoZSAwLjAuNjQ3MzEzNSBIZWRlcmEgYWNjb3VudCBpZC5cbmA7XG59O1xudmFyIHRyYW5zZmVyRVJDMjAgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgY29uc3QgbWlycm9yTm9kZSA9IGdldE1pcnJvcm5vZGVTZXJ2aWNlKGNvbnRleHQubWlycm9ybm9kZVNlcnZpY2UsIGNsaWVudC5sZWRnZXJJZCk7XG4gIHRyeSB7XG4gICAgY29uc3Qgbm9ybWFsaXNlZFBhcmFtcyA9IGF3YWl0IEhlZGVyYVBhcmFtZXRlck5vcm1hbGlzZXIubm9ybWFsaXNlVHJhbnNmZXJFUkMyMFBhcmFtcyhcbiAgICAgIHBhcmFtcyxcbiAgICAgIEVSQzIwX1RSQU5TRkVSX0ZVTkNUSU9OX0FCSSxcbiAgICAgIEVSQzIwX1RSQU5TRkVSX0ZVTkNUSU9OX05BTUUsXG4gICAgICBjb250ZXh0LFxuICAgICAgbWlycm9yTm9kZVxuICAgICk7XG4gICAgY29uc3QgdHggPSBIZWRlcmFCdWlsZGVyLmV4ZWN1dGVUcmFuc2FjdGlvbihub3JtYWxpc2VkUGFyYW1zKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVUcmFuc2FjdGlvbih0eCwgY2xpZW50LCBjb250ZXh0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byB0cmFuc2ZlciBFUkMyMFwiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXNjICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgOiAke2Vycm9yLm1lc3NhZ2V9YCA6IFwiXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbdHJhbnNmZXJfZXJjMjBfdG9vbF1cIiwgbWVzc2FnZSk7XG4gICAgcmV0dXJuIHsgcmF3OiB7IHN0YXR1czogU3RhdHVzMjEuSW52YWxpZFRyYW5zYWN0aW9uLCBlcnJvcjogbWVzc2FnZSB9LCBodW1hbk1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgfVxufTtcbnZhciBUUkFOU0ZFUl9FUkMyMF9UT09MID0gXCJ0cmFuc2Zlcl9lcmMyMF90b29sXCI7XG52YXIgdG9vbDI3ID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogVFJBTlNGRVJfRVJDMjBfVE9PTCxcbiAgbmFtZTogXCJUcmFuc2ZlciBFUkMyMFwiLFxuICBkZXNjcmlwdGlvbjogdHJhbnNmZXJFUkMyMFByb21wdChjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogdHJhbnNmZXJFUkMyMFBhcmFtZXRlcnMoY29udGV4dCksXG4gIGV4ZWN1dGU6IHRyYW5zZmVyRVJDMjBcbn0pO1xudmFyIHRyYW5zZmVyX2VyYzIwX2RlZmF1bHQgPSB0b29sMjc7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtZXZtLXBsdWdpbi90b29scy9lcmM3MjEvdHJhbnNmZXItZXJjNzIxLnRzXG5pbXBvcnQgeyBTdGF0dXMgYXMgU3RhdHVzMjIgfSBmcm9tIFwiQGhhc2hncmFwaC9zZGtcIjtcbnZhciB0cmFuc2ZlckVSQzcyMVByb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IGZyb21BZGRyZXNzRGVzYyA9IFByb21wdEdlbmVyYXRvci5nZXRBbnlBZGRyZXNzUGFyYW1ldGVyRGVzY3JpcHRpb24oXCJmcm9tQWRkcmVzc1wiLCBjb250ZXh0KTtcbiAgY29uc3QgdXNhZ2VJbnN0cnVjdGlvbnMgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0UGFyYW1ldGVyVXNhZ2VJbnN0cnVjdGlvbnMoKTtcbiAgcmV0dXJuIGBcbiR7Y29udGV4dFNuaXBwZXR9XG5cblRoaXMgdG9vbCB3aWxsIHRyYW5zZmVyIGFuIGV4aXN0aW5nIEVSQzcyMSB0b2tlbiBvbiBIZWRlcmEuXG5cblBhcmFtZXRlcnM6XG4tIGNvbnRyYWN0SWQgKHN0ciwgcmVxdWlyZWQpOiBUaGUgaWQgb2YgdGhlIEVSQzcyMSBjb250cmFjdFxuLSAke2Zyb21BZGRyZXNzRGVzY31cbi0gdG9BZGRyZXNzIChzdHIsIHJlcXVpcmVkKTogVGhlIGFkZHJlc3MgdG8gd2hpY2ggdGhlIHRva2VuIHdpbGwgYmUgdHJhbnNmZXJyZWQuIFRoaXMgY2FuIGJlIHRoZSBFVk0gYWRkcmVzcyBvciB0aGUgSGVkZXJhIGFjY291bnQgaWQuXG4tIHRva2VuSWQgKG51bWJlciwgcmVxdWlyZWQpOiBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyZWQgdG9rZW5cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5cbkV4YW1wbGU6IFwiVHJhbnNmZXIgRVJDNzIxIHRva2VuIDAuMC42NDg2NzkzIHdpdGggaWQgMCBmcm9tIDB4ZDk0ZGM3ZjgyZjEwMzc1N2Y3MTU1MTRlNGEzNzE4NmJlNmU0NTgwYiB0byAweGQ5NGRjN2Y4MmYxMDM3NTdmNzE1NTE0ZTRhMzcxODZiZTZlNDU4MGJcIiBtZWFucyB0cmFuc2ZlcmluZyB0aGUgRVJDNzIxIHRva2VuIChpZGVudGlmaWVkIGJ5IDApIHdpdGggY29udHJhY3QgaWQgMC4wLjY0ODY3OTMgZnJvbSB0aGUgMHhkOTRkYzdmODJmMTAzNzU3ZjcxNTUxNGU0YTM3MTg2YmU2ZTQ1ODBiIEVWTSBhZGRyZXNzIHRvIHRoZSAweGQ5NGRjN2Y4MmYxMDM3NTdmNzE1NTE0ZTRhMzcxODZiZTZlNDU4MGIgRVZNIGFkZHJlc3MuXG5FeGFtcGxlOiBcIlRyYW5zZmVyIEVSQzcyMSB0b2tlbiAwLjAuNjQ4Njc5MyB3aXRoIGlkIDAgZnJvbSAwLjAuNjQ4Njc5MyB0byAweGQ5NGRjN2Y4MmYxMDM3NTdmNzE1NTE0ZTRhMzcxODZiZTZlNDU4MGJcIiBtZWFucyB0cmFuc2ZlcmluZyB0aGUgRVJDNzIxIHRva2VuIChpZGVudGlmaWVkIGJ5IDApIHdpdGggY29udHJhY3QgaWQgMC4wLjY0ODY3OTMgZnJvbSB0aGUgMC4wLjY0ODY3OTMgSGVkZXJhIGFjY291bnQgaWQgdG8gdGhlIDB4ZDk0ZGM3ZjgyZjEwMzc1N2Y3MTU1MTRlNGEzNzE4NmJlNmU0NTgwYiBFVk0gYWRkcmVzcy5cbmA7XG59O1xudmFyIHRyYW5zZmVyRVJDNzIxID0gYXN5bmMgKGNsaWVudCwgY29udGV4dCwgcGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWlycm9yTm9kZSA9IGdldE1pcnJvcm5vZGVTZXJ2aWNlKGNvbnRleHQubWlycm9ybm9kZVNlcnZpY2UsIGNsaWVudC5sZWRnZXJJZCk7XG4gICAgY29uc3Qgbm9ybWFsaXNlZFBhcmFtcyA9IGF3YWl0IEhlZGVyYVBhcmFtZXRlck5vcm1hbGlzZXIubm9ybWFsaXNlVHJhbnNmZXJFUkM3MjFQYXJhbXMoXG4gICAgICBwYXJhbXMsXG4gICAgICBFUkM3MjFfVFJBTlNGRVJfRlVOQ1RJT05fQUJJLFxuICAgICAgRVJDNzIxX1RSQU5TRkVSX0ZVTkNUSU9OX05BTUUsXG4gICAgICBjb250ZXh0LFxuICAgICAgbWlycm9yTm9kZSxcbiAgICAgIGNsaWVudFxuICAgICk7XG4gICAgY29uc3QgdHggPSBIZWRlcmFCdWlsZGVyLmV4ZWN1dGVUcmFuc2FjdGlvbihub3JtYWxpc2VkUGFyYW1zKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVUcmFuc2FjdGlvbih0eCwgY2xpZW50LCBjb250ZXh0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byB0cmFuc2ZlciBFUkM3MjFcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW3RyYW5zZmVyX2VyYzcyMV90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgc3RhdHVzOiBTdGF0dXMyMi5JbnZhbGlkVHJhbnNhY3Rpb24sIGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIFRSQU5TRkVSX0VSQzcyMV9UT09MID0gXCJ0cmFuc2Zlcl9lcmM3MjFfdG9vbFwiO1xudmFyIHRvb2wyOCA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IFRSQU5TRkVSX0VSQzcyMV9UT09MLFxuICBuYW1lOiBcIlRyYW5zZmVyIEVSQzcyMVwiLFxuICBkZXNjcmlwdGlvbjogdHJhbnNmZXJFUkM3MjFQcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IHRyYW5zZmVyRVJDNzIxUGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogdHJhbnNmZXJFUkM3MjFcbn0pO1xudmFyIHRyYW5zZmVyX2VyYzcyMV9kZWZhdWx0ID0gdG9vbDI4O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLWV2bS1wbHVnaW4vdG9vbHMvZXJjNzIxL21pbnQtZXJjNzIxLnRzXG5pbXBvcnQgeyBTdGF0dXMgYXMgU3RhdHVzMjMgfSBmcm9tIFwiQGhhc2hncmFwaC9zZGtcIjtcbnZhciBtaW50RVJDNzIxUHJvbXB0ID0gKGNvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCBjb250ZXh0U25pcHBldCA9IFByb21wdEdlbmVyYXRvci5nZXRDb250ZXh0U25pcHBldChjb250ZXh0KTtcbiAgY29uc3QgdXNhZ2VJbnN0cnVjdGlvbnMgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0UGFyYW1ldGVyVXNhZ2VJbnN0cnVjdGlvbnMoKTtcbiAgY29uc3QgdG9BZGRyZXNzRGVzYyA9IFByb21wdEdlbmVyYXRvci5nZXRBbnlBZGRyZXNzUGFyYW1ldGVyRGVzY3JpcHRpb24oXCJ0b0FkZHJlc3NcIiwgY29udGV4dCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCBtaW50IGEgbmV3IEVSQzcyMSB0b2tlbiBvbiBIZWRlcmEuXG5cblBhcmFtZXRlcnM6XG4tIGNvbnRyYWN0SWQgKHN0ciwgcmVxdWlyZWQpOiBUaGUgaWQgb2YgdGhlIEVSQzcyMSBjb250cmFjdFxuLSAke3RvQWRkcmVzc0Rlc2N9XG4ke3VzYWdlSW5zdHJ1Y3Rpb25zfVxuXG5FeGFtcGxlOiBcIk1pbnQgRVJDNzIxIHRva2VuIDAuMC42NDg2NzkzIHRvIDB4ZDk0ZGM3ZjgyZjEwMzc1N2Y3MTU1MTRlNGEzNzE4NmJlNmU0NTgwYlwiIG1lYW5zIG1pbnRpbmcgdGhlIEVSQzcyMSB0b2tlbiB3aXRoIGNvbnRyYWN0IGlkIDAuMC42NDg2NzkzIHRvIHRoZSAweGQ5NGRjN2Y4MmYxMDM3NTdmNzE1NTE0ZTRhMzcxODZiZTZlNDU4MGIgRVZNIGFkZHJlc3MuXG5FeGFtcGxlOiBcIk1pbnQgRVJDNzIxIHRva2VuIDAuMC42NDg2NzkzIHRvIDAuMC42NDg2NzkzXCIgbWVhbnMgbWludGluZyB0aGUgRVJDNzIxIHRva2VuIHdpdGggY29udHJhY3QgaWQgMC4wLjY0ODY3OTMgdG8gdGhlIDAuMC42NDg2NzkzIEhlZGVyYSBhY2NvdW50IGlkLlxuYDtcbn07XG52YXIgbWludEVSQzcyMSA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG1pcnJvck5vZGUgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IG5vcm1hbGlzZWRQYXJhbXMgPSBhd2FpdCBIZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLm5vcm1hbGlzZU1pbnRFUkM3MjFQYXJhbXMoXG4gICAgICBwYXJhbXMsXG4gICAgICBFUkM3MjFfTUlOVF9GVU5DVElPTl9BQkksXG4gICAgICBFUkM3MjFfTUlOVF9GVU5DVElPTl9OQU1FLFxuICAgICAgY29udGV4dCxcbiAgICAgIG1pcnJvck5vZGUsXG4gICAgICBjbGllbnRcbiAgICApO1xuICAgIGNvbnN0IHR4ID0gSGVkZXJhQnVpbGRlci5leGVjdXRlVHJhbnNhY3Rpb24obm9ybWFsaXNlZFBhcmFtcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlVHJhbnNhY3Rpb24odHgsIGNsaWVudCwgY29udGV4dCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gbWludCBFUkM3MjFcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW21pbnRfZXJjNzIxX3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBzdGF0dXM6IFN0YXR1czIzLkludmFsaWRUcmFuc2FjdGlvbiwgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgTUlOVF9FUkM3MjFfVE9PTCA9IFwibWludF9lcmM3MjFfdG9vbFwiO1xudmFyIHRvb2wyOSA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IE1JTlRfRVJDNzIxX1RPT0wsXG4gIG5hbWU6IFwiTWludCBFUkM3MjFcIixcbiAgZGVzY3JpcHRpb246IG1pbnRFUkM3MjFQcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IG1pbnRFUkM3MjFQYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBtaW50RVJDNzIxXG59KTtcbnZhciBtaW50X2VyYzcyMV9kZWZhdWx0ID0gdG9vbDI5O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLWV2bS1wbHVnaW4vdG9vbHMvZXJjNzIxL2NyZWF0ZS1lcmM3MjEudHNcbmltcG9ydCB7IFN0YXR1cyBhcyBTdGF0dXMyNCwgVHJhbnNhY3Rpb25SZWNvcmRRdWVyeSBhcyBUcmFuc2FjdGlvblJlY29yZFF1ZXJ5MiB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIGNyZWF0ZUVSQzcyMVByb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgY3JlYXRlcyBhbiBFUkM3MjEgdG9rZW4gb24gSGVkZXJhIGJ5IGNhbGxpbmcgdGhlIEJhc2VFUkM3MjFGYWN0b3J5IGNvbnRyYWN0LlxuXG5QYXJhbWV0ZXJzOlxuLSB0b2tlbk5hbWUgKHN0ciwgcmVxdWlyZWQpOiBUaGUgbmFtZSBvZiB0aGUgdG9rZW5cbi0gdG9rZW5TeW1ib2wgKHN0ciwgcmVxdWlyZWQpOiBUaGUgc3ltYm9sIG9mIHRoZSB0b2tlblxuLSBiYXNlVVJJIChzdHIsIHJlcXVpcmVkKTogVGhlIGJhc2UgVVJJIGZvciB0b2tlbiBtZXRhZGF0YS5cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5cblRoZSBjb250cmFjdElkIHJldHVybmVkIGJ5IHRoZSB0b29sIGlzIHRoZSBhZGRyZXNzIG9mIHRoZSBFUkM3MjEgRmFjdG9yeSBjb250cmFjdCwgdGhlIGFkZHJlc3Mgb2YgdGhlIEVSQzcyMSB0b2tlbiBpcyB0aGUgZXJjNzIxQWRkcmVzcyByZXR1cm5lZCBieSB0aGUgdG9vbC5cbmA7XG59O1xudmFyIGdldEVSQzcyMUFkZHJlc3MgPSBhc3luYyAoY2xpZW50LCBleGVjdXRlU3RyYXRlZ3lSZXN1bHQpID0+IHtcbiAgY29uc3QgcmVjb3JkID0gYXdhaXQgbmV3IFRyYW5zYWN0aW9uUmVjb3JkUXVlcnkyKCkuc2V0VHJhbnNhY3Rpb25JZChleGVjdXRlU3RyYXRlZ3lSZXN1bHQucmF3LnRyYW5zYWN0aW9uSWQpLmV4ZWN1dGUoY2xpZW50KTtcbiAgcmV0dXJuIFwiMHhcIiArIHJlY29yZC5jb250cmFjdEZ1bmN0aW9uUmVzdWx0Py5nZXRBZGRyZXNzKDApO1xufTtcbnZhciBjcmVhdGVFUkM3MjEgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmYWN0b3J5Q29udHJhY3RBZGRyZXNzID0gZ2V0RVJDNzIxRmFjdG9yeUFkZHJlc3MoY2xpZW50LmxlZGdlcklkKTtcbiAgICBjb25zdCBub3JtYWxpc2VkUGFyYW1zID0gSGVkZXJhUGFyYW1ldGVyTm9ybWFsaXNlci5ub3JtYWxpc2VDcmVhdGVFUkM3MjFQYXJhbXMoXG4gICAgICBwYXJhbXMsXG4gICAgICBmYWN0b3J5Q29udHJhY3RBZGRyZXNzLFxuICAgICAgRVJDNzIxX0ZBQ1RPUllfQUJJLFxuICAgICAgXCJkZXBsb3lUb2tlblwiLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgY29uc3QgdHggPSBIZWRlcmFCdWlsZGVyLmV4ZWN1dGVUcmFuc2FjdGlvbihub3JtYWxpc2VkUGFyYW1zKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVUcmFuc2FjdGlvbih0eCwgY2xpZW50LCBjb250ZXh0KTtcbiAgICBpZiAoY29udGV4dC5tb2RlID09IFwiYXV0b25vbW91c1wiIC8qIEFVVE9OT01PVVMgKi8pIHtcbiAgICAgIGNvbnN0IGVyYzcyMUFkZHJlc3MgPSBhd2FpdCBnZXRFUkM3MjFBZGRyZXNzKGNsaWVudCwgcmVzdWx0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgZXJjNzIxQWRkcmVzczogZXJjNzIxQWRkcmVzcz8udG9TdHJpbmcoKSxcbiAgICAgICAgbWVzc2FnZTogYEVSQzcyMSB0b2tlbiBjcmVhdGVkIHN1Y2Nlc3NmdWxseSBhdCBhZGRyZXNzICR7ZXJjNzIxQWRkcmVzcz8udG9TdHJpbmcoKX1gXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBjcmVhdGUgRVJDNzIxIHRva2VuXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIltjcmVhdGVfZXJjNzIxX3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBzdGF0dXM6IFN0YXR1czI0LkludmFsaWRUcmFuc2FjdGlvbiwgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgQ1JFQVRFX0VSQzcyMV9UT09MID0gXCJjcmVhdGVfZXJjNzIxX3Rvb2xcIjtcbnZhciB0b29sMzAgPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBDUkVBVEVfRVJDNzIxX1RPT0wsXG4gIG5hbWU6IFwiQ3JlYXRlIEVSQzcyMSBUb2tlblwiLFxuICBkZXNjcmlwdGlvbjogY3JlYXRlRVJDNzIxUHJvbXB0KGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiBjcmVhdGVFUkM3MjFQYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBjcmVhdGVFUkM3MjFcbn0pO1xudmFyIGNyZWF0ZV9lcmM3MjFfZGVmYXVsdCA9IHRvb2wzMDtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS1ldm0tcGx1Z2luL2luZGV4LnRzXG52YXIgY29yZUVWTVBsdWdpbiA9IHtcbiAgbmFtZTogXCJjb3JlLWV2bS1wbHVnaW5cIixcbiAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICBkZXNjcmlwdGlvbjogXCJBIHBsdWdpbiBmb3IgdGhlIEhlZGVyYSBFVk1cIixcbiAgdG9vbHM6IChjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGNyZWF0ZV9lcmMyMF9kZWZhdWx0KGNvbnRleHQpLFxuICAgICAgdHJhbnNmZXJfZXJjMjBfZGVmYXVsdChjb250ZXh0KSxcbiAgICAgIHRyYW5zZmVyX2VyYzcyMV9kZWZhdWx0KGNvbnRleHQpLFxuICAgICAgbWludF9lcmM3MjFfZGVmYXVsdChjb250ZXh0KSxcbiAgICAgIGNyZWF0ZV9lcmM3MjFfZGVmYXVsdChjb250ZXh0KVxuICAgIF07XG4gIH1cbn07XG52YXIgY29yZUVWTVBsdWdpblRvb2xOYW1lcyA9IHtcbiAgVFJBTlNGRVJfRVJDNzIxX1RPT0wsXG4gIE1JTlRfRVJDNzIxX1RPT0wsXG4gIENSRUFURV9FUkMyMF9UT09MLFxuICBUUkFOU0ZFUl9FUkMyMF9UT09MLFxuICBDUkVBVEVfRVJDNzIxX1RPT0xcbn07XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtYWNjb3VudC1xdWVyeS1wbHVnaW4vdG9vbHMvcXVlcmllcy9nZXQtaGJhci1iYWxhbmNlLXF1ZXJ5LnRzXG52YXIgZ2V0SGJhckJhbGFuY2VRdWVyeVByb21wdDIgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCBhY2NvdW50RGVzYyA9IFByb21wdEdlbmVyYXRvci5nZXRBY2NvdW50UGFyYW1ldGVyRGVzY3JpcHRpb24oXCJhY2NvdW50SWRcIiwgY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCByZXR1cm4gdGhlIEhCQVIgYmFsYW5jZSBmb3IgYSBnaXZlbiBIZWRlcmEgYWNjb3VudC5cblxuUGFyYW1ldGVyczpcbi0gJHthY2NvdW50RGVzY31cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczI2ID0gKGhiYXJCYWxhbmNlLCBhY2NvdW50SWQpID0+IHtcbiAgcmV0dXJuIGBBY2NvdW50ICR7YWNjb3VudElkfSBoYXMgYSBiYWxhbmNlIG9mICR7aGJhckJhbGFuY2V9IEhCQVJgO1xufTtcbnZhciBnZXRIYmFyQmFsYW5jZVF1ZXJ5MiA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG5vcm1hbGlzZWRQYXJhbXMgPSBIZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLm5vcm1hbGlzZUhiYXJCYWxhbmNlUGFyYW1zKFxuICAgICAgcGFyYW1zLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNsaWVudFxuICAgICk7XG4gICAgY29uc3QgbWlycm9ybm9kZVNlcnZpY2UgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBtaXJyb3Jub2RlU2VydmljZS5nZXRBY2NvdW50SEJhckJhbGFuY2UoXG4gICAgICBub3JtYWxpc2VkUGFyYW1zLmFjY291bnRJZFxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhdzogeyBhY2NvdW50SWQ6IG5vcm1hbGlzZWRQYXJhbXMuYWNjb3VudElkLCBoYmFyQmFsYW5jZTogdG9IQmFyKGJhbGFuY2UpLnRvU3RyaW5nKCkgfSxcbiAgICAgIGh1bWFuTWVzc2FnZTogcG9zdFByb2Nlc3MyNih0b0hCYXIoYmFsYW5jZSkudG9TdHJpbmcoKSwgbm9ybWFsaXNlZFBhcmFtcy5hY2NvdW50SWQpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gZ2V0IEhCQVIgYmFsYW5jZVwiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXNjICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgOiAke2Vycm9yLm1lc3NhZ2V9YCA6IFwiXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZ2V0X2hiYXJfYmFsYW5jZV9xdWVyeV90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgR0VUX0hCQVJfQkFMQU5DRV9RVUVSWV9UT09MMiA9IFwiZ2V0X2hiYXJfYmFsYW5jZV9xdWVyeV90b29sXCI7XG52YXIgdG9vbDMxID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogR0VUX0hCQVJfQkFMQU5DRV9RVUVSWV9UT09MMixcbiAgbmFtZTogXCJHZXQgSEJBUiBCYWxhbmNlXCIsXG4gIGRlc2NyaXB0aW9uOiBnZXRIYmFyQmFsYW5jZVF1ZXJ5UHJvbXB0Mihjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogYWNjb3VudEJhbGFuY2VRdWVyeVBhcmFtZXRlcnMoY29udGV4dCksXG4gIGV4ZWN1dGU6IGdldEhiYXJCYWxhbmNlUXVlcnkyXG59KTtcbnZhciBnZXRfaGJhcl9iYWxhbmNlX3F1ZXJ5X2RlZmF1bHQyID0gdG9vbDMxO1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLWFjY291bnQtcXVlcnktcGx1Z2luL3Rvb2xzL3F1ZXJpZXMvZ2V0LWFjY291bnQtcXVlcnkudHNcbmltcG9ydCB7IFN0YXR1cyBhcyBTdGF0dXMyNSB9IGZyb20gXCJAaGFzaGdyYXBoL3Nka1wiO1xudmFyIGdldEFjY291bnRRdWVyeVByb21wdDIgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuJHtjb250ZXh0U25pcHBldH1cblxuVGhpcyB0b29sIHdpbGwgcmV0dXJuIHRoZSBhY2NvdW50IGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIEhlZGVyYSBhY2NvdW50LlxuXG5QYXJhbWV0ZXJzOlxuLSBhY2NvdW50SWQgKHN0ciwgcmVxdWlyZWQpOiBUaGUgYWNjb3VudCBJRCB0byBxdWVyeVxuJHt1c2FnZUluc3RydWN0aW9uc31cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzMjcgPSAoYWNjb3VudCkgPT4ge1xuICByZXR1cm4gYERldGFpbHMgZm9yICR7YWNjb3VudC5hY2NvdW50SWR9XG5CYWxhbmNlOiAke2FjY291bnQuYmFsYW5jZS5iYWxhbmNlLnRvU3RyaW5nKCl9XG5QdWJsaWMgS2V5OiAke2FjY291bnQuYWNjb3VudFB1YmxpY0tleX0sXG5FVk0gYWRkcmVzczogJHthY2NvdW50LmV2bUFkZHJlc3N9LFxuYDtcbn07XG52YXIgZ2V0QWNjb3VudFF1ZXJ5MiA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG1pcnJvcm5vZGVTZXJ2aWNlID0gZ2V0TWlycm9ybm9kZVNlcnZpY2UoY29udGV4dC5taXJyb3Jub2RlU2VydmljZSwgY2xpZW50LmxlZGdlcklkKTtcbiAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgbWlycm9ybm9kZVNlcnZpY2UuZ2V0QWNjb3VudChwYXJhbXMuYWNjb3VudElkKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmF3OiB7IGFjY291bnRJZDogcGFyYW1zLmFjY291bnRJZCwgYWNjb3VudCB9LFxuICAgICAgaHVtYW5NZXNzYWdlOiBwb3N0UHJvY2VzczI3KGFjY291bnQpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBkZXNjID0gXCJGYWlsZWQgdG8gZ2V0IGFjY291bnQgcXVlcnlcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW2dldF9hY2NvdW50X3F1ZXJ5X3Rvb2xdXCIsIG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IHJhdzogeyBzdGF0dXM6IFN0YXR1czI1LkludmFsaWRUcmFuc2FjdGlvbiwgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgR0VUX0FDQ09VTlRfUVVFUllfVE9PTDIgPSBcImdldF9hY2NvdW50X3F1ZXJ5X3Rvb2xcIjtcbnZhciB0b29sMzIgPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBHRVRfQUNDT1VOVF9RVUVSWV9UT09MMixcbiAgbmFtZTogXCJHZXQgQWNjb3VudCBRdWVyeVwiLFxuICBkZXNjcmlwdGlvbjogZ2V0QWNjb3VudFF1ZXJ5UHJvbXB0Mihjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogYWNjb3VudFF1ZXJ5UGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogZ2V0QWNjb3VudFF1ZXJ5MlxufSk7XG52YXIgZ2V0X2FjY291bnRfcXVlcnlfZGVmYXVsdDIgPSB0b29sMzI7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtYWNjb3VudC1xdWVyeS1wbHVnaW4vdG9vbHMvcXVlcmllcy9nZXQtYWNjb3VudC10b2tlbi1iYWxhbmNlcy1xdWVyeS50c1xudmFyIGdldEFjY291bnRUb2tlbkJhbGFuY2VzUXVlcnlQcm9tcHQyID0gKGNvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCBjb250ZXh0U25pcHBldCA9IFByb21wdEdlbmVyYXRvci5nZXRDb250ZXh0U25pcHBldChjb250ZXh0KTtcbiAgY29uc3QgYWNjb3VudERlc2MgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0QWNjb3VudFBhcmFtZXRlckRlc2NyaXB0aW9uKFwiYWNjb3VudElkXCIsIGNvbnRleHQpO1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuJHtjb250ZXh0U25pcHBldH1cblxuVGhpcyB0b29sIHdpbGwgcmV0dXJuIHRoZSB0b2tlbiBiYWxhbmNlcyBmb3IgYSBnaXZlbiBIZWRlcmEgYWNjb3VudC5cblxuUGFyYW1ldGVyczpcbi0gJHthY2NvdW50RGVzY31cbi0gdG9rZW5JZCAoc3RyLCBvcHRpb25hbCk6IFRoZSB0b2tlbiBJRCB0byBxdWVyeSBmb3IuIElmIG5vdCBwcm92aWRlZCwgYWxsIHRva2VuIGJhbGFuY2VzIHdpbGwgYmUgcmV0dXJuZWRcbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczI4ID0gKHRva2VuQmFsYW5jZXMsIGFjY291bnRJZCkgPT4ge1xuICBpZiAodG9rZW5CYWxhbmNlcy50b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGBObyB0b2tlbiBiYWxhbmNlcyBmb3VuZCBmb3IgYWNjb3VudCAke2FjY291bnRJZH1gO1xuICB9XG4gIGNvbnN0IGJhbGFuY2VzVGV4dCA9IHRva2VuQmFsYW5jZXMudG9rZW5zLm1hcChcbiAgICAodG9rZW4pID0+IGAgIFRva2VuOiAke3Rva2VuLnRva2VuX2lkfSwgQmFsYW5jZTogJHt0b2tlbi5iYWxhbmNlfSwgRGVjaW1hbHM6ICR7dG9rZW4uZGVjaW1hbHN9YFxuICApLmpvaW4oXCJcXG5cIik7XG4gIHJldHVybiBgRGV0YWlscyBmb3IgJHthY2NvdW50SWR9XG4tLS0gVG9rZW4gQmFsYW5jZXMgLS0tXG4ke2JhbGFuY2VzVGV4dH1gO1xufTtcbnZhciBnZXRBY2NvdW50VG9rZW5CYWxhbmNlc1F1ZXJ5MiA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG5vcm1hbGlzZWRQYXJhbXMgPSBIZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLm5vcm1hbGlzZUFjY291bnRUb2tlbkJhbGFuY2VzUGFyYW1zKFxuICAgICAgcGFyYW1zLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNsaWVudFxuICAgICk7XG4gICAgY29uc3QgbWlycm9ybm9kZVNlcnZpY2UgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IHRva2VuQmFsYW5jZXMgPSBhd2FpdCBtaXJyb3Jub2RlU2VydmljZS5nZXRBY2NvdW50VG9rZW5CYWxhbmNlcyhcbiAgICAgIG5vcm1hbGlzZWRQYXJhbXMuYWNjb3VudElkLFxuICAgICAgbm9ybWFsaXNlZFBhcmFtcy50b2tlbklkXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmF3OiB7IGFjY291bnRJZDogbm9ybWFsaXNlZFBhcmFtcy5hY2NvdW50SWQsIHRva2VuQmFsYW5jZXMgfSxcbiAgICAgIGh1bWFuTWVzc2FnZTogcG9zdFByb2Nlc3MyOCh0b2tlbkJhbGFuY2VzLCBub3JtYWxpc2VkUGFyYW1zLmFjY291bnRJZClcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBnZXQgYWNjb3VudCB0b2tlbiBiYWxhbmNlc1wiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXNjICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgOiAke2Vycm9yLm1lc3NhZ2V9YCA6IFwiXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZ2V0X2FjY291bnRfdG9rZW5fYmFsYW5jZXNfcXVlcnlfdG9vbF1cIiwgbWVzc2FnZSk7XG4gICAgcmV0dXJuIHsgcmF3OiB7IGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIEdFVF9BQ0NPVU5UX1RPS0VOX0JBTEFOQ0VTX1FVRVJZX1RPT0wyID0gXCJnZXRfYWNjb3VudF90b2tlbl9iYWxhbmNlc19xdWVyeV90b29sXCI7XG52YXIgdG9vbDMzID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogR0VUX0FDQ09VTlRfVE9LRU5fQkFMQU5DRVNfUVVFUllfVE9PTDIsXG4gIG5hbWU6IFwiR2V0IEFjY291bnQgVG9rZW4gQmFsYW5jZXNcIixcbiAgZGVzY3JpcHRpb246IGdldEFjY291bnRUb2tlbkJhbGFuY2VzUXVlcnlQcm9tcHQyKGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiBhY2NvdW50VG9rZW5CYWxhbmNlc1F1ZXJ5UGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogZ2V0QWNjb3VudFRva2VuQmFsYW5jZXNRdWVyeTJcbn0pO1xudmFyIGdldF9hY2NvdW50X3Rva2VuX2JhbGFuY2VzX3F1ZXJ5X2RlZmF1bHQyID0gdG9vbDMzO1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLWFjY291bnQtcXVlcnktcGx1Z2luL2luZGV4LnRzXG52YXIgY29yZUFjY291bnRRdWVyeVBsdWdpbiA9IHtcbiAgbmFtZTogXCJjb3JlLWFjY291bnQtcXVlcnktcGx1Z2luXCIsXG4gIHZlcnNpb246IFwiMS4wLjBcIixcbiAgZGVzY3JpcHRpb246IFwiQSBwbHVnaW4gZm9yIEhlZGVyYSBBY2NvdW50IFNlcnZpY2UgcXVlcmllc1wiLFxuICB0b29sczogKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgZ2V0X2hiYXJfYmFsYW5jZV9xdWVyeV9kZWZhdWx0Mihjb250ZXh0KSxcbiAgICAgIGdldF9hY2NvdW50X3F1ZXJ5X2RlZmF1bHQyKGNvbnRleHQpLFxuICAgICAgZ2V0X2FjY291bnRfdG9rZW5fYmFsYW5jZXNfcXVlcnlfZGVmYXVsdDIoY29udGV4dClcbiAgICBdO1xuICB9XG59O1xudmFyIGNvcmVBY2NvdW50UXVlcnlQbHVnaW5Ub29sTmFtZXMgPSB7XG4gIEdFVF9IQkFSX0JBTEFOQ0VfUVVFUllfVE9PTDogR0VUX0hCQVJfQkFMQU5DRV9RVUVSWV9UT09MMixcbiAgR0VUX0FDQ09VTlRfUVVFUllfVE9PTDogR0VUX0FDQ09VTlRfUVVFUllfVE9PTDIsXG4gIEdFVF9BQ0NPVU5UX1RPS0VOX0JBTEFOQ0VTX1FVRVJZX1RPT0w6IEdFVF9BQ0NPVU5UX1RPS0VOX0JBTEFOQ0VTX1FVRVJZX1RPT0wyXG59O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLXRva2VuLXF1ZXJ5LXBsdWdpbi90b29scy9xdWVyaWVzL2dldC10b2tlbi1pbmZvLXF1ZXJ5LnRzXG52YXIgZ2V0VG9rZW5JbmZvUXVlcnlQcm9tcHQyID0gKGNvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCBjb250ZXh0U25pcHBldCA9IFByb21wdEdlbmVyYXRvci5nZXRDb250ZXh0U25pcHBldChjb250ZXh0KTtcbiAgY29uc3QgdXNhZ2VJbnN0cnVjdGlvbnMgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0UGFyYW1ldGVyVXNhZ2VJbnN0cnVjdGlvbnMoKTtcbiAgcmV0dXJuIGBcbiR7Y29udGV4dFNuaXBwZXR9XG5cblRoaXMgdG9vbCB3aWxsIHJldHVybiB0aGUgaW5mb3JtYXRpb24gZm9yIGEgZ2l2ZW4gSGVkZXJhIHRva2VuLlxuXG5QYXJhbWV0ZXJzOlxuLSB0b2tlbklkIChzdHIpOiBUaGUgdG9rZW4gSUQgdG8gcXVlcnkgZm9yLlxuJHt1c2FnZUluc3RydWN0aW9uc31cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzMjkgPSAodG9rZW5JbmZvKSA9PiB7XG4gIGNvbnN0IGZvcm1hdFN1cHBseSA9IChzdXBwbHkpID0+IHtcbiAgICBpZiAoIXN1cHBseSkgcmV0dXJuIFwiTi9BXCI7XG4gICAgY29uc3QgZGVjaW1hbHMgPSBOdW1iZXIodG9rZW5JbmZvLmRlY2ltYWxzIHx8IFwiMFwiKTtcbiAgICBjb25zdCBhbW91bnQgPSBOdW1iZXIoc3VwcGx5KTtcbiAgICBpZiAoaXNOYU4oYW1vdW50KSkgcmV0dXJuIHN1cHBseTtcbiAgICByZXR1cm4gKGFtb3VudCAvIDEwICoqIGRlY2ltYWxzKS50b0xvY2FsZVN0cmluZygpO1xuICB9O1xuICBjb25zdCBmb3JtYXRLZXkgPSAoa2V5KSA9PiB7XG4gICAgaWYgKCFrZXkpIHJldHVybiBcIk5vdCBTZXRcIjtcbiAgICByZXR1cm4ga2V5Ll90eXBlID8gYCR7a2V5LmtleX1gIDogXCJQcmVzZW50XCI7XG4gIH07XG4gIGNvbnN0IHN1cHBseVR5cGUgPSB0b2tlbkluZm8uc3VwcGx5X3R5cGUgPT09IFwiSU5GSU5JVEVcIiA/IFwiSW5maW5pdGVcIiA6IFwiRmluaXRlXCI7XG4gIGNvbnN0IGZyZWV6ZVN0YXR1cyA9IHRva2VuSW5mby5mcmVlemVfZGVmYXVsdCA/IFwiRnJvemVuXCIgOiBcIkFjdGl2ZVwiO1xuICByZXR1cm4gYEhlcmUgYXJlIHRoZSBkZXRhaWxzIGZvciB0b2tlbiAqKiR7dG9rZW5JbmZvLnRva2VuX2lkfSoqOlxuXG4tICoqVG9rZW4gTmFtZSoqOiAke3Rva2VuSW5mby5uYW1lfVxuLSAqKlRva2VuIFN5bWJvbCoqOiAke3Rva2VuSW5mby5zeW1ib2x9XG4tICoqVG9rZW4gVHlwZSoqOiAke3Rva2VuSW5mby50eXBlIHx8IFwiTi9BXCJ9XG4tICoqRGVjaW1hbHMqKjogJHt0b2tlbkluZm8uZGVjaW1hbHN9XG4tICoqTWF4IFN1cHBseSoqOiAke2Zvcm1hdFN1cHBseSh0b2tlbkluZm8ubWF4X3N1cHBseSl9XG4tICoqQ3VycmVudCBTdXBwbHkqKjogJHtmb3JtYXRTdXBwbHkodG9rZW5JbmZvLnRvdGFsX3N1cHBseSl9XG4tICoqU3VwcGx5IFR5cGUqKjogJHtzdXBwbHlUeXBlfVxuLSAqKlRyZWFzdXJ5IEFjY291bnQgSUQqKjogJHt0b2tlbkluZm8udHJlYXN1cnlfYWNjb3VudF9pZCB8fCBcIk4vQVwifVxuLSAqKlN0YXR1cyAoRGVsZXRlZC9BY3RpdmUpKio6ICR7dG9rZW5JbmZvLmRlbGV0ZWQgPyBcIkRlbGV0ZWRcIiA6IFwiQWN0aXZlXCJ9XG4tICoqU3RhdHVzIChGcm96ZW4vQWN0aXZlKSoqOiAke2ZyZWV6ZVN0YXR1c31cblxuKipLZXlzKio6XG4tIEFkbWluIEtleTogJHtmb3JtYXRLZXkodG9rZW5JbmZvLmFkbWluX2tleSl9XG4tIFN1cHBseSBLZXk6ICR7Zm9ybWF0S2V5KHRva2VuSW5mby5zdXBwbHlfa2V5KX1cbi0gV2lwZSBLZXk6ICR7Zm9ybWF0S2V5KHRva2VuSW5mby53aXBlX2tleSl9XG4tIEtZQyBLZXk6ICR7Zm9ybWF0S2V5KHRva2VuSW5mby5reWNfa2V5KX1cbi0gRnJlZXplIEtleTogJHtmb3JtYXRLZXkodG9rZW5JbmZvLmZyZWV6ZV9rZXkpfVxuLSBGZWUgU2NoZWR1bGUgS2V5OiAke2Zvcm1hdEtleSh0b2tlbkluZm8uZmVlX3NjaGVkdWxlX2tleSl9XG4tIFBhdXNlIEtleTogJHtmb3JtYXRLZXkodG9rZW5JbmZvLnBhdXNlX2tleSl9XG4tIE1ldGFkYXRhIEtleTogJHtmb3JtYXRLZXkodG9rZW5JbmZvLm1ldGFkYXRhX2tleSl9XG5cbiR7dG9rZW5JbmZvLm1lbW8gPyBgKipNZW1vKio6ICR7dG9rZW5JbmZvLm1lbW99YCA6IFwiXCJ9XG5gO1xufTtcbnZhciBnZXRUb2tlbkluZm9RdWVyeTIgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBtaXJyb3Jub2RlU2VydmljZSA9IGdldE1pcnJvcm5vZGVTZXJ2aWNlKGNvbnRleHQubWlycm9ybm9kZVNlcnZpY2UsIGNsaWVudC5sZWRnZXJJZCk7XG4gICAgY29uc3QgdG9rZW5JbmZvID0ge1xuICAgICAgLi4uYXdhaXQgbWlycm9ybm9kZVNlcnZpY2UuZ2V0VG9rZW5JbmZvKHBhcmFtcy50b2tlbklkKSxcbiAgICAgIHRva2VuX2lkOiBwYXJhbXMudG9rZW5JZFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhdzogeyB0b2tlbklkOiBwYXJhbXMudG9rZW5JZCwgdG9rZW5JbmZvIH0sXG4gICAgICBodW1hbk1lc3NhZ2U6IHBvc3RQcm9jZXNzMjkodG9rZW5JbmZvKVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZGVzYyA9IFwiRmFpbGVkIHRvIGdldCB0b2tlbiBpbmZvXCI7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlc2MgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGA6ICR7ZXJyb3IubWVzc2FnZX1gIDogXCJcIik7XG4gICAgY29uc29sZS5lcnJvcihcIltnZXRfdG9rZW5faW5mb19xdWVyeV90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgR0VUX1RPS0VOX0lORk9fUVVFUllfVE9PTDIgPSBcImdldF90b2tlbl9pbmZvX3F1ZXJ5X3Rvb2xcIjtcbnZhciB0b29sMzQgPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBHRVRfVE9LRU5fSU5GT19RVUVSWV9UT09MMixcbiAgbmFtZTogXCJHZXQgVG9rZW4gSW5mb1wiLFxuICBkZXNjcmlwdGlvbjogZ2V0VG9rZW5JbmZvUXVlcnlQcm9tcHQyKGNvbnRleHQpLFxuICBwYXJhbWV0ZXJzOiB0b2tlbkluZm9RdWVyeVBhcmFtZXRlcnMoY29udGV4dCksXG4gIGV4ZWN1dGU6IGdldFRva2VuSW5mb1F1ZXJ5MlxufSk7XG52YXIgZ2V0X3Rva2VuX2luZm9fcXVlcnlfZGVmYXVsdDIgPSB0b29sMzQ7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtdG9rZW4tcXVlcnktcGx1Z2luL3Rvb2xzL3F1ZXJpZXMvZ2V0LXBlbmRpbmctYWlyZHJvcC1xdWVyeS50c1xudmFyIGdldFBlbmRpbmdBaXJkcm9wUXVlcnlQcm9tcHQgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCBhY2NvdW50RGVzYyA9IFByb21wdEdlbmVyYXRvci5nZXRBY2NvdW50UGFyYW1ldGVyRGVzY3JpcHRpb24oXCJhY2NvdW50SWRcIiwgY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCByZXR1cm4gcGVuZGluZyBhaXJkcm9wcyBmb3IgYSBnaXZlbiBIZWRlcmEgYWNjb3VudC5cblxuUGFyYW1ldGVyczpcbi0gJHthY2NvdW50RGVzY31cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBmb3JtYXRBaXJkcm9wID0gKGFpcmRyb3AsIGluZGV4KSA9PiB7XG4gIGNvbnN0IHRva2VuID0gYWlyZHJvcC50b2tlbl9pZCA/PyBcIk4vQVwiO1xuICBjb25zdCBhbW91bnQgPSBhaXJkcm9wLmFtb3VudCA/PyAwO1xuICBjb25zdCBzZXJpYWwgPSBhaXJkcm9wLnNlcmlhbF9udW1iZXIgPz8gXCJOL0FcIjtcbiAgY29uc3Qgc2VuZGVyID0gYWlyZHJvcC5zZW5kZXJfaWQgPz8gXCJOL0FcIjtcbiAgY29uc3QgcmVjZWl2ZXIgPSBhaXJkcm9wLnJlY2VpdmVyX2lkID8/IFwiTi9BXCI7XG4gIGNvbnN0IGZyb21UcyA9IGFpcmRyb3AudGltZXN0YW1wPy5mcm9tID8/IFwiTi9BXCI7XG4gIGNvbnN0IHRvVHMgPSBhaXJkcm9wLnRpbWVzdGFtcD8udG8gPz8gXCJOL0FcIjtcbiAgcmV0dXJuIGAjJHtpbmRleCArIDF9IFRva2VuOiAke3Rva2VufSwgQW1vdW50OiAke2Ftb3VudH0sIFNlcmlhbDogJHtzZXJpYWx9LCBTZW5kZXI6ICR7c2VuZGVyfSwgUmVjZWl2ZXI6ICR7cmVjZWl2ZXJ9LCBUaW1lc3RhbXA6ICR7ZnJvbVRzfSR7dG9UcyA/IGAgXFx1MjE5MiAke3RvVHN9YCA6IFwiXCJ9YDtcbn07XG52YXIgcG9zdFByb2Nlc3MzMCA9IChhY2NvdW50SWQsIHJlc3BvbnNlKSA9PiB7XG4gIGNvbnN0IGNvdW50ID0gcmVzcG9uc2UuYWlyZHJvcHM/Lmxlbmd0aCA/PyAwO1xuICBpZiAoY291bnQgPT09IDApIHtcbiAgICByZXR1cm4gYE5vIHBlbmRpbmcgYWlyZHJvcHMgZm91bmQgZm9yIGFjY291bnQgJHthY2NvdW50SWR9YDtcbiAgfVxuICBjb25zdCBkZXRhaWxzID0gcmVzcG9uc2UuYWlyZHJvcHMubWFwKGZvcm1hdEFpcmRyb3ApLmpvaW4oXCJcXG5cIik7XG4gIHJldHVybiBgSGVyZSBhcmUgdGhlIHBlbmRpbmcgYWlyZHJvcHMgZm9yIGFjY291bnQgKioke2FjY291bnRJZH0qKiAodG90YWw6ICR7Y291bnR9KTpcblxuJHtkZXRhaWxzfWA7XG59O1xudmFyIGdldFBlbmRpbmdBaXJkcm9wUXVlcnkgPSBhc3luYyAoY2xpZW50LCBjb250ZXh0LCBwYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhY2NvdW50SWQgPSBwYXJhbXMuYWNjb3VudElkID8/IEFjY291bnRSZXNvbHZlci5nZXREZWZhdWx0QWNjb3VudChjb250ZXh0LCBjbGllbnQpO1xuICAgIGlmICghYWNjb3VudElkKSB0aHJvdyBuZXcgRXJyb3IoXCJBY2NvdW50IElEIGlzIHJlcXVpcmVkIGFuZCB3YXMgbm90IHByb3ZpZGVkXCIpO1xuICAgIGNvbnN0IG1pcnJvcm5vZGVTZXJ2aWNlID0gZ2V0TWlycm9ybm9kZVNlcnZpY2UoY29udGV4dC5taXJyb3Jub2RlU2VydmljZSwgY2xpZW50LmxlZGdlcklkKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1pcnJvcm5vZGVTZXJ2aWNlLmdldFBlbmRpbmdBaXJkcm9wcyhhY2NvdW50SWQpO1xuICAgIHJldHVybiB7XG4gICAgICByYXc6IHsgYWNjb3VudElkLCBwZW5kaW5nQWlyZHJvcHM6IHJlc3BvbnNlIH0sXG4gICAgICBodW1hbk1lc3NhZ2U6IHBvc3RQcm9jZXNzMzAoYWNjb3VudElkLCByZXNwb25zZSlcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBnZXQgcGVuZGluZyBhaXJkcm9wc1wiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXNjICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgOiAke2Vycm9yLm1lc3NhZ2V9YCA6IFwiXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZ2V0X3BlbmRpbmdfYWlyZHJvcF9xdWVyeV90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgR0VUX1BFTkRJTkdfQUlSRFJPUF9UT09MID0gXCJnZXRfcGVuZGluZ19haXJkcm9wX3Rvb2xcIjtcbnZhciB0b29sMzUgPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBHRVRfUEVORElOR19BSVJEUk9QX1RPT0wsXG4gIG5hbWU6IFwiR2V0IFBlbmRpbmcgQWlyZHJvcHNcIixcbiAgZGVzY3JpcHRpb246IGdldFBlbmRpbmdBaXJkcm9wUXVlcnlQcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IHBlbmRpbmdBaXJkcm9wUXVlcnlQYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBnZXRQZW5kaW5nQWlyZHJvcFF1ZXJ5XG59KTtcbnZhciBnZXRfcGVuZGluZ19haXJkcm9wX3F1ZXJ5X2RlZmF1bHQgPSB0b29sMzU7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtdG9rZW4tcXVlcnktcGx1Z2luL2luZGV4LnRzXG52YXIgY29yZVRva2VuUXVlcnlQbHVnaW4gPSB7XG4gIG5hbWU6IFwiY29yZS10b2tlbi1xdWVyeS1wbHVnaW5cIixcbiAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICBkZXNjcmlwdGlvbjogXCJBIHBsdWdpbiBmb3IgSGVkZXJhIFRva2VuIFNlcnZpY2UgcXVlcmllc1wiLFxuICB0b29sczogKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gW2dldF90b2tlbl9pbmZvX3F1ZXJ5X2RlZmF1bHQyKGNvbnRleHQpLCBnZXRfcGVuZGluZ19haXJkcm9wX3F1ZXJ5X2RlZmF1bHQoY29udGV4dCldO1xuICB9XG59O1xudmFyIGNvcmVUb2tlblF1ZXJ5UGx1Z2luVG9vbE5hbWVzID0ge1xuICBHRVRfVE9LRU5fSU5GT19RVUVSWV9UT09MOiBHRVRfVE9LRU5fSU5GT19RVUVSWV9UT09MMixcbiAgR0VUX1BFTkRJTkdfQUlSRFJPUF9UT09MXG59O1xuXG4vLyBzcmMvcGx1Z2lucy9jb3JlLWNvbnNlbnN1cy1xdWVyeS1wbHVnaW4vdG9vbHMvcXVlcmllcy9nZXQtdG9waWMtbWVzc2FnZXMtcXVlcnkudHNcbnZhciBnZXRUb3BpY01lc3NhZ2VzUXVlcnlQcm9tcHQyID0gKGNvbnRleHQgPSB7fSkgPT4ge1xuICBjb25zdCBjb250ZXh0U25pcHBldCA9IFByb21wdEdlbmVyYXRvci5nZXRDb250ZXh0U25pcHBldChjb250ZXh0KTtcbiAgY29uc3QgdXNhZ2VJbnN0cnVjdGlvbnMgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0UGFyYW1ldGVyVXNhZ2VJbnN0cnVjdGlvbnMoKTtcbiAgcmV0dXJuIGBcbiR7Y29udGV4dFNuaXBwZXR9XG5cblRoaXMgdG9vbCB3aWxsIHJldHVybiB0aGUgbWVzc2FnZXMgZm9yIGEgZ2l2ZW4gSGVkZXJhIHRvcGljLlxuXG5QYXJhbWV0ZXJzOlxuLSB0b3BpY0lkIChzdHIsIHJlcXVpcmVkKTogVGhlIHRvcGljIElEIHRvIHF1ZXJ5XG4tIHN0YXJ0VGltZSAoZGF0ZXRpbWUsIG9wdGlvbmFsKTogVGhlIHN0YXJ0IGRhdGV0aW1lIHRvIHF1ZXJ5LiBJZiBzZXQsIHRoZSBtZXNzYWdlcyB3aWxsIGJlIHJldHVybmVkIGFmdGVyIHRoaXMgZGF0ZXRpbWVcbi0gZW5kVGltZSAoZGF0ZXRpbWUsIG9wdGlvbmFsKTogVGhlIGVuZCBkYXRldGltZSB0byBxdWVyeS4gSWYgc2V0LCB0aGUgbWVzc2FnZXMgd2lsbCBiZSByZXR1cm5lZCBiZWZvcmUgdGhpcyBkYXRldGltZVxuLSBsaW1pdCAoaW50LCBvcHRpb25hbCk6IFRoZSBsaW1pdCBvZiBtZXNzYWdlcyB0byBxdWVyeS4gSWYgc2V0LCB0aGUgbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIHJldHVyblxuJHt1c2FnZUluc3RydWN0aW9uc31cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzMzEgPSAobWVzc2FnZXMsIHRvcGljSWQpID0+IHtcbiAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBgTm8gbWVzc2FnZXMgZm91bmQgZm9yIHRvcGljICR7dG9waWNJZH0uYDtcbiAgfVxuICBjb25zdCBtZXNzYWdlc1RleHQgPSBtZXNzYWdlcy5tYXAoXG4gICAgKG1lc3NhZ2UpID0+IGAke0J1ZmZlci5mcm9tKG1lc3NhZ2UubWVzc2FnZSwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJ1dGYtOFwiKX0gLSBwb3N0ZWQgYXQ6ICR7bWVzc2FnZS5jb25zZW5zdXNfdGltZXN0YW1wfVxuYFxuICApO1xuICByZXR1cm4gYE1lc3NhZ2VzIGZvciB0b3BpYyAke3RvcGljSWR9OlxuICAtLS0gTWVzc2FnZXMgLS0tXG4gICR7bWVzc2FnZXNUZXh0fVxuICBgO1xufTtcbnZhciBnZXRUb3BpY01lc3NhZ2VzUXVlcnlQYXJhbXMyID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4ge1xuICAgIHRvcGljSWQ6IHBhcmFtcy50b3BpY0lkLFxuICAgIGxvd2VyVGltZXN0YW1wOiBwYXJhbXMuc3RhcnRUaW1lID8gYCR7TWF0aC5mbG9vcihuZXcgRGF0ZShwYXJhbXMuc3RhcnRUaW1lKS5nZXRUaW1lKCkgLyAxZTMpfS4wMDAwMDAwMDBgIDogXCJcIixcbiAgICB1cHBlclRpbWVzdGFtcDogcGFyYW1zLmVuZFRpbWUgPyBgJHtNYXRoLmZsb29yKG5ldyBEYXRlKHBhcmFtcy5lbmRUaW1lKS5nZXRUaW1lKCkgLyAxZTMpfS4wMDAwMDAwMDBgIDogXCJcIixcbiAgICBsaW1pdDogcGFyYW1zLmxpbWl0IHx8IDEwMFxuICB9O1xufTtcbnZhciBjb252ZXJ0TWVzc2FnZXNGcm9tQmFzZTY0VG9TdHJpbmcyID0gKG1lc3NhZ2VzKSA9PiB7XG4gIHJldHVybiBtZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIG1lc3NhZ2U6IEJ1ZmZlci5mcm9tKG1lc3NhZ2UubWVzc2FnZSwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJ1dGYtOFwiKVxuICAgIH07XG4gIH0pO1xufTtcbnZhciBnZXRUb3BpY01lc3NhZ2VzUXVlcnkyID0gYXN5bmMgKGNsaWVudCwgY29udGV4dCwgcGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWlycm9ybm9kZVNlcnZpY2UgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgbWlycm9ybm9kZVNlcnZpY2UuZ2V0VG9waWNNZXNzYWdlcyhnZXRUb3BpY01lc3NhZ2VzUXVlcnlQYXJhbXMyKHBhcmFtcykpO1xuICAgIHJldHVybiB7XG4gICAgICByYXc6IHtcbiAgICAgICAgdG9waWNJZDogbWVzc2FnZXMudG9waWNJZCxcbiAgICAgICAgbWVzc2FnZXM6IGNvbnZlcnRNZXNzYWdlc0Zyb21CYXNlNjRUb1N0cmluZzIobWVzc2FnZXMubWVzc2FnZXMpXG4gICAgICB9LFxuICAgICAgaHVtYW5NZXNzYWdlOiBwb3N0UHJvY2VzczMxKG1lc3NhZ2VzLm1lc3NhZ2VzLCBwYXJhbXMudG9waWNJZClcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBnZXQgdG9waWMgbWVzc2FnZXNcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW2dldF90b3BpY19tZXNzYWdlc19xdWVyeV90b29sXVwiLCBtZXNzYWdlKTtcbiAgICByZXR1cm4geyByYXc6IHsgZXJyb3I6IG1lc3NhZ2UgfSwgaHVtYW5NZXNzYWdlOiBtZXNzYWdlIH07XG4gIH1cbn07XG52YXIgR0VUX1RPUElDX01FU1NBR0VTX1FVRVJZX1RPT0wyID0gXCJnZXRfdG9waWNfbWVzc2FnZXNfcXVlcnlfdG9vbFwiO1xudmFyIHRvb2wzNiA9IChjb250ZXh0KSA9PiAoe1xuICBtZXRob2Q6IEdFVF9UT1BJQ19NRVNTQUdFU19RVUVSWV9UT09MMixcbiAgbmFtZTogXCJHZXQgVG9waWMgTWVzc2FnZXNcIixcbiAgZGVzY3JpcHRpb246IGdldFRvcGljTWVzc2FnZXNRdWVyeVByb21wdDIoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IHRvcGljTWVzc2FnZXNRdWVyeVBhcmFtZXRlcnMoY29udGV4dCksXG4gIGV4ZWN1dGU6IGdldFRvcGljTWVzc2FnZXNRdWVyeTJcbn0pO1xudmFyIGdldF90b3BpY19tZXNzYWdlc19xdWVyeV9kZWZhdWx0MiA9IHRvb2wzNjtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS1jb25zZW5zdXMtcXVlcnktcGx1Z2luL3Rvb2xzL3F1ZXJpZXMvZ2V0LXRvcGljLWluZm8tcXVlcnkudHNcbnZhciBnZXRUb3BpY0luZm9RdWVyeVByb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCByZXR1cm4gdGhlIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIEhlZGVyYSB0b3BpYyAoSENTKS5cblxuUGFyYW1ldGVyczpcbi0gdG9waWNJZCAoc3RyKTogVGhlIHRvcGljIElEIHRvIHF1ZXJ5IGZvci5cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczMyID0gKHRvcGljKSA9PiB7XG4gIGNvbnN0IGZvcm1hdEtleSA9IChrZXkpID0+IHtcbiAgICBpZiAoIWtleSkgcmV0dXJuIFwiTm90IFNldFwiO1xuICAgIHJldHVybiBrZXkuX3R5cGUgPyBrZXkua2V5IHx8IFwiUHJlc2VudFwiIDogXCJQcmVzZW50XCI7XG4gIH07XG4gIGNvbnN0IGZvcm1hdFRpbWVzdGFtcCA9ICh0cykgPT4ge1xuICAgIGlmICghdHMpIHJldHVybiBcIk4vQVwiO1xuICAgIGNvbnN0IFtzZWNvbmRzXSA9IHRzLnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoTnVtYmVyKHNlY29uZHMpICogMWUzKTtcbiAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xuICB9O1xuICByZXR1cm4gYEhlcmUgYXJlIHRoZSBkZXRhaWxzIGZvciB0b3BpYyAqKiR7dG9waWMudG9waWNfaWQgfHwgXCJOL0FcIn0qKjpcblxuLSAqKk1lbW8qKjogJHt0b3BpYy5tZW1vIHx8IFwiTi9BXCJ9XG4tICoqRGVsZXRlZCoqOiAke3RvcGljLmRlbGV0ZWQgPyBcIlllc1wiIDogXCJOb1wifVxuLSAqKlNlcXVlbmNlIE51bWJlcioqOiAke3RvcGljLnNlcXVlbmNlX251bWJlciA/PyBcIk4vQVwifVxuXG4qKlRpbWVzdGFtcHMqKjpcbi0gQ3JlYXRlZDogJHtmb3JtYXRUaW1lc3RhbXAodG9waWMuY3JlYXRlZF90aW1lc3RhbXApfVxuXG4qKkVudGl0eSBJRHMqKjpcbi0gQXV0byBSZW5ldyBBY2NvdW50OiAke3RvcGljLmF1dG9fcmVuZXdfYWNjb3VudCB8fCBcIk4vQVwifVxuLSBBdXRvIFJlbmV3IFBlcmlvZDogJHt0b3BpYy5hdXRvX3JlbmV3X3BlcmlvZCA/PyBcIk4vQVwifVxuXG4qKktleXMqKjpcbi0gQWRtaW4gS2V5OiAke2Zvcm1hdEtleSh0b3BpYy5hZG1pbl9rZXkpfVxuLSBTdWJtaXQgS2V5OiAke2Zvcm1hdEtleSh0b3BpYy5zdWJtaXRfa2V5KX1cbmA7XG59O1xudmFyIGdldFRvcGljSW5mb1F1ZXJ5ID0gYXN5bmMgKGNsaWVudCwgY29udGV4dCwgcGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWlycm9ybm9kZVNlcnZpY2UgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IHRvcGljSW5mbyA9IHtcbiAgICAgIC4uLmF3YWl0IG1pcnJvcm5vZGVTZXJ2aWNlLmdldFRvcGljSW5mbyhwYXJhbXMudG9waWNJZCksXG4gICAgICB0b3BpY19pZDogcGFyYW1zLnRvcGljSWRcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICByYXc6IHsgdG9waWNJZDogcGFyYW1zLnRvcGljSWQsIHRvcGljSW5mbyB9LFxuICAgICAgaHVtYW5NZXNzYWdlOiBwb3N0UHJvY2VzczMyKHRvcGljSW5mbylcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBnZXQgdG9waWMgaW5mb1wiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXNjICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgOiAke2Vycm9yLm1lc3NhZ2V9YCA6IFwiXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZ2V0X3RvcGljX2luZm9fcXVlcnlfdG9vbF1cIiwgbWVzc2FnZSk7XG4gICAgcmV0dXJuIHsgcmF3OiB7IGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIEdFVF9UT1BJQ19JTkZPX1FVRVJZX1RPT0wgPSBcImdldF90b3BpY19pbmZvX3F1ZXJ5X3Rvb2xcIjtcbnZhciB0b29sMzcgPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBHRVRfVE9QSUNfSU5GT19RVUVSWV9UT09MLFxuICBuYW1lOiBcIkdldCBUb3BpYyBJbmZvXCIsXG4gIGRlc2NyaXB0aW9uOiBnZXRUb3BpY0luZm9RdWVyeVByb21wdChjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogZ2V0VG9waWNJbmZvUGFyYW1ldGVycyhjb250ZXh0KSxcbiAgZXhlY3V0ZTogZ2V0VG9waWNJbmZvUXVlcnlcbn0pO1xudmFyIGdldF90b3BpY19pbmZvX3F1ZXJ5X2RlZmF1bHQgPSB0b29sMzc7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtY29uc2Vuc3VzLXF1ZXJ5LXBsdWdpbi9pbmRleC50c1xudmFyIGNvcmVDb25zZW5zdXNRdWVyeVBsdWdpbiA9IHtcbiAgbmFtZTogXCJjb3JlLWNvbnNlbnN1cy1xdWVyeS1wbHVnaW5cIixcbiAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICBkZXNjcmlwdGlvbjogXCJBIHBsdWdpbiBmb3IgSGVkZXJhIENvbnNlbnN1cyBTZXJ2aWNlIHF1ZXJpZXNcIixcbiAgdG9vbHM6IChjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIFtnZXRfdG9waWNfbWVzc2FnZXNfcXVlcnlfZGVmYXVsdDIoY29udGV4dCksIGdldF90b3BpY19pbmZvX3F1ZXJ5X2RlZmF1bHQoY29udGV4dCldO1xuICB9XG59O1xudmFyIGNvcmVDb25zZW5zdXNRdWVyeVBsdWdpblRvb2xOYW1lcyA9IHtcbiAgR0VUX1RPUElDX01FU1NBR0VTX1FVRVJZX1RPT0w6IEdFVF9UT1BJQ19NRVNTQUdFU19RVUVSWV9UT09MMixcbiAgR0VUX1RPUElDX0lORk9fUVVFUllfVE9PTFxufTtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS1ldm0tcXVlcnktcGx1Z2luL3Rvb2xzL3F1ZXJpZXMvZ2V0LWNvbnRyYWN0LWluZm8tcXVlcnkudHNcbnZhciBnZXRDb250cmFjdEluZm9RdWVyeVByb21wdCA9IChjb250ZXh0ID0ge30pID0+IHtcbiAgY29uc3QgY29udGV4dFNuaXBwZXQgPSBQcm9tcHRHZW5lcmF0b3IuZ2V0Q29udGV4dFNuaXBwZXQoY29udGV4dCk7XG4gIGNvbnN0IHVzYWdlSW5zdHJ1Y3Rpb25zID0gUHJvbXB0R2VuZXJhdG9yLmdldFBhcmFtZXRlclVzYWdlSW5zdHJ1Y3Rpb25zKCk7XG4gIHJldHVybiBgXG4ke2NvbnRleHRTbmlwcGV0fVxuXG5UaGlzIHRvb2wgd2lsbCByZXR1cm4gdGhlIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIEhlZGVyYSBjb250cmFjdC5cblxuUGFyYW1ldGVyczpcbi0gY29udHJhY3RJZCAoc3RyKTogVGhlIGNvbnRyYWN0IElEIHRvIHF1ZXJ5IGZvci5cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5gO1xufTtcbnZhciBwb3N0UHJvY2VzczMzID0gKGNvbnRyYWN0KSA9PiB7XG4gIGNvbnN0IGZvcm1hdEtleSA9IChrZXkpID0+IHtcbiAgICBpZiAoIWtleSkgcmV0dXJuIFwiTm90IFNldFwiO1xuICAgIHJldHVybiBrZXkuX3R5cGUgPyBrZXkua2V5IHx8IFwiUHJlc2VudFwiIDogXCJQcmVzZW50XCI7XG4gIH07XG4gIGNvbnN0IGZvcm1hdFRpbWVzdGFtcCA9ICh0cykgPT4ge1xuICAgIGlmICghdHMpIHJldHVybiBcIk4vQVwiO1xuICAgIGNvbnN0IFtzZWNvbmRzLCBuYW5vc10gPSB0cy5zcGxpdChcIi5cIik7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKE51bWJlcihzZWNvbmRzKSAqIDFlMyk7XG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKSArIChuYW5vcyA/IGAuJHtuYW5vc31gIDogXCJcIik7XG4gIH07XG4gIHJldHVybiBgSGVyZSBhcmUgdGhlIGRldGFpbHMgZm9yIGNvbnRyYWN0ICoqJHtjb250cmFjdC5jb250cmFjdF9pZCB8fCBcIk4vQVwifSoqOlxuXG4tICoqTWVtbyoqOiAke2NvbnRyYWN0Lm1lbW8gfHwgXCJOL0FcIn1cbi0gKipEZWxldGVkKio6ICR7Y29udHJhY3QuZGVsZXRlZCA/IFwiWWVzXCIgOiBcIk5vXCJ9XG4tICoqUGVybWFuZW50IFJlbW92YWwqKjogJHtjb250cmFjdC5wZXJtYW5lbnRfcmVtb3ZhbCA/IFwiWWVzXCIgOiBcIk5vXCJ9XG4tICoqTm9uY2UqKjogJHtjb250cmFjdC5ub25jZSA/PyBcIk4vQVwifVxuXG4qKlRpbWVzdGFtcHMqKjpcbi0gQ3JlYXRlZDogJHtmb3JtYXRUaW1lc3RhbXAoY29udHJhY3QuY3JlYXRlZF90aW1lc3RhbXApfVxuLSBFeHBpcmF0aW9uOiAke2Zvcm1hdFRpbWVzdGFtcChjb250cmFjdC5leHBpcmF0aW9uX3RpbWVzdGFtcCl9XG4tIFZhbGlkIEZyb206ICR7Y29udHJhY3QudGltZXN0YW1wPy5mcm9tIHx8IFwiTi9BXCJ9XG4tIFZhbGlkIFRvOiAke2NvbnRyYWN0LnRpbWVzdGFtcD8udG8gfHwgXCJOL0FcIn1cblxuKipFbnRpdHkgSURzKio6XG4tIEF1dG8gUmVuZXcgQWNjb3VudDogJHtjb250cmFjdC5hdXRvX3JlbmV3X2FjY291bnQgfHwgXCJOL0FcIn1cbi0gRmlsZSBJRDogJHtjb250cmFjdC5maWxlX2lkIHx8IFwiTi9BXCJ9XG4tIE9idGFpbmVyIElEOiAke2NvbnRyYWN0Lm9idGFpbmVyX2lkIHx8IFwiTi9BXCJ9XG4tIFByb3h5IEFjY291bnQgSUQ6ICR7Y29udHJhY3QucHJveHlfYWNjb3VudF9pZCB8fCBcIk4vQVwifVxuXG4qKktleXMqKjpcbi0gQWRtaW4gS2V5OiAke2Zvcm1hdEtleShjb250cmFjdC5hZG1pbl9rZXkpfVxuXG4qKkVWTSoqOlxuLSBBZGRyZXNzOiAke2NvbnRyYWN0LmV2bV9hZGRyZXNzIHx8IFwiTi9BXCJ9XG5gO1xufTtcbnZhciBnZXRDb250cmFjdEluZm9RdWVyeSA9IGFzeW5jIChjbGllbnQsIGNvbnRleHQsIHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG1pcnJvcm5vZGVTZXJ2aWNlID0gZ2V0TWlycm9ybm9kZVNlcnZpY2UoY29udGV4dC5taXJyb3Jub2RlU2VydmljZSwgY2xpZW50LmxlZGdlcklkKTtcbiAgICBjb25zdCBjb250cmFjdEluZm8gPSBhd2FpdCBtaXJyb3Jub2RlU2VydmljZS5nZXRDb250cmFjdEluZm8ocGFyYW1zLmNvbnRyYWN0SWQpO1xuICAgIHJldHVybiB7XG4gICAgICByYXc6IHsgY29udHJhY3RJZDogcGFyYW1zLmNvbnRyYWN0SWQsIGNvbnRyYWN0SW5mbyB9LFxuICAgICAgaHVtYW5NZXNzYWdlOiBwb3N0UHJvY2VzczMzKGNvbnRyYWN0SW5mbylcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGRlc2MgPSBcIkZhaWxlZCB0byBnZXQgY29udHJhY3QgaW5mb1wiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBkZXNjICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgOiAke2Vycm9yLm1lc3NhZ2V9YCA6IFwiXCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbZ2V0X2NvbnRyYWN0X2luZm9fcXVlcnlfdG9vbF1cIiwgbWVzc2FnZSk7XG4gICAgcmV0dXJuIHsgcmF3OiB7IGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIEdFVF9DT05UUkFDVF9JTkZPX1FVRVJZX1RPT0wgPSBcImdldF9jb250cmFjdF9pbmZvX3F1ZXJ5X3Rvb2xcIjtcbnZhciB0b29sMzggPSAoY29udGV4dCkgPT4gKHtcbiAgbWV0aG9kOiBHRVRfQ09OVFJBQ1RfSU5GT19RVUVSWV9UT09MLFxuICBuYW1lOiBcIkdldCBDb250cmFjdCBJbmZvXCIsXG4gIGRlc2NyaXB0aW9uOiBnZXRDb250cmFjdEluZm9RdWVyeVByb21wdChjb250ZXh0KSxcbiAgcGFyYW1ldGVyczogY29udHJhY3RJbmZvUXVlcnlQYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBnZXRDb250cmFjdEluZm9RdWVyeVxufSk7XG52YXIgZ2V0X2NvbnRyYWN0X2luZm9fcXVlcnlfZGVmYXVsdCA9IHRvb2wzODtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS1ldm0tcXVlcnktcGx1Z2luL2luZGV4LnRzXG52YXIgY29yZUVWTVF1ZXJ5UGx1Z2luID0ge1xuICBuYW1lOiBcImNvcmUtZXZtLXF1ZXJ5LXBsdWdpblwiLFxuICB2ZXJzaW9uOiBcIjEuMC4wXCIsXG4gIGRlc2NyaXB0aW9uOiBcIkEgcGx1Z2luIGZvciBIZWRlcmEgRVZNIFNlcnZpY2UgcXVlcmllc1wiLFxuICB0b29sczogKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gW2dldF9jb250cmFjdF9pbmZvX3F1ZXJ5X2RlZmF1bHQoY29udGV4dCldO1xuICB9XG59O1xudmFyIGNvcmVFVk1RdWVyeVBsdWdpblRvb2xOYW1lcyA9IHtcbiAgR0VUX0NPTlRSQUNUX0lORk9fUVVFUllfVE9PTFxufTtcblxuLy8gc3JjL3BsdWdpbnMvY29yZS10cmFuc2FjdGlvbnMtcXVlcnktcGx1Z2luL3Rvb2xzL3F1ZXJpZXMvZ2V0LXRyYW5zYWN0aW9uLXJlY29yZC1xdWVyeS50c1xudmFyIGdldFRyYW5zYWN0aW9uUmVjb3JkUXVlcnlQcm9tcHQgPSAoY29udGV4dCA9IHt9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRTbmlwcGV0ID0gUHJvbXB0R2VuZXJhdG9yLmdldENvbnRleHRTbmlwcGV0KGNvbnRleHQpO1xuICBjb25zdCB1c2FnZUluc3RydWN0aW9ucyA9IFByb21wdEdlbmVyYXRvci5nZXRQYXJhbWV0ZXJVc2FnZUluc3RydWN0aW9ucygpO1xuICByZXR1cm4gYFxuJHtjb250ZXh0U25pcHBldH1cblxuVGhpcyB0b29sIHdpbGwgcmV0dXJuIHRoZSB0cmFuc2FjdGlvbiByZWNvcmQgZm9yIGEgZ2l2ZW4gSGVkZXJhIHRyYW5zYWN0aW9uIElELlxuXG5QYXJhbWV0ZXJzOlxuLSB0cmFuc2FjdGlvbklkIChzdHIsIHJlcXVpcmVkKTogVGhlIHRyYW5zYWN0aW9uIElEIHRvIGZldGNoIHJlY29yZCBmb3IuIFNob3VsZCBiZSBpbiBmb3JtYXQgXFxcXFwic2hhcmQucmVhbG0ubnVtLXNzcy1ubm5cXFxcXCIgZm9ybWF0IHdoZXJlIHNzcyBhcmUgc2Vjb25kcyBhbmQgbm5uIGFyZSBuYW5vc2Vjb25kc1xuLSBub25jZSAobnVtYmVyLCBvcHRpb25hbCk6IE9wdGlvbmFsIG5vbmNlIHZhbHVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiR7dXNhZ2VJbnN0cnVjdGlvbnN9XG5cbkFkZGl0aW9uYWwgaW5mb3JtYXRpb246XG5JZiB1c2VyIHByb3ZpZGVzIHRyYW5zYWN0aW9uIElEIGluIGZvcm1hdCAwLjAuNDE3NzgwNkAxNzU1MTY5OTgwLjA1MTcyMTI2NCwgcGFyc2UgaXQgdG8gMC4wLjQxNzc4MDYtMTc1NTE2OTk4MC0wNTE3MjEyNjQgYW5kIHVzZSBpdCBhcyB0cmFuc2FjdGlvbiBJRC4gRG8gbm90IHJlbW92ZSB0aGUgc3RhcmluZyB6ZXJvcy5cbmA7XG59O1xudmFyIHBvc3RQcm9jZXNzMzQgPSAodHJhbnNhY3Rpb25SZWNvcmQsIHRyYW5zYWN0aW9uSWQpID0+IHtcbiAgaWYgKCF0cmFuc2FjdGlvblJlY29yZC50cmFuc2FjdGlvbnMgfHwgdHJhbnNhY3Rpb25SZWNvcmQudHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBgTm8gdHJhbnNhY3Rpb24gZGV0YWlscyBmb3VuZCBmb3IgdHJhbnNhY3Rpb24gSUQ6ICR7dHJhbnNhY3Rpb25JZH1gO1xuICB9XG4gIGNvbnN0IHJlc3VsdHMgPSB0cmFuc2FjdGlvblJlY29yZC50cmFuc2FjdGlvbnMubWFwKCh0eCwgaW5kZXgpID0+IHtcbiAgICBsZXQgdHJhbnNmZXJzSW5mbyA9IFwiXCI7XG4gICAgaWYgKHR4LnRyYW5zZmVycyAmJiB0eC50cmFuc2ZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdHJhbnNmZXJzSW5mbyA9IFwiXFxuVHJhbnNmZXJzOlxcblwiICsgdHgudHJhbnNmZXJzLm1hcChcbiAgICAgICAgKHRyYW5zZmVyKSA9PiBgICBBY2NvdW50OiAke3RyYW5zZmVyLmFjY291bnR9LCBBbW91bnQ6ICR7dG9EaXNwbGF5VW5pdCh0cmFuc2Zlci5hbW91bnQsIDgpfVxcdTIxMEZgXG4gICAgICApLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uSGVhZGVyID0gdHJhbnNhY3Rpb25SZWNvcmQudHJhbnNhY3Rpb25zLmxlbmd0aCA+IDEgPyBgVHJhbnNhY3Rpb24gJHtpbmRleCArIDF9IERldGFpbHMgZm9yICR7dHJhbnNhY3Rpb25JZH1gIDogYFRyYW5zYWN0aW9uIERldGFpbHMgZm9yICR7dHJhbnNhY3Rpb25JZH1gO1xuICAgIHJldHVybiBgJHt0cmFuc2FjdGlvbkhlYWRlcn1cblN0YXR1czogJHt0eC5yZXN1bHR9XG5Db25zZW5zdXMgVGltZXN0YW1wOiAke3R4LmNvbnNlbnN1c190aW1lc3RhbXB9XG5UcmFuc2FjdGlvbiBIYXNoOiAke3R4LnRyYW5zYWN0aW9uX2hhc2h9XG5UcmFuc2FjdGlvbiBGZWU6ICR7dHguY2hhcmdlZF90eF9mZWV9XG5UeXBlOiAke3R4Lm5hbWV9XG5FbnRpdHkgSUQ6ICR7dHguZW50aXR5X2lkfSR7dHJhbnNmZXJzSW5mb31gO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdHMuam9pbihcIlxcblxcblwiICsgXCI9XCIucmVwZWF0KDUwKSArIFwiXFxuXFxuXCIpO1xufTtcbnZhciBnZXRUcmFuc2FjdGlvblJlY29yZFF1ZXJ5ID0gYXN5bmMgKGNsaWVudCwgY29udGV4dCwgcGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWlycm9ybm9kZVNlcnZpY2UgPSBnZXRNaXJyb3Jub2RlU2VydmljZShjb250ZXh0Lm1pcnJvcm5vZGVTZXJ2aWNlLCBjbGllbnQubGVkZ2VySWQpO1xuICAgIGNvbnN0IG5vcm1hbGlzZWRQYXJhbXMgPSBIZWRlcmFQYXJhbWV0ZXJOb3JtYWxpc2VyLm5vcm1hbGlzZUdldFRyYW5zYWN0aW9uUmVjb3JkUGFyYW1zKFxuICAgICAgcGFyYW1zLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25SZWNvcmQgPSBhd2FpdCBtaXJyb3Jub2RlU2VydmljZS5nZXRUcmFuc2FjdGlvblJlY29yZChcbiAgICAgIG5vcm1hbGlzZWRQYXJhbXMudHJhbnNhY3Rpb25JZCxcbiAgICAgIG5vcm1hbGlzZWRQYXJhbXMubm9uY2VcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICByYXc6IHsgdHJhbnNhY3Rpb25JZDogcGFyYW1zLnRyYW5zYWN0aW9uSWQsIHRyYW5zYWN0aW9uUmVjb3JkIH0sXG4gICAgICBodW1hbk1lc3NhZ2U6IHBvc3RQcm9jZXNzMzQodHJhbnNhY3Rpb25SZWNvcmQsIHBhcmFtcy50cmFuc2FjdGlvbklkKVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZGVzYyA9IFwiRmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbiByZWNvcmRcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gZGVzYyArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYDogJHtlcnJvci5tZXNzYWdlfWAgOiBcIlwiKTtcbiAgICBjb25zb2xlLmVycm9yKFwiW2dldF90cmFuc2FjdGlvbl9yZWNvcmRfcXVlcnlfdG9vbF1cIiwgbWVzc2FnZSk7XG4gICAgcmV0dXJuIHsgcmF3OiB7IGVycm9yOiBtZXNzYWdlIH0sIGh1bWFuTWVzc2FnZTogbWVzc2FnZSB9O1xuICB9XG59O1xudmFyIEdFVF9UUkFOU0FDVElPTl9SRUNPUkRfUVVFUllfVE9PTCA9IFwiZ2V0X3RyYW5zYWN0aW9uX3JlY29yZF9xdWVyeV90b29sXCI7XG52YXIgdG9vbDM5ID0gKGNvbnRleHQpID0+ICh7XG4gIG1ldGhvZDogR0VUX1RSQU5TQUNUSU9OX1JFQ09SRF9RVUVSWV9UT09MLFxuICBuYW1lOiBcIkdldCBUcmFuc2FjdGlvbiBSZWNvcmQgUXVlcnlcIixcbiAgZGVzY3JpcHRpb246IGdldFRyYW5zYWN0aW9uUmVjb3JkUXVlcnlQcm9tcHQoY29udGV4dCksXG4gIHBhcmFtZXRlcnM6IHRyYW5zYWN0aW9uUmVjb3JkUXVlcnlQYXJhbWV0ZXJzKGNvbnRleHQpLFxuICBleGVjdXRlOiBnZXRUcmFuc2FjdGlvblJlY29yZFF1ZXJ5XG59KTtcbnZhciBnZXRfdHJhbnNhY3Rpb25fcmVjb3JkX3F1ZXJ5X2RlZmF1bHQgPSB0b29sMzk7XG5cbi8vIHNyYy9wbHVnaW5zL2NvcmUtdHJhbnNhY3Rpb25zLXF1ZXJ5LXBsdWdpbi9pbmRleC50c1xudmFyIGNvcmVUcmFuc2FjdGlvblF1ZXJ5UGx1Z2luID0ge1xuICBuYW1lOiBcImNvcmUtdHJhbnNhY3Rpb24tcXVlcnktcGx1Z2luXCIsXG4gIHZlcnNpb246IFwiMS4wLjBcIixcbiAgZGVzY3JpcHRpb246IFwiQSBwbHVnaW4gZm9yIEhlZGVyYSBUcmFuc2FjdGlvbnMgcXVlcmllc1wiLFxuICB0b29sczogKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gW2dldF90cmFuc2FjdGlvbl9yZWNvcmRfcXVlcnlfZGVmYXVsdChjb250ZXh0KV07XG4gIH1cbn07XG52YXIgY29yZVRyYW5zYWN0aW9uUXVlcnlQbHVnaW5Ub29sTmFtZXMgPSB7XG4gIEdFVF9UUkFOU0FDVElPTl9SRUNPUkRfUVVFUllfVE9PTFxufTtcblxuLy8gc3JjL3BsdWdpbnMvaW5kZXgudHNcbnZhciBjb3JlSFRTUGx1Z2luID0gY29yZVRva2VuUGx1Z2luO1xudmFyIGNvcmVIVFNQbHVnaW5Ub29sTmFtZXMgPSBjb3JlVG9rZW5QbHVnaW5Ub29sTmFtZXM7XG52YXIgY29yZVNDU1BsdWdpbiA9IGNvcmVFVk1QbHVnaW47XG52YXIgY29yZVNDU1BsdWdpblRvb2xOYW1lcyA9IGNvcmVFVk1QbHVnaW5Ub29sTmFtZXM7XG5cbi8vIHNyYy9zaGFyZWQvcGx1Z2luLnRzXG52YXIgQ09SRV9QTFVHSU5TID0gW1xuICBjb3JlQWNjb3VudFBsdWdpbixcbiAgY29yZVRva2VuUGx1Z2luLFxuICBjb3JlQ29uc2Vuc3VzUGx1Z2luLFxuICBjb3JlRVZNUGx1Z2luLFxuICBjb3JlQWNjb3VudFF1ZXJ5UGx1Z2luLFxuICBjb3JlVG9rZW5RdWVyeVBsdWdpbixcbiAgY29yZUNvbnNlbnN1c1F1ZXJ5UGx1Z2luXG5dO1xudmFyIFBsdWdpblJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBwbHVnaW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmVnaXN0ZXIocGx1Z2luKSB7XG4gICAgaWYgKHRoaXMucGx1Z2lucy5oYXMocGx1Z2luLm5hbWUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFBsdWdpbiBcIiR7cGx1Z2luLm5hbWV9XCIgaXMgYWxyZWFkeSByZWdpc3RlcmVkLiBPdmVyd3JpdGluZy5gKTtcbiAgICB9XG4gICAgdGhpcy5wbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luKTtcbiAgfVxuICBnZXRQbHVnaW5zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGx1Z2lucy52YWx1ZXMoKSk7XG4gIH1cbiAgbG9hZENvcmVQbHVnaW5zKGNvbnRleHQpIHtcbiAgICBjb25zdCBwbHVnaW5Ub29scyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIENPUkVfUExVR0lOUykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdG9vbHMgPSBwbHVnaW4udG9vbHMoY29udGV4dCk7XG4gICAgICAgIHBsdWdpblRvb2xzLnB1c2goLi4udG9vbHMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgbG9hZGluZyB0b29scyBmcm9tIHBsdWdpbiBcIiR7cGx1Z2luLm5hbWV9XCI6YCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGx1Z2luVG9vbHM7XG4gIH1cbiAgbG9hZFBsdWdpbnMoY29udGV4dCkge1xuICAgIGNvbnN0IHBsdWdpblRvb2xzID0gW107XG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zLnZhbHVlcygpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0b29scyA9IHBsdWdpbi50b29scyhjb250ZXh0KTtcbiAgICAgICAgcGx1Z2luVG9vbHMucHVzaCguLi50b29scyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nIHRvb2xzIGZyb20gcGx1Z2luIFwiJHtwbHVnaW4ubmFtZX1cIjpgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW5Ub29scztcbiAgfVxuICBnZXRUb29scyhjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMucGx1Z2lucy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkQ29yZVBsdWdpbnMoY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRQbHVnaW5zKGNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnBsdWdpbnMuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gc3JjL2xhbmdjaGFpbi90b29sLnRzXG5pbXBvcnQgeyBTdHJ1Y3R1cmVkVG9vbCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvdG9vbHNcIjtcbnZhciBIZWRlcmFBZ2VudEtpdFRvb2wgPSBjbGFzcyBleHRlbmRzIFN0cnVjdHVyZWRUb29sIHtcbiAgaGVkZXJhQVBJO1xuICBtZXRob2Q7XG4gIG5hbWU7XG4gIGRlc2NyaXB0aW9uO1xuICBzY2hlbWE7XG4gIGNvbnN0cnVjdG9yKEhlZGVyYUFnZW50S2l0QVBJLCBtZXRob2QsIGRlc2NyaXB0aW9uLCBzY2hlbWEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaGVkZXJhQVBJID0gSGVkZXJhQWdlbnRLaXRBUEk7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy5uYW1lID0gbWV0aG9kO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgfVxuICBfY2FsbChhcmcsIF9ydW5NYW5hZ2VyLCBfcGFyZW50Q29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVkZXJhQVBJLnJ1bih0aGlzLm1ldGhvZCwgYXJnKTtcbiAgfVxufTtcbnZhciB0b29sX2RlZmF1bHQgPSBIZWRlcmFBZ2VudEtpdFRvb2w7XG5cbi8vIHNyYy9zaGFyZWQvdG9vbC1kaXNjb3ZlcnkudHNcbnZhciBUb29sRGlzY292ZXJ5ID0gY2xhc3MgX1Rvb2xEaXNjb3Zlcnkge1xuICBwbHVnaW5SZWdpc3RyeSA9IG5ldyBQbHVnaW5SZWdpc3RyeSgpO1xuICBjb25zdHJ1Y3RvcihwbHVnaW5zID0gW10pIHtcbiAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4gdGhpcy5wbHVnaW5SZWdpc3RyeS5yZWdpc3RlcihwbHVnaW4pKTtcbiAgfVxuICBnZXRBbGxUb29scyhjb250ZXh0LCBjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgcGx1Z2luVG9vbHMgPSB0aGlzLnBsdWdpblJlZ2lzdHJ5LmdldFRvb2xzKGNvbnRleHQpO1xuICAgIGNvbnN0IGFsbFRvb2xzID0gW107XG4gICAgY29uc3QgYWxsVG9vbE5hbWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBwbHVnaW5Ub29scy5mb3JFYWNoKChwbHVnaW5Ub29sKSA9PiB7XG4gICAgICBpZiAoIWFsbFRvb2xOYW1lcy5oYXMocGx1Z2luVG9vbC5tZXRob2QpKSB7XG4gICAgICAgIGFsbFRvb2xzLnB1c2gocGx1Z2luVG9vbCk7XG4gICAgICAgIGFsbFRvb2xOYW1lcy5hZGQocGx1Z2luVG9vbC5tZXRob2QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBQbHVnaW4gdG9vbCBcIiR7cGx1Z2luVG9vbC5tZXRob2R9XCIgY29uZmxpY3RzIHdpdGggY29yZSB0b29sLiBVc2luZyBjb3JlIHRvb2wuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjb25maWd1cmF0aW9uPy50b29scyAmJiBjb25maWd1cmF0aW9uLnRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBhbGxUb29scy5maWx0ZXIoKHRvb2w0MSkgPT4gY29uZmlndXJhdGlvbi50b29scy5pbmNsdWRlcyh0b29sNDEubWV0aG9kKSk7XG4gICAgfVxuICAgIHJldHVybiBhbGxUb29scztcbiAgfVxuICBzdGF0aWMgY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgX1Rvb2xEaXNjb3ZlcnkoY29uZmlndXJhdGlvbi5wbHVnaW5zIHx8IFtdKTtcbiAgfVxufTtcblxuLy8gc3JjL2xhbmdjaGFpbi90b29sa2l0LnRzXG52YXIgSGVkZXJhTGFuZ2NoYWluVG9vbGtpdCA9IGNsYXNzIHtcbiAgX2hlZGVyYUFnZW50S2l0O1xuICB0b29scztcbiAgY29uc3RydWN0b3IoeyBjbGllbnQsIGNvbmZpZ3VyYXRpb24gfSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjb25maWd1cmF0aW9uLmNvbnRleHQgfHwge307XG4gICAgY29uc3QgdG9vbERpc2NvdmVyeSA9IFRvb2xEaXNjb3ZlcnkuY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgY29uc3QgYWxsVG9vbHMgPSB0b29sRGlzY292ZXJ5LmdldEFsbFRvb2xzKGNvbnRleHQsIGNvbmZpZ3VyYXRpb24pO1xuICAgIHRoaXMuX2hlZGVyYUFnZW50S2l0ID0gbmV3IGFwaV9kZWZhdWx0KGNsaWVudCwgY29uZmlndXJhdGlvbi5jb250ZXh0LCBhbGxUb29scyk7XG4gICAgdGhpcy50b29scyA9IGFsbFRvb2xzLm1hcChcbiAgICAgICh0b29sNDEpID0+IG5ldyB0b29sX2RlZmF1bHQoXG4gICAgICAgIHRoaXMuX2hlZGVyYUFnZW50S2l0LFxuICAgICAgICB0b29sNDEubWV0aG9kLFxuICAgICAgICB0b29sNDEuZGVzY3JpcHRpb24sXG4gICAgICAgIHRvb2w0MS5wYXJhbWV0ZXJzXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBnZXRUb29scygpIHtcbiAgICByZXR1cm4gdGhpcy50b29scztcbiAgfVxuICBnZXRIZWRlcmFBZ2VudEtpdEFQSSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVkZXJhQWdlbnRLaXQ7XG4gIH1cbn07XG52YXIgdG9vbGtpdF9kZWZhdWx0ID0gSGVkZXJhTGFuZ2NoYWluVG9vbGtpdDtcblxuLy8gc3JjL21vZGVsY29udGV4dHByb3RvY29sL3Rvb2xraXQudHNcbmltcG9ydCB7IE1jcFNlcnZlciB9IGZyb20gXCJAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NlcnZlci9tY3AuanNcIjtcbnZhciBIZWRlcmFNQ1BUb29sa2l0ID0gY2xhc3MgZXh0ZW5kcyBNY3BTZXJ2ZXIge1xuICBfaGVkZXJhQWdlbnRLaXQ7XG4gIGNvbnN0cnVjdG9yKHsgY2xpZW50LCBjb25maWd1cmF0aW9uIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkhlZGVyYSBBZ2VudCBLaXRcIixcbiAgICAgIHZlcnNpb246IFwiMC4xLjBcIixcbiAgICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgLi4uY29uZmlndXJhdGlvbixcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLmNvbmZpZ3VyYXRpb24uY29udGV4dCxcbiAgICAgICAgICBtb2RlOiBcIm1vZGVsY29udGV4dHByb3RvY29sXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjb25maWd1cmF0aW9uLmNvbnRleHQgfHwge307XG4gICAgY29uc3QgdG9vbERpc2NvdmVyeSA9IFRvb2xEaXNjb3ZlcnkuY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgY29uc3QgYWxsVG9vbHMgPSB0b29sRGlzY292ZXJ5LmdldEFsbFRvb2xzKGNvbnRleHQsIGNvbmZpZ3VyYXRpb24pO1xuICAgIHRoaXMuX2hlZGVyYUFnZW50S2l0ID0gbmV3IGFwaV9kZWZhdWx0KGNsaWVudCwgY29uZmlndXJhdGlvbi5jb250ZXh0LCBhbGxUb29scyk7XG4gICAgYWxsVG9vbHMubWFwKCh0b29sNDEpID0+IHtcbiAgICAgIHRoaXMudG9vbChcbiAgICAgICAgdG9vbDQxLm1ldGhvZCxcbiAgICAgICAgdG9vbDQxLmRlc2NyaXB0aW9uLFxuICAgICAgICB0b29sNDEucGFyYW1ldGVycy5zaGFwZSxcbiAgICAgICAgYXN5bmMgKGFyZywgX2V4dHJhKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5faGVkZXJhQWdlbnRLaXQucnVuKHRvb2w0MS5tZXRob2QsIGFyZyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFN0cmluZyhyZXN1bHQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHRvb2xraXRfZGVmYXVsdDIgPSBIZWRlcmFNQ1BUb29sa2l0O1xuXG4vLyBzcmMvYWktc2RrL3Rvb2wudHNcbmltcG9ydCB7IHRvb2wgYXMgdG9vbDQwIH0gZnJvbSBcImFpXCI7XG5mdW5jdGlvbiBIZWRlcmFBZ2VudEtpdFRvb2wyKGhlZGVyYUFQSSwgbWV0aG9kLCBkZXNjcmlwdGlvbiwgc2NoZW1hKSB7XG4gIHJldHVybiB0b29sNDAoe1xuICAgIGRlc2NyaXB0aW9uLFxuICAgIHBhcmFtZXRlcnM6IHNjaGVtYSxcbiAgICBleGVjdXRlOiAoYXJnKSA9PiB7XG4gICAgICByZXR1cm4gaGVkZXJhQVBJLnJ1bihtZXRob2QsIGFyZyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2FpLXNkay90b29sa2l0LnRzXG52YXIgSGVkZXJhQUlUb29sa2l0ID0gY2xhc3Mge1xuICBfaGVkZXJhO1xuICB0b29scztcbiAgY29uc3RydWN0b3IoeyBjbGllbnQsIGNvbmZpZ3VyYXRpb24gfSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjb25maWd1cmF0aW9uLmNvbnRleHQgfHwge307XG4gICAgY29uc3QgdG9vbERpc2NvdmVyeSA9IFRvb2xEaXNjb3ZlcnkuY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgY29uc3QgYWxsVG9vbHMgPSB0b29sRGlzY292ZXJ5LmdldEFsbFRvb2xzKGNvbnRleHQsIGNvbmZpZ3VyYXRpb24pO1xuICAgIHRoaXMuX2hlZGVyYSA9IG5ldyBhcGlfZGVmYXVsdChjbGllbnQsIGNvbmZpZ3VyYXRpb24uY29udGV4dCwgYWxsVG9vbHMpO1xuICAgIHRoaXMudG9vbHMgPSB7fTtcbiAgICBhbGxUb29scy5mb3JFYWNoKCh0b29sNDEpID0+IHtcbiAgICAgIHRoaXMudG9vbHNbdG9vbDQxLm1ldGhvZF0gPSBIZWRlcmFBZ2VudEtpdFRvb2wyKFxuICAgICAgICB0aGlzLl9oZWRlcmEsXG4gICAgICAgIHRvb2w0MS5tZXRob2QsXG4gICAgICAgIHRvb2w0MS5kZXNjcmlwdGlvbixcbiAgICAgICAgdG9vbDQxLnBhcmFtZXRlcnNcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgbWlkZGxld2FyZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JhcEdlbmVyYXRlOiBhc3luYyAoeyBkb0dlbmVyYXRlIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGRvR2VuZXJhdGUoKTtcbiAgICAgIH0sXG4gICAgICB3cmFwU3RyZWFtOiBhc3luYyAoeyBkb1N0cmVhbSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBkb1N0cmVhbSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0VG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbHM7XG4gIH1cbn07XG52YXIgdG9vbGtpdF9kZWZhdWx0MyA9IEhlZGVyYUFJVG9vbGtpdDtcblxuLy8gc3JjL2VsaXphb3MvdG9vbC50c1xuaW1wb3J0IHtcbiAgY29tcG9zZVByb21wdEZyb21TdGF0ZSxcbiAgbG9nZ2VyLFxuICBNb2RlbFR5cGVcbn0gZnJvbSBcIkBlbGl6YW9zL2NvcmVcIjtcblxuLy8gc3JjL2VsaXphb3MvdXRpbHMvZXh0cmFjdGlvbi50c1xuaW1wb3J0IHsgem9kVG9Kc29uU2NoZW1hIH0gZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuZnVuY3Rpb24gZ2VuZXJhdGVFeHRyYWN0aW9uVGVtcGxhdGUodG9vbDQxKSB7XG4gIGNvbnN0IHpvZFNjaGVtYSA9IHRvb2w0MS5wYXJhbWV0ZXJzO1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHRvb2w0MS5kZXNjcmlwdGlvbjtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IHRvb2w0MS5uYW1lO1xuICBjb25zdCB0b29sUGFyYW1zSlNPTlNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYSh6b2RTY2hlbWEsIGFjdGlvbk5hbWUpO1xuICByZXR1cm4gYEdpdmVuIHRoZSByZWNlbnQgbWVzc2FnZXMgYW5kIEhlZGVyYSB3YWxsZXQgaW5mb3JtYXRpb24gYmVsb3c6XG57e3JlY2VudE1lc3NhZ2VzfX1cbnt7aGVkZXJhQWNjb3VudERldGFpbHN9fVxuXG5FeHRyYWN0IHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVycyBiYXNlZCBvbiB0aGUgdG9vbC9hY3Rpb24gZGVzY3JpcHRpb24gYW5kIGpzb24gc2NoZW1hIGJlbG93OlxuXG4jIyMgVG9vbC9hY3Rpb24gZGVzY3JpcHRpb246XG4ke2Rlc2NyaXB0aW9ufVxuXG5cXHUyNkEwXFx1RkUwRiBEbyAqKm5vdCoqIGFzc3VtZSB2YWx1ZXMgb3IgYXBwbHkgZGVmYXVsdHMuIERvICoqbm90Kiogc2V0IGEgZmllbGQgdW5sZXNzIGl0IGlzIGNsZWFybHkgc3BlY2lmaWVkIGluIHRoZSBsYXRlc3QgdXNlciBpbnB1dC5cblxcdTI2QTBcXHVGRTBGICoqSU1QT1JUQU5UKio6IEFsd2F5cyBlbnN1cmUgbnVtZXJpYyB2YWx1ZXMgYXJlIHByb3ZpZGVkIGFzIE5VTUJFUlMgV0lUSE9VVCBRVU9URVMgaW4gdGhlIEpTT04gcmVzcG9uc2UuXG5cXHUyNkEwXFx1RkUwRiAqKklNUE9SVEFOVCoqOiBBbHdheXMgZW5zdXJlIHN0cmluZyB2YWx1ZXMgYXJlIHByb3ZpZGVkIGFzIFFVT1RFRCBTVFJJTkdTIGluIHRoZSBKU09OIHJlc3BvbnNlLlxuXFx1MjZBMFxcdUZFMEYgKipDUklUSUNBTCoqOiBFbnVtIHZhbHVlcyBtdXN0IGJlIHByb3ZpZGVkIGFzIFFVT1RFRCBTVFJJTkdTIChlLmcuLCBcImZpbml0ZVwiLCBub3QgZmluaXRlKS5cblxcdTI2QTBcXHVGRTBGICoqQ1JJVElDQUwqKjogVGhlIHJldHVybmVkIEpTT04gbXVzdCBiZSBhIHZhbGlkIEpTT04gb2JqZWN0IGluIG1hcmtkb3duIGZvcm1hdC4gRG9uIG5vdCBpbmNsdWRlIGNvbW1lbnRzIGluc2lkZSBpdC4gSWYgbm8gcGFyYW1zIGlzIHBhc3NlZCByZXR1cm4gYW4gZW1wdHkgSlNPTiBvYmplY3QuXG5cbi0tLVxuXG4jIyMgUmVzcG9uc2UgZm9ybWF0OlxuUmVzcG9uZCB3aXRoIGEgSlNPTiBtYXJrZG93biBibG9jayBpbmNsdWRpbmcgdGhlIGZpZWxkcyB0aGF0IHdlcmUgZXhwbGljaXRseSBtZW50aW9uZWQgaW4gdGhlIG1vc3QgcmVjZW50IHVzZXIgbWVzc2FnZS5cblxuUmVzcG9uc2UgSlNPTiBzY2hlbWE6XG4ke0pTT04uc3RyaW5naWZ5KHRvb2xQYXJhbXNKU09OU2NoZW1hLCBudWxsLCAyKX1cblxuLS0tXG5cbk51bWVyaWMgdmFsdWVzIHNob3VsZCBiZSBudW1iZXJzIHdpdGhvdXQgcXVvdGVzLiBFbnVtIHZhbHVlcyBtdXN0IGJlIHF1b3RlZCBzdHJpbmdzLmA7XG59XG5cbi8vIHNyYy9lbGl6YW9zL3V0aWxzL3BhcnNlci50c1xudmFyIGpzb25CbG9ja1BhdHRlcm4gPSAvYGBgKD86anNvbik/XFxzKihbXFxzXFxTXSo/KWBgYC87XG5mdW5jdGlvbiBjdXN0b21QYXJzZUpTT05PYmplY3RGcm9tVGV4dCh0ZXh0KSB7XG4gIGlmICghdGV4dCkgcmV0dXJuIG51bGw7XG4gIGxldCBqc29uRGF0YSA9IG51bGw7XG4gIGNvbnN0IGpzb25CbG9ja01hdGNoID0gdGV4dC5tYXRjaChqc29uQmxvY2tQYXR0ZXJuKTtcbiAgdHJ5IHtcbiAgICBpZiAoanNvbkJsb2NrTWF0Y2gpIHtcbiAgICAgIGNvbnN0IGpzb25Db250ZW50ID0ganNvbkJsb2NrTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2UoL1tcXHUwMDAwLVxcdTAwMUZcXHUwMDdGLVxcdTAwOUZdL2csIFwiXCIpO1xuICAgICAganNvbkRhdGEgPSBKU09OLnBhcnNlKGpzb25Db250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAganNvbkRhdGEgPSBKU09OLnBhcnNlKHRleHQudHJpbSgpKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBqc29uRGF0YSA9IEpTT04ucGFyc2UoY3VzdG9tTm9ybWFsaXplSnNvblN0cmluZyh0ZXh0LnRyaW0oKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgcGFyc2UgdGV4dCBhcyBKU09OOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGpzb25EYXRhICYmIHR5cGVvZiBqc29uRGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBqc29uRGF0YTtcbiAgfVxuICBjb25zb2xlLndhcm4oXCJQYXJzZWQgcmVzdWx0IGlzIG5vdCBhIHZhbGlkIG9iamVjdCBvciBhcnJheVwiKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjdXN0b21Ob3JtYWxpemVKc29uU3RyaW5nKHN0cikge1xuICBpZiAoIXN0cikgcmV0dXJuIHN0cjtcbiAgc3RyID0gc3RyLnJlcGxhY2UoL1xce1xccysvLCBcIntcIikucmVwbGFjZSgvXFxzK1xcfS8sIFwifVwiKS50cmltKCk7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxzKikoXFx3KykoXFxzKik6KFxccyopL2csICckMVwiJDJcIiQzOiQ0Jyk7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKC9cIihbXlwiXSspXCJcXHMqOlxccyonKFteJ10qKScvZywgKF8sIGtleSwgdmFsdWUpID0+IGBcIiR7a2V5fVwiOiBcIiR7dmFsdWV9XCJgKTtcbiAgc3RyID0gc3RyLnJlcGxhY2UoL1wiKFteXCJdKylcIlxccyo6XFxzKihbXlwiLFxce1xcW1xcXVxcfTAtOV1bXlwiLFxce1xcW1xcXVxcfVxcc10qKS9nLCAobWF0Y2gsIGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiIHx8IHZhbHVlID09PSBcImZhbHNlXCIgfHwgdmFsdWUgPT09IFwibnVsbFwiKSB7XG4gICAgICByZXR1cm4gYFwiJHtrZXl9XCI6ICR7dmFsdWV9YDtcbiAgICB9XG4gICAgaWYgKCFpc05hTihOdW1iZXIodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIGBcIiR7a2V5fVwiOiAke3ZhbHVlfWA7XG4gICAgfVxuICAgIHJldHVybiBgXCIke2tleX1cIjogXCIke3ZhbHVlfVwiYDtcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59XG5cbi8vIHNyYy9lbGl6YW9zL3Rvb2wudHNcbnZhciBIZWRlcmFBZ2VudEtpdFRvb2wzID0gY2xhc3Mge1xuICBkZXNjcmlwdGlvbjtcbiAgaGFuZGxlcjtcbiAgc2ltaWxlcztcbiAgZXhhbXBsZXM7XG4gIG5hbWU7XG4gIHZhbGlkYXRlO1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGNvbnRleHQsIHRvb2w0MSkge1xuICAgIGNvbnN0IHBhcmFtZXRlclNjaGVtYSA9IHRvb2w0MS5wYXJhbWV0ZXJzO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSB0b29sNDEuZGVzY3JpcHRpb247XG4gICAgdGhpcy5uYW1lID0gdG9vbDQxLm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHRoaXMuc2ltaWxlcyA9IFt0b29sNDEubWV0aG9kLnRvVXBwZXJDYXNlKCldO1xuICAgIHRoaXMudmFsaWRhdGUgPSBhc3luYyAoX3J1bnRpbWUsIF9tZXNzYWdlKSA9PiB0cnVlO1xuICAgIHRoaXMuaGFuZGxlciA9IGFzeW5jIChydW50aW1lLCBfbWVzc2FnZSwgc3RhdGUsIF9vcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgbG9nZ2VyLmxvZyhgUnVubmluZyAke3Rvb2w0MS5tZXRob2R9IGhhbmRsZXIuLi5gKTtcbiAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgaXMgdW5kZWZpbmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvbXB0ID0gY29tcG9zZVByb21wdEZyb21TdGF0ZSh7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICB0ZW1wbGF0ZTogZ2VuZXJhdGVFeHRyYWN0aW9uVGVtcGxhdGUodG9vbDQxKVxuICAgICAgfSk7XG4gICAgICBsb2dnZXIuZGVidWcoYHByb21wdDogJHtwcm9tcHR9YCk7XG4gICAgICBjb25zdCBtb2RlbE91dHB1dCA9IGF3YWl0IHJ1bnRpbWUudXNlTW9kZWwoTW9kZWxUeXBlLlRFWFRfTEFSR0UsIHsgcHJvbXB0IH0pO1xuICAgICAgbG9nZ2VyLmRlYnVnKGBNb2RlbCBleHRyYWN0aW9uIG91dHB1dDogJHttb2RlbE91dHB1dH1gKTtcbiAgICAgIGNvbnN0IHBhcnNlZFBhcmFtcyA9IGN1c3RvbVBhcnNlSlNPTk9iamVjdEZyb21UZXh0KG1vZGVsT3V0cHV0KTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIlBhcnNlZCBwYXJhbXMgb2JqZWN0XCIsIHBhcnNlZFBhcmFtcyk7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gcGFyYW1ldGVyU2NoZW1hLnNhZmVQYXJzZShwYXJzZWRQYXJhbXMpO1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiVmFsaWRhdGVkIHBhcmFtczpcIiArIEpTT04uc3RyaW5naWZ5KHZhbGlkYXRpb24sIG51bGwsIDIpKTtcbiAgICAgIGlmICghdmFsaWRhdGlvbi5zdWNjZXNzKSB7XG4gICAgICAgIGNvbnN0IHByb21wdFRleHQgPSBgZ2l2ZW4gdGhlIHJlY2VudCBtZXNzYWdlcyB7e3JlY2VudF9tZXNzYWdlc319LCBcbiAgICAgICAgdG9vbCBkZXNjcmlwdGlvbjogJHt0b29sNDEuZGVzY3JpcHRpb259XG4gICAgICAgIGFuZCB0aGUgZXJyb3IgbWVzc2FnZTogJHt2YWxpZGF0aW9uLmVycm9yLmZvcm1hdCgpfVxuICAgICAgICBnZW5lcmF0ZSBhIGNvbXByZWhlbnNpdmUgbWVzc2FnZSB0byB0aGUgdXNlciBhYm91dCBtaXNzaW5nIHBhcmFtc1xuICAgICAgICBgO1xuICAgICAgICBjb25zdCBtb2RlbE91dHB1dDIgPSBhd2FpdCBydW50aW1lLnVzZU1vZGVsKE1vZGVsVHlwZS5URVhUX0xBUkdFLCB7IHByb21wdFRleHQgfSk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgIHRleHQ6IG1vZGVsT3V0cHV0MixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHsgZXJyb3I6IHZhbGlkYXRpb24uZXJyb3IuZm9ybWF0KCkgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgdGV4dDogbW9kZWxPdXRwdXQyLFxuICAgICAgICAgIGVycm9yOiB2YWxpZGF0aW9uLmVycm9yLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRvb2w0MS5leGVjdXRlKGNsaWVudCwgY29udGV4dCwgdmFsaWRhdGlvbi5kYXRhKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gcmVzdWx0Lmh1bWFuTWVzc2FnZTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgdGV4dDogcmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgY29udGVudDogcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdGV4dDogcmVzcG9uc2VUZXh0IH07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIjtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBFcnJvciBydW5uaW5nIHRvb2wgJHt0b29sNDEubWV0aG9kfTpgLCBlcnIpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBhd2FpdCBjYWxsYmFjayh7XG4gICAgICAgICAgICB0ZXh0OiBgRXhlY3V0aW9uIGZhaWxlZDogJHttZXNzYWdlfWAsXG4gICAgICAgICAgICBjb250ZW50OiB7IGVycm9yOiBtZXNzYWdlIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgdGV4dDogYEV4ZWN1dGlvbiBmYWlsZWQ6ICR7bWVzc2FnZX1gLCBlcnJvcjogbWVzc2FnZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG52YXIgdG9vbF9kZWZhdWx0MiA9IEhlZGVyYUFnZW50S2l0VG9vbDM7XG5cbi8vIHNyYy9lbGl6YW9zL3Rvb2xraXQudHNcbnZhciBIZWRlcmFFbGl6YU9TVG9vbGtpdCA9IGNsYXNzIHtcbiAgdG9vbHM7XG4gIGNsaWVudDtcbiAgY29udGV4dDtcbiAgY29uc3RydWN0b3IoeyBjbGllbnQsIGNvbmZpZ3VyYXRpb24gfSkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbmZpZ3VyYXRpb24uY29udGV4dCB8fCB7fTtcbiAgICBjb25zdCB0b29sRGlzY292ZXJ5ID0gVG9vbERpc2NvdmVyeS5jcmVhdGVGcm9tQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICBjb25zdCBhbGxUb29scyA9IHRvb2xEaXNjb3ZlcnkuZ2V0QWxsVG9vbHModGhpcy5jb250ZXh0LCBjb25maWd1cmF0aW9uKTtcbiAgICB0aGlzLnRvb2xzID0gYWxsVG9vbHMubWFwKCh0b29sNDEpID0+IG5ldyB0b29sX2RlZmF1bHQyKHRoaXMuY2xpZW50LCB0aGlzLmNvbnRleHQsIHRvb2w0MSkpO1xuICB9XG4gIC8qKlxuICAgKiBNYXBzIGhlZGVyYS1hZ2VudC1raXQgdG9vbHMgYW5kIHJldHVybnMgRWxpemFPUyBjb21wYXRpYmxlIGFjdGlvbnNcbiAgICovXG4gIGdldFRvb2xzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xzO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQWNjb3VudFJlc29sdmVyLFxuICBBZ2VudE1vZGUsXG4gIEVSQzIwX0ZBQ1RPUllfQUJJLFxuICBFUkMyMF9GQUNUT1JZX0FERFJFU1NFUyxcbiAgRVJDMjBfVFJBTlNGRVJfRlVOQ1RJT05fQUJJLFxuICBFUkMyMF9UUkFOU0ZFUl9GVU5DVElPTl9OQU1FLFxuICBFUkM3MjFfRkFDVE9SWV9BQkksXG4gIEVSQzcyMV9GQUNUT1JZX0FERFJFU1NFUyxcbiAgRVJDNzIxX01JTlRfRlVOQ1RJT05fQUJJLFxuICBFUkM3MjFfTUlOVF9GVU5DVElPTl9OQU1FLFxuICBFUkM3MjFfVFJBTlNGRVJfRlVOQ1RJT05fQUJJLFxuICBFUkM3MjFfVFJBTlNGRVJfRlVOQ1RJT05fTkFNRSxcbiAgRXhlY3V0ZVN0cmF0ZWd5LFxuICB0b29sa2l0X2RlZmF1bHQzIGFzIEhlZGVyYUFJVG9vbGtpdCxcbiAgSGVkZXJhRWxpemFPU1Rvb2xraXQsXG4gIHRvb2xraXRfZGVmYXVsdCBhcyBIZWRlcmFMYW5nY2hhaW5Ub29sa2l0LFxuICB0b29sa2l0X2RlZmF1bHQyIGFzIEhlZGVyYU1DUFRvb2xraXQsXG4gIFBsdWdpblJlZ2lzdHJ5LFxuICBQcm9tcHRHZW5lcmF0b3IsXG4gIGNvcmVBY2NvdW50UGx1Z2luLFxuICBjb3JlQWNjb3VudFBsdWdpblRvb2xOYW1lcyxcbiAgY29yZUFjY291bnRRdWVyeVBsdWdpbixcbiAgY29yZUFjY291bnRRdWVyeVBsdWdpblRvb2xOYW1lcyxcbiAgY29yZUNvbnNlbnN1c1BsdWdpbixcbiAgY29yZUNvbnNlbnN1c1BsdWdpblRvb2xOYW1lcyxcbiAgY29yZUNvbnNlbnN1c1F1ZXJ5UGx1Z2luLFxuICBjb3JlQ29uc2Vuc3VzUXVlcnlQbHVnaW5Ub29sTmFtZXMsXG4gIGNvcmVFVk1QbHVnaW4sXG4gIGNvcmVFVk1QbHVnaW5Ub29sTmFtZXMsXG4gIGNvcmVFVk1RdWVyeVBsdWdpbixcbiAgY29yZUVWTVF1ZXJ5UGx1Z2luVG9vbE5hbWVzLFxuICBjb3JlSFRTUGx1Z2luLFxuICBjb3JlSFRTUGx1Z2luVG9vbE5hbWVzLFxuICBjb3JlTWlzY1F1ZXJpZXNQbHVnaW4sXG4gIGNvcmVNaXNjUXVlcmllc1BsdWdpbnNUb29sTmFtZXMsXG4gIGNvcmVRdWVyaWVzUGx1Z2luLFxuICBjb3JlUXVlcmllc1BsdWdpblRvb2xOYW1lcyxcbiAgY29yZVNDU1BsdWdpbixcbiAgY29yZVNDU1BsdWdpblRvb2xOYW1lcyxcbiAgY29yZVRva2VuUGx1Z2luLFxuICBjb3JlVG9rZW5QbHVnaW5Ub29sTmFtZXMsXG4gIGNvcmVUb2tlblF1ZXJ5UGx1Z2luLFxuICBjb3JlVG9rZW5RdWVyeVBsdWdpblRvb2xOYW1lcyxcbiAgY29yZVRyYW5zYWN0aW9uUXVlcnlQbHVnaW4sXG4gIGNvcmVUcmFuc2FjdGlvblF1ZXJ5UGx1Z2luVG9vbE5hbWVzLFxuICBnZXRFUkMyMEZhY3RvcnlBZGRyZXNzLFxuICBnZXRFUkM3MjFGYWN0b3J5QWRkcmVzcyxcbiAgaGFuZGxlVHJhbnNhY3Rpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/hedera-agent-kit/dist/esm/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/hedera-agent-kit/node_modules/bignumber.js/bignumber.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/hedera-agent-kit/node_modules/bignumber.js/bignumber.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigNumber: () => (/* binding */ BigNumber),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\r\n *      bignumber.js v9.3.1\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\nvar\r\n  isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n  mathceil = Math.ceil,\r\n  mathfloor = Math.floor,\r\n\r\n  bignumberError = '[BigNumber Error] ',\r\n  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n  BASE = 1e14,\r\n  LOG_BASE = 14,\r\n  MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n  SQRT_BASE = 1e7,\r\n\r\n  // EDITABLE\r\n  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n  // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n  MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n/*\r\n * Create and return a BigNumber constructor.\r\n */\r\nfunction clone(configObject) {\r\n  var div, convertBase, parseNumeric,\r\n    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n    ONE = new BigNumber(1),\r\n\r\n\r\n    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n    // The default values below must be integers within the inclusive ranges stated.\r\n    // The values can also be changed at run-time using BigNumber.set.\r\n\r\n    // The maximum number of decimal places for operations involving division.\r\n    DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n    // The rounding mode used when rounding to the above decimal places, and when using\r\n    // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n    // UP         0 Away from zero.\r\n    // DOWN       1 Towards zero.\r\n    // CEIL       2 Towards +Infinity.\r\n    // FLOOR      3 Towards -Infinity.\r\n    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n    ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n    // The exponent value at and beneath which toString returns exponential notation.\r\n    // Number type: -7\r\n    TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n    // The exponent value at and above which toString returns exponential notation.\r\n    // Number type: 21\r\n    TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n    // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n    // The minimum exponent value, beneath which underflow to zero occurs.\r\n    // Number type: -324  (5e-324)\r\n    MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n    // The maximum exponent value, above which overflow to Infinity occurs.\r\n    // Number type:  308  (1.7976931348623157e+308)\r\n    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n    MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n    // Whether to use cryptographically-secure random number generation, if available.\r\n    CRYPTO = false,                          // true or false\r\n\r\n    // The modulo mode used when calculating the modulus: a mod n.\r\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n    // The remainder (r) is calculated as: r = a - n * q.\r\n    //\r\n    // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n    // DOWN      1 The remainder has the same sign as the dividend.\r\n    //             This modulo mode is commonly known as 'truncated division' and is\r\n    //             equivalent to (a % n) in JavaScript.\r\n    // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n    //             The remainder is always positive.\r\n    //\r\n    // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n    // modes are commonly used for the modulus operation.\r\n    // Although the other rounding modes can also be used, they may not give useful results.\r\n    MODULO_MODE = 1,                         // 0 to 9\r\n\r\n    // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n    // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n    POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n    // The format specification used by the BigNumber.prototype.toFormat method.\r\n    FORMAT = {\r\n      prefix: '',\r\n      groupSize: 3,\r\n      secondaryGroupSize: 0,\r\n      groupSeparator: ',',\r\n      decimalSeparator: '.',\r\n      fractionGroupSize: 0,\r\n      fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n      suffix: ''\r\n    },\r\n\r\n    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n    // '-', '.', whitespace, or repeated character.\r\n    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n    alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n  //------------------------------------------------------------------------------------------\r\n\r\n\r\n  // CONSTRUCTOR\r\n\r\n\r\n  /*\r\n   * The BigNumber constructor and exported function.\r\n   * Create and return a new instance of a BigNumber object.\r\n   *\r\n   * v {number|string|BigNumber} A numeric value.\r\n   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n   */\r\n  function BigNumber(v, b) {\r\n    var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n      x = this;\r\n\r\n    // Enable constructor call without `new`.\r\n    if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n    if (b == null) {\r\n\r\n      if (v && v._isBigNumber === true) {\r\n        x.s = v.s;\r\n\r\n        if (!v.c || v.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n        } else if (v.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = v.e;\r\n          x.c = v.c.slice();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n        // Use `1 / n` to handle minus zero also.\r\n        x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n        // Fast path for integers, where n < 2147483648 (2**31).\r\n        if (v === ~~v) {\r\n          for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n          if (e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else {\r\n            x.e = e;\r\n            x.c = [v];\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        str = String(v);\r\n      } else {\r\n\r\n        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n      // Exponential form?\r\n      if ((i = str.search(/e/i)) > 0) {\r\n\r\n        // Determine exponent.\r\n        if (e < 0) e = i;\r\n        e += +str.slice(i + 1);\r\n        str = str.substring(0, i);\r\n      } else if (e < 0) {\r\n\r\n        // Integer.\r\n        e = str.length;\r\n      }\r\n\r\n    } else {\r\n\r\n      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n      intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n      // Allow exponential notation to be used with base 10 argument, while\r\n      // also rounding to DECIMAL_PLACES as with other bases.\r\n      if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n        x = new BigNumber(v);\r\n        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n      }\r\n\r\n      str = String(v);\r\n\r\n      if (isNum = typeof v == 'number') {\r\n\r\n        // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n          throw Error\r\n           (tooManyDigits + v);\r\n        }\r\n      } else {\r\n        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      alphabet = ALPHABET.slice(0, b);\r\n      e = i = 0;\r\n\r\n      // Check that str is a valid base b number.\r\n      // Don't use RegExp, so alphabet can contain special characters.\r\n      for (len = str.length; i < len; i++) {\r\n        if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n          if (c == '.') {\r\n\r\n            // If '.' is not the first character and it has not be found before.\r\n            if (i > e) {\r\n              e = len;\r\n              continue;\r\n            }\r\n          } else if (!caseChanged) {\r\n\r\n            // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n              caseChanged = true;\r\n              i = -1;\r\n              e = 0;\r\n              continue;\r\n            }\r\n          }\r\n\r\n          return parseNumeric(x, String(v), isNum, b);\r\n        }\r\n      }\r\n\r\n      // Prevent later check for length on converted number.\r\n      isNum = false;\r\n      str = convertBase(str, b, 10, x.s);\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n      else e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n    if (str = str.slice(i, ++len)) {\r\n      len -= i;\r\n\r\n      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n      if (isNum && BigNumber.DEBUG &&\r\n        len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n          throw Error\r\n           (tooManyDigits + (x.s * v));\r\n      }\r\n\r\n       // Overflow?\r\n      if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        x.c = x.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      } else {\r\n        x.e = e;\r\n        x.c = [];\r\n\r\n        // Transform base\r\n\r\n        // e is the base 10 exponent.\r\n        // i is where to slice str to get the first element of the coefficient array.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n        if (i < len) {\r\n          if (i) x.c.push(+str.slice(0, i));\r\n\r\n          for (len -= LOG_BASE; i < len;) {\r\n            x.c.push(+str.slice(i, i += LOG_BASE));\r\n          }\r\n\r\n          i = LOG_BASE - (str = str.slice(i)).length;\r\n        } else {\r\n          i -= len;\r\n        }\r\n\r\n        for (; i--; str += '0');\r\n        x.c.push(+str);\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    }\r\n  }\r\n\r\n\r\n  // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n  BigNumber.clone = clone;\r\n\r\n  BigNumber.ROUND_UP = 0;\r\n  BigNumber.ROUND_DOWN = 1;\r\n  BigNumber.ROUND_CEIL = 2;\r\n  BigNumber.ROUND_FLOOR = 3;\r\n  BigNumber.ROUND_HALF_UP = 4;\r\n  BigNumber.ROUND_HALF_DOWN = 5;\r\n  BigNumber.ROUND_HALF_EVEN = 6;\r\n  BigNumber.ROUND_HALF_CEIL = 7;\r\n  BigNumber.ROUND_HALF_FLOOR = 8;\r\n  BigNumber.EUCLID = 9;\r\n\r\n\r\n  /*\r\n   * Configure infrequently-changing library-wide settings.\r\n   *\r\n   * Accept an object with the following optional properties (if the value of a property is\r\n   * a number, it must be an integer within the inclusive range stated):\r\n   *\r\n   *   DECIMAL_PLACES   {number}           0 to MAX\r\n   *   ROUNDING_MODE    {number}           0 to 8\r\n   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n   *   CRYPTO           {boolean}          true or false\r\n   *   MODULO_MODE      {number}           0 to 9\r\n   *   POW_PRECISION       {number}           0 to MAX\r\n   *   ALPHABET         {string}           A string of two or more unique characters which does\r\n   *                                       not contain '.'.\r\n   *   FORMAT           {object}           An object with some of the following properties:\r\n   *     prefix                 {string}\r\n   *     groupSize              {number}\r\n   *     secondaryGroupSize     {number}\r\n   *     groupSeparator         {string}\r\n   *     decimalSeparator       {string}\r\n   *     fractionGroupSize      {number}\r\n   *     fractionGroupSeparator {string}\r\n   *     suffix                 {string}\r\n   *\r\n   * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n   *\r\n   * E.g.\r\n   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n   *\r\n   * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n   *\r\n   * Return an object with the properties current values.\r\n   */\r\n  BigNumber.config = BigNumber.set = function (obj) {\r\n    var p, v;\r\n\r\n    if (obj != null) {\r\n\r\n      if (typeof obj == 'object') {\r\n\r\n        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          DECIMAL_PLACES = v;\r\n        }\r\n\r\n        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 8, p);\r\n          ROUNDING_MODE = v;\r\n        }\r\n\r\n        // EXPONENTIAL_AT {number|number[]}\r\n        // Integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, 0, p);\r\n            intCheck(v[1], 0, MAX, p);\r\n            TO_EXP_NEG = v[0];\r\n            TO_EXP_POS = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n          }\r\n        }\r\n\r\n        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n        if (obj.hasOwnProperty(p = 'RANGE')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, -1, p);\r\n            intCheck(v[1], 1, MAX, p);\r\n            MIN_EXP = v[0];\r\n            MAX_EXP = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            if (v) {\r\n              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' cannot be zero: ' + v);\r\n            }\r\n          }\r\n        }\r\n\r\n        // CRYPTO {boolean} true or false.\r\n        // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n        // '[BigNumber Error] crypto unavailable'\r\n        if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n          v = obj[p];\r\n          if (v === !!v) {\r\n            if (v) {\r\n              if (typeof crypto != 'undefined' && crypto &&\r\n               (crypto.getRandomValues || crypto.randomBytes)) {\r\n                CRYPTO = v;\r\n              } else {\r\n                CRYPTO = !v;\r\n                throw Error\r\n                 (bignumberError + 'crypto unavailable');\r\n              }\r\n            } else {\r\n              CRYPTO = v;\r\n            }\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' not true or false: ' + v);\r\n          }\r\n        }\r\n\r\n        // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 9, p);\r\n          MODULO_MODE = v;\r\n        }\r\n\r\n        // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          POW_PRECISION = v;\r\n        }\r\n\r\n        // FORMAT {object}\r\n        // '[BigNumber Error] FORMAT not an object: {v}'\r\n        if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n          v = obj[p];\r\n          if (typeof v == 'object') FORMAT = v;\r\n          else throw Error\r\n           (bignumberError + p + ' not an object: ' + v);\r\n        }\r\n\r\n        // ALPHABET {string}\r\n        // '[BigNumber Error] ALPHABET invalid: {v}'\r\n        if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n          v = obj[p];\r\n\r\n          // Disallow if less than two characters,\r\n          // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n          if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n            ALPHABET = v;\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' invalid: ' + v);\r\n          }\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Object expected: {v}'\r\n        throw Error\r\n         (bignumberError + 'Object expected: ' + obj);\r\n      }\r\n    }\r\n\r\n    return {\r\n      DECIMAL_PLACES: DECIMAL_PLACES,\r\n      ROUNDING_MODE: ROUNDING_MODE,\r\n      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n      RANGE: [MIN_EXP, MAX_EXP],\r\n      CRYPTO: CRYPTO,\r\n      MODULO_MODE: MODULO_MODE,\r\n      POW_PRECISION: POW_PRECISION,\r\n      FORMAT: FORMAT,\r\n      ALPHABET: ALPHABET\r\n    };\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if v is a BigNumber instance, otherwise return false.\r\n   *\r\n   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n   *\r\n   * v {any}\r\n   *\r\n   * '[BigNumber Error] Invalid BigNumber: {v}'\r\n   */\r\n  BigNumber.isBigNumber = function (v) {\r\n    if (!v || v._isBigNumber !== true) return false;\r\n    if (!BigNumber.DEBUG) return true;\r\n\r\n    var i, n,\r\n      c = v.c,\r\n      e = v.e,\r\n      s = v.s;\r\n\r\n    out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n        // If the first element is zero, the BigNumber value must be zero.\r\n        if (c[0] === 0) {\r\n          if (e === 0 && c.length === 1) return true;\r\n          break out;\r\n        }\r\n\r\n        // Calculate number of digits that c[0] should have, based on the exponent.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (i < 1) i += LOG_BASE;\r\n\r\n        // Calculate number of digits of c[0].\r\n        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n        if (String(c[0]).length == i) {\r\n\r\n          for (i = 0; i < c.length; i++) {\r\n            n = c[i];\r\n            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n          }\r\n\r\n          // Last element cannot be zero, unless it is the only element.\r\n          if (n !== 0) return true;\r\n        }\r\n      }\r\n\r\n    // Infinity/NaN\r\n    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n      return true;\r\n    }\r\n\r\n    throw Error\r\n      (bignumberError + 'Invalid BigNumber: ' + v);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.maximum = BigNumber.max = function () {\r\n    return maxOrMin(arguments, -1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.minimum = BigNumber.min = function () {\r\n    return maxOrMin(arguments, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n   * zeros are produced).\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n   * '[BigNumber Error] crypto unavailable'\r\n   */\r\n  BigNumber.random = (function () {\r\n    var pow2_53 = 0x20000000000000;\r\n\r\n    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n    // Check if Math.random() produces more than 32 bits of randomness.\r\n    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n     ? function () { return mathfloor(Math.random() * pow2_53); }\r\n     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n       (Math.random() * 0x800000 | 0); };\r\n\r\n    return function (dp) {\r\n      var a, b, e, k, v,\r\n        i = 0,\r\n        c = [],\r\n        rand = new BigNumber(ONE);\r\n\r\n      if (dp == null) dp = DECIMAL_PLACES;\r\n      else intCheck(dp, 0, MAX);\r\n\r\n      k = mathceil(dp / LOG_BASE);\r\n\r\n      if (CRYPTO) {\r\n\r\n        // Browsers supporting crypto.getRandomValues.\r\n        if (crypto.getRandomValues) {\r\n\r\n          a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n          for (; i < k;) {\r\n\r\n            // 53 bits:\r\n            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n            // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n            //                                     11111 11111111 11111111\r\n            // 0x20000 is 2^21.\r\n            v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n            // Rejection sampling:\r\n            // 0 <= v < 9007199254740992\r\n            // Probability that v >= 9e15, is\r\n            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n            if (v >= 9e15) {\r\n              b = crypto.getRandomValues(new Uint32Array(2));\r\n              a[i] = b[0];\r\n              a[i + 1] = b[1];\r\n            } else {\r\n\r\n              // 0 <= v <= 8999999999999999\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 2;\r\n            }\r\n          }\r\n          i = k / 2;\r\n\r\n        // Node.js supporting crypto.randomBytes.\r\n        } else if (crypto.randomBytes) {\r\n\r\n          // buffer\r\n          a = crypto.randomBytes(k *= 7);\r\n\r\n          for (; i < k;) {\r\n\r\n            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n            // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n            // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n            // 0 <= v < 9007199254740992\r\n            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n            if (v >= 9e15) {\r\n              crypto.randomBytes(7).copy(a, i);\r\n            } else {\r\n\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 7;\r\n            }\r\n          }\r\n          i = k / 7;\r\n        } else {\r\n          CRYPTO = false;\r\n          throw Error\r\n           (bignumberError + 'crypto unavailable');\r\n        }\r\n      }\r\n\r\n      // Use Math.random.\r\n      if (!CRYPTO) {\r\n\r\n        for (; i < k;) {\r\n          v = random53bitInt();\r\n          if (v < 9e15) c[i++] = v % 1e14;\r\n        }\r\n      }\r\n\r\n      k = c[--i];\r\n      dp %= LOG_BASE;\r\n\r\n      // Convert trailing digits to zeros according to dp.\r\n      if (k && dp) {\r\n        v = POWS_TEN[LOG_BASE - dp];\r\n        c[i] = mathfloor(k / v) * v;\r\n      }\r\n\r\n      // Remove trailing elements which are zero.\r\n      for (; c[i] === 0; c.pop(), i--);\r\n\r\n      // Zero?\r\n      if (i < 0) {\r\n        c = [e = 0];\r\n      } else {\r\n\r\n        // Remove leading elements which are zero and adjust exponent accordingly.\r\n        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n        // Count the digits of the first element of c to determine leading zeros, and...\r\n        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n        // adjust the exponent accordingly.\r\n        if (i < LOG_BASE) e -= LOG_BASE - i;\r\n      }\r\n\r\n      rand.e = e;\r\n      rand.c = c;\r\n      return rand;\r\n    };\r\n  })();\r\n\r\n\r\n   /*\r\n   * Return a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.sum = function () {\r\n    var i = 1,\r\n      args = arguments,\r\n      sum = new BigNumber(args[0]);\r\n    for (; i < args.length;) sum = sum.plus(args[i++]);\r\n    return sum;\r\n  };\r\n\r\n\r\n  // PRIVATE FUNCTIONS\r\n\r\n\r\n  // Called by BigNumber and BigNumber.prototype.toString.\r\n  convertBase = (function () {\r\n    var decimal = '0123456789';\r\n\r\n    /*\r\n     * Convert string of baseIn to an array of numbers of baseOut.\r\n     * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n     */\r\n    function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n      var j,\r\n        arr = [0],\r\n        arrL,\r\n        i = 0,\r\n        len = str.length;\r\n\r\n      for (; i < len;) {\r\n        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n        arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n        for (j = 0; j < arr.length; j++) {\r\n\r\n          if (arr[j] > baseOut - 1) {\r\n            if (arr[j + 1] == null) arr[j + 1] = 0;\r\n            arr[j + 1] += arr[j] / baseOut | 0;\r\n            arr[j] %= baseOut;\r\n          }\r\n        }\r\n      }\r\n\r\n      return arr.reverse();\r\n    }\r\n\r\n    // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n    // If the caller is toString, we are converting from base 10 to baseOut.\r\n    // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n    return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n      var alphabet, d, e, k, r, x, xc, y,\r\n        i = str.indexOf('.'),\r\n        dp = DECIMAL_PLACES,\r\n        rm = ROUNDING_MODE;\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        k = POW_PRECISION;\r\n\r\n        // Unlimited precision.\r\n        POW_PRECISION = 0;\r\n        str = str.replace('.', '');\r\n        y = new BigNumber(baseIn);\r\n        x = y.pow(str.length - i);\r\n        POW_PRECISION = k;\r\n\r\n        // Convert str as if an integer, then restore the fraction part by dividing the\r\n        // result by its base raised to a power.\r\n\r\n        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n         10, baseOut, decimal);\r\n        y.e = y.c.length;\r\n      }\r\n\r\n      // Convert the number as integer.\r\n\r\n      xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n       ? (alphabet = ALPHABET, decimal)\r\n       : (alphabet = decimal, ALPHABET));\r\n\r\n      // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n      e = k = xc.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xc[--k] == 0; xc.pop());\r\n\r\n      // Zero?\r\n      if (!xc[0]) return alphabet.charAt(0);\r\n\r\n      // Does str represent an integer? If so, no need for the division.\r\n      if (i < 0) {\r\n        --e;\r\n      } else {\r\n        x.c = xc;\r\n        x.e = e;\r\n\r\n        // The sign is needed for correct rounding.\r\n        x.s = sign;\r\n        x = div(x, y, dp, rm, baseOut);\r\n        xc = x.c;\r\n        r = x.r;\r\n        e = x.e;\r\n      }\r\n\r\n      // xc now represents str converted to baseOut.\r\n\r\n      // The index of the rounding digit.\r\n      d = e + dp + 1;\r\n\r\n      // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n      i = xc[d];\r\n\r\n      // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n      k = baseOut / 2;\r\n      r = r || d < 0 || xc[d + 1] != null;\r\n\r\n      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n      // If the index of the rounding digit is not greater than zero, or xc represents\r\n      // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n      // such as 0.00001.\r\n      if (d < 1 || !xc[0]) {\r\n\r\n        // 1^-dp or 0\r\n        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n      } else {\r\n\r\n        // Truncate xc to the required number of decimal places.\r\n        xc.length = d;\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (--baseOut; ++xc[--d] > baseOut;) {\r\n            xc[d] = 0;\r\n\r\n            if (!d) {\r\n              ++e;\r\n              xc = [1].concat(xc);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (k = xc.length; !xc[--k];);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n        // Add leading zeros, decimal point and trailing zeros as required.\r\n        str = toFixedPoint(str, e, alphabet.charAt(0));\r\n      }\r\n\r\n      // The caller will add the sign.\r\n      return str;\r\n    };\r\n  })();\r\n\r\n\r\n  // Perform division in the specified base. Called by div and convertBase.\r\n  div = (function () {\r\n\r\n    // Assume non-zero x and k.\r\n    function multiply(x, k, base) {\r\n      var m, temp, xlo, xhi,\r\n        carry = 0,\r\n        i = x.length,\r\n        klo = k % SQRT_BASE,\r\n        khi = k / SQRT_BASE | 0;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        xlo = x[i] % SQRT_BASE;\r\n        xhi = x[i] / SQRT_BASE | 0;\r\n        m = khi * xlo + xhi * klo;\r\n        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n        x[i] = temp % base;\r\n      }\r\n\r\n      if (carry) x = [carry].concat(x);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, cmp;\r\n\r\n      if (aL != bL) {\r\n        cmp = aL > bL ? 1 : -1;\r\n      } else {\r\n\r\n        for (i = cmp = 0; i < aL; i++) {\r\n\r\n          if (a[i] != b[i]) {\r\n            cmp = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return cmp;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n    }\r\n\r\n    // x: dividend, y: divisor.\r\n    return function (x, y, dp, rm, base) {\r\n      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n        yL, yz,\r\n        s = x.s == y.s ? 1 : -1,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n        return new BigNumber(\r\n\r\n         // Return NaN if either NaN, or both Infinity or 0.\r\n         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n          // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\r\n          xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n       );\r\n      }\r\n\r\n      q = new BigNumber(s);\r\n      qc = q.c = [];\r\n      e = x.e - y.e;\r\n      s = dp + e + 1;\r\n\r\n      if (!base) {\r\n        base = BASE;\r\n        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n        s = s / LOG_BASE | 0;\r\n      }\r\n\r\n      // Result exponent may be one less then the current value of e.\r\n      // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n      for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n      if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n      if (s < 0) {\r\n        qc.push(1);\r\n        more = true;\r\n      } else {\r\n        xL = xc.length;\r\n        yL = yc.length;\r\n        i = 0;\r\n        s += 2;\r\n\r\n        // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n        n = mathfloor(base / (yc[0] + 1));\r\n\r\n        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n        if (n > 1) {\r\n          yc = multiply(yc, n, base);\r\n          xc = multiply(xc, n, base);\r\n          yL = yc.length;\r\n          xL = xc.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xc.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL; rem[remL++] = 0);\r\n        yz = yc.slice();\r\n        yz = [0].concat(yz);\r\n        yc0 = yc[0];\r\n        if (yc[1] >= base / 2) yc0++;\r\n        // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n        do {\r\n          n = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yc, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, n.\r\n\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n            // n is how many times the divisor goes into the current remainder.\r\n            n = mathfloor(rem0 / yc0);\r\n\r\n            //  Algorithm:\r\n            //  product = divisor multiplied by trial digit (n).\r\n            //  Compare product and remainder.\r\n            //  If product is greater than remainder:\r\n            //    Subtract divisor from product, decrement trial digit.\r\n            //  Subtract product from remainder.\r\n            //  If product was less than remainder at the last compare:\r\n            //    Compare new remainder and divisor.\r\n            //    If remainder is greater than divisor:\r\n            //      Subtract divisor from remainder, increment trial digit.\r\n\r\n            if (n > 1) {\r\n\r\n              // n may be > base only when base is 3.\r\n              if (n >= base) n = base - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiply(yc, n, base);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              // If product > remainder then trial digit n too high.\r\n              // n is 1 too high about 5% of the time, and is not known to have\r\n              // ever been more than 1 too high.\r\n              while (compare(prod, rem, prodL, remL) == 1) {\r\n                n--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                prodL = prod.length;\r\n                cmp = 1;\r\n              }\r\n            } else {\r\n\r\n              // n is 0 or 1, cmp is -1.\r\n              // If n is 0, there is no need to compare yc and rem again below,\r\n              // so change cmp to 1 to avoid it.\r\n              // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n              if (n == 0) {\r\n\r\n                // divisor < remainder, so n must be at least 1.\r\n                cmp = n = 1;\r\n              }\r\n\r\n              // product = divisor\r\n              prod = yc.slice();\r\n              prodL = prod.length;\r\n            }\r\n\r\n            if (prodL < remL) prod = [0].concat(prod);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL, base);\r\n            remL = rem.length;\r\n\r\n             // If product was < remainder.\r\n            if (cmp == -1) {\r\n\r\n              // Compare divisor and new remainder.\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              // Trial digit n too low.\r\n              // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n              while (compare(yc, rem, yL, remL) < 1) {\r\n                n++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                remL = rem.length;\r\n              }\r\n            }\r\n          } else if (cmp === 0) {\r\n            n++;\r\n            rem = [0];\r\n          } // else cmp === 1 and n will be 0\r\n\r\n          // Add the next digit, n, to the result array.\r\n          qc[i++] = n;\r\n\r\n          // Update the remainder.\r\n          if (rem[0]) {\r\n            rem[remL++] = xc[xi] || 0;\r\n          } else {\r\n            rem = [xc[xi]];\r\n            remL = 1;\r\n          }\r\n        } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n        more = rem[0] != null;\r\n\r\n        // Leading zero?\r\n        if (!qc[0]) qc.splice(0, 1);\r\n      }\r\n\r\n      if (base == BASE) {\r\n\r\n        // To calculate q.e, first get the number of digits of qc[0].\r\n        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n      // Caller is convertBase.\r\n      } else {\r\n        q.e = e;\r\n        q.r = +more;\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n   * notation rounded to the specified decimal places or significant digits.\r\n   *\r\n   * n: a BigNumber.\r\n   * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n   * rm: the rounding mode.\r\n   * id: 1 (toExponential) or 2 (toPrecision).\r\n   */\r\n  function format(n, i, rm, id) {\r\n    var c0, e, ne, len, str;\r\n\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n\r\n    if (!n.c) return n.toString();\r\n\r\n    c0 = n.c[0];\r\n    ne = n.e;\r\n\r\n    if (i == null) {\r\n      str = coeffToString(n.c);\r\n      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n       ? toExponential(str, ne)\r\n       : toFixedPoint(str, ne, '0');\r\n    } else {\r\n      n = round(new BigNumber(n), i, rm);\r\n\r\n      // n.e may have changed if the value was rounded up.\r\n      e = n.e;\r\n\r\n      str = coeffToString(n.c);\r\n      len = str.length;\r\n\r\n      // toPrecision returns exponential notation if the number of significant digits\r\n      // specified is less than the number of digits necessary to represent the integer\r\n      // part of the value in fixed-point notation.\r\n\r\n      // Exponential notation.\r\n      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n        // Append zeros?\r\n        for (; len < i; str += '0', len++);\r\n        str = toExponential(str, e);\r\n\r\n      // Fixed-point notation.\r\n      } else {\r\n        i -= ne + (id === 2 && e > ne);\r\n        str = toFixedPoint(str, e, '0');\r\n\r\n        // Append zeros?\r\n        if (e + 1 > len) {\r\n          if (--i > 0) for (str += '.'; i--; str += '0');\r\n        } else {\r\n          i += e - len;\r\n          if (i > 0) {\r\n            if (e + 1 == len) str += '.';\r\n            for (; i--; str += '0');\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return n.s < 0 && c0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Handle BigNumber.max and BigNumber.min.\r\n  // If any number is NaN, return NaN.\r\n  function maxOrMin(args, n) {\r\n    var k, y,\r\n      i = 1,\r\n      x = new BigNumber(args[0]);\r\n\r\n    for (; i < args.length; i++) {\r\n      y = new BigNumber(args[i]);\r\n      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n   * Called by minus, plus and times.\r\n   */\r\n  function normalise(n, c, e) {\r\n    var i = 1,\r\n      j = c.length;\r\n\r\n     // Remove trailing zeros.\r\n    for (; !c[--j]; c.pop());\r\n\r\n    // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n    for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n    // Overflow?\r\n    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n      // Infinity.\r\n      n.c = n.e = null;\r\n\r\n    // Underflow?\r\n    } else if (e < MIN_EXP) {\r\n\r\n      // Zero.\r\n      n.c = [n.e = 0];\r\n    } else {\r\n      n.e = e;\r\n      n.c = c;\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n\r\n  // Handle values that fail the validity test in BigNumber.\r\n  parseNumeric = (function () {\r\n    var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n      dotAfter = /^([^.]+)\\.$/,\r\n      dotBefore = /^\\.([^.]+)$/,\r\n      isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n      whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n    return function (x, str, isNum, b) {\r\n      var base,\r\n        s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n      // No exception on ±Infinity or NaN.\r\n      if (isInfinityOrNaN.test(s)) {\r\n        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n      } else {\r\n        if (!isNum) {\r\n\r\n          // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n          s = s.replace(basePrefix, function (m, p1, p2) {\r\n            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n            return !b || b == base ? p1 : m;\r\n          });\r\n\r\n          if (b) {\r\n            base = b;\r\n\r\n            // E.g. '1.' to '1', '.1' to '0.1'\r\n            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n          }\r\n\r\n          if (str != s) return new BigNumber(s, base);\r\n        }\r\n\r\n        // '[BigNumber Error] Not a number: {n}'\r\n        // '[BigNumber Error] Not a base {b} number: {n}'\r\n        if (BigNumber.DEBUG) {\r\n          throw Error\r\n            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n        }\r\n\r\n        // NaN\r\n        x.s = null;\r\n      }\r\n\r\n      x.c = x.e = null;\r\n    }\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n   * If r is truthy, it is known that there are more digits after the rounding digit.\r\n   */\r\n  function round(x, sd, rm, r) {\r\n    var d, i, j, k, n, ni, rd,\r\n      xc = x.c,\r\n      pows10 = POWS_TEN;\r\n\r\n    // if x is not Infinity or NaN...\r\n    if (xc) {\r\n\r\n      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n      // ni is the index of n within x.c.\r\n      // d is the number of digits of n.\r\n      // i is the index of rd within n including leading zeros.\r\n      // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n      out: {\r\n\r\n        // Get the number of digits of the first element of xc.\r\n        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n        i = sd - d;\r\n\r\n        // If the rounding digit is in the first element of xc...\r\n        if (i < 0) {\r\n          i += LOG_BASE;\r\n          j = sd;\r\n          n = xc[ni = 0];\r\n\r\n          // Get the rounding digit at index j of n.\r\n          rd = mathfloor(n / pows10[d - j - 1] % 10);\r\n        } else {\r\n          ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n          if (ni >= xc.length) {\r\n\r\n            if (r) {\r\n\r\n              // Needed by sqrt.\r\n              for (; xc.length <= ni; xc.push(0));\r\n              n = rd = 0;\r\n              d = 1;\r\n              i %= LOG_BASE;\r\n              j = i - LOG_BASE + 1;\r\n            } else {\r\n              break out;\r\n            }\r\n          } else {\r\n            n = k = xc[ni];\r\n\r\n            // Get the number of digits of n.\r\n            for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n            // Get the index of rd within n.\r\n            i %= LOG_BASE;\r\n\r\n            // Get the index of rd within n, adjusted for leading zeros.\r\n            // The number of leading zeros of n is given by LOG_BASE - d.\r\n            j = i - LOG_BASE + d;\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\r\n          }\r\n        }\r\n\r\n        r = r || sd < 0 ||\r\n\r\n        // Are there any non-zero digits after the rounding digit?\r\n        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n        r = rm < 4\r\n         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n           rm == (x.s < 0 ? 8 : 7));\r\n\r\n        if (sd < 1 || !xc[0]) {\r\n          xc.length = 0;\r\n\r\n          if (r) {\r\n\r\n            // Convert sd to decimal places.\r\n            sd -= x.e + 1;\r\n\r\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n            x.e = -sd || 0;\r\n          } else {\r\n\r\n            // Zero.\r\n            xc[0] = x.e = 0;\r\n          }\r\n\r\n          return x;\r\n        }\r\n\r\n        // Remove excess digits.\r\n        if (i == 0) {\r\n          xc.length = ni;\r\n          k = 1;\r\n          ni--;\r\n        } else {\r\n          xc.length = ni + 1;\r\n          k = pows10[LOG_BASE - i];\r\n\r\n          // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n          // j > 0 means i > number of leading zeros of n.\r\n          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n        }\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          for (; ;) {\r\n\r\n            // If the digit to be rounded up is in the first element of xc...\r\n            if (ni == 0) {\r\n\r\n              // i will be the length of xc[0] before k is added.\r\n              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n              j = xc[0] += k;\r\n              for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n              // if i != k the length has increased.\r\n              if (i != k) {\r\n                x.e++;\r\n                if (xc[0] == BASE) xc[0] = 1;\r\n              }\r\n\r\n              break;\r\n            } else {\r\n              xc[ni] += k;\r\n              if (xc[ni] != BASE) break;\r\n              xc[ni--] = 0;\r\n              k = 1;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Remove trailing zeros.\r\n        for (i = xc.length; xc[--i] === 0; xc.pop());\r\n      }\r\n\r\n      // Overflow? Infinity.\r\n      if (x.e > MAX_EXP) {\r\n        x.c = x.e = null;\r\n\r\n      // Underflow? Zero.\r\n      } else if (x.e < MIN_EXP) {\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function valueOf(n) {\r\n    var str,\r\n      e = n.e;\r\n\r\n    if (e === null) return n.toString();\r\n\r\n    str = coeffToString(n.c);\r\n\r\n    str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n      ? toExponential(str, e)\r\n      : toFixedPoint(str, e, '0');\r\n\r\n    return n.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new BigNumber(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   *   0 if they have the same value,\r\n   *   or null if the value of either is NaN.\r\n   */\r\n  P.comparedTo = function (y, b) {\r\n    return compare(this, new BigNumber(y, b));\r\n  };\r\n\r\n\r\n  /*\r\n   * If dp is undefined or null or true or false, return the number of decimal places of the\r\n   * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   *\r\n   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.decimalPlaces = P.dp = function (dp, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), dp + x.e + 1, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last number.\r\n    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n    if (n < 0) n = 0;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.dividedBy = P.div = function (y, b) {\r\n    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n   * BigNumber by the value of BigNumber(y, b).\r\n   */\r\n  P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n    return div(this, new BigNumber(y, b), 0, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n   *\r\n   * If m is present, return the result modulo m.\r\n   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n   *\r\n   * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n   *\r\n   * n {number|string|BigNumber} The exponent. An integer.\r\n   * [m] {number|string|BigNumber} The modulus.\r\n   *\r\n   * '[BigNumber Error] Exponent not an integer: {n}'\r\n   */\r\n  P.exponentiatedBy = P.pow = function (n, m) {\r\n    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n      x = this;\r\n\r\n    n = new BigNumber(n);\r\n\r\n    // Allow NaN and ±Infinity, but not other non-integers.\r\n    if (n.c && !n.isInteger()) {\r\n      throw Error\r\n        (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n    }\r\n\r\n    if (m != null) m = new BigNumber(m);\r\n\r\n    // Exponent of MAX_SAFE_INTEGER is 15.\r\n    nIsBig = n.e > 14;\r\n\r\n    // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\r\n    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n      // The sign of the result of pow when x is negative depends on the evenness of n.\r\n      // If +n overflows to ±Infinity, the evenness of n would be not be known.\r\n      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\r\n      return m ? y.mod(m) : y;\r\n    }\r\n\r\n    nIsNeg = n.s < 0;\r\n\r\n    if (m) {\r\n\r\n      // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n      isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n      if (isModExp) x = x.mod(m);\r\n\r\n    // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n    // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\r\n    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n      // [1, 240000000]\r\n      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n      // [80000000000000]  [99999750000000]\r\n      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n      // If x is negative and n is odd, k = -0, else k = 0.\r\n      k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n      // If x >= 1, k = ±Infinity.\r\n      if (x.e > -1) k = 1 / k;\r\n\r\n      // If n is negative return ±0, else return ±Infinity.\r\n      return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n    } else if (POW_PRECISION) {\r\n\r\n      // Truncating each coefficient array to a length of k after each multiplication\r\n      // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n      // i.e. there will be a minimum of 28 guard digits retained.\r\n      k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n    }\r\n\r\n    if (nIsBig) {\r\n      half = new BigNumber(0.5);\r\n      if (nIsNeg) n.s = 1;\r\n      nIsOdd = isOdd(n);\r\n    } else {\r\n      i = Math.abs(+valueOf(n));\r\n      nIsOdd = i % 2;\r\n    }\r\n\r\n    y = new BigNumber(ONE);\r\n\r\n    // Performs 54 loop iterations for n of 9007199254740991.\r\n    for (; ;) {\r\n\r\n      if (nIsOdd) {\r\n        y = y.times(x);\r\n        if (!y.c) break;\r\n\r\n        if (k) {\r\n          if (y.c.length > k) y.c.length = k;\r\n        } else if (isModExp) {\r\n          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (i) {\r\n        i = mathfloor(i / 2);\r\n        if (i === 0) break;\r\n        nIsOdd = i % 2;\r\n      } else {\r\n        n = n.times(half);\r\n        round(n, n.e + 1, 1);\r\n\r\n        if (n.e > 14) {\r\n          nIsOdd = isOdd(n);\r\n        } else {\r\n          i = +valueOf(n);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        }\r\n      }\r\n\r\n      x = x.times(x);\r\n\r\n      if (k) {\r\n        if (x.c && x.c.length > k) x.c.length = k;\r\n      } else if (isModExp) {\r\n        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n      }\r\n    }\r\n\r\n    if (isModExp) return y;\r\n    if (nIsNeg) y = ONE.div(y);\r\n\r\n    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n   */\r\n  P.integerValue = function (rm) {\r\n    var n = new BigNumber(this);\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n    return round(n, n.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isEqualTo = P.eq = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.c;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isGreaterThan = P.gt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n   */\r\n  P.isInteger = function () {\r\n    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isLessThan = P.lt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is negative, otherwise return false.\r\n   */\r\n  P.isNegative = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is positive, otherwise return false.\r\n   */\r\n  P.isPositive = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.c && this.c[0] == 0;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.minus = function (y, b) {\r\n    var i, j, t, xLTy,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Either Infinity?\r\n      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n      // Either zero?\r\n      if (!xc[0] || !yc[0]) {\r\n\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n         ROUNDING_MODE == 3 ? -0 : 0);\r\n      }\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Determine which is the bigger number.\r\n    if (a = xe - ye) {\r\n\r\n      if (xLTy = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      for (b = a; b--; t.push(0));\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n\r\n        if (xc[b] != yc[b]) {\r\n          xLTy = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xLTy) {\r\n      t = xc;\r\n      xc = yc;\r\n      yc = t;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    b = (j = yc.length) - (i = xc.length);\r\n\r\n    // Append zeros to xc if shorter.\r\n    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n    if (b > 0) for (; b--; xc[i++] = 0);\r\n    b = BASE - 1;\r\n\r\n    // Subtract yc from xc.\r\n    for (; j > a;) {\r\n\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i]; xc[i] = b);\r\n        --xc[i];\r\n        xc[j] += BASE;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n    // Zero?\r\n    if (!xc[0]) {\r\n\r\n      // Following IEEE 754 (2008) 6.3,\r\n      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n      y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n    // for finite x and y.\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n   * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n   */\r\n  P.modulo = P.mod = function (y, b) {\r\n    var q, s,\r\n      x = this;\r\n\r\n    y = new BigNumber(y, b);\r\n\r\n    // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n    if (!x.c || !y.s || y.c && !y.c[0]) {\r\n      return new BigNumber(NaN);\r\n\r\n    // Return x if y is Infinity or x is zero.\r\n    } else if (!y.c || x.c && !x.c[0]) {\r\n      return new BigNumber(x);\r\n    }\r\n\r\n    if (MODULO_MODE == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // r = x - qy    where  0 <= r < abs(y)\r\n      s = y.s;\r\n      y.s = 1;\r\n      q = div(x, y, 0, 3);\r\n      y.s = s;\r\n      q.s *= s;\r\n    } else {\r\n      q = div(x, y, 0, MODULO_MODE);\r\n    }\r\n\r\n    y = x.minus(q.times(y));\r\n\r\n    // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n   * of BigNumber(y, b).\r\n   */\r\n  P.multipliedBy = P.times = function (y, b) {\r\n    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n      base, sqrtBase,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new BigNumber(y, b)).c;\r\n\r\n    // Either NaN, ±Infinity or ±0?\r\n    if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n      // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n        y.c = y.e = y.s = null;\r\n      } else {\r\n        y.s *= x.s;\r\n\r\n        // Return ±Infinity if either is ±Infinity.\r\n        if (!xc || !yc) {\r\n          y.c = y.e = null;\r\n\r\n        // Return ±0 if either is ±0.\r\n        } else {\r\n          y.c = [0];\r\n          y.e = 0;\r\n        }\r\n      }\r\n\r\n      return y;\r\n    }\r\n\r\n    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n    y.s *= x.s;\r\n    xcL = xc.length;\r\n    ycL = yc.length;\r\n\r\n    // Ensure xc points to longer array and xcL to its length.\r\n    if (xcL < ycL) {\r\n      zc = xc;\r\n      xc = yc;\r\n      yc = zc;\r\n      i = xcL;\r\n      xcL = ycL;\r\n      ycL = i;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n    base = BASE;\r\n    sqrtBase = SQRT_BASE;\r\n\r\n    for (i = ycL; --i >= 0;) {\r\n      c = 0;\r\n      ylo = yc[i] % sqrtBase;\r\n      yhi = yc[i] / sqrtBase | 0;\r\n\r\n      for (k = xcL, j = i + k; j > i;) {\r\n        xlo = xc[--k] % sqrtBase;\r\n        xhi = xc[k] / sqrtBase | 0;\r\n        m = yhi * xlo + xhi * ylo;\r\n        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n        zc[j--] = xlo % base;\r\n      }\r\n\r\n      zc[j] = c;\r\n    }\r\n\r\n    if (c) {\r\n      ++e;\r\n    } else {\r\n      zc.splice(0, 1);\r\n    }\r\n\r\n    return normalise(y, zc, e);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n   * i.e. multiplied by -1.\r\n   */\r\n  P.negated = function () {\r\n    var x = new BigNumber(this);\r\n    x.s = -x.s || null;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.plus = function (y, b) {\r\n    var t,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n     if (a != b) {\r\n      y.s = -b;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Return ±Infinity if either ±Infinity.\r\n      if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n      // Either zero?\r\n      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n    if (a = xe - ye) {\r\n      if (a > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        a = -a;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; a--; t.push(0));\r\n      t.reverse();\r\n    }\r\n\r\n    a = xc.length;\r\n    b = yc.length;\r\n\r\n    // Point xc to the longer array, and b to the shorter length.\r\n    if (a - b < 0) {\r\n      t = yc;\r\n      yc = xc;\r\n      xc = t;\r\n      b = a;\r\n    }\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n    for (a = 0; b;) {\r\n      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n    }\r\n\r\n    if (a) {\r\n      xc = [a].concat(xc);\r\n      ++ye;\r\n    }\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    // ye = MAX_EXP + 1 possible\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   * If sd is undefined or null or true or false, return the number of significant digits of\r\n   * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   * If sd is true include integer-part trailing zeros in the count.\r\n   *\r\n   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n   *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.precision = P.sd = function (sd, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (sd != null && sd !== !!sd) {\r\n      intCheck(sd, 1, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), sd, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    v = c.length - 1;\r\n    n = v * LOG_BASE + 1;\r\n\r\n    if (v = c[v]) {\r\n\r\n      // Subtract the number of trailing zeros of the last element.\r\n      for (; v % 10 == 0; v /= 10, n--);\r\n\r\n      // Add the number of digits of the first element.\r\n      for (v = c[0]; v >= 10; v /= 10, n++);\r\n    }\r\n\r\n    if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n   *\r\n   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n   */\r\n  P.shiftedBy = function (k) {\r\n    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n    return this.times('1e' + k);\r\n  };\r\n\r\n\r\n  /*\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N) =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I) =  I\r\n   *  sqrt(0) =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, r, rep, t,\r\n      x = this,\r\n      c = x.c,\r\n      s = x.s,\r\n      e = x.e,\r\n      dp = DECIMAL_PLACES + 4,\r\n      half = new BigNumber('0.5');\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !c || !c[0]) {\r\n      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n    }\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+valueOf(x));\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = coeffToString(c);\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(+n);\r\n      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new BigNumber(n);\r\n    } else {\r\n      r = new BigNumber(s + '');\r\n    }\r\n\r\n    // Check for zero.\r\n    // r could be zero if MIN_EXP is changed after the this value was created.\r\n    // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n    // coeffToString to throw.\r\n    if (r.c[0]) {\r\n      e = r.e;\r\n      s = e + dp;\r\n      if (s < 3) s = 0;\r\n\r\n      // Newton-Raphson iteration.\r\n      for (; ;) {\r\n        t = r;\r\n        r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n          // The exponent of r may here be one less than the final result exponent,\r\n          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n          // are indexed correctly.\r\n          if (r.e < e) --s;\r\n          n = n.slice(s - 3, s + 1);\r\n\r\n          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n          // iteration.\r\n          if (n == '9999' || !rep && n == '4999') {\r\n\r\n            // On the first iteration only, check to see if rounding up gives the\r\n            // exact result as the nines may infinitely repeat.\r\n            if (!rep) {\r\n              round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n              if (t.times(t).eq(x)) {\r\n                r = t;\r\n                break;\r\n              }\r\n            }\r\n\r\n            dp += 4;\r\n            s += 4;\r\n            rep = 1;\r\n          } else {\r\n\r\n            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n            // result. If not, then there are further digits and m will be truthy.\r\n            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n              // Truncate to the first rounding digit.\r\n              round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n              m = !r.times(r).eq(x);\r\n            }\r\n\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in exponential notation and\r\n   * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp++;\r\n    }\r\n    return format(this, dp, rm, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n   * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp = dp + this.e + 1;\r\n    }\r\n    return format(this, dp, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n   * of the format or FORMAT object (see BigNumber.set).\r\n   *\r\n   * The formatting object may contain some or all of the properties shown below.\r\n   *\r\n   * FORMAT = {\r\n   *   prefix: '',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   groupSeparator: ',',\r\n   *   decimalSeparator: '.',\r\n   *   fractionGroupSize: 0,\r\n   *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n   *   suffix: ''\r\n   * };\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   * [format] {object} Formatting options. See FORMAT pbject above.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   * '[BigNumber Error] Argument not an object: {format}'\r\n   */\r\n  P.toFormat = function (dp, rm, format) {\r\n    var str,\r\n      x = this;\r\n\r\n    if (format == null) {\r\n      if (dp != null && rm && typeof rm == 'object') {\r\n        format = rm;\r\n        rm = null;\r\n      } else if (dp && typeof dp == 'object') {\r\n        format = dp;\r\n        dp = rm = null;\r\n      } else {\r\n        format = FORMAT;\r\n      }\r\n    } else if (typeof format != 'object') {\r\n      throw Error\r\n        (bignumberError + 'Argument not an object: ' + format);\r\n    }\r\n\r\n    str = x.toFixed(dp, rm);\r\n\r\n    if (x.c) {\r\n      var i,\r\n        arr = str.split('.'),\r\n        g1 = +format.groupSize,\r\n        g2 = +format.secondaryGroupSize,\r\n        groupSeparator = format.groupSeparator || '',\r\n        intPart = arr[0],\r\n        fractionPart = arr[1],\r\n        isNeg = x.s < 0,\r\n        intDigits = isNeg ? intPart.slice(1) : intPart,\r\n        len = intDigits.length;\r\n\r\n      if (g2) {\r\n        i = g1;\r\n        g1 = g2;\r\n        g2 = i;\r\n        len -= i;\r\n      }\r\n\r\n      if (g1 > 0 && len > 0) {\r\n        i = len % g1 || g1;\r\n        intPart = intDigits.substr(0, i);\r\n        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n        if (isNeg) intPart = '-' + intPart;\r\n      }\r\n\r\n      str = fractionPart\r\n       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n        ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n         '$&' + (format.fractionGroupSeparator || ''))\r\n        : fractionPart)\r\n       : intPart;\r\n    }\r\n\r\n    return (format.prefix || '') + str + (format.suffix || '');\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to the specified\r\n   * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n   * the lowest value necessary to represent the number exactly.\r\n   *\r\n   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n   *\r\n   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n   */\r\n  P.toFraction = function (md) {\r\n    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n      x = this,\r\n      xc = x.c;\r\n\r\n    if (md != null) {\r\n      n = new BigNumber(md);\r\n\r\n      // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n        throw Error\r\n          (bignumberError + 'Argument ' +\r\n            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n      }\r\n    }\r\n\r\n    if (!xc) return new BigNumber(x);\r\n\r\n    d = new BigNumber(ONE);\r\n    n1 = d0 = new BigNumber(ONE);\r\n    d1 = n0 = new BigNumber(ONE);\r\n    s = coeffToString(xc);\r\n\r\n    // Determine initial denominator.\r\n    // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n    e = d.e = s.length - x.e - 1;\r\n    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n    exp = MAX_EXP;\r\n    MAX_EXP = 1 / 0;\r\n    n = new BigNumber(s);\r\n\r\n    // n0 = d1 = 0\r\n    n0.c[0] = 0;\r\n\r\n    for (; ;)  {\r\n      q = div(n, d, 0, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.comparedTo(md) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      n1 = n0.plus(q.times(d2 = n1));\r\n      n0 = d2;\r\n      d = n.minus(q.times(d2 = d));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = div(md.minus(d0), d1, 0, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n    e = e * 2;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n    MAX_EXP = exp;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this BigNumber converted to a number primitive.\r\n   */\r\n  P.toNumber = function () {\r\n    return +valueOf(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n   * necessary to represent the integer part of the value in fixed-point notation, then use\r\n   * exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    if (sd != null) intCheck(sd, 1, MAX);\r\n    return format(this, sd, rm, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n   * TO_EXP_NEG, return exponential notation.\r\n   *\r\n   * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n   *\r\n   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n   */\r\n  P.toString = function (b) {\r\n    var str,\r\n      n = this,\r\n      s = n.s,\r\n      e = n.e;\r\n\r\n    // Infinity or NaN?\r\n    if (e === null) {\r\n      if (s) {\r\n        str = 'Infinity';\r\n        if (s < 0) str = '-' + str;\r\n      } else {\r\n        str = 'NaN';\r\n      }\r\n    } else {\r\n      if (b == null) {\r\n        str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n         ? toExponential(coeffToString(n.c), e)\r\n         : toFixedPoint(coeffToString(n.c), e, '0');\r\n      } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n        str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n      } else {\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n      }\r\n\r\n      if (s < 0 && n.c[0]) str = '-' + str;\r\n    }\r\n\r\n    return str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return as toString, but do not accept a base argument, and include the minus sign for\r\n   * negative zero.\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    return valueOf(this);\r\n  };\r\n\r\n\r\n  P._isBigNumber = true;\r\n\r\n  P[Symbol.toStringTag] = 'BigNumber';\r\n\r\n  // Node.js v10.12.0+\r\n  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;\r\n\r\n  if (configObject != null) BigNumber.set(configObject);\r\n\r\n  return BigNumber;\r\n}\r\n\r\n\r\n// PRIVATE HELPER FUNCTIONS\r\n\r\n// These functions don't need access to variables,\r\n// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\nfunction bitFloor(n) {\r\n  var i = n | 0;\r\n  return n > 0 || n === i ? i : i - 1;\r\n}\r\n\r\n\r\n// Return a coefficient array as a string of base 10 digits.\r\nfunction coeffToString(a) {\r\n  var s, z,\r\n    i = 1,\r\n    j = a.length,\r\n    r = a[0] + '';\r\n\r\n  for (; i < j;) {\r\n    s = a[i++] + '';\r\n    z = LOG_BASE - s.length;\r\n    for (; z--; s = '0' + s);\r\n    r += s;\r\n  }\r\n\r\n  // Determine trailing zeros.\r\n  for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n  return r.slice(0, j + 1 || 1);\r\n}\r\n\r\n\r\n// Compare the value of BigNumbers x and y.\r\nfunction compare(x, y) {\r\n  var a, b,\r\n    xc = x.c,\r\n    yc = y.c,\r\n    i = x.s,\r\n    j = y.s,\r\n    k = x.e,\r\n    l = y.e;\r\n\r\n  // Either NaN?\r\n  if (!i || !j) return null;\r\n\r\n  a = xc && !xc[0];\r\n  b = yc && !yc[0];\r\n\r\n  // Either zero?\r\n  if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n  // Signs differ?\r\n  if (i != j) return i;\r\n\r\n  a = i < 0;\r\n  b = k == l;\r\n\r\n  // Either Infinity?\r\n  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n  // Compare exponents.\r\n  if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n  j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n  // Compare digit by digit.\r\n  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n  // Compare lengths.\r\n  return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n}\r\n\r\n\r\n/*\r\n * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n */\r\nfunction intCheck(n, min, max, name) {\r\n  if (n < min || n > max || n !== mathfloor(n)) {\r\n    throw Error\r\n     (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n       ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n       : ' not a primitive number: ') + String(n));\r\n  }\r\n}\r\n\r\n\r\n// Assumes finite n.\r\nfunction isOdd(n) {\r\n  var k = n.c.length - 1;\r\n  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n}\r\n\r\n\r\nfunction toExponential(str, e) {\r\n  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n   (e < 0 ? 'e' : 'e+') + e;\r\n}\r\n\r\n\r\nfunction toFixedPoint(str, e, z) {\r\n  var len, zs;\r\n\r\n  // Negative exponent?\r\n  if (e < 0) {\r\n\r\n    // Prepend zeros.\r\n    for (zs = z + '.'; ++e; zs += z);\r\n    str = zs + str;\r\n\r\n  // Positive exponent\r\n  } else {\r\n    len = str.length;\r\n\r\n    // Append zeros.\r\n    if (++e > len) {\r\n      for (zs = z, e -= len; --e; zs += z);\r\n      str += zs;\r\n    } else if (e < len) {\r\n      str = str.slice(0, e) + '.' + str.slice(e);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n\r\n// EXPORT\r\n\r\n\r\nvar BigNumber = clone();\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BigNumber);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaGVkZXJhLWFnZW50LWtpdC9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdURBQXVEO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxrQ0FBa0MsbURBQW1ELEdBQUcsR0FBRztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUVBQWUsU0FBUyxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9oZWRlcmEtYWdlbnQta2l0L25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4zLjFcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyNSBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbnZhclxyXG4gIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgdG9vTWFueURpZ2l0cyA9IGJpZ251bWJlckVycm9yICsgJ051bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6ICcsXHJcblxyXG4gIEJBU0UgPSAxZTE0LFxyXG4gIExPR19CQVNFID0gMTQsXHJcbiAgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYsICAgICAgICAgLy8gMl41MyAtIDFcclxuICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgU1FSVF9CQVNFID0gMWU3LFxyXG5cclxuICAvLyBFRElUQUJMRVxyXG4gIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gIC8vIHRoZSBhcmd1bWVudHMgdG8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQsIGFuZCB0b1ByZWNpc2lvbi5cclxuICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbi8qXHJcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxyXG4gKi9cclxuZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgdmFyIGRpdiwgY29udmVydEJhc2UsIHBhcnNlTnVtZXJpYyxcclxuICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUQUJMRSBDT05GSUcgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbi5cclxuICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgLy8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQgYW5kIHRvUHJlY2lzaW9uLCBhbmQgcm91bmQgKGRlZmF1bHQgdmFsdWUpLlxyXG4gICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgIC8vIENFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAvLyBIQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgLy8gSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAvL1xyXG4gICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAvLyBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgIC8vIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgLy8gICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgIC8vIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiB0aGUgZXhwb25lbnRpYXRlZEJ5IG9wZXJhdGlvbi5cclxuICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgIEZPUk1BVCA9IHtcclxuICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgc3VmZml4OiAnJ1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgIC8vICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAvLyAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXydcclxuICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXHJcbiAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB0cnVlO1xyXG5cclxuXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAvKlxyXG4gICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgKlxyXG4gICAqIHYge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBCaWdOdW1iZXIodiwgYikge1xyXG4gICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IGBuZXdgLlxyXG4gICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgIGlmIChiID09IG51bGwpIHtcclxuXHJcbiAgICAgIGlmICh2ICYmIHYuX2lzQmlnTnVtYmVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICBpZiAoIXYuYyB8fCB2LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICB4LmMgPSB2LmMuc2xpY2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSAmJiB2ICogMCA9PSAwKSB7XHJcblxyXG4gICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHYgPSAtdiwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycywgd2hlcmUgbiA8IDIxNDc0ODM2NDggKDIqKjMxKS5cclxuICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrKTtcclxuXHJcbiAgICAgICAgICBpZiAoZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuXHJcbiAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAvLyBhbHNvIHJvdW5kaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgIGlmIChiID09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgIHJldHVybiByb3VuZCh4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICBpZiAoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXHJcbiAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyB2KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYWxwaGFiZXQgPSBBTFBIQUJFVC5zbGljZSgwLCBiKTtcclxuICAgICAgZSA9IGkgPSAwO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAvLyBEb24ndCB1c2UgUmVnRXhwLCBzbyBhbHBoYWJldCBjYW4gY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiAnLicgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGl0IGhhcyBub3QgYmUgZm91bmQgYmVmb3JlLlxyXG4gICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICBlID0gbGVuO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjYXNlQ2hhbmdlZCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQWxsb3cgZS5nLiBoZXhhZGVjaW1hbCAnRkYnIGFzIHdlbGwgYXMgJ2ZmJy5cclxuICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgIGNhc2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKHgsIFN0cmluZyh2KSwgaXNOdW0sIGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ciwgYiwgMTAsIHgucyk7XHJcblxyXG4gICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgZWxzZSBlID0gc3RyLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICBpZiAoc3RyID0gc3RyLnNsaWNlKGksICsrbGVuKSkge1xyXG4gICAgICBsZW4gLT0gaTtcclxuXHJcbiAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgIGlmIChpc051bSAmJiBCaWdOdW1iZXIuREVCVUcgJiZcclxuICAgICAgICBsZW4gPiAxNSAmJiAodiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdiAhPT0gbWF0aGZsb29yKHYpKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAodG9vTWFueURpZ2l0cyArICh4LnMgKiB2KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKChlID0gZSAtIGkgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG5cclxuICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICB4LmMucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgeC5jLnB1c2goK3N0cik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBaZXJvLlxyXG4gICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgQmlnTnVtYmVyLmNsb25lID0gY2xvbmU7XHJcblxyXG4gIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAqXHJcbiAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgKiBhIG51bWJlciwgaXQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIHN0YXRlZCk6XHJcbiAgICpcclxuICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICogICBST1VORElOR19NT0RFICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDhcclxuICAgKiAgIEVYUE9ORU5USUFMX0FUICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYICBvciAgWy1NQVggdG8gMCwgMCB0byBNQVhdXHJcbiAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAqICAgQ1JZUFRPICAgICAgICAgICB7Ym9vbGVhbn0gICAgICAgICAgdHJ1ZSBvciBmYWxzZVxyXG4gICAqICAgTU9EVUxPX01PREUgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA5XHJcbiAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAqICAgQUxQSEFCRVQgICAgICAgICB7c3RyaW5nfSAgICAgICAgICAgQSBzdHJpbmcgb2YgdHdvIG9yIG1vcmUgdW5pcXVlIGNoYXJhY3RlcnMgd2hpY2ggZG9lc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvbnRhaW4gJy4nLlxyXG4gICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICogICAgIHByZWZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgKiAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICogICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cclxuICAgKiAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICogICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cclxuICAgKiAgICAgc3VmZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAqXHJcbiAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgKlxyXG4gICAqIEUuZy5cclxuICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgKlxyXG4gICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxyXG4gICAqL1xyXG4gIEJpZ051bWJlci5jb25maWcgPSBCaWdOdW1iZXIuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgdmFyIHAsIHY7XHJcblxyXG4gICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnREVDSU1BTF9QTEFDRVMnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJPVU5ESU5HX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdST1VORElOR19NT0RFJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpbnRDaGVjayh2LCAwLCA4LCBwKTtcclxuICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBFWFBPTkVOVElBTF9BVCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0VYUE9ORU5USUFMX0FUJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAwLCBwKTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF07XHJcbiAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oVE9fRVhQX1BPUyA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJBTkdFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZXxjYW5ub3QgYmUgemVyb306IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUkFOR0UnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIC0xLCBwKTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF07XHJcbiAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQ1JZUFRPIG5vdCB0cnVlIG9yIGZhbHNlOiB7dn0nXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQ1JZUFRPJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvICYmXHJcbiAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTU9EVUxPX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdNT0RVTE9fTU9ERScpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaW50Q2hlY2sodiwgMCwgOSwgcCk7XHJcbiAgICAgICAgICBNT0RVTE9fTU9ERSA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUE9XX1BSRUNJU0lPTiB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdGT1JNQVQnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgIGVsc2UgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgYW4gb2JqZWN0OiAnICsgdik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBTFBIQUJFVCB7c3RyaW5nfVxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBBTFBIQUJFVCBpbnZhbGlkOiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcblxyXG4gICAgICAgICAgLy8gRGlzYWxsb3cgaWYgbGVzcyB0aGFuIHR3byBjaGFyYWN0ZXJzLFxyXG4gICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ3N0cmluZycgJiYgIS9eLj8kfFsrXFwtLlxcc118KC4pLipcXDEvLnRlc3QodikpIHtcclxuICAgICAgICAgICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdi5zbGljZSgwLCAxMCkgPT0gJzAxMjM0NTY3ODknO1xyXG4gICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBPYmplY3QgZXhwZWN0ZWQ6IHt2fSdcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTOiBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgUk9VTkRJTkdfTU9ERTogUk9VTkRJTkdfTU9ERSxcclxuICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgUkFOR0U6IFtNSU5fRVhQLCBNQVhfRVhQXSxcclxuICAgICAgQ1JZUFRPOiBDUllQVE8sXHJcbiAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgUE9XX1BSRUNJU0lPTjogUE9XX1BSRUNJU0lPTixcclxuICAgICAgRk9STUFUOiBGT1JNQVQsXHJcbiAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB2IGlzIGEgQmlnTnVtYmVyIGluc3RhbmNlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgKlxyXG4gICAqIHYge2FueX1cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBJbnZhbGlkIEJpZ051bWJlcjoge3Z9J1xyXG4gICAqL1xyXG4gIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICBpZiAoIXYgfHwgdi5faXNCaWdOdW1iZXIgIT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgIGlmICghQmlnTnVtYmVyLkRFQlVHKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICB2YXIgaSwgbixcclxuICAgICAgYyA9IHYuYyxcclxuICAgICAgZSA9IHYuZSxcclxuICAgICAgcyA9IHYucztcclxuXHJcbiAgICBvdXQ6IGlmICh7fS50b1N0cmluZy5jYWxsKGMpID09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuXHJcbiAgICAgIGlmICgocyA9PT0gMSB8fCBzID09PSAtMSkgJiYgZSA+PSAtTUFYICYmIGUgPD0gTUFYICYmIGUgPT09IG1hdGhmbG9vcihlKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICBpZiAoY1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgaWYgKGUgPT09IDAgJiYgYy5sZW5ndGggPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgdGhhdCBjWzBdIHNob3VsZCBoYXZlLCBiYXNlZCBvbiB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICBpZiAoaSA8IDEpIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgIGlmIChTdHJpbmcoY1swXSkubGVuZ3RoID09IGkpIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gQkFTRSB8fCBuICE9PSBtYXRoZmxvb3IobikpIGJyZWFrIG91dDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgaWYgKG4gIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgfSBlbHNlIGlmIChjID09PSBudWxsICYmIGUgPT09IG51bGwgJiYgKHMgPT09IG51bGwgfHwgcyA9PT0gMSB8fCBzID09PSAtMSkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgRXJyb3JcclxuICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAqXHJcbiAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgKi9cclxuICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCAtMSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAqXHJcbiAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgKi9cclxuICBCaWdOdW1iZXIubWluaW11bSA9IEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCAxKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfSdcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAqL1xyXG4gIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAvLyBDaGVjayBpZiBNYXRoLnJhbmRvbSgpIHByb2R1Y2VzIG1vcmUgdGhhbiAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXHJcbiAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICB2YXIgcmFuZG9tNTNiaXRJbnQgPSAoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpICYgMHgxZmZmZmZcclxuICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICBpID0gMCxcclxuICAgICAgICBjID0gW10sXHJcbiAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgIGlmIChkcCA9PSBudWxsKSBkcCA9IERFQ0lNQUxfUExBQ0VTO1xyXG4gICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgayA9IG1hdGhjZWlsKGRwIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuXHJcbiAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoayAqPSAyKSk7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSk7XHJcbiAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XHJcbiAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpID0gayAvIDI7XHJcblxyXG4gICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgIChhW2kgKyAyXSAqIDB4MTAwMDAwMDAwKSArIChhW2kgKyAzXSAqIDB4MTAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAoYVtpICsgNF0gPDwgMTYpICsgKGFbaSArIDVdIDw8IDgpICsgYVtpICsgNl07XHJcblxyXG4gICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoYSwgaSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgaWYgKHYgPCA5ZTE1KSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGsgPSBjWy0taV07XHJcbiAgICAgIGRwICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICBpZiAoayAmJiBkcCkge1xyXG4gICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cclxuICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICBmb3IgKGkgPSAxLCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICBpZiAoaSA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgcmFuZC5jID0gYztcclxuICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICB9O1xyXG4gIH0pKCk7XHJcblxyXG5cclxuICAgLypcclxuICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAqXHJcbiAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgKi9cclxuICBCaWdOdW1iZXIuc3VtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGkgPSAxLFxyXG4gICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICBzdW0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICByZXR1cm4gc3VtO1xyXG4gIH07XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgLy8gQ2FsbGVkIGJ5IEJpZ051bWJlciBhbmQgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5cclxuICBjb252ZXJ0QmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29udmVydCBzdHJpbmcgb2YgYmFzZUluIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYmFzZU91dC5cclxuICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAqIEVnLiB0b0Jhc2VPdXQoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICB2YXIgaixcclxuICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgYXJyTCxcclxuICAgICAgICBpID0gMCxcclxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluKTtcclxuXHJcbiAgICAgICAgYXJyWzBdICs9IGFscGhhYmV0LmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PSBudWxsKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgdG9TdHJpbmcsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZSAxMCB0byBiYXNlT3V0LlxyXG4gICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgYmFzZUluLCBiYXNlT3V0LCBzaWduLCBjYWxsZXJJc1RvU3RyaW5nKSB7XHJcbiAgICAgIHZhciBhbHBoYWJldCwgZCwgZSwgaywgciwgeCwgeGMsIHksXHJcbiAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgeCA9IHkucG93KHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuXHJcbiAgICAgICAgeS5jID0gdG9CYXNlT3V0KHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKHguYyksIHguZSwgJzAnKSxcclxuICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgeGMgPSB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGNhbGxlcklzVG9TdHJpbmdcclxuICAgICAgID8gKGFscGhhYmV0ID0gQUxQSEFCRVQsIGRlY2ltYWwpXHJcbiAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgYXMgYW4gaW50ZWdlciBhbmQgY29udmVydGVkIHRvIGJhc2VPdXQuIGUgaXMgdGhlIGV4cG9uZW50LlxyXG4gICAgICBlID0gayA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgIC8vIERvZXMgc3RyIHJlcHJlc2VudCBhbiBpbnRlZ2VyPyBJZiBzbywgbm8gbmVlZCBmb3IgdGhlIGRpdmlzaW9uLlxyXG4gICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAtLWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeC5jID0geGM7XHJcbiAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgIHIgPSB4LnI7XHJcbiAgICAgICAgZSA9IHguZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGNvbnZlcnRlZCB0byBiYXNlT3V0LlxyXG5cclxuICAgICAgLy8gVGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQ6IHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgIC8vIExvb2sgYXQgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhbmQgbW9kZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byByb3VuZCB1cC5cclxuXHJcbiAgICAgIGsgPSBiYXNlT3V0IC8gMjtcclxuICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICByID0gcm0gPCA0ID8gKGkgIT0gbnVsbCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiYgeGNbZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBub3QgZ3JlYXRlciB0aGFuIHplcm8sIG9yIHhjIHJlcHJlc2VudHNcclxuICAgICAgLy8gemVybywgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBiYXNlIGNvbnZlcnNpb24gaXMgemVybyBvciwgaWYgcm91bmRpbmcgdXAsIGEgdmFsdWVcclxuICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICBpZiAoZCA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIDFeLWRwIG9yIDBcclxuICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0ZSB4YyB0byB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgIGZvciAoLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0Oykge1xyXG4gICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgeGMgPSBbMV0uY29uY2F0KHhjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoayA9IHhjLmxlbmd0aDsgIXhjWy0ta107KTtcclxuXHJcbiAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVyb3MsIGRlY2ltYWwgcG9pbnQgYW5kIHRyYWlsaW5nIHplcm9zIGFzIHJlcXVpcmVkLlxyXG4gICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsIGFscGhhYmV0LmNoYXJBdCgwKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG4gIH0pKCk7XHJcblxyXG5cclxuICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgIGZ1bmN0aW9uIG11bHRpcGx5KHgsIGssIGJhc2UpIHtcclxuICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICBpID0geC5sZW5ndGgsXHJcbiAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOykge1xyXG4gICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcclxuICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICBjYXJyeSA9ICh0ZW1wIC8gYmFzZSB8IDApICsgKG0gLyBTUVJUX0JBU0UgfCAwKSArIGtoaSAqIHhoaTtcclxuICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjYXJyeSkgeCA9IFtjYXJyeV0uY29uY2F0KHgpO1xyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXHJcbiAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgaWYgKCF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcclxuXHJcbiAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXHJcbiAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IDA7IHljW2ldID09ICh4Y1tpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgaWYgKHMgPCAwKSB7XHJcbiAgICAgICAgcWMucHVzaCgxKTtcclxuICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICBpID0gMDtcclxuICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgbiA9IG1hdGhmbG9vcihiYXNlIC8gKHljWzBdICsgMSkpO1xyXG5cclxuICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gaGFuZGxlIG9kZCBiYXNlcyB3aGVyZSB5Y1swXSA9PSAoYmFzZSAvIDIpIC0gMS5cclxuICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgIGlmIChuID4gMSkge1xyXG4gICAgICAgICAgeWMgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgIHJlbSA9IHhjLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyByZW1bcmVtTCsrXSA9IDApO1xyXG4gICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICB5eiA9IFswXS5jb25jYXQoeXopO1xyXG4gICAgICAgIHljMCA9IHljWzBdO1xyXG4gICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxyXG4gICAgICAgIC8vIGVsc2UgaWYgKGJhc2UgPT0gMyAmJiB5YzAgPT0gMSkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IocmVtMCAvIHljMCk7XHJcblxyXG4gICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgIC8vICBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgLy8gIElmIHByb2R1Y3QgaXMgZ3JlYXRlciB0aGFuIHJlbWFpbmRlcjpcclxuICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgLy8gIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IHdhcyBsZXNzIHRoYW4gcmVtYWluZGVyIGF0IHRoZSBsYXN0IGNvbXBhcmU6XHJcbiAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgLy8gICAgSWYgcmVtYWluZGVyIGlzIGdyZWF0ZXIgdGhhbiBkaXZpc29yOlxyXG4gICAgICAgICAgICAvLyAgICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIsIGluY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuXHJcbiAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0ID4gcmVtYWluZGVyIHRoZW4gdHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5YywgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgIC8vIElmIG4gaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3csXHJcbiAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICBpZiAobiA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgcHJvZCA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZCA9IFswXS5jb25jYXQocHJvZCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgaWYgKHJlbVswXSkge1xyXG4gICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVtID0gW3hjW3hpXV07XHJcbiAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwpICYmIHMtLSk7XHJcblxyXG4gICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgIGlmICghcWNbMF0pIHFjLnNwbGljZSgwLCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgZm9yIChpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcS5lID0gZTtcclxuICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHE7XHJcbiAgICB9O1xyXG4gIH0pKCk7XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZ051bWJlciBuIGluIGZpeGVkLXBvaW50IG9yIGV4cG9uZW50aWFsXHJcbiAgICogbm90YXRpb24gcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgKlxyXG4gICAqIG46IGEgQmlnTnVtYmVyLlxyXG4gICAqIGk6IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAqIGlkOiAxICh0b0V4cG9uZW50aWFsKSBvciAyICh0b1ByZWNpc2lvbikuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgIGlmICghbi5jKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgIGMwID0gbi5jWzBdO1xyXG4gICAgbmUgPSBuLmU7XHJcblxyXG4gICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgbmUpXHJcbiAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIG5lLCAnMCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIGksIHJtKTtcclxuXHJcbiAgICAgIC8vIG4uZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSB3YXMgcm91bmRlZCB1cC5cclxuICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIGlmIChpZCA9PSAxIHx8IGlkID09IDIgJiYgKGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcpKSB7XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoc3RyLCBlKTtcclxuXHJcbiAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgLT0gbmUgKyAoaWQgPT09IDIgJiYgZSA+IG5lKTtcclxuICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgZnVuY3Rpb24gbWF4T3JNaW4oYXJncywgbikge1xyXG4gICAgdmFyIGssIHksXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICB4ID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYXJnc1tpXSk7XHJcbiAgICAgIGlmICgheS5zIHx8IChrID0gY29tcGFyZSh4LCB5KSkgPT09IG4gfHwgayA9PT0gMCAmJiB4LnMgPT09IG4pIHtcclxuICAgICAgICB4ID0geTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgdmFyIGkgPSAxLFxyXG4gICAgICBqID0gYy5sZW5ndGg7XHJcblxyXG4gICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAvLyBPdmVyZmxvdz9cclxuICAgIGlmICgoZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgIC8vIFVuZGVyZmxvdz9cclxuICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgIC8vIFplcm8uXHJcbiAgICAgIG4uYyA9IFtuLmUgPSAwXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4uZSA9IGU7XHJcbiAgICAgIG4uYyA9IGM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG47XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXHJcbiAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcclxuICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICBpZiAoaXNJbmZpbml0eU9yTmFOLnRlc3QocykpIHtcclxuICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIWlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICBiYXNlID0gKHAyID0gcDIudG9Mb3dlckNhc2UoKSkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGRvdEFmdGVyLCAnJDEnKS5yZXBsYWNlKGRvdEJlZm9yZSwgJzAuJDEnKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOYU5cclxuICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0pKCk7XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICByZCA9IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKGogPCAwID8gbiA6IG4gJSBwb3dzMTBbZCAtIGogLSAxXSk7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgPyAocmQgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IG4gLyBwb3dzMTBbZCAtIGpdIDogMCA6IHhjW25pIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG4gICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbMF0gPT0gQkFTRSkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgaWYgKHhjW25pXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICBpZiAoeC5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoeC5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHZhbHVlT2Yobikge1xyXG4gICAgdmFyIHN0cixcclxuICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICBpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgcmV0dXJuIG4ucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICovXHJcbiAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVyblxyXG4gICAqICAgMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICogICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgKiAgIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICovXHJcbiAgUC5jb21wYXJlZFRvID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIElmIGRwIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZVxyXG4gICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgKlxyXG4gICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICovXHJcbiAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgcmV0dXJuIG47XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gLyAwID0gSVxyXG4gICAqICBuIC8gTiA9IE5cclxuICAgKiAgbiAvIEkgPSAwXHJcbiAgICogIDAgLyBuID0gMFxyXG4gICAqICAwIC8gMCA9IE5cclxuICAgKiAgMCAvIE4gPSBOXHJcbiAgICogIDAgLyBJID0gMFxyXG4gICAqICBOIC8gbiA9IE5cclxuICAgKiAgTiAvIDAgPSBOXHJcbiAgICogIE4gLyBOID0gTlxyXG4gICAqICBOIC8gSSA9IE5cclxuICAgKiAgSSAvIG4gPSBJXHJcbiAgICogIEkgLyAwID0gSVxyXG4gICAqICBJIC8gTiA9IE5cclxuICAgKiAgSSAvIEkgPSBOXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICovXHJcbiAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAqXHJcbiAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICpcclxuICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICpcclxuICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICovXHJcbiAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgIC8vIEFsbG93IE5hTiBhbmQgwrFJbmZpbml0eSwgYnV0IG5vdCBvdGhlciBub24taW50ZWdlcnMuXHJcbiAgICBpZiAobi5jICYmICFuLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiAnICsgdmFsdWVPZihuKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgLy8gRXhwb25lbnQgb2YgTUFYX1NBRkVfSU5URUdFUiBpcyAxNS5cclxuICAgIG5Jc0JpZyA9IG4uZSA+IDE0O1xyXG5cclxuICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE1hdGgucG93KCt2YWx1ZU9mKHgpLCBuSXNCaWcgPyBuLnMgKiAoMiAtIGlzT2RkKG4pKSA6ICt2YWx1ZU9mKG4pKSk7XHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgfVxyXG5cclxuICAgIG5Jc05lZyA9IG4ucyA8IDA7XHJcblxyXG4gICAgaWYgKG0pIHtcclxuXHJcbiAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgaWYgKG0uYyA/ICFtLmNbMF0gOiAhbS5zKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgIC8vIE92ZXJmbG93IHRvIMKxSW5maW5pdHk6ID49MioqMWUxMCBvciA+PTEuMDAwMDAyNCoqMWUxNS5cclxuICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgIC8vIElmIHggPj0gMSwgayA9IMKxSW5maW5pdHkuXHJcbiAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICB9XHJcblxyXG4gICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaSkge1xyXG4gICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICovXHJcbiAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhdGhpcy5zO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gLSAwID0gblxyXG4gICAqICBuIC0gTiA9IE5cclxuICAgKiAgbiAtIEkgPSAtSVxyXG4gICAqICAwIC0gbiA9IC1uXHJcbiAgICogIDAgLSAwID0gMFxyXG4gICAqICAwIC0gTiA9IE5cclxuICAgKiAgMCAtIEkgPSAtSVxyXG4gICAqICBOIC0gbiA9IE5cclxuICAgKiAgTiAtIDAgPSBOXHJcbiAgICogIE4gLSBOID0gTlxyXG4gICAqICBOIC0gSSA9IE5cclxuICAgKiAgSSAtIG4gPSBJXHJcbiAgICogIEkgLSAwID0gSVxyXG4gICAqICBJIC0gTiA9IE5cclxuICAgKiAgSSAtIEkgPSBOXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICBiID0geS5zO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGEgIT0gYikge1xyXG4gICAgICB5LnMgPSAtYjtcclxuICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jO1xyXG5cclxuICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgIGEgPSAtYTtcclxuICAgICAgICB0ID0geGM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICB0ID0geWM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICBpZiAoeExUeSkge1xyXG4gICAgICB0ID0geGM7XHJcbiAgICAgIHhjID0geWM7XHJcbiAgICAgIHljID0gdDtcclxuICAgICAgeS5zID0gLXkucztcclxuICAgIH1cclxuXHJcbiAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAvLyBaZXJvP1xyXG4gICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICAgbiAlIDAgPSAgTlxyXG4gICAqICAgbiAlIE4gPSAgTlxyXG4gICAqICAgbiAlIEkgPSAgblxyXG4gICAqICAgMCAlIG4gPSAgMFxyXG4gICAqICAtMCAlIG4gPSAtMFxyXG4gICAqICAgMCAlIDAgPSAgTlxyXG4gICAqICAgMCAlIE4gPSAgTlxyXG4gICAqICAgMCAlIEkgPSAgMFxyXG4gICAqICAgTiAlIG4gPSAgTlxyXG4gICAqICAgTiAlIDAgPSAgTlxyXG4gICAqICAgTiAlIE4gPSAgTlxyXG4gICAqICAgTiAlIEkgPSAgTlxyXG4gICAqICAgSSAlIG4gPSAgTlxyXG4gICAqICAgSSAlIDAgPSAgTlxyXG4gICAqICAgSSAlIE4gPSAgTlxyXG4gICAqICAgSSAlIEkgPSAgTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgKi9cclxuICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciBxLCBzLFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgIHMgPSB5LnM7XHJcbiAgICAgIHkucyA9IDE7XHJcbiAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgIHkucyA9IHM7XHJcbiAgICAgIHEucyAqPSBzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICB9XHJcblxyXG4gICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgcmV0dXJuIHk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gKiAwID0gMFxyXG4gICAqICBuICogTiA9IE5cclxuICAgKiAgbiAqIEkgPSBJXHJcbiAgICogIDAgKiBuID0gMFxyXG4gICAqICAwICogMCA9IDBcclxuICAgKiAgMCAqIE4gPSBOXHJcbiAgICogIDAgKiBJID0gTlxyXG4gICAqICBOICogbiA9IE5cclxuICAgKiAgTiAqIDAgPSBOXHJcbiAgICogIE4gKiBOID0gTlxyXG4gICAqICBOICogSSA9IE5cclxuICAgKiAgSSAqIG4gPSBJXHJcbiAgICogIEkgKiAwID0gTlxyXG4gICAqICBJICogTiA9IE5cclxuICAgKiAgSSAqIEkgPSBJXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH1cclxuXHJcbiAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgeS5zICo9IHgucztcclxuICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICBpZiAoeGNMIDwgeWNMKSB7XHJcbiAgICAgIHpjID0geGM7XHJcbiAgICAgIHhjID0geWM7XHJcbiAgICAgIHljID0gemM7XHJcbiAgICAgIGkgPSB4Y0w7XHJcbiAgICAgIHhjTCA9IHljTDtcclxuICAgICAgeWNMID0gaTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICBiYXNlID0gQkFTRTtcclxuICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgIGMgPSAwO1xyXG4gICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgIGZvciAoayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTspIHtcclxuICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHpjW2pdID0gYztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYykge1xyXG4gICAgICArK2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB6YywgZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICovXHJcbiAgUC5uZWdhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gKyAwID0gblxyXG4gICAqICBuICsgTiA9IE5cclxuICAgKiAgbiArIEkgPSBJXHJcbiAgICogIDAgKyBuID0gblxyXG4gICAqICAwICsgMCA9IDBcclxuICAgKiAgMCArIE4gPSBOXHJcbiAgICogIDAgKyBJID0gSVxyXG4gICAqICBOICsgbiA9IE5cclxuICAgKiAgTiArIDAgPSBOXHJcbiAgICogIE4gKyBOID0gTlxyXG4gICAqICBOICsgSSA9IE5cclxuICAgKiAgSSArIG4gPSBJXHJcbiAgICogIEkgKyAwID0gSVxyXG4gICAqICBJICsgTiA9IE5cclxuICAgKiAgSSArIEkgPSBJXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgdmFyIHQsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBhID0geC5zO1xyXG5cclxuICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgYiA9IHkucztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgIHkucyA9IC1iO1xyXG4gICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jO1xyXG5cclxuICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgIH1cclxuXHJcbiAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICBpZiAoYSA+IDApIHtcclxuICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgIHQgPSB5YztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgdCA9IHhjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYSA9IHhjLmxlbmd0aDtcclxuICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgaWYgKGEgLSBiIDwgMCkge1xyXG4gICAgICB0ID0geWM7XHJcbiAgICAgIHljID0geGM7XHJcbiAgICAgIHhjID0gdDtcclxuICAgICAgYiA9IGE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGEpIHtcclxuICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgKyt5ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgKlxyXG4gICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICovXHJcbiAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgcmV0dXJuIG47XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgKlxyXG4gICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAqL1xyXG4gIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAqICBzcXJ0KE4pID0gIE5cclxuICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAqICBzcXJ0KEkpID0gIElcclxuICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICogIHNxcnQoLTApID0gLTBcclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgKi9cclxuICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgYyA9IHguYyxcclxuICAgICAgcyA9IHgucyxcclxuICAgICAgZSA9IHguZSxcclxuICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgZSA9IHIuZTtcclxuICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICB0ID0gcjtcclxuICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgaWYgKHIuZSA8IGUpIC0tcztcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZVxyXG4gICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICByb3VuZCh0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICovXHJcbiAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgIGRwKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgKi9cclxuICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICpcclxuICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICpcclxuICAgKiBGT1JNQVQgPSB7XHJcbiAgICogICBwcmVmaXg6ICcnLFxyXG4gICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAqICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgKiAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgKiAgIHN1ZmZpeDogJydcclxuICAgKiB9O1xyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAqL1xyXG4gIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZHAsIHJtLCBmb3JtYXQpIHtcclxuICAgIHZhciBzdHIsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICBybSA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgZHAgPSBybSA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgbm90IGFuIG9iamVjdDogJyArIGZvcm1hdCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgaWYgKHguYykge1xyXG4gICAgICB2YXIgaSxcclxuICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICBnMSA9ICtmb3JtYXQuZ3JvdXBTaXplLFxyXG4gICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmIChnMikge1xyXG4gICAgICAgIGkgPSBnMTtcclxuICAgICAgICBnMSA9IGcyO1xyXG4gICAgICAgIGcyID0gaTtcclxuICAgICAgICBsZW4gLT0gaTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgIDogaW50UGFydDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgKlxyXG4gICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICovXHJcbiAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICB4YyA9IHguYztcclxuXHJcbiAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgZm9yICg7IDspICB7XHJcbiAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgZDAgPSBkMTtcclxuICAgICAgZDEgPSBkMjtcclxuICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICBuMCA9IGQyO1xyXG4gICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICBuID0gZDI7XHJcbiAgICB9XHJcblxyXG4gICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICByZXR1cm4gcjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICovXHJcbiAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgKlxyXG4gICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICovXHJcbiAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqXHJcbiAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgKi9cclxuICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgIHZhciBzdHIsXHJcbiAgICAgIG4gPSB0aGlzLFxyXG4gICAgICBzID0gbi5zLFxyXG4gICAgICBlID0gbi5lO1xyXG5cclxuICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICovXHJcbiAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICB9O1xyXG5cclxuXHJcbiAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICBQW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnQmlnTnVtYmVyJztcclxuXHJcbiAgLy8gTm9kZS5qcyB2MTAuMTIuMCtcclxuICBQW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gUC52YWx1ZU9mO1xyXG5cclxuICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgcmV0dXJuIEJpZ051bWJlcjtcclxufVxyXG5cclxuXHJcbi8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbmZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICB2YXIgaSA9IG4gfCAwO1xyXG4gIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG59XHJcblxyXG5cclxuLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbmZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gIHZhciBzLCB6LFxyXG4gICAgaSA9IDEsXHJcbiAgICBqID0gYS5sZW5ndGgsXHJcbiAgICByID0gYVswXSArICcnO1xyXG5cclxuICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgIHIgKz0gcztcclxuICB9XHJcblxyXG4gIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG59XHJcblxyXG5cclxuLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG5mdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICB2YXIgYSwgYixcclxuICAgIHhjID0geC5jLFxyXG4gICAgeWMgPSB5LmMsXHJcbiAgICBpID0geC5zLFxyXG4gICAgaiA9IHkucyxcclxuICAgIGsgPSB4LmUsXHJcbiAgICBsID0geS5lO1xyXG5cclxuICAvLyBFaXRoZXIgTmFOP1xyXG4gIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgLy8gRWl0aGVyIHplcm8/XHJcbiAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICBhID0gaSA8IDA7XHJcbiAgYiA9IGsgPT0gbDtcclxuXHJcbiAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICB0aHJvdyBFcnJvclxyXG4gICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG5mdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgdmFyIGxlbiwgenM7XHJcblxyXG4gIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gIGlmIChlIDwgMCkge1xyXG5cclxuICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gIH0gZWxzZSB7XHJcbiAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICBzdHIgKz0genM7XHJcbiAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cjtcclxufVxyXG5cclxuXHJcbi8vIEVYUE9SVFxyXG5cclxuXHJcbmV4cG9ydCB2YXIgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJpZ051bWJlcjtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/hedera-agent-kit/node_modules/bignumber.js/bignumber.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/hedera-agent-kit/node_modules/long/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/hedera-agent-kit/node_modules/long/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2009 The Closure Library Authors\n * Copyright 2020 Daniel Wirtz / The long.js Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// WebAssembly optimizations to do native i64 multiplication and divide\nvar wasm = null;\ntry {\n  wasm = new WebAssembly.Instance(\n    new WebAssembly.Module(\n      new Uint8Array([\n        // \\0asm\n        0, 97, 115, 109,\n        // version 1\n        1, 0, 0, 0,\n\n        // section \"type\"\n        1, 13, 2,\n        // 0, () => i32\n        96, 0, 1, 127,\n        // 1, (i32, i32, i32, i32) => i32\n        96, 4, 127, 127, 127, 127, 1, 127,\n\n        // section \"function\"\n        3, 7, 6,\n        // 0, type 0\n        0,\n        // 1, type 1\n        1,\n        // 2, type 1\n        1,\n        // 3, type 1\n        1,\n        // 4, type 1\n        1,\n        // 5, type 1\n        1,\n\n        // section \"global\"\n        6, 6, 1,\n        // 0, \"high\", mutable i32\n        127, 1, 65, 0, 11,\n\n        // section \"export\"\n        7, 50, 6,\n        // 0, \"mul\"\n        3, 109, 117, 108, 0, 1,\n        // 1, \"div_s\"\n        5, 100, 105, 118, 95, 115, 0, 2,\n        // 2, \"div_u\"\n        5, 100, 105, 118, 95, 117, 0, 3,\n        // 3, \"rem_s\"\n        5, 114, 101, 109, 95, 115, 0, 4,\n        // 4, \"rem_u\"\n        5, 114, 101, 109, 95, 117, 0, 5,\n        // 5, \"get_high\"\n        8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0,\n\n        // section \"code\"\n        10, 191, 1, 6,\n        // 0, \"get_high\"\n        4, 0, 35, 0, 11,\n        // 1, \"mul\"\n        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,\n        3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,\n        167, 11,\n        // 2, \"div_s\"\n        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,\n        3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,\n        167, 11,\n        // 3, \"div_u\"\n        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,\n        3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,\n        167, 11,\n        // 4, \"rem_s\"\n        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,\n        3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,\n        167, 11,\n        // 5, \"rem_u\"\n        36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32,\n        3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,\n        167, 11,\n      ]),\n    ),\n    {},\n  ).exports;\n} catch {\n  // no wasm support :(\n}\n\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n *  See the from* functions below for more convenient ways of constructing Longs.\n * @exports Long\n * @class A Long class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @constructor\n */\nfunction Long(low, high, unsigned) {\n  /**\n   * The low 32 bits as a signed value.\n   * @type {number}\n   */\n  this.low = low | 0;\n\n  /**\n   * The high 32 bits as a signed value.\n   * @type {number}\n   */\n  this.high = high | 0;\n\n  /**\n   * Whether unsigned or not.\n   * @type {boolean}\n   */\n  this.unsigned = !!unsigned;\n}\n\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n\n/**\n * An indicator used to reliably determine if an object is a Long or not.\n * @type {boolean}\n * @const\n * @private\n */\nLong.prototype.__isLong__;\n\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n\n/**\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n * @inner\n */\nfunction isLong(obj) {\n  return (obj && obj[\"__isLong__\"]) === true;\n}\n\n/**\n * @function\n * @param {*} value number\n * @returns {number}\n * @inner\n */\nfunction ctz32(value) {\n  var c = Math.clz32(value & -value);\n  return value ? 31 - c : c;\n}\n\n/**\n * Tests if the specified object is a Long.\n * @function\n * @param {*} obj Object\n * @returns {boolean}\n */\nLong.isLong = isLong;\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @inner\n */\nvar INT_CACHE = {};\n\n/**\n * A cache of the Long representations of small unsigned integer values.\n * @type {!Object}\n * @inner\n */\nvar UINT_CACHE = {};\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromInt(value, unsigned) {\n  var obj, cachedObj, cache;\n  if (unsigned) {\n    value >>>= 0;\n    if ((cache = 0 <= value && value < 256)) {\n      cachedObj = UINT_CACHE[value];\n      if (cachedObj) return cachedObj;\n    }\n    obj = fromBits(value, 0, true);\n    if (cache) UINT_CACHE[value] = obj;\n    return obj;\n  } else {\n    value |= 0;\n    if ((cache = -128 <= value && value < 128)) {\n      cachedObj = INT_CACHE[value];\n      if (cachedObj) return cachedObj;\n    }\n    obj = fromBits(value, value < 0 ? -1 : 0, false);\n    if (cache) INT_CACHE[value] = obj;\n    return obj;\n  }\n}\n\n/**\n * Returns a Long representing the given 32 bit integer value.\n * @function\n * @param {number} value The 32 bit integer in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromInt = fromInt;\n\n/**\n * @param {number} value\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromNumber(value, unsigned) {\n  if (isNaN(value)) return unsigned ? UZERO : ZERO;\n  if (unsigned) {\n    if (value < 0) return UZERO;\n    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n  } else {\n    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n  }\n  if (value < 0) return fromNumber(-value, unsigned).neg();\n  return fromBits(\n    value % TWO_PWR_32_DBL | 0,\n    (value / TWO_PWR_32_DBL) | 0,\n    unsigned,\n  );\n}\n\n/**\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n * @function\n * @param {number} value The number in question\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromNumber = fromNumber;\n\n/**\n * @param {number} lowBits\n * @param {number} highBits\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromBits(lowBits, highBits, unsigned) {\n  return new Long(lowBits, highBits, unsigned);\n}\n\n/**\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n *  assumed to use 32 bits.\n * @function\n * @param {number} lowBits The low 32 bits\n * @param {number} highBits The high 32 bits\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long} The corresponding Long value\n */\nLong.fromBits = fromBits;\n\n/**\n * @function\n * @param {number} base\n * @param {number} exponent\n * @returns {number}\n * @inner\n */\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n\n/**\n * @param {string} str\n * @param {(boolean|number)=} unsigned\n * @param {number=} radix\n * @returns {!Long}\n * @inner\n */\nfunction fromString(str, unsigned, radix) {\n  if (str.length === 0) throw Error(\"empty string\");\n  if (typeof unsigned === \"number\") {\n    // For goog.math.long compatibility\n    radix = unsigned;\n    unsigned = false;\n  } else {\n    unsigned = !!unsigned;\n  }\n  if (\n    str === \"NaN\" ||\n    str === \"Infinity\" ||\n    str === \"+Infinity\" ||\n    str === \"-Infinity\"\n  )\n    return unsigned ? UZERO : ZERO;\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n\n  var p;\n  if ((p = str.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n  else if (p === 0) {\n    return fromString(str.substring(1), unsigned, radix).neg();\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = fromNumber(pow_dbl(radix, 8));\n\n  var result = ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i),\n      value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = fromNumber(pow_dbl(radix, size));\n      result = result.mul(power).add(fromNumber(value));\n    } else {\n      result = result.mul(radixToPower);\n      result = result.add(fromNumber(value));\n    }\n  }\n  result.unsigned = unsigned;\n  return result;\n}\n\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @function\n * @param {string} str The textual representation of the Long\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n * @returns {!Long} The corresponding Long value\n */\nLong.fromString = fromString;\n\n/**\n * @function\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n * @param {boolean=} unsigned\n * @returns {!Long}\n * @inner\n */\nfunction fromValue(val, unsigned) {\n  if (typeof val === \"number\") return fromNumber(val, unsigned);\n  if (typeof val === \"string\") return fromString(val, unsigned);\n  // Throws for non-objects, converts non-instanceof Long:\n  return fromBits(\n    val.low,\n    val.high,\n    typeof unsigned === \"boolean\" ? unsigned : val.unsigned,\n  );\n}\n\n/**\n * Converts the specified value to a Long using the appropriate from* function for its type.\n * @function\n * @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {!Long}\n */\nLong.fromValue = fromValue;\n\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n\n/**\n * @type {number}\n * @const\n * @inner\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n\n/**\n * @type {!Long}\n * @const\n * @inner\n */\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ZERO = fromInt(0);\n\n/**\n * Signed zero.\n * @type {!Long}\n */\nLong.ZERO = ZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UZERO = fromInt(0, true);\n\n/**\n * Unsigned zero.\n * @type {!Long}\n */\nLong.UZERO = UZERO;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar ONE = fromInt(1);\n\n/**\n * Signed one.\n * @type {!Long}\n */\nLong.ONE = ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar UONE = fromInt(1, true);\n\n/**\n * Unsigned one.\n * @type {!Long}\n */\nLong.UONE = UONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar NEG_ONE = fromInt(-1);\n\n/**\n * Signed negative one.\n * @type {!Long}\n */\nLong.NEG_ONE = NEG_ONE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_VALUE = fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\n\n/**\n * Maximum signed value.\n * @type {!Long}\n */\nLong.MAX_VALUE = MAX_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MAX_UNSIGNED_VALUE = fromBits(0xffffffff | 0, 0xffffffff | 0, true);\n\n/**\n * Maximum unsigned value.\n * @type {!Long}\n */\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n\n/**\n * @type {!Long}\n * @inner\n */\nvar MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n\n/**\n * Minimum signed value.\n * @type {!Long}\n */\nLong.MIN_VALUE = MIN_VALUE;\n\n/**\n * @alias Long.prototype\n * @inner\n */\nvar LongPrototype = Long.prototype;\n\n/**\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toInt = function toInt() {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\n\n/**\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.toNumber = function toNumber() {\n  if (this.unsigned)\n    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n};\n\n/**\n * Converts the Long to a string written in the specified radix.\n * @this {!Long}\n * @param {number=} radix Radix (2-36), defaults to 10\n * @returns {string}\n * @override\n * @throws {RangeError} If `radix` is out of range\n */\nLongPrototype.toString = function toString(radix) {\n  radix = radix || 10;\n  if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n  if (this.isZero()) return \"0\";\n  if (this.isNegative()) {\n    // Unsigned Longs are never negative\n    if (this.eq(MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = fromNumber(radix),\n        div = this.div(radixLong),\n        rem1 = div.mul(radixLong).sub(this);\n      return div.toString(radix) + rem1.toInt().toString(radix);\n    } else return \"-\" + this.neg().toString(radix);\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n    rem = this;\n  var result = \"\";\n  while (true) {\n    var remDiv = rem.div(radixToPower),\n      intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n      digits = intval.toString(radix);\n    rem = remDiv;\n    if (rem.isZero()) return digits + result;\n    else {\n      while (digits.length < 6) digits = \"0\" + digits;\n      result = \"\" + digits + result;\n    }\n  }\n};\n\n/**\n * Gets the high 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed high bits\n */\nLongPrototype.getHighBits = function getHighBits() {\n  return this.high;\n};\n\n/**\n * Gets the high 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned high bits\n */\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n  return this.high >>> 0;\n};\n\n/**\n * Gets the low 32 bits as a signed integer.\n * @this {!Long}\n * @returns {number} Signed low bits\n */\nLongPrototype.getLowBits = function getLowBits() {\n  return this.low;\n};\n\n/**\n * Gets the low 32 bits as an unsigned integer.\n * @this {!Long}\n * @returns {number} Unsigned low bits\n */\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n  return this.low >>> 0;\n};\n\n/**\n * Gets the number of bits needed to represent the absolute value of this Long.\n * @this {!Long}\n * @returns {number}\n */\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n  if (this.isNegative())\n    // Unsigned Longs are never negative\n    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n  var val = this.high != 0 ? this.high : this.low;\n  for (var bit = 31; bit > 0; bit--) if ((val & (1 << bit)) != 0) break;\n  return this.high != 0 ? bit + 33 : bit + 1;\n};\n\n/**\n * Tests if this Long can be safely represented as a JavaScript number.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isSafeInteger = function isSafeInteger() {\n  // 2^53-1 is the maximum safe value\n  var top11Bits = this.high >> 21;\n  // [0, 2^53-1]\n  if (!top11Bits) return true;\n  // > 2^53-1\n  if (this.unsigned) return false;\n  // [-2^53, -1] except -2^53\n  return top11Bits === -1 && !(this.low === 0 && this.high === -0x200000);\n};\n\n/**\n * Tests if this Long's value equals zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isZero = function isZero() {\n  return this.high === 0 && this.low === 0;\n};\n\n/**\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n * @returns {boolean}\n */\nLongPrototype.eqz = LongPrototype.isZero;\n\n/**\n * Tests if this Long's value is negative.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isNegative = function isNegative() {\n  return !this.unsigned && this.high < 0;\n};\n\n/**\n * Tests if this Long's value is positive or zero.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isPositive = function isPositive() {\n  return this.unsigned || this.high >= 0;\n};\n\n/**\n * Tests if this Long's value is odd.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isOdd = function isOdd() {\n  return (this.low & 1) === 1;\n};\n\n/**\n * Tests if this Long's value is even.\n * @this {!Long}\n * @returns {boolean}\n */\nLongPrototype.isEven = function isEven() {\n  return (this.low & 1) === 0;\n};\n\n/**\n * Tests if this Long's value equals the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.equals = function equals(other) {\n  if (!isLong(other)) other = fromValue(other);\n  if (\n    this.unsigned !== other.unsigned &&\n    this.high >>> 31 === 1 &&\n    other.high >>> 31 === 1\n  )\n    return false;\n  return this.high === other.high && this.low === other.low;\n};\n\n/**\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.eq = LongPrototype.equals;\n\n/**\n * Tests if this Long's value differs from the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.notEquals = function notEquals(other) {\n  return !this.eq(/* validates */ other);\n};\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.neq = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ne = LongPrototype.notEquals;\n\n/**\n * Tests if this Long's value is less than the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThan = function lessThan(other) {\n  return this.comp(/* validates */ other) < 0;\n};\n\n/**\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lt = LongPrototype.lessThan;\n\n/**\n * Tests if this Long's value is less than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n  return this.comp(/* validates */ other) <= 0;\n};\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.le = LongPrototype.lessThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThan = function greaterThan(other) {\n  return this.comp(/* validates */ other) > 0;\n};\n\n/**\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gt = LongPrototype.greaterThan;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n  return this.comp(/* validates */ other) >= 0;\n};\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\n\n/**\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {boolean}\n */\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\n\n/**\n * Compares this Long's value with the specified's.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.compare = function compare(other) {\n  if (!isLong(other)) other = fromValue(other);\n  if (this.eq(other)) return 0;\n  var thisNeg = this.isNegative(),\n    otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) return -1;\n  if (!thisNeg && otherNeg) return 1;\n  // At this point the sign bits are the same\n  if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n  // Both are positive if at least one is unsigned\n  return other.high >>> 0 > this.high >>> 0 ||\n    (other.high === this.high && other.low >>> 0 > this.low >>> 0)\n    ? -1\n    : 1;\n};\n\n/**\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n * @function\n * @param {!Long|number|bigint|string} other Other value\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n *  if the given one is greater\n */\nLongPrototype.comp = LongPrototype.compare;\n\n/**\n * Negates this Long's value.\n * @this {!Long}\n * @returns {!Long} Negated Long\n */\nLongPrototype.negate = function negate() {\n  if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n  return this.not().add(ONE);\n};\n\n/**\n * Negates this Long's value. This is an alias of {@link Long#negate}.\n * @function\n * @returns {!Long} Negated Long\n */\nLongPrototype.neg = LongPrototype.negate;\n\n/**\n * Returns the sum of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|bigint|string} addend Addend\n * @returns {!Long} Sum\n */\nLongPrototype.add = function add(addend) {\n  if (!isLong(addend)) addend = fromValue(addend);\n\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 0xffff;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 0xffff;\n\n  var b48 = addend.high >>> 16;\n  var b32 = addend.high & 0xffff;\n  var b16 = addend.low >>> 16;\n  var b00 = addend.low & 0xffff;\n\n  var c48 = 0,\n    c32 = 0,\n    c16 = 0,\n    c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xffff;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xffff;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xffff;\n  c48 += a48 + b48;\n  c48 &= 0xffff;\n  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the difference of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|bigint|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.subtract = function subtract(subtrahend) {\n  if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n  return this.add(subtrahend.neg());\n};\n\n/**\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n * @function\n * @param {!Long|number|bigint|string} subtrahend Subtrahend\n * @returns {!Long} Difference\n */\nLongPrototype.sub = LongPrototype.subtract;\n\n/**\n * Returns the product of this and the specified Long.\n * @this {!Long}\n * @param {!Long|number|bigint|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.multiply = function multiply(multiplier) {\n  if (this.isZero()) return this;\n  if (!isLong(multiplier)) multiplier = fromValue(multiplier);\n\n  // use wasm support if present\n  if (wasm) {\n    var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n  if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n  if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n\n  if (this.isNegative()) {\n    if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n    else return this.neg().mul(multiplier).neg();\n  } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n\n  // If both longs are small, use float multiplication\n  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\n    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high >>> 16;\n  var a32 = this.high & 0xffff;\n  var a16 = this.low >>> 16;\n  var a00 = this.low & 0xffff;\n\n  var b48 = multiplier.high >>> 16;\n  var b32 = multiplier.high & 0xffff;\n  var b16 = multiplier.low >>> 16;\n  var b00 = multiplier.low & 0xffff;\n\n  var c48 = 0,\n    c32 = 0,\n    c16 = 0,\n    c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xffff;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xffff;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xffff;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xffff;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xffff;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xffff;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xffff;\n  return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n};\n\n/**\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n * @function\n * @param {!Long|number|bigint|string} multiplier Multiplier\n * @returns {!Long} Product\n */\nLongPrototype.mul = LongPrototype.multiply;\n\n/**\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\n *  unsigned if this Long is unsigned.\n * @this {!Long}\n * @param {!Long|number|bigint|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.divide = function divide(divisor) {\n  if (!isLong(divisor)) divisor = fromValue(divisor);\n  if (divisor.isZero()) throw Error(\"division by zero\");\n\n  // use wasm support if present\n  if (wasm) {\n    // guard against signed division overflow: the largest\n    // negative number / -1 would be 1 larger than the largest\n    // positive number, due to two's complement.\n    if (\n      !this.unsigned &&\n      this.high === -0x80000000 &&\n      divisor.low === -1 &&\n      divisor.high === -1\n    ) {\n      // be consistent with non-wasm code path\n      return this;\n    }\n    var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(\n      this.low,\n      this.high,\n      divisor.low,\n      divisor.high,\n    );\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n  var approx, rem, res;\n  if (!this.unsigned) {\n    // This section is only relevant for signed longs and is derived from the\n    // closure library as a whole.\n    if (this.eq(MIN_VALUE)) {\n      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\n        return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n      else if (divisor.eq(MIN_VALUE)) return ONE;\n      else {\n        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n        var halfThis = this.shr(1);\n        approx = halfThis.div(divisor).shl(1);\n        if (approx.eq(ZERO)) {\n          return divisor.isNegative() ? ONE : NEG_ONE;\n        } else {\n          rem = this.sub(divisor.mul(approx));\n          res = approx.add(rem.div(divisor));\n          return res;\n        }\n      }\n    } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n    if (this.isNegative()) {\n      if (divisor.isNegative()) return this.neg().div(divisor.neg());\n      return this.neg().div(divisor).neg();\n    } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n    res = ZERO;\n  } else {\n    // The algorithm below has not been made for unsigned longs. It's therefore\n    // required to take special care of the MSB prior to running it.\n    if (!divisor.unsigned) divisor = divisor.toUnsigned();\n    if (divisor.gt(this)) return UZERO;\n    if (divisor.gt(this.shru(1)))\n      // 15 >>> 1 = 7 ; with divisor = 8 ; true\n      return UONE;\n    res = UZERO;\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  rem = this;\n  while (rem.gte(divisor)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n      delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),\n      // Decrease the approximation until it is smaller than the remainder.  Note\n      // that if it is too large, the product overflows and is negative.\n      approxRes = fromNumber(approx),\n      approxRem = approxRes.mul(divisor);\n    while (approxRem.isNegative() || approxRem.gt(rem)) {\n      approx -= delta;\n      approxRes = fromNumber(approx, this.unsigned);\n      approxRem = approxRes.mul(divisor);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) approxRes = ONE;\n\n    res = res.add(approxRes);\n    rem = rem.sub(approxRem);\n  }\n  return res;\n};\n\n/**\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n * @function\n * @param {!Long|number|bigint|string} divisor Divisor\n * @returns {!Long} Quotient\n */\nLongPrototype.div = LongPrototype.divide;\n\n/**\n * Returns this Long modulo the specified.\n * @this {!Long}\n * @param {!Long|number|bigint|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.modulo = function modulo(divisor) {\n  if (!isLong(divisor)) divisor = fromValue(divisor);\n\n  // use wasm support if present\n  if (wasm) {\n    var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(\n      this.low,\n      this.high,\n      divisor.low,\n      divisor.high,\n    );\n    return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n  }\n\n  return this.sub(this.div(divisor).mul(divisor));\n};\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|bigint|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.mod = LongPrototype.modulo;\n\n/**\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n * @function\n * @param {!Long|number|bigint|string} divisor Divisor\n * @returns {!Long} Remainder\n */\nLongPrototype.rem = LongPrototype.modulo;\n\n/**\n * Returns the bitwise NOT of this Long.\n * @this {!Long}\n * @returns {!Long}\n */\nLongPrototype.not = function not() {\n  return fromBits(~this.low, ~this.high, this.unsigned);\n};\n\n/**\n * Returns count leading zeros of this Long.\n * @this {!Long}\n * @returns {!number}\n */\nLongPrototype.countLeadingZeros = function countLeadingZeros() {\n  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n};\n\n/**\n * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n * @function\n * @param {!Long}\n * @returns {!number}\n */\nLongPrototype.clz = LongPrototype.countLeadingZeros;\n\n/**\n * Returns count trailing zeros of this Long.\n * @this {!Long}\n * @returns {!number}\n */\nLongPrototype.countTrailingZeros = function countTrailingZeros() {\n  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n};\n\n/**\n * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n * @function\n * @param {!Long}\n * @returns {!number}\n */\nLongPrototype.ctz = LongPrototype.countTrailingZeros;\n\n/**\n * Returns the bitwise AND of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.and = function and(other) {\n  if (!isLong(other)) other = fromValue(other);\n  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise OR of this Long and the specified.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.or = function or(other) {\n  if (!isLong(other)) other = fromValue(other);\n  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n};\n\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @this {!Long}\n * @param {!Long|number|bigint|string} other Other Long\n * @returns {!Long}\n */\nLongPrototype.xor = function xor(other) {\n  if (!isLong(other)) other = fromValue(other);\n  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  else if (numBits < 32)\n    return fromBits(\n      this.low << numBits,\n      (this.high << numBits) | (this.low >>> (32 - numBits)),\n      this.unsigned,\n    );\n  else return fromBits(0, this.low << (numBits - 32), this.unsigned);\n};\n\n/**\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shl = LongPrototype.shiftLeft;\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRight = function shiftRight(numBits) {\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  else if (numBits < 32)\n    return fromBits(\n      (this.low >>> numBits) | (this.high << (32 - numBits)),\n      this.high >> numBits,\n      this.unsigned,\n    );\n  else\n    return fromBits(\n      this.high >> (numBits - 32),\n      this.high >= 0 ? 0 : -1,\n      this.unsigned,\n    );\n};\n\n/**\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr = LongPrototype.shiftRight;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits < 32)\n    return fromBits(\n      (this.low >>> numBits) | (this.high << (32 - numBits)),\n      this.high >>> numBits,\n      this.unsigned,\n    );\n  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n  return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);\n};\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Shifted Long\n */\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n\n/**\n * Returns this Long with bits rotated to the left by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateLeft = function rotateLeft(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  if (numBits < 32) {\n    b = 32 - numBits;\n    return fromBits(\n      (this.low << numBits) | (this.high >>> b),\n      (this.high << numBits) | (this.low >>> b),\n      this.unsigned,\n    );\n  }\n  numBits -= 32;\n  b = 32 - numBits;\n  return fromBits(\n    (this.high << numBits) | (this.low >>> b),\n    (this.low << numBits) | (this.high >>> b),\n    this.unsigned,\n  );\n};\n/**\n * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotl = LongPrototype.rotateLeft;\n\n/**\n * Returns this Long with bits rotated to the right by the given amount.\n * @this {!Long}\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotateRight = function rotateRight(numBits) {\n  var b;\n  if (isLong(numBits)) numBits = numBits.toInt();\n  if ((numBits &= 63) === 0) return this;\n  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  if (numBits < 32) {\n    b = 32 - numBits;\n    return fromBits(\n      (this.high << b) | (this.low >>> numBits),\n      (this.low << b) | (this.high >>> numBits),\n      this.unsigned,\n    );\n  }\n  numBits -= 32;\n  b = 32 - numBits;\n  return fromBits(\n    (this.low << b) | (this.high >>> numBits),\n    (this.high << b) | (this.low >>> numBits),\n    this.unsigned,\n  );\n};\n/**\n * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n * @function\n * @param {number|!Long} numBits Number of bits\n * @returns {!Long} Rotated Long\n */\nLongPrototype.rotr = LongPrototype.rotateRight;\n\n/**\n * Converts this Long to signed.\n * @this {!Long}\n * @returns {!Long} Signed long\n */\nLongPrototype.toSigned = function toSigned() {\n  if (!this.unsigned) return this;\n  return fromBits(this.low, this.high, false);\n};\n\n/**\n * Converts this Long to unsigned.\n * @this {!Long}\n * @returns {!Long} Unsigned long\n */\nLongPrototype.toUnsigned = function toUnsigned() {\n  if (this.unsigned) return this;\n  return fromBits(this.low, this.high, true);\n};\n\n/**\n * Converts this Long to its byte representation.\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @this {!Long}\n * @returns {!Array.<number>} Byte representation\n */\nLongPrototype.toBytes = function toBytes(le) {\n  return le ? this.toBytesLE() : this.toBytesBE();\n};\n\n/**\n * Converts this Long to its little endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Little endian byte representation\n */\nLongPrototype.toBytesLE = function toBytesLE() {\n  var hi = this.high,\n    lo = this.low;\n  return [\n    lo & 0xff,\n    (lo >>> 8) & 0xff,\n    (lo >>> 16) & 0xff,\n    lo >>> 24,\n    hi & 0xff,\n    (hi >>> 8) & 0xff,\n    (hi >>> 16) & 0xff,\n    hi >>> 24,\n  ];\n};\n\n/**\n * Converts this Long to its big endian byte representation.\n * @this {!Long}\n * @returns {!Array.<number>} Big endian byte representation\n */\nLongPrototype.toBytesBE = function toBytesBE() {\n  var hi = this.high,\n    lo = this.low;\n  return [\n    hi >>> 24,\n    (hi >>> 16) & 0xff,\n    (hi >>> 8) & 0xff,\n    hi & 0xff,\n    lo >>> 24,\n    (lo >>> 16) & 0xff,\n    (lo >>> 8) & 0xff,\n    lo & 0xff,\n  ];\n};\n\n/**\n * Creates a Long from its byte representation.\n * @param {!Array.<number>} bytes Byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @param {boolean=} le Whether little or big endian, defaults to big endian\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\n  return le\n    ? Long.fromBytesLE(bytes, unsigned)\n    : Long.fromBytesBE(bytes, unsigned);\n};\n\n/**\n * Creates a Long from its little endian byte representation.\n * @param {!Array.<number>} bytes Little endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n  return new Long(\n    bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24),\n    bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24),\n    unsigned,\n  );\n};\n\n/**\n * Creates a Long from its big endian byte representation.\n * @param {!Array.<number>} bytes Big endian byte representation\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n * @returns {Long} The corresponding Long value\n */\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n  return new Long(\n    (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7],\n    (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3],\n    unsigned,\n  );\n};\n\n// Support conversion to/from BigInt where available\nif (typeof BigInt === \"function\") {\n  /**\n   * Returns a Long representing the given big integer.\n   * @function\n   * @param {number} value The big integer value\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  Long.fromBigInt = function fromBigInt(value, unsigned) {\n    var lowBits = Number(BigInt.asIntN(32, value));\n    var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));\n    return fromBits(lowBits, highBits, unsigned);\n  };\n\n  // Override\n  Long.fromValue = function fromValueWithBigInt(value, unsigned) {\n    if (typeof value === \"bigint\") return Long.fromBigInt(value, unsigned);\n    return fromValue(value, unsigned);\n  };\n\n  /**\n   * Converts the Long to its big integer representation.\n   * @this {!Long}\n   * @returns {bigint}\n   */\n  LongPrototype.toBigInt = function toBigInt() {\n    var lowBigInt = BigInt(this.low >>> 0);\n    var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);\n    return (highBigInt << BigInt(32)) | lowBigInt;\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Long);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaGVkZXJhLWFnZW50LWtpdC9ub2RlX21vZHVsZXMvbG9uZy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFD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OztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsSUFBSSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9oZWRlcmEtYWdlbnQta2l0L25vZGVfbW9kdWxlcy9sb25nL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9yc1xuICogQ29weXJpZ2h0IDIwMjAgRGFuaWVsIFdpcnR6IC8gVGhlIGxvbmcuanMgQXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG4vLyBXZWJBc3NlbWJseSBvcHRpbWl6YXRpb25zIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxudmFyIHdhc20gPSBudWxsO1xudHJ5IHtcbiAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShcbiAgICBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAvLyBcXDBhc21cbiAgICAgICAgMCwgOTcsIDExNSwgMTA5LFxuICAgICAgICAvLyB2ZXJzaW9uIDFcbiAgICAgICAgMSwgMCwgMCwgMCxcblxuICAgICAgICAvLyBzZWN0aW9uIFwidHlwZVwiXG4gICAgICAgIDEsIDEzLCAyLFxuICAgICAgICAvLyAwLCAoKSA9PiBpMzJcbiAgICAgICAgOTYsIDAsIDEsIDEyNyxcbiAgICAgICAgLy8gMSwgKGkzMiwgaTMyLCBpMzIsIGkzMikgPT4gaTMyXG4gICAgICAgIDk2LCA0LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEsIDEyNyxcblxuICAgICAgICAvLyBzZWN0aW9uIFwiZnVuY3Rpb25cIlxuICAgICAgICAzLCA3LCA2LFxuICAgICAgICAvLyAwLCB0eXBlIDBcbiAgICAgICAgMCxcbiAgICAgICAgLy8gMSwgdHlwZSAxXG4gICAgICAgIDEsXG4gICAgICAgIC8vIDIsIHR5cGUgMVxuICAgICAgICAxLFxuICAgICAgICAvLyAzLCB0eXBlIDFcbiAgICAgICAgMSxcbiAgICAgICAgLy8gNCwgdHlwZSAxXG4gICAgICAgIDEsXG4gICAgICAgIC8vIDUsIHR5cGUgMVxuICAgICAgICAxLFxuXG4gICAgICAgIC8vIHNlY3Rpb24gXCJnbG9iYWxcIlxuICAgICAgICA2LCA2LCAxLFxuICAgICAgICAvLyAwLCBcImhpZ2hcIiwgbXV0YWJsZSBpMzJcbiAgICAgICAgMTI3LCAxLCA2NSwgMCwgMTEsXG5cbiAgICAgICAgLy8gc2VjdGlvbiBcImV4cG9ydFwiXG4gICAgICAgIDcsIDUwLCA2LFxuICAgICAgICAvLyAwLCBcIm11bFwiXG4gICAgICAgIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsXG4gICAgICAgIC8vIDEsIFwiZGl2X3NcIlxuICAgICAgICA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE1LCAwLCAyLFxuICAgICAgICAvLyAyLCBcImRpdl91XCJcbiAgICAgICAgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMyxcbiAgICAgICAgLy8gMywgXCJyZW1fc1wiXG4gICAgICAgIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsXG4gICAgICAgIC8vIDQsIFwicmVtX3VcIlxuICAgICAgICA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE3LCAwLCA1LFxuICAgICAgICAvLyA1LCBcImdldF9oaWdoXCJcbiAgICAgICAgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCxcblxuICAgICAgICAvLyBzZWN0aW9uIFwiY29kZVwiXG4gICAgICAgIDEwLCAxOTEsIDEsIDYsXG4gICAgICAgIC8vIDAsIFwiZ2V0X2hpZ2hcIlxuICAgICAgICA0LCAwLCAzNSwgMCwgMTEsXG4gICAgICAgIC8vIDEsIFwibXVsXCJcbiAgICAgICAgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsXG4gICAgICAgIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LFxuICAgICAgICAxNjcsIDExLFxuICAgICAgICAvLyAyLCBcImRpdl9zXCJcbiAgICAgICAgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsXG4gICAgICAgIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI3LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LFxuICAgICAgICAxNjcsIDExLFxuICAgICAgICAvLyAzLCBcImRpdl91XCJcbiAgICAgICAgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsXG4gICAgICAgIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LFxuICAgICAgICAxNjcsIDExLFxuICAgICAgICAvLyA0LCBcInJlbV9zXCJcbiAgICAgICAgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsXG4gICAgICAgIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LFxuICAgICAgICAxNjcsIDExLFxuICAgICAgICAvLyA1LCBcInJlbV91XCJcbiAgICAgICAgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsXG4gICAgICAgIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTMwLCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LFxuICAgICAgICAxNjcsIDExLFxuICAgICAgXSksXG4gICAgKSxcbiAgICB7fSxcbiAgKS5leHBvcnRzO1xufSBjYXRjaCB7XG4gIC8vIG5vIHdhc20gc3VwcG9ydCA6KFxufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cbiAqIEBleHBvcnRzIExvbmdcbiAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xuICAvKipcbiAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuXG4gIC8qKlxuICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xufVxuXG4vLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxuLy8gV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcbi8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxuLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxuLy8gbXVsdGlwbGllZCB3aXRoaW4gSmF2YXNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcbi8vIG9yIGNoYW5nZSBpbiBzaWduLlxuLy9cbi8vIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcbi8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxuLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXG4vLyAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXG4vLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXG4vLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXG4vL1xuLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXG4vLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxuXG4vKipcbiAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cbiAqIEB0eXBlIHtib29sZWFufVxuICogQGNvbnN0XG4gKiBAcHJpdmF0ZVxuICovXG5Mb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZy5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBpc0xvbmcob2JqKSB7XG4gIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZSBudW1iZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gY3R6MzIodmFsdWUpIHtcbiAgdmFyIGMgPSBNYXRoLmNsejMyKHZhbHVlICYgLXZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlID8gMzEgLSBjIDogYztcbn1cblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmcuaXNMb25nID0gaXNMb25nO1xuXG4vKipcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxuICogQHR5cGUgeyFPYmplY3R9XG4gKiBAaW5uZXJcbiAqL1xudmFyIElOVF9DQUNIRSA9IHt9O1xuXG4vKipcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLlxuICogQHR5cGUgeyFPYmplY3R9XG4gKiBAaW5uZXJcbiAqL1xudmFyIFVJTlRfQ0FDSEUgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcbiAgaWYgKHVuc2lnbmVkKSB7XG4gICAgdmFsdWUgPj4+PSAwO1xuICAgIGlmICgoY2FjaGUgPSAwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xuICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XG4gICAgICBpZiAoY2FjaGVkT2JqKSByZXR1cm4gY2FjaGVkT2JqO1xuICAgIH1cbiAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgMCwgdHJ1ZSk7XG4gICAgaWYgKGNhY2hlKSBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlIHw9IDA7XG4gICAgaWYgKChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XG4gICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgaWYgKGNhY2hlZE9iaikgcmV0dXJuIGNhY2hlZE9iajtcbiAgICB9XG4gICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgIGlmIChjYWNoZSkgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gKi9cbkxvbmcuZnJvbUludCA9IGZyb21JbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICogQHJldHVybnMgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XG4gIGlmIChpc05hTih2YWx1ZSkpIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgaWYgKHVuc2lnbmVkKSB7XG4gICAgaWYgKHZhbHVlIDwgMCkgcmV0dXJuIFVaRVJPO1xuICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTCkgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKSByZXR1cm4gTUlOX1ZBTFVFO1xuICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpIHJldHVybiBNQVhfVkFMVUU7XG4gIH1cbiAgaWYgKHZhbHVlIDwgMCkgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XG4gIHJldHVybiBmcm9tQml0cyhcbiAgICB2YWx1ZSAlIFRXT19QV1JfMzJfREJMIHwgMCxcbiAgICAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLFxuICAgIHVuc2lnbmVkLFxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tTnVtYmVyID0gZnJvbU51bWJlcjtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93Qml0c1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICogQHJldHVybnMgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xuICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0IGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcbiAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxuICogQHJldHVybnMge251bWJlcn1cbiAqIEBpbm5lclxuICovXG52YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkgdGhyb3cgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gIGlmICh0eXBlb2YgdW5zaWduZWQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxuICAgIHJhZGl4ID0gdW5zaWduZWQ7XG4gICAgdW5zaWduZWQgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gIH1cbiAgaWYgKFxuICAgIHN0ciA9PT0gXCJOYU5cIiB8fFxuICAgIHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8XG4gICAgc3RyID09PSBcIitJbmZpbml0eVwiIHx8XG4gICAgc3RyID09PSBcIi1JbmZpbml0eVwiXG4gIClcbiAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkgdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO1xuXG4gIHZhciBwO1xuICBpZiAoKHAgPSBzdHIuaW5kZXhPZihcIi1cIikpID4gMCkgdGhyb3cgRXJyb3IoXCJpbnRlcmlvciBoeXBoZW5cIik7XG4gIGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xuICB9XG5cbiAgLy8gRG8gc2V2ZXJhbCAoOCkgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xuXG4gIHZhciByZXN1bHQgPSBaRVJPO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xuICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxuICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xuICAgIGlmIChzaXplIDwgOCkge1xuICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XG4gICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XG4gICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHJldHVybiBmcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XG4gIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XG4gIHJldHVybiBmcm9tQml0cyhcbiAgICB2YWwubG93LFxuICAgIHZhbC5oaWdoLFxuICAgIHR5cGVvZiB1bnNpZ25lZCA9PT0gXCJib29sZWFuXCIgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCxcbiAgKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZyB1c2luZyB0aGUgYXBwcm9wcmlhdGUgZnJvbSogZnVuY3Rpb24gZm9yIGl0cyB0eXBlLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqL1xuTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XG5cbi8vIE5PVEU6IHRoZSBjb21waWxlciBzaG91bGQgaW5saW5lIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiZWxvdyBhbmQgdGhlbiByZW1vdmUgdGhlc2UgdmFyaWFibGVzLCBzbyB0aGVyZSBzaG91bGQgYmVcbi8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKi9cbnZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICovXG52YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgWkVSTyA9IGZyb21JbnQoMCk7XG5cbi8qKlxuICogU2lnbmVkIHplcm8uXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuWkVSTyA9IFpFUk87XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbnZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XG5cbi8qKlxuICogVW5zaWduZWQgemVyby5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5VWkVSTyA9IFVaRVJPO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgT05FID0gZnJvbUludCgxKTtcblxuLyoqXG4gKiBTaWduZWQgb25lLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk9ORSA9IE9ORTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xuXG4vKipcbiAqIFVuc2lnbmVkIG9uZS5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5VT05FID0gVU9ORTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcblxuLyoqXG4gKiBTaWduZWQgbmVnYXRpdmUgb25lLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk5FR19PTkUgPSBORUdfT05FO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4N2ZmZmZmZmYgfCAwLCBmYWxzZSk7XG5cbi8qKlxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4ZmZmZmZmZmYgfCAwLCB0cnVlKTtcblxuLyoqXG4gKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XG5cbi8qKlxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xuXG4vKipcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxuICogQGlubmVyXG4gKi9cbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcbiAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcbiAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgcmV0dXJuICh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xuICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFJhZGl4ICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiBAb3ZlcnJpZGVcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGByYWRpeGAgaXMgb3V0IG9mIHJhbmdlXG4gKi9cbkxvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xuICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHRocm93IFJhbmdlRXJyb3IoXCJyYWRpeFwiKTtcbiAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBcIjBcIjtcbiAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcbiAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cbiAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSxcbiAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcbiAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XG4gICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgfSBlbHNlIHJldHVybiBcIi1cIiArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xuICB9XG5cbiAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxuICAgIHJlbSA9IHRoaXM7XG4gIHZhciByZXN1bHQgPSBcIlwiO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXG4gICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcbiAgICAgIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XG4gICAgcmVtID0gcmVtRGl2O1xuICAgIGlmIChyZW0uaXNaZXJvKCkpIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7XG4gICAgZWxzZSB7XG4gICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpIGRpZ2l0cyA9IFwiMFwiICsgZGlnaXRzO1xuICAgICAgcmVzdWx0ID0gXCJcIiArIGRpZ2l0cyArIHJlc3VsdDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXG4gKi9cbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBoaWdoIGJpdHNcbiAqL1xuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xuICovXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xuICByZXR1cm4gdGhpcy5sb3c7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xuICovXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcbiAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpXG4gICAgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XG4gIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xuICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMCkgYnJlYWs7XG4gIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nIGNhbiBiZSBzYWZlbHkgcmVwcmVzZW50ZWQgYXMgYSBKYXZhU2NyaXB0IG51bWJlci5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzU2FmZUludGVnZXIgPSBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKCkge1xuICAvLyAyXjUzLTEgaXMgdGhlIG1heGltdW0gc2FmZSB2YWx1ZVxuICB2YXIgdG9wMTFCaXRzID0gdGhpcy5oaWdoID4+IDIxO1xuICAvLyBbMCwgMl41My0xXVxuICBpZiAoIXRvcDExQml0cykgcmV0dXJuIHRydWU7XG4gIC8vID4gMl41My0xXG4gIGlmICh0aGlzLnVuc2lnbmVkKSByZXR1cm4gZmFsc2U7XG4gIC8vIFstMl41MywgLTFdIGV4Y2VwdCAtMl41M1xuICByZXR1cm4gdG9wMTFCaXRzID09PSAtMSAmJiAhKHRoaXMubG93ID09PSAwICYmIHRoaXMuaGlnaCA9PT0gLTB4MjAwMDAwKTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XG4gIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xuICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUgb3IgemVyby5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xuICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgb2RkLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcbiAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xuICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICBpZiAoXG4gICAgdGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiZcbiAgICB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmXG4gICAgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDFcbiAgKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2VxdWFsc30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XG4gIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xuICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPCAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xuICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubHRlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID49IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XG5cbi8qKlxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxuICovXG5Mb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICBpZiAodGhpcy5lcShvdGhlcikpIHJldHVybiAwO1xuICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxuICAgIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xuICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpIHJldHVybiAtMTtcbiAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKSByZXR1cm4gMTtcbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxuICBpZiAoIXRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xuICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcbiAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHxcbiAgICAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwKVxuICAgID8gLTFcbiAgICA6IDE7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxuICovXG5Mb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7XG5cbi8qKlxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xuICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKSByZXR1cm4gTUlOX1ZBTFVFO1xuICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcbn07XG5cbi8qKlxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBhZGRlbmQgQWRkZW5kXG4gKiBAcmV0dXJucyB7IUxvbmd9IFN1bVxuICovXG5Mb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHtcbiAgaWYgKCFpc0xvbmcoYWRkZW5kKSkgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XG5cbiAgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXG5cbiAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweGZmZmY7XG4gIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4ZmZmZjtcblxuICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xuICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweGZmZmY7XG4gIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcbiAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweGZmZmY7XG5cbiAgdmFyIGM0OCA9IDAsXG4gICAgYzMyID0gMCxcbiAgICBjMTYgPSAwLFxuICAgIGMwMCA9IDA7XG4gIGMwMCArPSBhMDAgKyBiMDA7XG4gIGMxNiArPSBjMDAgPj4+IDE2O1xuICBjMDAgJj0gMHhmZmZmO1xuICBjMTYgKz0gYTE2ICsgYjE2O1xuICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgYzE2ICY9IDB4ZmZmZjtcbiAgYzMyICs9IGEzMiArIGIzMjtcbiAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gIGMzMiAmPSAweGZmZmY7XG4gIGM0OCArPSBhNDggKyBiNDg7XG4gIGM0OCAmPSAweGZmZmY7XG4gIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXG4gKi9cbkxvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XG4gIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKSBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xuICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAqL1xuTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcbiAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiB0aGlzO1xuICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSkgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcblxuICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgaWYgKHdhc20pIHtcbiAgICB2YXIgbG93ID0gd2FzbVtcIm11bFwiXSh0aGlzLmxvdywgdGhpcy5oaWdoLCBtdWx0aXBsaWVyLmxvdywgbXVsdGlwbGllci5oaWdoKTtcbiAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gIH1cblxuICBpZiAobXVsdGlwbGllci5pc1plcm8oKSkgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xuICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKSByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcblxuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcbiAgICBlbHNlIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcbiAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xuXG4gIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cbiAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xuXG4gIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxuICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxuXG4gIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhmZmZmO1xuICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweGZmZmY7XG5cbiAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XG4gIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweGZmZmY7XG4gIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XG4gIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4ZmZmZjtcblxuICB2YXIgYzQ4ID0gMCxcbiAgICBjMzIgPSAwLFxuICAgIGMxNiA9IDAsXG4gICAgYzAwID0gMDtcbiAgYzAwICs9IGEwMCAqIGIwMDtcbiAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gIGMwMCAmPSAweGZmZmY7XG4gIGMxNiArPSBhMTYgKiBiMDA7XG4gIGMzMiArPSBjMTYgPj4+IDE2O1xuICBjMTYgJj0gMHhmZmZmO1xuICBjMTYgKz0gYTAwICogYjE2O1xuICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgYzE2ICY9IDB4ZmZmZjtcbiAgYzMyICs9IGEzMiAqIGIwMDtcbiAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gIGMzMiAmPSAweGZmZmY7XG4gIGMzMiArPSBhMTYgKiBiMTY7XG4gIGM0OCArPSBjMzIgPj4+IDE2O1xuICBjMzIgJj0gMHhmZmZmO1xuICBjMzIgKz0gYTAwICogYjMyO1xuICBjNDggKz0gYzMyID4+PiAxNjtcbiAgYzMyICY9IDB4ZmZmZjtcbiAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcbiAgYzQ4ICY9IDB4ZmZmZjtcbiAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAqL1xuTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICovXG5Mb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XG4gIGlmICghaXNMb25nKGRpdmlzb3IpKSBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xuICBpZiAoZGl2aXNvci5pc1plcm8oKSkgdGhyb3cgRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO1xuXG4gIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICBpZiAod2FzbSkge1xuICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxuICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcbiAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxuICAgIGlmIChcbiAgICAgICF0aGlzLnVuc2lnbmVkICYmXG4gICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXG4gICAgICBkaXZpc29yLmxvdyA9PT0gLTEgJiZcbiAgICAgIGRpdmlzb3IuaGlnaCA9PT0gLTFcbiAgICApIHtcbiAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtW1wiZGl2X3VcIl0gOiB3YXNtW1wiZGl2X3NcIl0pKFxuICAgICAgdGhpcy5sb3csXG4gICAgICB0aGlzLmhpZ2gsXG4gICAgICBkaXZpc29yLmxvdyxcbiAgICAgIGRpdmlzb3IuaGlnaCxcbiAgICApO1xuICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgdmFyIGFwcHJveCwgcmVtLCByZXM7XG4gIGlmICghdGhpcy51bnNpZ25lZCkge1xuICAgIC8vIFRoaXMgc2VjdGlvbiBpcyBvbmx5IHJlbGV2YW50IGZvciBzaWduZWQgbG9uZ3MgYW5kIGlzIGRlcml2ZWQgZnJvbSB0aGVcbiAgICAvLyBjbG9zdXJlIGxpYnJhcnkgYXMgYSB3aG9sZS5cbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XG4gICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7IC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXG4gICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpIHJldHVybiBPTkU7XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcbiAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcbiAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xuICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XG4gICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XG4gICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XG4gICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xuICAgIHJlcyA9IFpFUk87XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXG4gICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxuICAgIGlmICghZGl2aXNvci51bnNpZ25lZCkgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xuICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKSByZXR1cm4gVVpFUk87XG4gICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSlcbiAgICAgIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXG4gICAgICByZXR1cm4gVU9ORTtcbiAgICByZXMgPSBVWkVSTztcbiAgfVxuXG4gIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXG4gIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcbiAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxuICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXG4gIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxuICByZW0gPSB0aGlzO1xuICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xuICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcbiAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cbiAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XG5cbiAgICAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXG4gICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxuICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXG4gICAgICBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxuICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXG4gICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cbiAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSxcbiAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcbiAgICAgIGFwcHJveCAtPSBkZWx0YTtcbiAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgfVxuXG4gICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXG4gICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXG4gICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkgYXBwcm94UmVzID0gT05FO1xuXG4gICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xuICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XG4gKi9cbkxvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gKi9cbkxvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcbiAgaWYgKCFpc0xvbmcoZGl2aXNvcikpIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XG5cbiAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XG4gIGlmICh3YXNtKSB7XG4gICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcInJlbV91XCJdIDogd2FzbVtcInJlbV9zXCJdKShcbiAgICAgIHRoaXMubG93LFxuICAgICAgdGhpcy5oaWdoLFxuICAgICAgZGl2aXNvci5sb3csXG4gICAgICBkaXZpc29yLmhpZ2gsXG4gICAgKTtcbiAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICovXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcbiAqL1xuTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKi9cbkxvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xuICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBjb3VudCBsZWFkaW5nIHplcm9zIG9mIHRoaXMgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshbnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRMZWFkaW5nWmVyb3MoKSB7XG4gIHJldHVybiB0aGlzLmhpZ2ggPyBNYXRoLmNsejMyKHRoaXMuaGlnaCkgOiBNYXRoLmNsejMyKHRoaXMubG93KSArIDMyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRMZWFkaW5nWmVyb3N9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfVxuICogQHJldHVybnMgeyFudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUuY2x6ID0gTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcztcblxuLyoqXG4gKiBSZXR1cm5zIGNvdW50IHRyYWlsaW5nIHplcm9zIG9mIHRoaXMgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshbnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmNvdW50VHJhaWxpbmdaZXJvcyA9IGZ1bmN0aW9uIGNvdW50VHJhaWxpbmdaZXJvcygpIHtcbiAgcmV0dXJuIHRoaXMubG93ID8gY3R6MzIodGhpcy5sb3cpIDogY3R6MzIodGhpcy5oaWdoKSArIDMyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGNvdW50IHRyYWlsaW5nIHplcm9zLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvdW50VHJhaWxpbmdaZXJvc30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IW51bWJlcn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5jdHogPSBMb25nUHJvdG90eXBlLmNvdW50VHJhaWxpbmdaZXJvcztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKi9cbkxvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqL1xuTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKi9cbkxvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcbiAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcbiAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICB0aGlzLmxvdyA8PCBudW1CaXRzLFxuICAgICAgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLFxuICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICApO1xuICBlbHNlIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XG4gIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXG4gICAgcmV0dXJuIGZyb21CaXRzKFxuICAgICAgKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLFxuICAgICAgdGhpcy5oaWdoID4+IG51bUJpdHMsXG4gICAgICB0aGlzLnVuc2lnbmVkLFxuICAgICk7XG4gIGVsc2VcbiAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICB0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksXG4gICAgICB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSxcbiAgICAgIHRoaXMudW5zaWduZWQsXG4gICAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xuICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKG51bUJpdHMgPCAzMilcbiAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICAodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksXG4gICAgICB0aGlzLmhpZ2ggPj4+IG51bUJpdHMsXG4gICAgICB0aGlzLnVuc2lnbmVkLFxuICAgICk7XG4gIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUucm90YXRlTGVmdCA9IGZ1bmN0aW9uIHJvdGF0ZUxlZnQobnVtQml0cykge1xuICB2YXIgYjtcbiAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpO1xuICBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICAodGhpcy5sb3cgPDwgbnVtQml0cykgfCAodGhpcy5oaWdoID4+PiBiKSxcbiAgICAgICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+IGIpLFxuICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICApO1xuICB9XG4gIG51bUJpdHMgLT0gMzI7XG4gIGIgPSAzMiAtIG51bUJpdHM7XG4gIHJldHVybiBmcm9tQml0cyhcbiAgICAodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiBiKSxcbiAgICAodGhpcy5sb3cgPDwgbnVtQml0cykgfCAodGhpcy5oaWdoID4+PiBiKSxcbiAgICB0aGlzLnVuc2lnbmVkLFxuICApO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNyb3RhdGVMZWZ0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUucm90bCA9IExvbmdQcm90b3R5cGUucm90YXRlTGVmdDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gcm90YXRlUmlnaHQobnVtQml0cykge1xuICB2YXIgYjtcbiAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpO1xuICBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICAodGhpcy5oaWdoIDw8IGIpIHwgKHRoaXMubG93ID4+PiBudW1CaXRzKSxcbiAgICAgICh0aGlzLmxvdyA8PCBiKSB8ICh0aGlzLmhpZ2ggPj4+IG51bUJpdHMpLFxuICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICApO1xuICB9XG4gIG51bUJpdHMgLT0gMzI7XG4gIGIgPSAzMiAtIG51bUJpdHM7XG4gIHJldHVybiBmcm9tQml0cyhcbiAgICAodGhpcy5sb3cgPDwgYikgfCAodGhpcy5oaWdoID4+PiBudW1CaXRzKSxcbiAgICAodGhpcy5oaWdoIDw8IGIpIHwgKHRoaXMubG93ID4+PiBudW1CaXRzKSxcbiAgICB0aGlzLnVuc2lnbmVkLFxuICApO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjcm90YXRlUmlnaHR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5yb3RyID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVSaWdodDtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gc2lnbmVkLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7XG4gIGlmICghdGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXM7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byB1bnNpZ25lZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkge1xuICBpZiAodGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXM7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxuICovXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XG4gIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICovXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcbiAgdmFyIGhpID0gdGhpcy5oaWdoLFxuICAgIGxvID0gdGhpcy5sb3c7XG4gIHJldHVybiBbXG4gICAgbG8gJiAweGZmLFxuICAgIChsbyA+Pj4gOCkgJiAweGZmLFxuICAgIChsbyA+Pj4gMTYpICYgMHhmZixcbiAgICBsbyA+Pj4gMjQsXG4gICAgaGkgJiAweGZmLFxuICAgIChoaSA+Pj4gOCkgJiAweGZmLFxuICAgIChoaSA+Pj4gMTYpICYgMHhmZixcbiAgICBoaSA+Pj4gMjQsXG4gIF07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gKi9cbkxvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xuICB2YXIgaGkgPSB0aGlzLmhpZ2gsXG4gICAgbG8gPSB0aGlzLmxvdztcbiAgcmV0dXJuIFtcbiAgICBoaSA+Pj4gMjQsXG4gICAgKGhpID4+PiAxNikgJiAweGZmLFxuICAgIChoaSA+Pj4gOCkgJiAweGZmLFxuICAgIGhpICYgMHhmZixcbiAgICBsbyA+Pj4gMjQsXG4gICAgKGxvID4+PiAxNikgJiAweGZmLFxuICAgIChsbyA+Pj4gOCkgJiAweGZmLFxuICAgIGxvICYgMHhmZixcbiAgXTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XG4gIHJldHVybiBsZVxuICAgID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpXG4gICAgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gKi9cbkxvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcbiAgcmV0dXJuIG5ldyBMb25nKFxuICAgIGJ5dGVzWzBdIHwgKGJ5dGVzWzFdIDw8IDgpIHwgKGJ5dGVzWzJdIDw8IDE2KSB8IChieXRlc1szXSA8PCAyNCksXG4gICAgYnl0ZXNbNF0gfCAoYnl0ZXNbNV0gPDwgOCkgfCAoYnl0ZXNbNl0gPDwgMTYpIHwgKGJ5dGVzWzddIDw8IDI0KSxcbiAgICB1bnNpZ25lZCxcbiAgKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICByZXR1cm4gbmV3IExvbmcoXG4gICAgKGJ5dGVzWzRdIDw8IDI0KSB8IChieXRlc1s1XSA8PCAxNikgfCAoYnl0ZXNbNl0gPDwgOCkgfCBieXRlc1s3XSxcbiAgICAoYnl0ZXNbMF0gPDwgMjQpIHwgKGJ5dGVzWzFdIDw8IDE2KSB8IChieXRlc1syXSA8PCA4KSB8IGJ5dGVzWzNdLFxuICAgIHVuc2lnbmVkLFxuICApO1xufTtcblxuLy8gU3VwcG9ydCBjb252ZXJzaW9uIHRvL2Zyb20gQmlnSW50IHdoZXJlIGF2YWlsYWJsZVxuaWYgKHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBiaWcgaW50ZWdlci5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYmlnIGludGVnZXIgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIExvbmcuZnJvbUJpZ0ludCA9IGZ1bmN0aW9uIGZyb21CaWdJbnQodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgdmFyIGxvd0JpdHMgPSBOdW1iZXIoQmlnSW50LmFzSW50TigzMiwgdmFsdWUpKTtcbiAgICB2YXIgaGlnaEJpdHMgPSBOdW1iZXIoQmlnSW50LmFzSW50TigzMiwgdmFsdWUgPj4gQmlnSW50KDMyKSkpO1xuICAgIHJldHVybiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xuICB9O1xuXG4gIC8vIE92ZXJyaWRlXG4gIExvbmcuZnJvbVZhbHVlID0gZnVuY3Rpb24gZnJvbVZhbHVlV2l0aEJpZ0ludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSByZXR1cm4gTG9uZy5mcm9tQmlnSW50KHZhbHVlLCB1bnNpZ25lZCk7XG4gICAgcmV0dXJuIGZyb21WYWx1ZSh2YWx1ZSwgdW5zaWduZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBpdHMgYmlnIGludGVnZXIgcmVwcmVzZW50YXRpb24uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICovXG4gIExvbmdQcm90b3R5cGUudG9CaWdJbnQgPSBmdW5jdGlvbiB0b0JpZ0ludCgpIHtcbiAgICB2YXIgbG93QmlnSW50ID0gQmlnSW50KHRoaXMubG93ID4+PiAwKTtcbiAgICB2YXIgaGlnaEJpZ0ludCA9IEJpZ0ludCh0aGlzLnVuc2lnbmVkID8gdGhpcy5oaWdoID4+PiAwIDogdGhpcy5oaWdoKTtcbiAgICByZXR1cm4gKGhpZ2hCaWdJbnQgPDwgQmlnSW50KDMyKSkgfCBsb3dCaWdJbnQ7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IExvbmc7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/hedera-agent-kit/node_modules/long/index.js\n");

/***/ })

};
;