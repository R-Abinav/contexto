/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pino";
exports.ids = ["vendor-chunks/pino"];
exports.modules = {

/***/ "(rsc)/./node_modules/pino/lib/caller.js":
/*!*****************************************!*\
  !*** ./node_modules/pino/lib/caller.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction noOpPrepareStackTrace (_, stack) {\n  return stack\n}\n\nmodule.exports = function getCallers () {\n  const originalPrepare = Error.prepareStackTrace\n  Error.prepareStackTrace = noOpPrepareStackTrace\n  const stack = new Error().stack\n  Error.prepareStackTrace = originalPrepare\n\n  if (!Array.isArray(stack)) {\n    return undefined\n  }\n\n  const entries = stack.slice(2)\n\n  const fileNames = []\n\n  for (const entry of entries) {\n    if (!entry) {\n      continue\n    }\n\n    fileNames.push(entry.getFileName())\n  }\n\n  return fileNames\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvY2FsbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2NhbGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gbm9PcFByZXBhcmVTdGFja1RyYWNlIChfLCBzdGFjaykge1xuICByZXR1cm4gc3RhY2tcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRDYWxsZXJzICgpIHtcbiAgY29uc3Qgb3JpZ2luYWxQcmVwYXJlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2VcbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBub09wUHJlcGFyZVN0YWNrVHJhY2VcbiAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFja1xuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IG9yaWdpbmFsUHJlcGFyZVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShzdGFjaykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBlbnRyaWVzID0gc3RhY2suc2xpY2UoMilcblxuICBjb25zdCBmaWxlTmFtZXMgPSBbXVxuXG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgZmlsZU5hbWVzLnB1c2goZW50cnkuZ2V0RmlsZU5hbWUoKSlcbiAgfVxuXG4gIHJldHVybiBmaWxlTmFtZXNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/constants.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/constants.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * Represents default log level values\n *\n * @enum {number}\n */\nconst DEFAULT_LEVELS = {\n  trace: 10,\n  debug: 20,\n  info: 30,\n  warn: 40,\n  error: 50,\n  fatal: 60\n}\n\n/**\n * Represents sort order direction: `ascending` or `descending`\n *\n * @enum {string}\n */\nconst SORTING_ORDER = {\n  ASC: 'ASC',\n  DESC: 'DESC'\n}\n\nmodule.exports = {\n  DEFAULT_LEVELS,\n  SORTING_ORDER\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlcHJlc2VudHMgZGVmYXVsdCBsb2cgbGV2ZWwgdmFsdWVzXG4gKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgREVGQVVMVF9MRVZFTFMgPSB7XG4gIHRyYWNlOiAxMCxcbiAgZGVidWc6IDIwLFxuICBpbmZvOiAzMCxcbiAgd2FybjogNDAsXG4gIGVycm9yOiA1MCxcbiAgZmF0YWw6IDYwXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBzb3J0IG9yZGVyIGRpcmVjdGlvbjogYGFzY2VuZGluZ2Agb3IgYGRlc2NlbmRpbmdgXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgU09SVElOR19PUkRFUiA9IHtcbiAgQVNDOiAnQVNDJyxcbiAgREVTQzogJ0RFU0MnXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBERUZBVUxUX0xFVkVMUyxcbiAgU09SVElOR19PUkRFUlxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/levels.js":
/*!*****************************************!*\
  !*** ./node_modules/pino/lib/levels.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint no-prototype-builtins: 0 */\nconst {\n  lsCacheSym,\n  levelValSym,\n  useOnlyCustomLevelsSym,\n  streamSym,\n  formattersSym,\n  hooksSym,\n  levelCompSym\n} = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/pino/lib/symbols.js\")\nconst { noop, genLog } = __webpack_require__(/*! ./tools */ \"(rsc)/./node_modules/pino/lib/tools.js\")\nconst { DEFAULT_LEVELS, SORTING_ORDER } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/pino/lib/constants.js\")\n\nconst levelMethods = {\n  fatal: (hook) => {\n    const logFatal = genLog(DEFAULT_LEVELS.fatal, hook)\n    return function (...args) {\n      const stream = this[streamSym]\n      logFatal.call(this, ...args)\n      if (typeof stream.flushSync === 'function') {\n        try {\n          stream.flushSync()\n        } catch (e) {\n          // https://github.com/pinojs/pino/pull/740#discussion_r346788313\n        }\n      }\n    }\n  },\n  error: (hook) => genLog(DEFAULT_LEVELS.error, hook),\n  warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),\n  info: (hook) => genLog(DEFAULT_LEVELS.info, hook),\n  debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),\n  trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)\n}\n\nconst nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {\n  o[DEFAULT_LEVELS[k]] = k\n  return o\n}, {})\n\nconst initialLsCache = Object.keys(nums).reduce((o, k) => {\n  o[k] = '{\"level\":' + Number(k)\n  return o\n}, {})\n\nfunction genLsCache (instance) {\n  const formatter = instance[formattersSym].level\n  const { labels } = instance.levels\n  const cache = {}\n  for (const label in labels) {\n    const level = formatter(labels[label], Number(label))\n    cache[label] = JSON.stringify(level).slice(0, -1)\n  }\n  instance[lsCacheSym] = cache\n  return instance\n}\n\nfunction isStandardLevel (level, useOnlyCustomLevels) {\n  if (useOnlyCustomLevels) {\n    return false\n  }\n\n  switch (level) {\n    case 'fatal':\n    case 'error':\n    case 'warn':\n    case 'info':\n    case 'debug':\n    case 'trace':\n      return true\n    default:\n      return false\n  }\n}\n\nfunction setLevel (level) {\n  const { labels, values } = this.levels\n  if (typeof level === 'number') {\n    if (labels[level] === undefined) throw Error('unknown level value' + level)\n    level = labels[level]\n  }\n  if (values[level] === undefined) throw Error('unknown level ' + level)\n  const preLevelVal = this[levelValSym]\n  const levelVal = this[levelValSym] = values[level]\n  const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym]\n  const levelComparison = this[levelCompSym]\n  const hook = this[hooksSym].logMethod\n\n  for (const key in values) {\n    if (levelComparison(values[key], levelVal) === false) {\n      this[key] = noop\n      continue\n    }\n    this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook)\n  }\n\n  this.emit(\n    'level-change',\n    level,\n    levelVal,\n    labels[preLevelVal],\n    preLevelVal,\n    this\n  )\n}\n\nfunction getLevel (level) {\n  const { levels, levelVal } = this\n  // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)\n  return (levels && levels.labels) ? levels.labels[levelVal] : ''\n}\n\nfunction isLevelEnabled (logLevel) {\n  const { values } = this.levels\n  const logLevelVal = values[logLevel]\n  return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym])\n}\n\n/**\n * Determine if the given `current` level is enabled by comparing it\n * against the current threshold (`expected`).\n *\n * @param {SORTING_ORDER} direction comparison direction \"ASC\" or \"DESC\"\n * @param {number} current current log level number representation\n * @param {number} expected threshold value to compare with\n * @returns {boolean}\n */\nfunction compareLevel (direction, current, expected) {\n  if (direction === SORTING_ORDER.DESC) {\n    return current <= expected\n  }\n\n  return current >= expected\n}\n\n/**\n * Create a level comparison function based on `levelComparison`\n * it could a default function which compares levels either in \"ascending\" or \"descending\" order or custom comparison function\n *\n * @param {SORTING_ORDER | Function} levelComparison sort levels order direction or custom comparison function\n * @returns Function\n */\nfunction genLevelComparison (levelComparison) {\n  if (typeof levelComparison === 'string') {\n    return compareLevel.bind(null, levelComparison)\n  }\n\n  return levelComparison\n}\n\nfunction mappings (customLevels = null, useOnlyCustomLevels = false) {\n  const customNums = customLevels\n    /* eslint-disable */\n    ? Object.keys(customLevels).reduce((o, k) => {\n        o[customLevels[k]] = k\n        return o\n      }, {})\n    : null\n    /* eslint-enable */\n\n  const labels = Object.assign(\n    Object.create(Object.prototype, { Infinity: { value: 'silent' } }),\n    useOnlyCustomLevels ? null : nums,\n    customNums\n  )\n  const values = Object.assign(\n    Object.create(Object.prototype, { silent: { value: Infinity } }),\n    useOnlyCustomLevels ? null : DEFAULT_LEVELS,\n    customLevels\n  )\n  return { labels, values }\n}\n\nfunction assertDefaultLevelFound (defaultLevel, customLevels, useOnlyCustomLevels) {\n  if (typeof defaultLevel === 'number') {\n    const values = [].concat(\n      Object.keys(customLevels || {}).map(key => customLevels[key]),\n      useOnlyCustomLevels ? [] : Object.keys(nums).map(level => +level),\n      Infinity\n    )\n    if (!values.includes(defaultLevel)) {\n      throw Error(`default level:${defaultLevel} must be included in custom levels`)\n    }\n    return\n  }\n\n  const labels = Object.assign(\n    Object.create(Object.prototype, { silent: { value: Infinity } }),\n    useOnlyCustomLevels ? null : DEFAULT_LEVELS,\n    customLevels\n  )\n  if (!(defaultLevel in labels)) {\n    throw Error(`default level:${defaultLevel} must be included in custom levels`)\n  }\n}\n\nfunction assertNoLevelCollisions (levels, customLevels) {\n  const { labels, values } = levels\n  for (const k in customLevels) {\n    if (k in values) {\n      throw Error('levels cannot be overridden')\n    }\n    if (customLevels[k] in labels) {\n      throw Error('pre-existing level values cannot be used for new levels')\n    }\n  }\n}\n\n/**\n * Validates whether `levelComparison` is correct\n *\n * @throws Error\n * @param {SORTING_ORDER | Function} levelComparison - value to validate\n * @returns\n */\nfunction assertLevelComparison (levelComparison) {\n  if (typeof levelComparison === 'function') {\n    return\n  }\n\n  if (typeof levelComparison === 'string' && Object.values(SORTING_ORDER).includes(levelComparison)) {\n    return\n  }\n\n  throw new Error('Levels comparison should be one of \"ASC\", \"DESC\" or \"function\" type')\n}\n\nmodule.exports = {\n  initialLsCache,\n  genLsCache,\n  levelMethods,\n  getLevel,\n  setLevel,\n  isLevelEnabled,\n  mappings,\n  assertNoLevelCollisions,\n  assertDefaultLevelFound,\n  genLevelComparison,\n  assertLevelComparison\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbGV2ZWxzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkRBQVc7QUFDdkIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyx1REFBUztBQUMxQyxRQUFRLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsK0RBQWE7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0EsV0FBVztBQUNYO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsWUFBWSxtQkFBbUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxtQkFBbUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxVQUFVLG1CQUFtQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2xldmVscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8qIGVzbGludCBuby1wcm90b3R5cGUtYnVpbHRpbnM6IDAgKi9cbmNvbnN0IHtcbiAgbHNDYWNoZVN5bSxcbiAgbGV2ZWxWYWxTeW0sXG4gIHVzZU9ubHlDdXN0b21MZXZlbHNTeW0sXG4gIHN0cmVhbVN5bSxcbiAgZm9ybWF0dGVyc1N5bSxcbiAgaG9va3NTeW0sXG4gIGxldmVsQ29tcFN5bVxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IG5vb3AsIGdlbkxvZyB9ID0gcmVxdWlyZSgnLi90b29scycpXG5jb25zdCB7IERFRkFVTFRfTEVWRUxTLCBTT1JUSU5HX09SREVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmNvbnN0IGxldmVsTWV0aG9kcyA9IHtcbiAgZmF0YWw6IChob29rKSA9PiB7XG4gICAgY29uc3QgbG9nRmF0YWwgPSBnZW5Mb2coREVGQVVMVF9MRVZFTFMuZmF0YWwsIGhvb2spXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSB0aGlzW3N0cmVhbVN5bV1cbiAgICAgIGxvZ0ZhdGFsLmNhbGwodGhpcywgLi4uYXJncylcbiAgICAgIGlmICh0eXBlb2Ygc3RyZWFtLmZsdXNoU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0cmVhbS5mbHVzaFN5bmMoKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9waW5vL3B1bGwvNzQwI2Rpc2N1c3Npb25fcjM0Njc4ODMxM1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogKGhvb2spID0+IGdlbkxvZyhERUZBVUxUX0xFVkVMUy5lcnJvciwgaG9vayksXG4gIHdhcm46IChob29rKSA9PiBnZW5Mb2coREVGQVVMVF9MRVZFTFMud2FybiwgaG9vayksXG4gIGluZm86IChob29rKSA9PiBnZW5Mb2coREVGQVVMVF9MRVZFTFMuaW5mbywgaG9vayksXG4gIGRlYnVnOiAoaG9vaykgPT4gZ2VuTG9nKERFRkFVTFRfTEVWRUxTLmRlYnVnLCBob29rKSxcbiAgdHJhY2U6IChob29rKSA9PiBnZW5Mb2coREVGQVVMVF9MRVZFTFMudHJhY2UsIGhvb2spXG59XG5cbmNvbnN0IG51bXMgPSBPYmplY3Qua2V5cyhERUZBVUxUX0xFVkVMUykucmVkdWNlKChvLCBrKSA9PiB7XG4gIG9bREVGQVVMVF9MRVZFTFNba11dID0ga1xuICByZXR1cm4gb1xufSwge30pXG5cbmNvbnN0IGluaXRpYWxMc0NhY2hlID0gT2JqZWN0LmtleXMobnVtcykucmVkdWNlKChvLCBrKSA9PiB7XG4gIG9ba10gPSAne1wibGV2ZWxcIjonICsgTnVtYmVyKGspXG4gIHJldHVybiBvXG59LCB7fSlcblxuZnVuY3Rpb24gZ2VuTHNDYWNoZSAoaW5zdGFuY2UpIHtcbiAgY29uc3QgZm9ybWF0dGVyID0gaW5zdGFuY2VbZm9ybWF0dGVyc1N5bV0ubGV2ZWxcbiAgY29uc3QgeyBsYWJlbHMgfSA9IGluc3RhbmNlLmxldmVsc1xuICBjb25zdCBjYWNoZSA9IHt9XG4gIGZvciAoY29uc3QgbGFiZWwgaW4gbGFiZWxzKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBmb3JtYXR0ZXIobGFiZWxzW2xhYmVsXSwgTnVtYmVyKGxhYmVsKSlcbiAgICBjYWNoZVtsYWJlbF0gPSBKU09OLnN0cmluZ2lmeShsZXZlbCkuc2xpY2UoMCwgLTEpXG4gIH1cbiAgaW5zdGFuY2VbbHNDYWNoZVN5bV0gPSBjYWNoZVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxuZnVuY3Rpb24gaXNTdGFuZGFyZExldmVsIChsZXZlbCwgdXNlT25seUN1c3RvbUxldmVscykge1xuICBpZiAodXNlT25seUN1c3RvbUxldmVscykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgJ2ZhdGFsJzpcbiAgICBjYXNlICdlcnJvcic6XG4gICAgY2FzZSAnd2Fybic6XG4gICAgY2FzZSAnaW5mbyc6XG4gICAgY2FzZSAnZGVidWcnOlxuICAgIGNhc2UgJ3RyYWNlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldExldmVsIChsZXZlbCkge1xuICBjb25zdCB7IGxhYmVscywgdmFsdWVzIH0gPSB0aGlzLmxldmVsc1xuICBpZiAodHlwZW9mIGxldmVsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChsYWJlbHNbbGV2ZWxdID09PSB1bmRlZmluZWQpIHRocm93IEVycm9yKCd1bmtub3duIGxldmVsIHZhbHVlJyArIGxldmVsKVxuICAgIGxldmVsID0gbGFiZWxzW2xldmVsXVxuICB9XG4gIGlmICh2YWx1ZXNbbGV2ZWxdID09PSB1bmRlZmluZWQpIHRocm93IEVycm9yKCd1bmtub3duIGxldmVsICcgKyBsZXZlbClcbiAgY29uc3QgcHJlTGV2ZWxWYWwgPSB0aGlzW2xldmVsVmFsU3ltXVxuICBjb25zdCBsZXZlbFZhbCA9IHRoaXNbbGV2ZWxWYWxTeW1dID0gdmFsdWVzW2xldmVsXVxuICBjb25zdCB1c2VPbmx5Q3VzdG9tTGV2ZWxzVmFsID0gdGhpc1t1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltXVxuICBjb25zdCBsZXZlbENvbXBhcmlzb24gPSB0aGlzW2xldmVsQ29tcFN5bV1cbiAgY29uc3QgaG9vayA9IHRoaXNbaG9va3NTeW1dLmxvZ01ldGhvZFxuXG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuICAgIGlmIChsZXZlbENvbXBhcmlzb24odmFsdWVzW2tleV0sIGxldmVsVmFsKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXNba2V5XSA9IG5vb3BcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHRoaXNba2V5XSA9IGlzU3RhbmRhcmRMZXZlbChrZXksIHVzZU9ubHlDdXN0b21MZXZlbHNWYWwpID8gbGV2ZWxNZXRob2RzW2tleV0oaG9vaykgOiBnZW5Mb2codmFsdWVzW2tleV0sIGhvb2spXG4gIH1cblxuICB0aGlzLmVtaXQoXG4gICAgJ2xldmVsLWNoYW5nZScsXG4gICAgbGV2ZWwsXG4gICAgbGV2ZWxWYWwsXG4gICAgbGFiZWxzW3ByZUxldmVsVmFsXSxcbiAgICBwcmVMZXZlbFZhbCxcbiAgICB0aGlzXG4gIClcbn1cblxuZnVuY3Rpb24gZ2V0TGV2ZWwgKGxldmVsKSB7XG4gIGNvbnN0IHsgbGV2ZWxzLCBsZXZlbFZhbCB9ID0gdGhpc1xuICAvLyBwcm90ZWN0aW9uIGFnYWluc3QgcG90ZW50aWFsIGxvc3Mgb2YgUGlubyBzY29wZSBmcm9tIHNlcmlhbGl6ZXJzIChlZGdlIGNhc2Ugd2l0aCBjaXJjdWxhciByZWZzIC0gaHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9waW5vL2lzc3Vlcy84MzMpXG4gIHJldHVybiAobGV2ZWxzICYmIGxldmVscy5sYWJlbHMpID8gbGV2ZWxzLmxhYmVsc1tsZXZlbFZhbF0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc0xldmVsRW5hYmxlZCAobG9nTGV2ZWwpIHtcbiAgY29uc3QgeyB2YWx1ZXMgfSA9IHRoaXMubGV2ZWxzXG4gIGNvbnN0IGxvZ0xldmVsVmFsID0gdmFsdWVzW2xvZ0xldmVsXVxuICByZXR1cm4gbG9nTGV2ZWxWYWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzW2xldmVsQ29tcFN5bV0obG9nTGV2ZWxWYWwsIHRoaXNbbGV2ZWxWYWxTeW1dKVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gYGN1cnJlbnRgIGxldmVsIGlzIGVuYWJsZWQgYnkgY29tcGFyaW5nIGl0XG4gKiBhZ2FpbnN0IHRoZSBjdXJyZW50IHRocmVzaG9sZCAoYGV4cGVjdGVkYCkuXG4gKlxuICogQHBhcmFtIHtTT1JUSU5HX09SREVSfSBkaXJlY3Rpb24gY29tcGFyaXNvbiBkaXJlY3Rpb24gXCJBU0NcIiBvciBcIkRFU0NcIlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnQgY3VycmVudCBsb2cgbGV2ZWwgbnVtYmVyIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWQgdGhyZXNob2xkIHZhbHVlIHRvIGNvbXBhcmUgd2l0aFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVMZXZlbCAoZGlyZWN0aW9uLCBjdXJyZW50LCBleHBlY3RlZCkge1xuICBpZiAoZGlyZWN0aW9uID09PSBTT1JUSU5HX09SREVSLkRFU0MpIHtcbiAgICByZXR1cm4gY3VycmVudCA8PSBleHBlY3RlZFxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnQgPj0gZXhwZWN0ZWRcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBsZXZlbCBjb21wYXJpc29uIGZ1bmN0aW9uIGJhc2VkIG9uIGBsZXZlbENvbXBhcmlzb25gXG4gKiBpdCBjb3VsZCBhIGRlZmF1bHQgZnVuY3Rpb24gd2hpY2ggY29tcGFyZXMgbGV2ZWxzIGVpdGhlciBpbiBcImFzY2VuZGluZ1wiIG9yIFwiZGVzY2VuZGluZ1wiIG9yZGVyIG9yIGN1c3RvbSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtTT1JUSU5HX09SREVSIHwgRnVuY3Rpb259IGxldmVsQ29tcGFyaXNvbiBzb3J0IGxldmVscyBvcmRlciBkaXJlY3Rpb24gb3IgY3VzdG9tIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAqIEByZXR1cm5zIEZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdlbkxldmVsQ29tcGFyaXNvbiAobGV2ZWxDb21wYXJpc29uKSB7XG4gIGlmICh0eXBlb2YgbGV2ZWxDb21wYXJpc29uID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb21wYXJlTGV2ZWwuYmluZChudWxsLCBsZXZlbENvbXBhcmlzb24pXG4gIH1cblxuICByZXR1cm4gbGV2ZWxDb21wYXJpc29uXG59XG5cbmZ1bmN0aW9uIG1hcHBpbmdzIChjdXN0b21MZXZlbHMgPSBudWxsLCB1c2VPbmx5Q3VzdG9tTGV2ZWxzID0gZmFsc2UpIHtcbiAgY29uc3QgY3VzdG9tTnVtcyA9IGN1c3RvbUxldmVsc1xuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgPyBPYmplY3Qua2V5cyhjdXN0b21MZXZlbHMpLnJlZHVjZSgobywgaykgPT4ge1xuICAgICAgICBvW2N1c3RvbUxldmVsc1trXV0gPSBrXG4gICAgICAgIHJldHVybiBvXG4gICAgICB9LCB7fSlcbiAgICA6IG51bGxcbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmFzc2lnbihcbiAgICBPYmplY3QuY3JlYXRlKE9iamVjdC5wcm90b3R5cGUsIHsgSW5maW5pdHk6IHsgdmFsdWU6ICdzaWxlbnQnIH0gfSksXG4gICAgdXNlT25seUN1c3RvbUxldmVscyA/IG51bGwgOiBudW1zLFxuICAgIGN1c3RvbU51bXNcbiAgKVxuICBjb25zdCB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKFxuICAgIE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwgeyBzaWxlbnQ6IHsgdmFsdWU6IEluZmluaXR5IH0gfSksXG4gICAgdXNlT25seUN1c3RvbUxldmVscyA/IG51bGwgOiBERUZBVUxUX0xFVkVMUyxcbiAgICBjdXN0b21MZXZlbHNcbiAgKVxuICByZXR1cm4geyBsYWJlbHMsIHZhbHVlcyB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlZmF1bHRMZXZlbEZvdW5kIChkZWZhdWx0TGV2ZWwsIGN1c3RvbUxldmVscywgdXNlT25seUN1c3RvbUxldmVscykge1xuICBpZiAodHlwZW9mIGRlZmF1bHRMZXZlbCA9PT0gJ251bWJlcicpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5jb25jYXQoXG4gICAgICBPYmplY3Qua2V5cyhjdXN0b21MZXZlbHMgfHwge30pLm1hcChrZXkgPT4gY3VzdG9tTGV2ZWxzW2tleV0pLFxuICAgICAgdXNlT25seUN1c3RvbUxldmVscyA/IFtdIDogT2JqZWN0LmtleXMobnVtcykubWFwKGxldmVsID0+ICtsZXZlbCksXG4gICAgICBJbmZpbml0eVxuICAgIClcbiAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyhkZWZhdWx0TGV2ZWwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZGVmYXVsdCBsZXZlbDoke2RlZmF1bHRMZXZlbH0gbXVzdCBiZSBpbmNsdWRlZCBpbiBjdXN0b20gbGV2ZWxzYClcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBsYWJlbHMgPSBPYmplY3QuYXNzaWduKFxuICAgIE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwgeyBzaWxlbnQ6IHsgdmFsdWU6IEluZmluaXR5IH0gfSksXG4gICAgdXNlT25seUN1c3RvbUxldmVscyA/IG51bGwgOiBERUZBVUxUX0xFVkVMUyxcbiAgICBjdXN0b21MZXZlbHNcbiAgKVxuICBpZiAoIShkZWZhdWx0TGV2ZWwgaW4gbGFiZWxzKSkge1xuICAgIHRocm93IEVycm9yKGBkZWZhdWx0IGxldmVsOiR7ZGVmYXVsdExldmVsfSBtdXN0IGJlIGluY2x1ZGVkIGluIGN1c3RvbSBsZXZlbHNgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5vTGV2ZWxDb2xsaXNpb25zIChsZXZlbHMsIGN1c3RvbUxldmVscykge1xuICBjb25zdCB7IGxhYmVscywgdmFsdWVzIH0gPSBsZXZlbHNcbiAgZm9yIChjb25zdCBrIGluIGN1c3RvbUxldmVscykge1xuICAgIGlmIChrIGluIHZhbHVlcykge1xuICAgICAgdGhyb3cgRXJyb3IoJ2xldmVscyBjYW5ub3QgYmUgb3ZlcnJpZGRlbicpXG4gICAgfVxuICAgIGlmIChjdXN0b21MZXZlbHNba10gaW4gbGFiZWxzKSB7XG4gICAgICB0aHJvdyBFcnJvcigncHJlLWV4aXN0aW5nIGxldmVsIHZhbHVlcyBjYW5ub3QgYmUgdXNlZCBmb3IgbmV3IGxldmVscycpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgYGxldmVsQ29tcGFyaXNvbmAgaXMgY29ycmVjdFxuICpcbiAqIEB0aHJvd3MgRXJyb3JcbiAqIEBwYXJhbSB7U09SVElOR19PUkRFUiB8IEZ1bmN0aW9ufSBsZXZlbENvbXBhcmlzb24gLSB2YWx1ZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0TGV2ZWxDb21wYXJpc29uIChsZXZlbENvbXBhcmlzb24pIHtcbiAgaWYgKHR5cGVvZiBsZXZlbENvbXBhcmlzb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0eXBlb2YgbGV2ZWxDb21wYXJpc29uID09PSAnc3RyaW5nJyAmJiBPYmplY3QudmFsdWVzKFNPUlRJTkdfT1JERVIpLmluY2x1ZGVzKGxldmVsQ29tcGFyaXNvbikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignTGV2ZWxzIGNvbXBhcmlzb24gc2hvdWxkIGJlIG9uZSBvZiBcIkFTQ1wiLCBcIkRFU0NcIiBvciBcImZ1bmN0aW9uXCIgdHlwZScpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0aWFsTHNDYWNoZSxcbiAgZ2VuTHNDYWNoZSxcbiAgbGV2ZWxNZXRob2RzLFxuICBnZXRMZXZlbCxcbiAgc2V0TGV2ZWwsXG4gIGlzTGV2ZWxFbmFibGVkLFxuICBtYXBwaW5ncyxcbiAgYXNzZXJ0Tm9MZXZlbENvbGxpc2lvbnMsXG4gIGFzc2VydERlZmF1bHRMZXZlbEZvdW5kLFxuICBnZW5MZXZlbENvbXBhcmlzb24sXG4gIGFzc2VydExldmVsQ29tcGFyaXNvblxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/levels.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/meta.js":
/*!***************************************!*\
  !*** ./node_modules/pino/lib/meta.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = { version: '9.6.0' }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbWV0YS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixtQkFBbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL21ldGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnOS42LjAnIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/meta.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/multistream.js":
/*!**********************************************!*\
  !*** ./node_modules/pino/lib/multistream.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst metadata = Symbol.for('pino.metadata')\nconst { DEFAULT_LEVELS } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/pino/lib/constants.js\")\n\nconst DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info\n\nfunction multistream (streamsArray, opts) {\n  let counter = 0\n  streamsArray = streamsArray || []\n  opts = opts || { dedupe: false }\n\n  const streamLevels = Object.create(DEFAULT_LEVELS)\n  streamLevels.silent = Infinity\n  if (opts.levels && typeof opts.levels === 'object') {\n    Object.keys(opts.levels).forEach(i => {\n      streamLevels[i] = opts.levels[i]\n    })\n  }\n\n  const res = {\n    write,\n    add,\n    emit,\n    flushSync,\n    end,\n    minLevel: 0,\n    streams: [],\n    clone,\n    [metadata]: true,\n    streamLevels\n  }\n\n  if (Array.isArray(streamsArray)) {\n    streamsArray.forEach(add, res)\n  } else {\n    add.call(res, streamsArray)\n  }\n\n  // clean this object up\n  // or it will stay allocated forever\n  // as it is closed on the following closures\n  streamsArray = null\n\n  return res\n\n  // we can exit early because the streams are ordered by level\n  function write (data) {\n    let dest\n    const level = this.lastLevel\n    const { streams } = this\n    // for handling situation when several streams has the same level\n    let recordedLevel = 0\n    let stream\n\n    // if dedupe set to true we send logs to the stream with the highest level\n    // therefore, we have to change sorting order\n    for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {\n      dest = streams[i]\n      if (dest.level <= level) {\n        if (recordedLevel !== 0 && recordedLevel !== dest.level) {\n          break\n        }\n        stream = dest.stream\n        if (stream[metadata]) {\n          const { lastTime, lastMsg, lastObj, lastLogger } = this\n          stream.lastLevel = level\n          stream.lastTime = lastTime\n          stream.lastMsg = lastMsg\n          stream.lastObj = lastObj\n          stream.lastLogger = lastLogger\n        }\n        stream.write(data)\n        if (opts.dedupe) {\n          recordedLevel = dest.level\n        }\n      } else if (!opts.dedupe) {\n        break\n      }\n    }\n  }\n\n  function emit (...args) {\n    for (const { stream } of this.streams) {\n      if (typeof stream.emit === 'function') {\n        stream.emit(...args)\n      }\n    }\n  }\n\n  function flushSync () {\n    for (const { stream } of this.streams) {\n      if (typeof stream.flushSync === 'function') {\n        stream.flushSync()\n      }\n    }\n  }\n\n  function add (dest) {\n    if (!dest) {\n      return res\n    }\n\n    // Check that dest implements either StreamEntry or DestinationStream\n    const isStream = typeof dest.write === 'function' || dest.stream\n    const stream_ = dest.write ? dest : dest.stream\n    // This is necessary to provide a meaningful error message, otherwise it throws somewhere inside write()\n    if (!isStream) {\n      throw Error('stream object needs to implement either StreamEntry or DestinationStream interface')\n    }\n\n    const { streams, streamLevels } = this\n\n    let level\n    if (typeof dest.levelVal === 'number') {\n      level = dest.levelVal\n    } else if (typeof dest.level === 'string') {\n      level = streamLevels[dest.level]\n    } else if (typeof dest.level === 'number') {\n      level = dest.level\n    } else {\n      level = DEFAULT_INFO_LEVEL\n    }\n\n    const dest_ = {\n      stream: stream_,\n      level,\n      levelVal: undefined,\n      id: counter++\n    }\n\n    streams.unshift(dest_)\n    streams.sort(compareByLevel)\n\n    this.minLevel = streams[0].level\n\n    return res\n  }\n\n  function end () {\n    for (const { stream } of this.streams) {\n      if (typeof stream.flushSync === 'function') {\n        stream.flushSync()\n      }\n      stream.end()\n    }\n  }\n\n  function clone (level) {\n    const streams = new Array(this.streams.length)\n\n    for (let i = 0; i < streams.length; i++) {\n      streams[i] = {\n        level,\n        stream: this.streams[i].stream\n      }\n    }\n\n    return {\n      write,\n      add,\n      minLevel: level,\n      streams,\n      clone,\n      emit,\n      flushSync,\n      [metadata]: true\n    }\n  }\n}\n\nfunction compareByLevel (a, b) {\n  return a.level - b.level\n}\n\nfunction initLoopVar (length, dedupe) {\n  return dedupe ? length - 1 : 0\n}\n\nfunction adjustLoopVar (i, dedupe) {\n  return dedupe ? i - 1 : i + 1\n}\n\nfunction checkLoopVar (i, length, dedupe) {\n  return dedupe ? i >= 0 : i < length\n}\n\nmodule.exports = multistream\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbXVsdGlzdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsK0RBQWE7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJELDhDQUE4QztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBeUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHdCQUF3Qjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9waW5vL2xpYi9tdWx0aXN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgbWV0YWRhdGEgPSBTeW1ib2wuZm9yKCdwaW5vLm1ldGFkYXRhJylcbmNvbnN0IHsgREVGQVVMVF9MRVZFTFMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY29uc3QgREVGQVVMVF9JTkZPX0xFVkVMID0gREVGQVVMVF9MRVZFTFMuaW5mb1xuXG5mdW5jdGlvbiBtdWx0aXN0cmVhbSAoc3RyZWFtc0FycmF5LCBvcHRzKSB7XG4gIGxldCBjb3VudGVyID0gMFxuICBzdHJlYW1zQXJyYXkgPSBzdHJlYW1zQXJyYXkgfHwgW11cbiAgb3B0cyA9IG9wdHMgfHwgeyBkZWR1cGU6IGZhbHNlIH1cblxuICBjb25zdCBzdHJlYW1MZXZlbHMgPSBPYmplY3QuY3JlYXRlKERFRkFVTFRfTEVWRUxTKVxuICBzdHJlYW1MZXZlbHMuc2lsZW50ID0gSW5maW5pdHlcbiAgaWYgKG9wdHMubGV2ZWxzICYmIHR5cGVvZiBvcHRzLmxldmVscyA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3Qua2V5cyhvcHRzLmxldmVscykuZm9yRWFjaChpID0+IHtcbiAgICAgIHN0cmVhbUxldmVsc1tpXSA9IG9wdHMubGV2ZWxzW2ldXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHJlcyA9IHtcbiAgICB3cml0ZSxcbiAgICBhZGQsXG4gICAgZW1pdCxcbiAgICBmbHVzaFN5bmMsXG4gICAgZW5kLFxuICAgIG1pbkxldmVsOiAwLFxuICAgIHN0cmVhbXM6IFtdLFxuICAgIGNsb25lLFxuICAgIFttZXRhZGF0YV06IHRydWUsXG4gICAgc3RyZWFtTGV2ZWxzXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zQXJyYXkpKSB7XG4gICAgc3RyZWFtc0FycmF5LmZvckVhY2goYWRkLCByZXMpXG4gIH0gZWxzZSB7XG4gICAgYWRkLmNhbGwocmVzLCBzdHJlYW1zQXJyYXkpXG4gIH1cblxuICAvLyBjbGVhbiB0aGlzIG9iamVjdCB1cFxuICAvLyBvciBpdCB3aWxsIHN0YXkgYWxsb2NhdGVkIGZvcmV2ZXJcbiAgLy8gYXMgaXQgaXMgY2xvc2VkIG9uIHRoZSBmb2xsb3dpbmcgY2xvc3VyZXNcbiAgc3RyZWFtc0FycmF5ID0gbnVsbFxuXG4gIHJldHVybiByZXNcblxuICAvLyB3ZSBjYW4gZXhpdCBlYXJseSBiZWNhdXNlIHRoZSBzdHJlYW1zIGFyZSBvcmRlcmVkIGJ5IGxldmVsXG4gIGZ1bmN0aW9uIHdyaXRlIChkYXRhKSB7XG4gICAgbGV0IGRlc3RcbiAgICBjb25zdCBsZXZlbCA9IHRoaXMubGFzdExldmVsXG4gICAgY29uc3QgeyBzdHJlYW1zIH0gPSB0aGlzXG4gICAgLy8gZm9yIGhhbmRsaW5nIHNpdHVhdGlvbiB3aGVuIHNldmVyYWwgc3RyZWFtcyBoYXMgdGhlIHNhbWUgbGV2ZWxcbiAgICBsZXQgcmVjb3JkZWRMZXZlbCA9IDBcbiAgICBsZXQgc3RyZWFtXG5cbiAgICAvLyBpZiBkZWR1cGUgc2V0IHRvIHRydWUgd2Ugc2VuZCBsb2dzIHRvIHRoZSBzdHJlYW0gd2l0aCB0aGUgaGlnaGVzdCBsZXZlbFxuICAgIC8vIHRoZXJlZm9yZSwgd2UgaGF2ZSB0byBjaGFuZ2Ugc29ydGluZyBvcmRlclxuICAgIGZvciAobGV0IGkgPSBpbml0TG9vcFZhcihzdHJlYW1zLmxlbmd0aCwgb3B0cy5kZWR1cGUpOyBjaGVja0xvb3BWYXIoaSwgc3RyZWFtcy5sZW5ndGgsIG9wdHMuZGVkdXBlKTsgaSA9IGFkanVzdExvb3BWYXIoaSwgb3B0cy5kZWR1cGUpKSB7XG4gICAgICBkZXN0ID0gc3RyZWFtc1tpXVxuICAgICAgaWYgKGRlc3QubGV2ZWwgPD0gbGV2ZWwpIHtcbiAgICAgICAgaWYgKHJlY29yZGVkTGV2ZWwgIT09IDAgJiYgcmVjb3JkZWRMZXZlbCAhPT0gZGVzdC5sZXZlbCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtID0gZGVzdC5zdHJlYW1cbiAgICAgICAgaWYgKHN0cmVhbVttZXRhZGF0YV0pIHtcbiAgICAgICAgICBjb25zdCB7IGxhc3RUaW1lLCBsYXN0TXNnLCBsYXN0T2JqLCBsYXN0TG9nZ2VyIH0gPSB0aGlzXG4gICAgICAgICAgc3RyZWFtLmxhc3RMZXZlbCA9IGxldmVsXG4gICAgICAgICAgc3RyZWFtLmxhc3RUaW1lID0gbGFzdFRpbWVcbiAgICAgICAgICBzdHJlYW0ubGFzdE1zZyA9IGxhc3RNc2dcbiAgICAgICAgICBzdHJlYW0ubGFzdE9iaiA9IGxhc3RPYmpcbiAgICAgICAgICBzdHJlYW0ubGFzdExvZ2dlciA9IGxhc3RMb2dnZXJcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ud3JpdGUoZGF0YSlcbiAgICAgICAgaWYgKG9wdHMuZGVkdXBlKSB7XG4gICAgICAgICAgcmVjb3JkZWRMZXZlbCA9IGRlc3QubGV2ZWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghb3B0cy5kZWR1cGUpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0ICguLi5hcmdzKSB7XG4gICAgZm9yIChjb25zdCB7IHN0cmVhbSB9IG9mIHRoaXMuc3RyZWFtcykge1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW0uZW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdHJlYW0uZW1pdCguLi5hcmdzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoU3luYyAoKSB7XG4gICAgZm9yIChjb25zdCB7IHN0cmVhbSB9IG9mIHRoaXMuc3RyZWFtcykge1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW0uZmx1c2hTeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0cmVhbS5mbHVzaFN5bmMoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZCAoZGVzdCkge1xuICAgIGlmICghZGVzdCkge1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoYXQgZGVzdCBpbXBsZW1lbnRzIGVpdGhlciBTdHJlYW1FbnRyeSBvciBEZXN0aW5hdGlvblN0cmVhbVxuICAgIGNvbnN0IGlzU3RyZWFtID0gdHlwZW9mIGRlc3Qud3JpdGUgPT09ICdmdW5jdGlvbicgfHwgZGVzdC5zdHJlYW1cbiAgICBjb25zdCBzdHJlYW1fID0gZGVzdC53cml0ZSA/IGRlc3QgOiBkZXN0LnN0cmVhbVxuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHByb3ZpZGUgYSBtZWFuaW5nZnVsIGVycm9yIG1lc3NhZ2UsIG90aGVyd2lzZSBpdCB0aHJvd3Mgc29tZXdoZXJlIGluc2lkZSB3cml0ZSgpXG4gICAgaWYgKCFpc1N0cmVhbSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ3N0cmVhbSBvYmplY3QgbmVlZHMgdG8gaW1wbGVtZW50IGVpdGhlciBTdHJlYW1FbnRyeSBvciBEZXN0aW5hdGlvblN0cmVhbSBpbnRlcmZhY2UnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc3RyZWFtcywgc3RyZWFtTGV2ZWxzIH0gPSB0aGlzXG5cbiAgICBsZXQgbGV2ZWxcbiAgICBpZiAodHlwZW9mIGRlc3QubGV2ZWxWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICBsZXZlbCA9IGRlc3QubGV2ZWxWYWxcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0LmxldmVsID09PSAnc3RyaW5nJykge1xuICAgICAgbGV2ZWwgPSBzdHJlYW1MZXZlbHNbZGVzdC5sZXZlbF1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0LmxldmVsID09PSAnbnVtYmVyJykge1xuICAgICAgbGV2ZWwgPSBkZXN0LmxldmVsXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsID0gREVGQVVMVF9JTkZPX0xFVkVMXG4gICAgfVxuXG4gICAgY29uc3QgZGVzdF8gPSB7XG4gICAgICBzdHJlYW06IHN0cmVhbV8sXG4gICAgICBsZXZlbCxcbiAgICAgIGxldmVsVmFsOiB1bmRlZmluZWQsXG4gICAgICBpZDogY291bnRlcisrXG4gICAgfVxuXG4gICAgc3RyZWFtcy51bnNoaWZ0KGRlc3RfKVxuICAgIHN0cmVhbXMuc29ydChjb21wYXJlQnlMZXZlbClcblxuICAgIHRoaXMubWluTGV2ZWwgPSBzdHJlYW1zWzBdLmxldmVsXG5cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBlbmQgKCkge1xuICAgIGZvciAoY29uc3QgeyBzdHJlYW0gfSBvZiB0aGlzLnN0cmVhbXMpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyZWFtLmZsdXNoU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdHJlYW0uZmx1c2hTeW5jKClcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5lbmQoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lIChsZXZlbCkge1xuICAgIGNvbnN0IHN0cmVhbXMgPSBuZXcgQXJyYXkodGhpcy5zdHJlYW1zLmxlbmd0aClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3RyZWFtc1tpXSA9IHtcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIHN0cmVhbTogdGhpcy5zdHJlYW1zW2ldLnN0cmVhbVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3cml0ZSxcbiAgICAgIGFkZCxcbiAgICAgIG1pbkxldmVsOiBsZXZlbCxcbiAgICAgIHN0cmVhbXMsXG4gICAgICBjbG9uZSxcbiAgICAgIGVtaXQsXG4gICAgICBmbHVzaFN5bmMsXG4gICAgICBbbWV0YWRhdGFdOiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVCeUxldmVsIChhLCBiKSB7XG4gIHJldHVybiBhLmxldmVsIC0gYi5sZXZlbFxufVxuXG5mdW5jdGlvbiBpbml0TG9vcFZhciAobGVuZ3RoLCBkZWR1cGUpIHtcbiAgcmV0dXJuIGRlZHVwZSA/IGxlbmd0aCAtIDEgOiAwXG59XG5cbmZ1bmN0aW9uIGFkanVzdExvb3BWYXIgKGksIGRlZHVwZSkge1xuICByZXR1cm4gZGVkdXBlID8gaSAtIDEgOiBpICsgMVxufVxuXG5mdW5jdGlvbiBjaGVja0xvb3BWYXIgKGksIGxlbmd0aCwgZGVkdXBlKSB7XG4gIHJldHVybiBkZWR1cGUgPyBpID49IDAgOiBpIDwgbGVuZ3RoXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbXVsdGlzdHJlYW1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/multistream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/proto.js":
/*!****************************************!*\
  !*** ./node_modules/pino/lib/proto.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint no-prototype-builtins: 0 */\n\nconst { EventEmitter } = __webpack_require__(/*! node:events */ \"node:events\")\nconst {\n  lsCacheSym,\n  levelValSym,\n  setLevelSym,\n  getLevelSym,\n  chindingsSym,\n  parsedChindingsSym,\n  mixinSym,\n  asJsonSym,\n  writeSym,\n  mixinMergeStrategySym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  serializersSym,\n  formattersSym,\n  errorKeySym,\n  messageKeySym,\n  useOnlyCustomLevelsSym,\n  needsMetadataGsym,\n  redactFmtSym,\n  stringifySym,\n  formatOptsSym,\n  stringifiersSym,\n  msgPrefixSym,\n  hooksSym\n} = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/pino/lib/symbols.js\")\nconst {\n  getLevel,\n  setLevel,\n  isLevelEnabled,\n  mappings,\n  initialLsCache,\n  genLsCache,\n  assertNoLevelCollisions\n} = __webpack_require__(/*! ./levels */ \"(rsc)/./node_modules/pino/lib/levels.js\")\nconst {\n  asChindings,\n  asJson,\n  buildFormatters,\n  stringify\n} = __webpack_require__(/*! ./tools */ \"(rsc)/./node_modules/pino/lib/tools.js\")\nconst {\n  version\n} = __webpack_require__(/*! ./meta */ \"(rsc)/./node_modules/pino/lib/meta.js\")\nconst redaction = __webpack_require__(/*! ./redaction */ \"(rsc)/./node_modules/pino/lib/redaction.js\")\n\n// note: use of class is satirical\n// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127\nconst constructor = class Pino {}\nconst prototype = {\n  constructor,\n  child,\n  bindings,\n  setBindings,\n  flush,\n  isLevelEnabled,\n  version,\n  get level () { return this[getLevelSym]() },\n  set level (lvl) { this[setLevelSym](lvl) },\n  get levelVal () { return this[levelValSym] },\n  set levelVal (n) { throw Error('levelVal is read-only') },\n  [lsCacheSym]: initialLsCache,\n  [writeSym]: write,\n  [asJsonSym]: asJson,\n  [getLevelSym]: getLevel,\n  [setLevelSym]: setLevel\n}\n\nObject.setPrototypeOf(prototype, EventEmitter.prototype)\n\n// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing\nmodule.exports = function () {\n  return Object.create(prototype)\n}\n\nconst resetChildingsFormatter = bindings => bindings\nfunction child (bindings, options) {\n  if (!bindings) {\n    throw Error('missing bindings for child Pino')\n  }\n  options = options || {} // default options to empty object\n  const serializers = this[serializersSym]\n  const formatters = this[formattersSym]\n  const instance = Object.create(this)\n\n  if (options.hasOwnProperty('serializers') === true) {\n    instance[serializersSym] = Object.create(null)\n\n    for (const k in serializers) {\n      instance[serializersSym][k] = serializers[k]\n    }\n    const parentSymbols = Object.getOwnPropertySymbols(serializers)\n    /* eslint no-var: off */\n    for (var i = 0; i < parentSymbols.length; i++) {\n      const ks = parentSymbols[i]\n      instance[serializersSym][ks] = serializers[ks]\n    }\n\n    for (const bk in options.serializers) {\n      instance[serializersSym][bk] = options.serializers[bk]\n    }\n    const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers)\n    for (var bi = 0; bi < bindingsSymbols.length; bi++) {\n      const bks = bindingsSymbols[bi]\n      instance[serializersSym][bks] = options.serializers[bks]\n    }\n  } else instance[serializersSym] = serializers\n  if (options.hasOwnProperty('formatters')) {\n    const { level, bindings: chindings, log } = options.formatters\n    instance[formattersSym] = buildFormatters(\n      level || formatters.level,\n      chindings || resetChildingsFormatter,\n      log || formatters.log\n    )\n  } else {\n    instance[formattersSym] = buildFormatters(\n      formatters.level,\n      resetChildingsFormatter,\n      formatters.log\n    )\n  }\n  if (options.hasOwnProperty('customLevels') === true) {\n    assertNoLevelCollisions(this.levels, options.customLevels)\n    instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym])\n    genLsCache(instance)\n  }\n\n  // redact must place before asChindings and only replace if exist\n  if ((typeof options.redact === 'object' && options.redact !== null) || Array.isArray(options.redact)) {\n    instance.redact = options.redact // replace redact directly\n    const stringifiers = redaction(instance.redact, stringify)\n    const formatOpts = { stringify: stringifiers[redactFmtSym] }\n    instance[stringifySym] = stringify\n    instance[stringifiersSym] = stringifiers\n    instance[formatOptsSym] = formatOpts\n  }\n\n  if (typeof options.msgPrefix === 'string') {\n    instance[msgPrefixSym] = (this[msgPrefixSym] || '') + options.msgPrefix\n  }\n\n  instance[chindingsSym] = asChindings(instance, bindings)\n  const childLevel = options.level || this.level\n  instance[setLevelSym](childLevel)\n  this.onChild(instance)\n  return instance\n}\n\nfunction bindings () {\n  const chindings = this[chindingsSym]\n  const chindingsJson = `{${chindings.substr(1)}}` // at least contains ,\"pid\":7068,\"hostname\":\"myMac\"\n  const bindingsFromJson = JSON.parse(chindingsJson)\n  delete bindingsFromJson.pid\n  delete bindingsFromJson.hostname\n  return bindingsFromJson\n}\n\nfunction setBindings (newBindings) {\n  const chindings = asChindings(this, newBindings)\n  this[chindingsSym] = chindings\n  delete this[parsedChindingsSym]\n}\n\n/**\n * Default strategy for creating `mergeObject` from arguments and the result from `mixin()`.\n * Fields from `mergeObject` have higher priority in this strategy.\n *\n * @param {Object} mergeObject The object a user has supplied to the logging function.\n * @param {Object} mixinObject The result of the `mixin` method.\n * @return {Object}\n */\nfunction defaultMixinMergeStrategy (mergeObject, mixinObject) {\n  return Object.assign(mixinObject, mergeObject)\n}\n\nfunction write (_obj, msg, num) {\n  const t = this[timeSym]()\n  const mixin = this[mixinSym]\n  const errorKey = this[errorKeySym]\n  const messageKey = this[messageKeySym]\n  const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy\n  let obj\n  const streamWriteHook = this[hooksSym].streamWrite\n\n  if (_obj === undefined || _obj === null) {\n    obj = {}\n  } else if (_obj instanceof Error) {\n    obj = { [errorKey]: _obj }\n    if (msg === undefined) {\n      msg = _obj.message\n    }\n  } else {\n    obj = _obj\n    if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {\n      msg = _obj[errorKey].message\n    }\n  }\n\n  if (mixin) {\n    obj = mixinMergeStrategy(obj, mixin(obj, num, this))\n  }\n\n  const s = this[asJsonSym](obj, msg, num, t)\n\n  const stream = this[streamSym]\n  if (stream[needsMetadataGsym] === true) {\n    stream.lastLevel = num\n    stream.lastObj = obj\n    stream.lastMsg = msg\n    stream.lastTime = t.slice(this[timeSliceIndexSym])\n    stream.lastLogger = this // for child loggers\n  }\n  stream.write(streamWriteHook ? streamWriteHook(s) : s)\n}\n\nfunction noop () {}\n\nfunction flush (cb) {\n  if (cb != null && typeof cb !== 'function') {\n    throw Error('callback must be a function')\n  }\n\n  const stream = this[streamSym]\n\n  if (typeof stream.flush === 'function') {\n    stream.flush(cb || noop)\n  } else if (cb) cb()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvcHJvdG8uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUEsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkRBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHlEQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx1REFBUztBQUNyQjtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscURBQVE7QUFDcEIsa0JBQWtCLG1CQUFPLENBQUMsK0RBQWE7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDLG9CQUFvQix3QkFBd0I7QUFDNUMsb0JBQW9CLDBCQUEwQjtBQUM5QyxxQkFBcUIsc0NBQXNDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixFQUFFLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9waW5vL2xpYi9wcm90by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyogZXNsaW50IG5vLXByb3RvdHlwZS1idWlsdGluczogMCAqL1xuXG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuY29uc3Qge1xuICBsc0NhY2hlU3ltLFxuICBsZXZlbFZhbFN5bSxcbiAgc2V0TGV2ZWxTeW0sXG4gIGdldExldmVsU3ltLFxuICBjaGluZGluZ3NTeW0sXG4gIHBhcnNlZENoaW5kaW5nc1N5bSxcbiAgbWl4aW5TeW0sXG4gIGFzSnNvblN5bSxcbiAgd3JpdGVTeW0sXG4gIG1peGluTWVyZ2VTdHJhdGVneVN5bSxcbiAgdGltZVN5bSxcbiAgdGltZVNsaWNlSW5kZXhTeW0sXG4gIHN0cmVhbVN5bSxcbiAgc2VyaWFsaXplcnNTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBtZXNzYWdlS2V5U3ltLFxuICB1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltLFxuICBuZWVkc01ldGFkYXRhR3N5bSxcbiAgcmVkYWN0Rm10U3ltLFxuICBzdHJpbmdpZnlTeW0sXG4gIGZvcm1hdE9wdHNTeW0sXG4gIHN0cmluZ2lmaWVyc1N5bSxcbiAgbXNnUHJlZml4U3ltLFxuICBob29rc1N5bVxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7XG4gIGdldExldmVsLFxuICBzZXRMZXZlbCxcbiAgaXNMZXZlbEVuYWJsZWQsXG4gIG1hcHBpbmdzLFxuICBpbml0aWFsTHNDYWNoZSxcbiAgZ2VuTHNDYWNoZSxcbiAgYXNzZXJ0Tm9MZXZlbENvbGxpc2lvbnNcbn0gPSByZXF1aXJlKCcuL2xldmVscycpXG5jb25zdCB7XG4gIGFzQ2hpbmRpbmdzLFxuICBhc0pzb24sXG4gIGJ1aWxkRm9ybWF0dGVycyxcbiAgc3RyaW5naWZ5XG59ID0gcmVxdWlyZSgnLi90b29scycpXG5jb25zdCB7XG4gIHZlcnNpb25cbn0gPSByZXF1aXJlKCcuL21ldGEnKVxuY29uc3QgcmVkYWN0aW9uID0gcmVxdWlyZSgnLi9yZWRhY3Rpb24nKVxuXG4vLyBub3RlOiB1c2Ugb2YgY2xhc3MgaXMgc2F0aXJpY2FsXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGlub2pzL3Bpbm8vcHVsbC80MzMjcHVsbHJlcXVlc3RyZXZpZXctMTI3NzAzMTI3XG5jb25zdCBjb25zdHJ1Y3RvciA9IGNsYXNzIFBpbm8ge31cbmNvbnN0IHByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3IsXG4gIGNoaWxkLFxuICBiaW5kaW5ncyxcbiAgc2V0QmluZGluZ3MsXG4gIGZsdXNoLFxuICBpc0xldmVsRW5hYmxlZCxcbiAgdmVyc2lvbixcbiAgZ2V0IGxldmVsICgpIHsgcmV0dXJuIHRoaXNbZ2V0TGV2ZWxTeW1dKCkgfSxcbiAgc2V0IGxldmVsIChsdmwpIHsgdGhpc1tzZXRMZXZlbFN5bV0obHZsKSB9LFxuICBnZXQgbGV2ZWxWYWwgKCkgeyByZXR1cm4gdGhpc1tsZXZlbFZhbFN5bV0gfSxcbiAgc2V0IGxldmVsVmFsIChuKSB7IHRocm93IEVycm9yKCdsZXZlbFZhbCBpcyByZWFkLW9ubHknKSB9LFxuICBbbHNDYWNoZVN5bV06IGluaXRpYWxMc0NhY2hlLFxuICBbd3JpdGVTeW1dOiB3cml0ZSxcbiAgW2FzSnNvblN5bV06IGFzSnNvbixcbiAgW2dldExldmVsU3ltXTogZ2V0TGV2ZWwsXG4gIFtzZXRMZXZlbFN5bV06IHNldExldmVsXG59XG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90b3R5cGUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpXG5cbi8vIGV4cG9ydGluZyBhbmQgY29uc3VtaW5nIHRoZSBwcm90b3R5cGUgb2JqZWN0IHVzaW5nIGZhY3RvcnkgcGF0dGVybiBmaXhlcyBzY29waW5nIGlzc3VlcyB3aXRoIGdldHRlcnMgd2hlbiBzZXJpYWxpemluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSlcbn1cblxuY29uc3QgcmVzZXRDaGlsZGluZ3NGb3JtYXR0ZXIgPSBiaW5kaW5ncyA9PiBiaW5kaW5nc1xuZnVuY3Rpb24gY2hpbGQgKGJpbmRpbmdzLCBvcHRpb25zKSB7XG4gIGlmICghYmluZGluZ3MpIHtcbiAgICB0aHJvdyBFcnJvcignbWlzc2luZyBiaW5kaW5ncyBmb3IgY2hpbGQgUGlubycpXG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge30gLy8gZGVmYXVsdCBvcHRpb25zIHRvIGVtcHR5IG9iamVjdFxuICBjb25zdCBzZXJpYWxpemVycyA9IHRoaXNbc2VyaWFsaXplcnNTeW1dXG4gIGNvbnN0IGZvcm1hdHRlcnMgPSB0aGlzW2Zvcm1hdHRlcnNTeW1dXG4gIGNvbnN0IGluc3RhbmNlID0gT2JqZWN0LmNyZWF0ZSh0aGlzKVxuXG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdzZXJpYWxpemVycycpID09PSB0cnVlKSB7XG4gICAgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgZm9yIChjb25zdCBrIGluIHNlcmlhbGl6ZXJzKSB7XG4gICAgICBpbnN0YW5jZVtzZXJpYWxpemVyc1N5bV1ba10gPSBzZXJpYWxpemVyc1trXVxuICAgIH1cbiAgICBjb25zdCBwYXJlbnRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzZXJpYWxpemVycylcbiAgICAvKiBlc2xpbnQgbm8tdmFyOiBvZmYgKi9cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtzID0gcGFyZW50U3ltYm9sc1tpXVxuICAgICAgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dW2tzXSA9IHNlcmlhbGl6ZXJzW2tzXVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgYmsgaW4gb3B0aW9ucy5zZXJpYWxpemVycykge1xuICAgICAgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dW2JrXSA9IG9wdGlvbnMuc2VyaWFsaXplcnNbYmtdXG4gICAgfVxuICAgIGNvbnN0IGJpbmRpbmdzU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob3B0aW9ucy5zZXJpYWxpemVycylcbiAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYmluZGluZ3NTeW1ib2xzLmxlbmd0aDsgYmkrKykge1xuICAgICAgY29uc3QgYmtzID0gYmluZGluZ3NTeW1ib2xzW2JpXVxuICAgICAgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dW2Jrc10gPSBvcHRpb25zLnNlcmlhbGl6ZXJzW2Jrc11cbiAgICB9XG4gIH0gZWxzZSBpbnN0YW5jZVtzZXJpYWxpemVyc1N5bV0gPSBzZXJpYWxpemVyc1xuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZm9ybWF0dGVycycpKSB7XG4gICAgY29uc3QgeyBsZXZlbCwgYmluZGluZ3M6IGNoaW5kaW5ncywgbG9nIH0gPSBvcHRpb25zLmZvcm1hdHRlcnNcbiAgICBpbnN0YW5jZVtmb3JtYXR0ZXJzU3ltXSA9IGJ1aWxkRm9ybWF0dGVycyhcbiAgICAgIGxldmVsIHx8IGZvcm1hdHRlcnMubGV2ZWwsXG4gICAgICBjaGluZGluZ3MgfHwgcmVzZXRDaGlsZGluZ3NGb3JtYXR0ZXIsXG4gICAgICBsb2cgfHwgZm9ybWF0dGVycy5sb2dcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2VbZm9ybWF0dGVyc1N5bV0gPSBidWlsZEZvcm1hdHRlcnMoXG4gICAgICBmb3JtYXR0ZXJzLmxldmVsLFxuICAgICAgcmVzZXRDaGlsZGluZ3NGb3JtYXR0ZXIsXG4gICAgICBmb3JtYXR0ZXJzLmxvZ1xuICAgIClcbiAgfVxuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnY3VzdG9tTGV2ZWxzJykgPT09IHRydWUpIHtcbiAgICBhc3NlcnROb0xldmVsQ29sbGlzaW9ucyh0aGlzLmxldmVscywgb3B0aW9ucy5jdXN0b21MZXZlbHMpXG4gICAgaW5zdGFuY2UubGV2ZWxzID0gbWFwcGluZ3Mob3B0aW9ucy5jdXN0b21MZXZlbHMsIGluc3RhbmNlW3VzZU9ubHlDdXN0b21MZXZlbHNTeW1dKVxuICAgIGdlbkxzQ2FjaGUoaW5zdGFuY2UpXG4gIH1cblxuICAvLyByZWRhY3QgbXVzdCBwbGFjZSBiZWZvcmUgYXNDaGluZGluZ3MgYW5kIG9ubHkgcmVwbGFjZSBpZiBleGlzdFxuICBpZiAoKHR5cGVvZiBvcHRpb25zLnJlZGFjdCA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucy5yZWRhY3QgIT09IG51bGwpIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZWRhY3QpKSB7XG4gICAgaW5zdGFuY2UucmVkYWN0ID0gb3B0aW9ucy5yZWRhY3QgLy8gcmVwbGFjZSByZWRhY3QgZGlyZWN0bHlcbiAgICBjb25zdCBzdHJpbmdpZmllcnMgPSByZWRhY3Rpb24oaW5zdGFuY2UucmVkYWN0LCBzdHJpbmdpZnkpXG4gICAgY29uc3QgZm9ybWF0T3B0cyA9IHsgc3RyaW5naWZ5OiBzdHJpbmdpZmllcnNbcmVkYWN0Rm10U3ltXSB9XG4gICAgaW5zdGFuY2Vbc3RyaW5naWZ5U3ltXSA9IHN0cmluZ2lmeVxuICAgIGluc3RhbmNlW3N0cmluZ2lmaWVyc1N5bV0gPSBzdHJpbmdpZmllcnNcbiAgICBpbnN0YW5jZVtmb3JtYXRPcHRzU3ltXSA9IGZvcm1hdE9wdHNcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5tc2dQcmVmaXggPT09ICdzdHJpbmcnKSB7XG4gICAgaW5zdGFuY2VbbXNnUHJlZml4U3ltXSA9ICh0aGlzW21zZ1ByZWZpeFN5bV0gfHwgJycpICsgb3B0aW9ucy5tc2dQcmVmaXhcbiAgfVxuXG4gIGluc3RhbmNlW2NoaW5kaW5nc1N5bV0gPSBhc0NoaW5kaW5ncyhpbnN0YW5jZSwgYmluZGluZ3MpXG4gIGNvbnN0IGNoaWxkTGV2ZWwgPSBvcHRpb25zLmxldmVsIHx8IHRoaXMubGV2ZWxcbiAgaW5zdGFuY2Vbc2V0TGV2ZWxTeW1dKGNoaWxkTGV2ZWwpXG4gIHRoaXMub25DaGlsZChpbnN0YW5jZSlcbiAgcmV0dXJuIGluc3RhbmNlXG59XG5cbmZ1bmN0aW9uIGJpbmRpbmdzICgpIHtcbiAgY29uc3QgY2hpbmRpbmdzID0gdGhpc1tjaGluZGluZ3NTeW1dXG4gIGNvbnN0IGNoaW5kaW5nc0pzb24gPSBgeyR7Y2hpbmRpbmdzLnN1YnN0cigxKX19YCAvLyBhdCBsZWFzdCBjb250YWlucyAsXCJwaWRcIjo3MDY4LFwiaG9zdG5hbWVcIjpcIm15TWFjXCJcbiAgY29uc3QgYmluZGluZ3NGcm9tSnNvbiA9IEpTT04ucGFyc2UoY2hpbmRpbmdzSnNvbilcbiAgZGVsZXRlIGJpbmRpbmdzRnJvbUpzb24ucGlkXG4gIGRlbGV0ZSBiaW5kaW5nc0Zyb21Kc29uLmhvc3RuYW1lXG4gIHJldHVybiBiaW5kaW5nc0Zyb21Kc29uXG59XG5cbmZ1bmN0aW9uIHNldEJpbmRpbmdzIChuZXdCaW5kaW5ncykge1xuICBjb25zdCBjaGluZGluZ3MgPSBhc0NoaW5kaW5ncyh0aGlzLCBuZXdCaW5kaW5ncylcbiAgdGhpc1tjaGluZGluZ3NTeW1dID0gY2hpbmRpbmdzXG4gIGRlbGV0ZSB0aGlzW3BhcnNlZENoaW5kaW5nc1N5bV1cbn1cblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5IGZvciBjcmVhdGluZyBgbWVyZ2VPYmplY3RgIGZyb20gYXJndW1lbnRzIGFuZCB0aGUgcmVzdWx0IGZyb20gYG1peGluKClgLlxuICogRmllbGRzIGZyb20gYG1lcmdlT2JqZWN0YCBoYXZlIGhpZ2hlciBwcmlvcml0eSBpbiB0aGlzIHN0cmF0ZWd5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZXJnZU9iamVjdCBUaGUgb2JqZWN0IGEgdXNlciBoYXMgc3VwcGxpZWQgdG8gdGhlIGxvZ2dpbmcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gbWl4aW5PYmplY3QgVGhlIHJlc3VsdCBvZiB0aGUgYG1peGluYCBtZXRob2QuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRNaXhpbk1lcmdlU3RyYXRlZ3kgKG1lcmdlT2JqZWN0LCBtaXhpbk9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihtaXhpbk9iamVjdCwgbWVyZ2VPYmplY3QpXG59XG5cbmZ1bmN0aW9uIHdyaXRlIChfb2JqLCBtc2csIG51bSkge1xuICBjb25zdCB0ID0gdGhpc1t0aW1lU3ltXSgpXG4gIGNvbnN0IG1peGluID0gdGhpc1ttaXhpblN5bV1cbiAgY29uc3QgZXJyb3JLZXkgPSB0aGlzW2Vycm9yS2V5U3ltXVxuICBjb25zdCBtZXNzYWdlS2V5ID0gdGhpc1ttZXNzYWdlS2V5U3ltXVxuICBjb25zdCBtaXhpbk1lcmdlU3RyYXRlZ3kgPSB0aGlzW21peGluTWVyZ2VTdHJhdGVneVN5bV0gfHwgZGVmYXVsdE1peGluTWVyZ2VTdHJhdGVneVxuICBsZXQgb2JqXG4gIGNvbnN0IHN0cmVhbVdyaXRlSG9vayA9IHRoaXNbaG9va3NTeW1dLnN0cmVhbVdyaXRlXG5cbiAgaWYgKF9vYmogPT09IHVuZGVmaW5lZCB8fCBfb2JqID09PSBudWxsKSB7XG4gICAgb2JqID0ge31cbiAgfSBlbHNlIGlmIChfb2JqIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBvYmogPSB7IFtlcnJvcktleV06IF9vYmogfVxuICAgIGlmIChtc2cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbXNnID0gX29iai5tZXNzYWdlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9iaiA9IF9vYmpcbiAgICBpZiAobXNnID09PSB1bmRlZmluZWQgJiYgX29ialttZXNzYWdlS2V5XSA9PT0gdW5kZWZpbmVkICYmIF9vYmpbZXJyb3JLZXldKSB7XG4gICAgICBtc2cgPSBfb2JqW2Vycm9yS2V5XS5tZXNzYWdlXG4gICAgfVxuICB9XG5cbiAgaWYgKG1peGluKSB7XG4gICAgb2JqID0gbWl4aW5NZXJnZVN0cmF0ZWd5KG9iaiwgbWl4aW4ob2JqLCBudW0sIHRoaXMpKVxuICB9XG5cbiAgY29uc3QgcyA9IHRoaXNbYXNKc29uU3ltXShvYmosIG1zZywgbnVtLCB0KVxuXG4gIGNvbnN0IHN0cmVhbSA9IHRoaXNbc3RyZWFtU3ltXVxuICBpZiAoc3RyZWFtW25lZWRzTWV0YWRhdGFHc3ltXSA9PT0gdHJ1ZSkge1xuICAgIHN0cmVhbS5sYXN0TGV2ZWwgPSBudW1cbiAgICBzdHJlYW0ubGFzdE9iaiA9IG9ialxuICAgIHN0cmVhbS5sYXN0TXNnID0gbXNnXG4gICAgc3RyZWFtLmxhc3RUaW1lID0gdC5zbGljZSh0aGlzW3RpbWVTbGljZUluZGV4U3ltXSlcbiAgICBzdHJlYW0ubGFzdExvZ2dlciA9IHRoaXMgLy8gZm9yIGNoaWxkIGxvZ2dlcnNcbiAgfVxuICBzdHJlYW0ud3JpdGUoc3RyZWFtV3JpdGVIb29rID8gc3RyZWFtV3JpdGVIb29rKHMpIDogcylcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBmbHVzaCAoY2IpIHtcbiAgaWYgKGNiICE9IG51bGwgJiYgdHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gIH1cblxuICBjb25zdCBzdHJlYW0gPSB0aGlzW3N0cmVhbVN5bV1cblxuICBpZiAodHlwZW9mIHN0cmVhbS5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0cmVhbS5mbHVzaChjYiB8fCBub29wKVxuICB9IGVsc2UgaWYgKGNiKSBjYigpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/proto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/redaction.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/redaction.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fastRedact = __webpack_require__(/*! fast-redact */ \"(rsc)/./node_modules/fast-redact/index.js\")\nconst { redactFmtSym, wildcardFirstSym } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/pino/lib/symbols.js\")\nconst { rx, validator } = fastRedact\n\nconst validate = validator({\n  ERR_PATHS_MUST_BE_STRINGS: () => 'pino – redacted paths must be strings',\n  ERR_INVALID_PATH: (s) => `pino – redact paths array contains an invalid path (${s})`\n})\n\nconst CENSOR = '[Redacted]'\nconst strict = false // TODO should this be configurable?\n\nfunction redaction (opts, serialize) {\n  const { paths, censor } = handle(opts)\n\n  const shape = paths.reduce((o, str) => {\n    rx.lastIndex = 0\n    const first = rx.exec(str)\n    const next = rx.exec(str)\n\n    // ns is the top-level path segment, brackets + quoting removed.\n    let ns = first[1] !== undefined\n      ? first[1].replace(/^(?:\"|'|`)(.*)(?:\"|'|`)$/, '$1')\n      : first[0]\n\n    if (ns === '*') {\n      ns = wildcardFirstSym\n    }\n\n    // top level key:\n    if (next === null) {\n      o[ns] = null\n      return o\n    }\n\n    // path with at least two segments:\n    // if ns is already redacted at the top level, ignore lower level redactions\n    if (o[ns] === null) {\n      return o\n    }\n\n    const { index } = next\n    const nextPath = `${str.substr(index, str.length - 1)}`\n\n    o[ns] = o[ns] || []\n\n    // shape is a mix of paths beginning with literal values and wildcard\n    // paths [ \"a.b.c\", \"*.b.z\" ] should reduce to a shape of\n    // { \"a\": [ \"b.c\", \"b.z\" ], *: [ \"b.z\" ] }\n    // note: \"b.z\" is in both \"a\" and * arrays because \"a\" matches the wildcard.\n    // (* entry has wildcardFirstSym as key)\n    if (ns !== wildcardFirstSym && o[ns].length === 0) {\n      // first time ns's get all '*' redactions so far\n      o[ns].push(...(o[wildcardFirstSym] || []))\n    }\n\n    if (ns === wildcardFirstSym) {\n      // new * path gets added to all previously registered literal ns's.\n      Object.keys(o).forEach(function (k) {\n        if (o[k]) {\n          o[k].push(nextPath)\n        }\n      })\n    }\n\n    o[ns].push(nextPath)\n    return o\n  }, {})\n\n  // the redactor assigned to the format symbol key\n  // provides top level redaction for instances where\n  // an object is interpolated into the msg string\n  const result = {\n    [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })\n  }\n\n  const topCensor = (...args) => {\n    return typeof censor === 'function' ? serialize(censor(...args)) : serialize(censor)\n  }\n\n  return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {\n    // top level key:\n    if (shape[k] === null) {\n      o[k] = (value) => topCensor(value, [k])\n    } else {\n      const wrappedCensor = typeof censor === 'function'\n        ? (value, path) => {\n            return censor(value, [k, ...path])\n          }\n        : censor\n      o[k] = fastRedact({\n        paths: shape[k],\n        censor: wrappedCensor,\n        serialize,\n        strict\n      })\n    }\n    return o\n  }, result)\n}\n\nfunction handle (opts) {\n  if (Array.isArray(opts)) {\n    opts = { paths: opts, censor: CENSOR }\n    validate(opts)\n    return opts\n  }\n  let { paths, censor = CENSOR, remove } = opts\n  if (Array.isArray(paths) === false) { throw Error('pino – redact must contain an array of strings') }\n  if (remove === true) censor = undefined\n  validate({ paths, censor })\n\n  return { paths, censor }\n}\n\nmodule.exports = redaction\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvcmVkYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLG1CQUFtQixtQkFBTyxDQUFDLDhEQUFhO0FBQ3hDLFFBQVEsaUNBQWlDLEVBQUUsbUJBQU8sQ0FBQywyREFBVztBQUM5RCxRQUFRLGdCQUFnQjs7QUFFeEI7QUFDQTtBQUNBLGtGQUFrRixFQUFFO0FBQ3BGLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLFVBQVUsZ0JBQWdCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksUUFBUTtBQUNwQix3QkFBd0Isa0NBQWtDOztBQUUxRDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEdBQUcsSUFBSTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQ0FBa0M7QUFDbkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6Qyx3Q0FBd0M7QUFDeEM7QUFDQSxhQUFhLGVBQWU7O0FBRTVCLFdBQVc7QUFDWDs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phc2h3YW50aHBlZGRpc2V0dHkvRG9jdW1lbnRzL2V0aGdsb2JhbC9jb250ZXh0by9ub2RlX21vZHVsZXMvcGluby9saWIvcmVkYWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmYXN0UmVkYWN0ID0gcmVxdWlyZSgnZmFzdC1yZWRhY3QnKVxuY29uc3QgeyByZWRhY3RGbXRTeW0sIHdpbGRjYXJkRmlyc3RTeW0gfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHJ4LCB2YWxpZGF0b3IgfSA9IGZhc3RSZWRhY3RcblxuY29uc3QgdmFsaWRhdGUgPSB2YWxpZGF0b3Ioe1xuICBFUlJfUEFUSFNfTVVTVF9CRV9TVFJJTkdTOiAoKSA9PiAncGlubyDigJMgcmVkYWN0ZWQgcGF0aHMgbXVzdCBiZSBzdHJpbmdzJyxcbiAgRVJSX0lOVkFMSURfUEFUSDogKHMpID0+IGBwaW5vIOKAkyByZWRhY3QgcGF0aHMgYXJyYXkgY29udGFpbnMgYW4gaW52YWxpZCBwYXRoICgke3N9KWBcbn0pXG5cbmNvbnN0IENFTlNPUiA9ICdbUmVkYWN0ZWRdJ1xuY29uc3Qgc3RyaWN0ID0gZmFsc2UgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBjb25maWd1cmFibGU/XG5cbmZ1bmN0aW9uIHJlZGFjdGlvbiAob3B0cywgc2VyaWFsaXplKSB7XG4gIGNvbnN0IHsgcGF0aHMsIGNlbnNvciB9ID0gaGFuZGxlKG9wdHMpXG5cbiAgY29uc3Qgc2hhcGUgPSBwYXRocy5yZWR1Y2UoKG8sIHN0cikgPT4ge1xuICAgIHJ4Lmxhc3RJbmRleCA9IDBcbiAgICBjb25zdCBmaXJzdCA9IHJ4LmV4ZWMoc3RyKVxuICAgIGNvbnN0IG5leHQgPSByeC5leGVjKHN0cilcblxuICAgIC8vIG5zIGlzIHRoZSB0b3AtbGV2ZWwgcGF0aCBzZWdtZW50LCBicmFja2V0cyArIHF1b3RpbmcgcmVtb3ZlZC5cbiAgICBsZXQgbnMgPSBmaXJzdFsxXSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZpcnN0WzFdLnJlcGxhY2UoL14oPzpcInwnfGApKC4qKSg/OlwifCd8YCkkLywgJyQxJylcbiAgICAgIDogZmlyc3RbMF1cblxuICAgIGlmIChucyA9PT0gJyonKSB7XG4gICAgICBucyA9IHdpbGRjYXJkRmlyc3RTeW1cbiAgICB9XG5cbiAgICAvLyB0b3AgbGV2ZWwga2V5OlxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICBvW25zXSA9IG51bGxcbiAgICAgIHJldHVybiBvXG4gICAgfVxuXG4gICAgLy8gcGF0aCB3aXRoIGF0IGxlYXN0IHR3byBzZWdtZW50czpcbiAgICAvLyBpZiBucyBpcyBhbHJlYWR5IHJlZGFjdGVkIGF0IHRoZSB0b3AgbGV2ZWwsIGlnbm9yZSBsb3dlciBsZXZlbCByZWRhY3Rpb25zXG4gICAgaWYgKG9bbnNdID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gb1xuICAgIH1cblxuICAgIGNvbnN0IHsgaW5kZXggfSA9IG5leHRcbiAgICBjb25zdCBuZXh0UGF0aCA9IGAke3N0ci5zdWJzdHIoaW5kZXgsIHN0ci5sZW5ndGggLSAxKX1gXG5cbiAgICBvW25zXSA9IG9bbnNdIHx8IFtdXG5cbiAgICAvLyBzaGFwZSBpcyBhIG1peCBvZiBwYXRocyBiZWdpbm5pbmcgd2l0aCBsaXRlcmFsIHZhbHVlcyBhbmQgd2lsZGNhcmRcbiAgICAvLyBwYXRocyBbIFwiYS5iLmNcIiwgXCIqLmIuelwiIF0gc2hvdWxkIHJlZHVjZSB0byBhIHNoYXBlIG9mXG4gICAgLy8geyBcImFcIjogWyBcImIuY1wiLCBcImIuelwiIF0sICo6IFsgXCJiLnpcIiBdIH1cbiAgICAvLyBub3RlOiBcImIuelwiIGlzIGluIGJvdGggXCJhXCIgYW5kICogYXJyYXlzIGJlY2F1c2UgXCJhXCIgbWF0Y2hlcyB0aGUgd2lsZGNhcmQuXG4gICAgLy8gKCogZW50cnkgaGFzIHdpbGRjYXJkRmlyc3RTeW0gYXMga2V5KVxuICAgIGlmIChucyAhPT0gd2lsZGNhcmRGaXJzdFN5bSAmJiBvW25zXS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGZpcnN0IHRpbWUgbnMncyBnZXQgYWxsICcqJyByZWRhY3Rpb25zIHNvIGZhclxuICAgICAgb1tuc10ucHVzaCguLi4ob1t3aWxkY2FyZEZpcnN0U3ltXSB8fCBbXSkpXG4gICAgfVxuXG4gICAgaWYgKG5zID09PSB3aWxkY2FyZEZpcnN0U3ltKSB7XG4gICAgICAvLyBuZXcgKiBwYXRoIGdldHMgYWRkZWQgdG8gYWxsIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBsaXRlcmFsIG5zJ3MuXG4gICAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChvW2tdKSB7XG4gICAgICAgICAgb1trXS5wdXNoKG5leHRQYXRoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIG9bbnNdLnB1c2gobmV4dFBhdGgpXG4gICAgcmV0dXJuIG9cbiAgfSwge30pXG5cbiAgLy8gdGhlIHJlZGFjdG9yIGFzc2lnbmVkIHRvIHRoZSBmb3JtYXQgc3ltYm9sIGtleVxuICAvLyBwcm92aWRlcyB0b3AgbGV2ZWwgcmVkYWN0aW9uIGZvciBpbnN0YW5jZXMgd2hlcmVcbiAgLy8gYW4gb2JqZWN0IGlzIGludGVycG9sYXRlZCBpbnRvIHRoZSBtc2cgc3RyaW5nXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBbcmVkYWN0Rm10U3ltXTogZmFzdFJlZGFjdCh7IHBhdGhzLCBjZW5zb3IsIHNlcmlhbGl6ZSwgc3RyaWN0IH0pXG4gIH1cblxuICBjb25zdCB0b3BDZW5zb3IgPSAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nID8gc2VyaWFsaXplKGNlbnNvciguLi5hcmdzKSkgOiBzZXJpYWxpemUoY2Vuc29yKVxuICB9XG5cbiAgcmV0dXJuIFsuLi5PYmplY3Qua2V5cyhzaGFwZSksIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc2hhcGUpXS5yZWR1Y2UoKG8sIGspID0+IHtcbiAgICAvLyB0b3AgbGV2ZWwga2V5OlxuICAgIGlmIChzaGFwZVtrXSA9PT0gbnVsbCkge1xuICAgICAgb1trXSA9ICh2YWx1ZSkgPT4gdG9wQ2Vuc29yKHZhbHVlLCBba10pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyYXBwZWRDZW5zb3IgPSB0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gKHZhbHVlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2Vuc29yKHZhbHVlLCBbaywgLi4ucGF0aF0pXG4gICAgICAgICAgfVxuICAgICAgICA6IGNlbnNvclxuICAgICAgb1trXSA9IGZhc3RSZWRhY3Qoe1xuICAgICAgICBwYXRoczogc2hhcGVba10sXG4gICAgICAgIGNlbnNvcjogd3JhcHBlZENlbnNvcixcbiAgICAgICAgc2VyaWFsaXplLFxuICAgICAgICBzdHJpY3RcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBvXG4gIH0sIHJlc3VsdClcbn1cblxuZnVuY3Rpb24gaGFuZGxlIChvcHRzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgb3B0cyA9IHsgcGF0aHM6IG9wdHMsIGNlbnNvcjogQ0VOU09SIH1cbiAgICB2YWxpZGF0ZShvcHRzKVxuICAgIHJldHVybiBvcHRzXG4gIH1cbiAgbGV0IHsgcGF0aHMsIGNlbnNvciA9IENFTlNPUiwgcmVtb3ZlIH0gPSBvcHRzXG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGhzKSA9PT0gZmFsc2UpIHsgdGhyb3cgRXJyb3IoJ3Bpbm8g4oCTIHJlZGFjdCBtdXN0IGNvbnRhaW4gYW4gYXJyYXkgb2Ygc3RyaW5ncycpIH1cbiAgaWYgKHJlbW92ZSA9PT0gdHJ1ZSkgY2Vuc29yID0gdW5kZWZpbmVkXG4gIHZhbGlkYXRlKHsgcGF0aHMsIGNlbnNvciB9KVxuXG4gIHJldHVybiB7IHBhdGhzLCBjZW5zb3IgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZGFjdGlvblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/redaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/symbols.js":
/*!******************************************!*\
  !*** ./node_modules/pino/lib/symbols.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst setLevelSym = Symbol('pino.setLevel')\nconst getLevelSym = Symbol('pino.getLevel')\nconst levelValSym = Symbol('pino.levelVal')\nconst levelCompSym = Symbol('pino.levelComp')\nconst useLevelLabelsSym = Symbol('pino.useLevelLabels')\nconst useOnlyCustomLevelsSym = Symbol('pino.useOnlyCustomLevels')\nconst mixinSym = Symbol('pino.mixin')\n\nconst lsCacheSym = Symbol('pino.lsCache')\nconst chindingsSym = Symbol('pino.chindings')\n\nconst asJsonSym = Symbol('pino.asJson')\nconst writeSym = Symbol('pino.write')\nconst redactFmtSym = Symbol('pino.redactFmt')\n\nconst timeSym = Symbol('pino.time')\nconst timeSliceIndexSym = Symbol('pino.timeSliceIndex')\nconst streamSym = Symbol('pino.stream')\nconst stringifySym = Symbol('pino.stringify')\nconst stringifySafeSym = Symbol('pino.stringifySafe')\nconst stringifiersSym = Symbol('pino.stringifiers')\nconst endSym = Symbol('pino.end')\nconst formatOptsSym = Symbol('pino.formatOpts')\nconst messageKeySym = Symbol('pino.messageKey')\nconst errorKeySym = Symbol('pino.errorKey')\nconst nestedKeySym = Symbol('pino.nestedKey')\nconst nestedKeyStrSym = Symbol('pino.nestedKeyStr')\nconst mixinMergeStrategySym = Symbol('pino.mixinMergeStrategy')\nconst msgPrefixSym = Symbol('pino.msgPrefix')\n\nconst wildcardFirstSym = Symbol('pino.wildcardFirst')\n\n// public symbols, no need to use the same pino\n// version for these\nconst serializersSym = Symbol.for('pino.serializers')\nconst formattersSym = Symbol.for('pino.formatters')\nconst hooksSym = Symbol.for('pino.hooks')\nconst needsMetadataGsym = Symbol.for('pino.metadata')\n\nmodule.exports = {\n  setLevelSym,\n  getLevelSym,\n  levelValSym,\n  levelCompSym,\n  useLevelLabelsSym,\n  mixinSym,\n  lsCacheSym,\n  chindingsSym,\n  asJsonSym,\n  writeSym,\n  serializersSym,\n  redactFmtSym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  stringifySym,\n  stringifySafeSym,\n  stringifiersSym,\n  endSym,\n  formatOptsSym,\n  messageKeySym,\n  errorKeySym,\n  nestedKeySym,\n  wildcardFirstSym,\n  needsMetadataGsym,\n  useOnlyCustomLevelsSym,\n  formattersSym,\n  hooksSym,\n  nestedKeyStrSym,\n  mixinMergeStrategySym,\n  msgPrefixSym\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL3N5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHNldExldmVsU3ltID0gU3ltYm9sKCdwaW5vLnNldExldmVsJylcbmNvbnN0IGdldExldmVsU3ltID0gU3ltYm9sKCdwaW5vLmdldExldmVsJylcbmNvbnN0IGxldmVsVmFsU3ltID0gU3ltYm9sKCdwaW5vLmxldmVsVmFsJylcbmNvbnN0IGxldmVsQ29tcFN5bSA9IFN5bWJvbCgncGluby5sZXZlbENvbXAnKVxuY29uc3QgdXNlTGV2ZWxMYWJlbHNTeW0gPSBTeW1ib2woJ3Bpbm8udXNlTGV2ZWxMYWJlbHMnKVxuY29uc3QgdXNlT25seUN1c3RvbUxldmVsc1N5bSA9IFN5bWJvbCgncGluby51c2VPbmx5Q3VzdG9tTGV2ZWxzJylcbmNvbnN0IG1peGluU3ltID0gU3ltYm9sKCdwaW5vLm1peGluJylcblxuY29uc3QgbHNDYWNoZVN5bSA9IFN5bWJvbCgncGluby5sc0NhY2hlJylcbmNvbnN0IGNoaW5kaW5nc1N5bSA9IFN5bWJvbCgncGluby5jaGluZGluZ3MnKVxuXG5jb25zdCBhc0pzb25TeW0gPSBTeW1ib2woJ3Bpbm8uYXNKc29uJylcbmNvbnN0IHdyaXRlU3ltID0gU3ltYm9sKCdwaW5vLndyaXRlJylcbmNvbnN0IHJlZGFjdEZtdFN5bSA9IFN5bWJvbCgncGluby5yZWRhY3RGbXQnKVxuXG5jb25zdCB0aW1lU3ltID0gU3ltYm9sKCdwaW5vLnRpbWUnKVxuY29uc3QgdGltZVNsaWNlSW5kZXhTeW0gPSBTeW1ib2woJ3Bpbm8udGltZVNsaWNlSW5kZXgnKVxuY29uc3Qgc3RyZWFtU3ltID0gU3ltYm9sKCdwaW5vLnN0cmVhbScpXG5jb25zdCBzdHJpbmdpZnlTeW0gPSBTeW1ib2woJ3Bpbm8uc3RyaW5naWZ5JylcbmNvbnN0IHN0cmluZ2lmeVNhZmVTeW0gPSBTeW1ib2woJ3Bpbm8uc3RyaW5naWZ5U2FmZScpXG5jb25zdCBzdHJpbmdpZmllcnNTeW0gPSBTeW1ib2woJ3Bpbm8uc3RyaW5naWZpZXJzJylcbmNvbnN0IGVuZFN5bSA9IFN5bWJvbCgncGluby5lbmQnKVxuY29uc3QgZm9ybWF0T3B0c1N5bSA9IFN5bWJvbCgncGluby5mb3JtYXRPcHRzJylcbmNvbnN0IG1lc3NhZ2VLZXlTeW0gPSBTeW1ib2woJ3Bpbm8ubWVzc2FnZUtleScpXG5jb25zdCBlcnJvcktleVN5bSA9IFN5bWJvbCgncGluby5lcnJvcktleScpXG5jb25zdCBuZXN0ZWRLZXlTeW0gPSBTeW1ib2woJ3Bpbm8ubmVzdGVkS2V5JylcbmNvbnN0IG5lc3RlZEtleVN0clN5bSA9IFN5bWJvbCgncGluby5uZXN0ZWRLZXlTdHInKVxuY29uc3QgbWl4aW5NZXJnZVN0cmF0ZWd5U3ltID0gU3ltYm9sKCdwaW5vLm1peGluTWVyZ2VTdHJhdGVneScpXG5jb25zdCBtc2dQcmVmaXhTeW0gPSBTeW1ib2woJ3Bpbm8ubXNnUHJlZml4JylcblxuY29uc3Qgd2lsZGNhcmRGaXJzdFN5bSA9IFN5bWJvbCgncGluby53aWxkY2FyZEZpcnN0JylcblxuLy8gcHVibGljIHN5bWJvbHMsIG5vIG5lZWQgdG8gdXNlIHRoZSBzYW1lIHBpbm9cbi8vIHZlcnNpb24gZm9yIHRoZXNlXG5jb25zdCBzZXJpYWxpemVyc1N5bSA9IFN5bWJvbC5mb3IoJ3Bpbm8uc2VyaWFsaXplcnMnKVxuY29uc3QgZm9ybWF0dGVyc1N5bSA9IFN5bWJvbC5mb3IoJ3Bpbm8uZm9ybWF0dGVycycpXG5jb25zdCBob29rc1N5bSA9IFN5bWJvbC5mb3IoJ3Bpbm8uaG9va3MnKVxuY29uc3QgbmVlZHNNZXRhZGF0YUdzeW0gPSBTeW1ib2wuZm9yKCdwaW5vLm1ldGFkYXRhJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldExldmVsU3ltLFxuICBnZXRMZXZlbFN5bSxcbiAgbGV2ZWxWYWxTeW0sXG4gIGxldmVsQ29tcFN5bSxcbiAgdXNlTGV2ZWxMYWJlbHNTeW0sXG4gIG1peGluU3ltLFxuICBsc0NhY2hlU3ltLFxuICBjaGluZGluZ3NTeW0sXG4gIGFzSnNvblN5bSxcbiAgd3JpdGVTeW0sXG4gIHNlcmlhbGl6ZXJzU3ltLFxuICByZWRhY3RGbXRTeW0sXG4gIHRpbWVTeW0sXG4gIHRpbWVTbGljZUluZGV4U3ltLFxuICBzdHJlYW1TeW0sXG4gIHN0cmluZ2lmeVN5bSxcbiAgc3RyaW5naWZ5U2FmZVN5bSxcbiAgc3RyaW5naWZpZXJzU3ltLFxuICBlbmRTeW0sXG4gIGZvcm1hdE9wdHNTeW0sXG4gIG1lc3NhZ2VLZXlTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBuZXN0ZWRLZXlTeW0sXG4gIHdpbGRjYXJkRmlyc3RTeW0sXG4gIG5lZWRzTWV0YWRhdGFHc3ltLFxuICB1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltLFxuICBmb3JtYXR0ZXJzU3ltLFxuICBob29rc1N5bSxcbiAgbmVzdGVkS2V5U3RyU3ltLFxuICBtaXhpbk1lcmdlU3RyYXRlZ3lTeW0sXG4gIG1zZ1ByZWZpeFN5bVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/time.js":
/*!***************************************!*\
  !*** ./node_modules/pino/lib/time.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst nullTime = () => ''\n\nconst epochTime = () => `,\"time\":${Date.now()}`\n\nconst unixTime = () => `,\"time\":${Math.round(Date.now() / 1000.0)}`\n\nconst isoTime = () => `,\"time\":\"${new Date(Date.now()).toISOString()}\"` // using Date.now() for testability\n\nmodule.exports = { nullTime, epochTime, unixTime, isoTime }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQSxtQ0FBbUMsV0FBVzs7QUFFOUMsa0NBQWtDLGdDQUFnQzs7QUFFbEUsa0NBQWtDLG1DQUFtQzs7QUFFckUsbUJBQW1CIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9waW5vL2xpYi90aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBudWxsVGltZSA9ICgpID0+ICcnXG5cbmNvbnN0IGVwb2NoVGltZSA9ICgpID0+IGAsXCJ0aW1lXCI6JHtEYXRlLm5vdygpfWBcblxuY29uc3QgdW5peFRpbWUgPSAoKSA9PiBgLFwidGltZVwiOiR7TWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMC4wKX1gXG5cbmNvbnN0IGlzb1RpbWUgPSAoKSA9PiBgLFwidGltZVwiOlwiJHtuZXcgRGF0ZShEYXRlLm5vdygpKS50b0lTT1N0cmluZygpfVwiYCAvLyB1c2luZyBEYXRlLm5vdygpIGZvciB0ZXN0YWJpbGl0eVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgbnVsbFRpbWUsIGVwb2NoVGltZSwgdW5peFRpbWUsIGlzb1RpbWUgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/time.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/tools.js":
/*!****************************************!*\
  !*** ./node_modules/pino/lib/tools.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint no-prototype-builtins: 0 */\n\nconst format = __webpack_require__(/*! quick-format-unescaped */ \"(rsc)/./node_modules/quick-format-unescaped/index.js\")\nconst { mapHttpRequest, mapHttpResponse } = __webpack_require__(/*! pino-std-serializers */ \"(rsc)/./node_modules/pino-std-serializers/index.js\")\nconst SonicBoom = __webpack_require__(/*! sonic-boom */ \"(rsc)/./node_modules/sonic-boom/index.js\")\nconst onExit = __webpack_require__(/*! on-exit-leak-free */ \"(rsc)/./node_modules/on-exit-leak-free/index.js\")\nconst {\n  lsCacheSym,\n  chindingsSym,\n  writeSym,\n  serializersSym,\n  formatOptsSym,\n  endSym,\n  stringifiersSym,\n  stringifySym,\n  stringifySafeSym,\n  wildcardFirstSym,\n  nestedKeySym,\n  formattersSym,\n  messageKeySym,\n  errorKeySym,\n  nestedKeyStrSym,\n  msgPrefixSym\n} = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/pino/lib/symbols.js\")\nconst { isMainThread } = __webpack_require__(/*! worker_threads */ \"worker_threads\")\nconst transport = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/pino/lib/transport.js\")\n\nfunction noop () {\n}\n\nfunction genLog (level, hook) {\n  if (!hook) return LOG\n\n  return function hookWrappedLog (...args) {\n    hook.call(this, args, LOG, level)\n  }\n\n  function LOG (o, ...n) {\n    if (typeof o === 'object') {\n      let msg = o\n      if (o !== null) {\n        if (o.method && o.headers && o.socket) {\n          o = mapHttpRequest(o)\n        } else if (typeof o.setHeader === 'function') {\n          o = mapHttpResponse(o)\n        }\n      }\n      let formatParams\n      if (msg === null && n.length === 0) {\n        formatParams = [null]\n      } else {\n        msg = n.shift()\n        formatParams = n\n      }\n      // We do not use a coercive check for `msg` as it is\n      // measurably slower than the explicit checks.\n      if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {\n        msg = this[msgPrefixSym] + msg\n      }\n      this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level)\n    } else {\n      let msg = o === undefined ? n.shift() : o\n\n      // We do not use a coercive check for `msg` as it is\n      // measurably slower than the explicit checks.\n      if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {\n        msg = this[msgPrefixSym] + msg\n      }\n      this[writeSym](null, format(msg, n, this[formatOptsSym]), level)\n    }\n  }\n}\n\n// magically escape strings for json\n// relying on their charCodeAt\n// everything below 32 needs JSON.stringify()\n// 34 and 92 happens all the time, so we\n// have a fast case for them\nfunction asString (str) {\n  let result = ''\n  let last = 0\n  let found = false\n  let point = 255\n  const l = str.length\n  if (l > 100) {\n    return JSON.stringify(str)\n  }\n  for (var i = 0; i < l && point >= 32; i++) {\n    point = str.charCodeAt(i)\n    if (point === 34 || point === 92) {\n      result += str.slice(last, i) + '\\\\'\n      last = i\n      found = true\n    }\n  }\n  if (!found) {\n    result = str\n  } else {\n    result += str.slice(last)\n  }\n  return point < 32 ? JSON.stringify(str) : '\"' + result + '\"'\n}\n\nfunction asJson (obj, msg, num, time) {\n  const stringify = this[stringifySym]\n  const stringifySafe = this[stringifySafeSym]\n  const stringifiers = this[stringifiersSym]\n  const end = this[endSym]\n  const chindings = this[chindingsSym]\n  const serializers = this[serializersSym]\n  const formatters = this[formattersSym]\n  const messageKey = this[messageKeySym]\n  const errorKey = this[errorKeySym]\n  let data = this[lsCacheSym][num] + time\n\n  // we need the child bindings added to the output first so instance logged\n  // objects can take precedence when JSON.parse-ing the resulting log line\n  data = data + chindings\n\n  let value\n  if (formatters.log) {\n    obj = formatters.log(obj)\n  }\n  const wildcardStringifier = stringifiers[wildcardFirstSym]\n  let propStr = ''\n  for (const key in obj) {\n    value = obj[key]\n    if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {\n      if (serializers[key]) {\n        value = serializers[key](value)\n      } else if (key === errorKey && serializers.err) {\n        value = serializers.err(value)\n      }\n\n      const stringifier = stringifiers[key] || wildcardStringifier\n\n      switch (typeof value) {\n        case 'undefined':\n        case 'function':\n          continue\n        case 'number':\n          /* eslint no-fallthrough: \"off\" */\n          if (Number.isFinite(value) === false) {\n            value = null\n          }\n        // this case explicitly falls through to the next one\n        case 'boolean':\n          if (stringifier) value = stringifier(value)\n          break\n        case 'string':\n          value = (stringifier || asString)(value)\n          break\n        default:\n          value = (stringifier || stringify)(value, stringifySafe)\n      }\n      if (value === undefined) continue\n      const strKey = asString(key)\n      propStr += ',' + strKey + ':' + value\n    }\n  }\n\n  let msgStr = ''\n  if (msg !== undefined) {\n    value = serializers[messageKey] ? serializers[messageKey](msg) : msg\n    const stringifier = stringifiers[messageKey] || wildcardStringifier\n\n    switch (typeof value) {\n      case 'function':\n        break\n      case 'number':\n        /* eslint no-fallthrough: \"off\" */\n        if (Number.isFinite(value) === false) {\n          value = null\n        }\n      // this case explicitly falls through to the next one\n      case 'boolean':\n        if (stringifier) value = stringifier(value)\n        msgStr = ',\"' + messageKey + '\":' + value\n        break\n      case 'string':\n        value = (stringifier || asString)(value)\n        msgStr = ',\"' + messageKey + '\":' + value\n        break\n      default:\n        value = (stringifier || stringify)(value, stringifySafe)\n        msgStr = ',\"' + messageKey + '\":' + value\n    }\n  }\n\n  if (this[nestedKeySym] && propStr) {\n    // place all the obj properties under the specified key\n    // the nested key is already formatted from the constructor\n    return data + this[nestedKeyStrSym] + propStr.slice(1) + '}' + msgStr + end\n  } else {\n    return data + propStr + msgStr + end\n  }\n}\n\nfunction asChindings (instance, bindings) {\n  let value\n  let data = instance[chindingsSym]\n  const stringify = instance[stringifySym]\n  const stringifySafe = instance[stringifySafeSym]\n  const stringifiers = instance[stringifiersSym]\n  const wildcardStringifier = stringifiers[wildcardFirstSym]\n  const serializers = instance[serializersSym]\n  const formatter = instance[formattersSym].bindings\n  bindings = formatter(bindings)\n\n  for (const key in bindings) {\n    value = bindings[key]\n    const valid = key !== 'level' &&\n      key !== 'serializers' &&\n      key !== 'formatters' &&\n      key !== 'customLevels' &&\n      bindings.hasOwnProperty(key) &&\n      value !== undefined\n    if (valid === true) {\n      value = serializers[key] ? serializers[key](value) : value\n      value = (stringifiers[key] || wildcardStringifier || stringify)(value, stringifySafe)\n      if (value === undefined) continue\n      data += ',\"' + key + '\":' + value\n    }\n  }\n  return data\n}\n\nfunction hasBeenTampered (stream) {\n  return stream.write !== stream.constructor.prototype.write\n}\n\nconst hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE\n\nfunction buildSafeSonicBoom (opts) {\n  const stream = new SonicBoom(opts)\n  stream.on('error', filterBrokenPipe)\n  // If we are sync: false, we must flush on exit\n  // We must disable this if there is node code coverage due to\n  // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308.\n  if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {\n    onExit.register(stream, autoEnd)\n\n    stream.on('close', function () {\n      onExit.unregister(stream)\n    })\n  }\n  return stream\n\n  function filterBrokenPipe (err) {\n    // Impossible to replicate across all operating systems\n    /* istanbul ignore next */\n    if (err.code === 'EPIPE') {\n      // If we get EPIPE, we should stop logging here\n      // however we have no control to the consumer of\n      // SonicBoom, so we just overwrite the write method\n      stream.write = noop\n      stream.end = noop\n      stream.flushSync = noop\n      stream.destroy = noop\n      return\n    }\n    stream.removeListener('error', filterBrokenPipe)\n    stream.emit('error', err)\n  }\n}\n\nfunction autoEnd (stream, eventName) {\n  // This check is needed only on some platforms\n  /* istanbul ignore next */\n  if (stream.destroyed) {\n    return\n  }\n\n  if (eventName === 'beforeExit') {\n    // We still have an event loop, let's use it\n    stream.flush()\n    stream.on('drain', function () {\n      stream.end()\n    })\n  } else {\n    // For some reason istanbul is not detecting this, but it's there\n    /* istanbul ignore next */\n    // We do not have an event loop, so flush synchronously\n    stream.flushSync()\n  }\n}\n\nfunction createArgsNormalizer (defaultOptions) {\n  return function normalizeArgs (instance, caller, opts = {}, stream) {\n    // support stream as a string\n    if (typeof opts === 'string') {\n      stream = buildSafeSonicBoom({ dest: opts })\n      opts = {}\n    } else if (typeof stream === 'string') {\n      if (opts && opts.transport) {\n        throw Error('only one of option.transport or stream can be specified')\n      }\n      stream = buildSafeSonicBoom({ dest: stream })\n    } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {\n      stream = opts\n      opts = {}\n    } else if (opts.transport) {\n      if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {\n        throw Error('option.transport do not allow stream, please pass to option directly. e.g. pino(transport)')\n      }\n      if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === 'function') {\n        throw Error('option.transport.targets do not allow custom level formatters')\n      }\n\n      let customLevels\n      if (opts.customLevels) {\n        customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels)\n      }\n      stream = transport({ caller, ...opts.transport, levels: customLevels })\n    }\n    opts = Object.assign({}, defaultOptions, opts)\n    opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers)\n    opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters)\n\n    if (opts.prettyPrint) {\n      throw new Error('prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)')\n    }\n\n    const { enabled, onChild } = opts\n    if (enabled === false) opts.level = 'silent'\n    if (!onChild) opts.onChild = noop\n    if (!stream) {\n      if (!hasBeenTampered(process.stdout)) {\n        // If process.stdout.fd is undefined, it means that we are running\n        // in a worker thread. Let's assume we are logging to file descriptor 1.\n        stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 })\n      } else {\n        stream = process.stdout\n      }\n    }\n    return { opts, stream }\n  }\n}\n\nfunction stringify (obj, stringifySafeFn) {\n  try {\n    return JSON.stringify(obj)\n  } catch (_) {\n    try {\n      const stringify = stringifySafeFn || this[stringifySafeSym]\n      return stringify(obj)\n    } catch (_) {\n      return '\"[unable to serialize, circular reference is too complex to analyze]\"'\n    }\n  }\n}\n\nfunction buildFormatters (level, bindings, log) {\n  return {\n    level,\n    bindings,\n    log\n  }\n}\n\n/**\n * Convert a string integer file descriptor to a proper native integer\n * file descriptor.\n *\n * @param {string} destination The file descriptor string to attempt to convert.\n *\n * @returns {Number}\n */\nfunction normalizeDestFileDescriptor (destination) {\n  const fd = Number(destination)\n  if (typeof destination === 'string' && Number.isFinite(fd)) {\n    return fd\n  }\n  // destination could be undefined if we are in a worker\n  if (destination === undefined) {\n    // This is stdout in UNIX systems\n    return 1\n  }\n  return destination\n}\n\nmodule.exports = {\n  noop,\n  buildSafeSonicBoom,\n  asChindings,\n  asJson,\n  genLog,\n  createArgsNormalizer,\n  stringify,\n  buildFormatters,\n  normalizeDestFileDescriptor\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdG9vbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLG9GQUF3QjtBQUMvQyxRQUFRLGtDQUFrQyxFQUFFLG1CQUFPLENBQUMsZ0ZBQXNCO0FBQzFFLGtCQUFrQixtQkFBTyxDQUFDLDREQUFZO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQywwRUFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJEQUFXO0FBQ3ZCLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsc0NBQWdCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLCtEQUFhOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xELE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0EsMkJBQTJCLGlEQUFpRDtBQUM1RTtBQUNBLDJCQUEyQjtBQUMzQix1Q0FBdUM7QUFDdkMsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUEsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDRCQUE0QjtBQUNsRSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9waW5vL2xpYi90b29scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyogZXNsaW50IG5vLXByb3RvdHlwZS1idWlsdGluczogMCAqL1xuXG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCdxdWljay1mb3JtYXQtdW5lc2NhcGVkJylcbmNvbnN0IHsgbWFwSHR0cFJlcXVlc3QsIG1hcEh0dHBSZXNwb25zZSB9ID0gcmVxdWlyZSgncGluby1zdGQtc2VyaWFsaXplcnMnKVxuY29uc3QgU29uaWNCb29tID0gcmVxdWlyZSgnc29uaWMtYm9vbScpXG5jb25zdCBvbkV4aXQgPSByZXF1aXJlKCdvbi1leGl0LWxlYWstZnJlZScpXG5jb25zdCB7XG4gIGxzQ2FjaGVTeW0sXG4gIGNoaW5kaW5nc1N5bSxcbiAgd3JpdGVTeW0sXG4gIHNlcmlhbGl6ZXJzU3ltLFxuICBmb3JtYXRPcHRzU3ltLFxuICBlbmRTeW0sXG4gIHN0cmluZ2lmaWVyc1N5bSxcbiAgc3RyaW5naWZ5U3ltLFxuICBzdHJpbmdpZnlTYWZlU3ltLFxuICB3aWxkY2FyZEZpcnN0U3ltLFxuICBuZXN0ZWRLZXlTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIG1lc3NhZ2VLZXlTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBuZXN0ZWRLZXlTdHJTeW0sXG4gIG1zZ1ByZWZpeFN5bVxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGlzTWFpblRocmVhZCB9ID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKVxuY29uc3QgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKVxuXG5mdW5jdGlvbiBub29wICgpIHtcbn1cblxuZnVuY3Rpb24gZ2VuTG9nIChsZXZlbCwgaG9vaykge1xuICBpZiAoIWhvb2spIHJldHVybiBMT0dcblxuICByZXR1cm4gZnVuY3Rpb24gaG9va1dyYXBwZWRMb2cgKC4uLmFyZ3MpIHtcbiAgICBob29rLmNhbGwodGhpcywgYXJncywgTE9HLCBsZXZlbClcbiAgfVxuXG4gIGZ1bmN0aW9uIExPRyAobywgLi4ubikge1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGxldCBtc2cgPSBvXG4gICAgICBpZiAobyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoby5tZXRob2QgJiYgby5oZWFkZXJzICYmIG8uc29ja2V0KSB7XG4gICAgICAgICAgbyA9IG1hcEh0dHBSZXF1ZXN0KG8pXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG8uc2V0SGVhZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbyA9IG1hcEh0dHBSZXNwb25zZShvKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgZm9ybWF0UGFyYW1zXG4gICAgICBpZiAobXNnID09PSBudWxsICYmIG4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZvcm1hdFBhcmFtcyA9IFtudWxsXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXNnID0gbi5zaGlmdCgpXG4gICAgICAgIGZvcm1hdFBhcmFtcyA9IG5cbiAgICAgIH1cbiAgICAgIC8vIFdlIGRvIG5vdCB1c2UgYSBjb2VyY2l2ZSBjaGVjayBmb3IgYG1zZ2AgYXMgaXQgaXNcbiAgICAgIC8vIG1lYXN1cmFibHkgc2xvd2VyIHRoYW4gdGhlIGV4cGxpY2l0IGNoZWNrcy5cbiAgICAgIGlmICh0eXBlb2YgdGhpc1ttc2dQcmVmaXhTeW1dID09PSAnc3RyaW5nJyAmJiBtc2cgIT09IHVuZGVmaW5lZCAmJiBtc2cgIT09IG51bGwpIHtcbiAgICAgICAgbXNnID0gdGhpc1ttc2dQcmVmaXhTeW1dICsgbXNnXG4gICAgICB9XG4gICAgICB0aGlzW3dyaXRlU3ltXShvLCBmb3JtYXQobXNnLCBmb3JtYXRQYXJhbXMsIHRoaXNbZm9ybWF0T3B0c1N5bV0pLCBsZXZlbClcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1zZyA9IG8gPT09IHVuZGVmaW5lZCA/IG4uc2hpZnQoKSA6IG9cblxuICAgICAgLy8gV2UgZG8gbm90IHVzZSBhIGNvZXJjaXZlIGNoZWNrIGZvciBgbXNnYCBhcyBpdCBpc1xuICAgICAgLy8gbWVhc3VyYWJseSBzbG93ZXIgdGhhbiB0aGUgZXhwbGljaXQgY2hlY2tzLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzW21zZ1ByZWZpeFN5bV0gPT09ICdzdHJpbmcnICYmIG1zZyAhPT0gdW5kZWZpbmVkICYmIG1zZyAhPT0gbnVsbCkge1xuICAgICAgICBtc2cgPSB0aGlzW21zZ1ByZWZpeFN5bV0gKyBtc2dcbiAgICAgIH1cbiAgICAgIHRoaXNbd3JpdGVTeW1dKG51bGwsIGZvcm1hdChtc2csIG4sIHRoaXNbZm9ybWF0T3B0c1N5bV0pLCBsZXZlbClcbiAgICB9XG4gIH1cbn1cblxuLy8gbWFnaWNhbGx5IGVzY2FwZSBzdHJpbmdzIGZvciBqc29uXG4vLyByZWx5aW5nIG9uIHRoZWlyIGNoYXJDb2RlQXRcbi8vIGV2ZXJ5dGhpbmcgYmVsb3cgMzIgbmVlZHMgSlNPTi5zdHJpbmdpZnkoKVxuLy8gMzQgYW5kIDkyIGhhcHBlbnMgYWxsIHRoZSB0aW1lLCBzbyB3ZVxuLy8gaGF2ZSBhIGZhc3QgY2FzZSBmb3IgdGhlbVxuZnVuY3Rpb24gYXNTdHJpbmcgKHN0cikge1xuICBsZXQgcmVzdWx0ID0gJydcbiAgbGV0IGxhc3QgPSAwXG4gIGxldCBmb3VuZCA9IGZhbHNlXG4gIGxldCBwb2ludCA9IDI1NVxuICBjb25zdCBsID0gc3RyLmxlbmd0aFxuICBpZiAobCA+IDEwMCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsICYmIHBvaW50ID49IDMyOyBpKyspIHtcbiAgICBwb2ludCA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKHBvaW50ID09PSAzNCB8fCBwb2ludCA9PT0gOTIpIHtcbiAgICAgIHJlc3VsdCArPSBzdHIuc2xpY2UobGFzdCwgaSkgKyAnXFxcXCdcbiAgICAgIGxhc3QgPSBpXG4gICAgICBmb3VuZCA9IHRydWVcbiAgICB9XG4gIH1cbiAgaWYgKCFmb3VuZCkge1xuICAgIHJlc3VsdCA9IHN0clxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBzdHIuc2xpY2UobGFzdClcbiAgfVxuICByZXR1cm4gcG9pbnQgPCAzMiA/IEpTT04uc3RyaW5naWZ5KHN0cikgOiAnXCInICsgcmVzdWx0ICsgJ1wiJ1xufVxuXG5mdW5jdGlvbiBhc0pzb24gKG9iaiwgbXNnLCBudW0sIHRpbWUpIHtcbiAgY29uc3Qgc3RyaW5naWZ5ID0gdGhpc1tzdHJpbmdpZnlTeW1dXG4gIGNvbnN0IHN0cmluZ2lmeVNhZmUgPSB0aGlzW3N0cmluZ2lmeVNhZmVTeW1dXG4gIGNvbnN0IHN0cmluZ2lmaWVycyA9IHRoaXNbc3RyaW5naWZpZXJzU3ltXVxuICBjb25zdCBlbmQgPSB0aGlzW2VuZFN5bV1cbiAgY29uc3QgY2hpbmRpbmdzID0gdGhpc1tjaGluZGluZ3NTeW1dXG4gIGNvbnN0IHNlcmlhbGl6ZXJzID0gdGhpc1tzZXJpYWxpemVyc1N5bV1cbiAgY29uc3QgZm9ybWF0dGVycyA9IHRoaXNbZm9ybWF0dGVyc1N5bV1cbiAgY29uc3QgbWVzc2FnZUtleSA9IHRoaXNbbWVzc2FnZUtleVN5bV1cbiAgY29uc3QgZXJyb3JLZXkgPSB0aGlzW2Vycm9yS2V5U3ltXVxuICBsZXQgZGF0YSA9IHRoaXNbbHNDYWNoZVN5bV1bbnVtXSArIHRpbWVcblxuICAvLyB3ZSBuZWVkIHRoZSBjaGlsZCBiaW5kaW5ncyBhZGRlZCB0byB0aGUgb3V0cHV0IGZpcnN0IHNvIGluc3RhbmNlIGxvZ2dlZFxuICAvLyBvYmplY3RzIGNhbiB0YWtlIHByZWNlZGVuY2Ugd2hlbiBKU09OLnBhcnNlLWluZyB0aGUgcmVzdWx0aW5nIGxvZyBsaW5lXG4gIGRhdGEgPSBkYXRhICsgY2hpbmRpbmdzXG5cbiAgbGV0IHZhbHVlXG4gIGlmIChmb3JtYXR0ZXJzLmxvZykge1xuICAgIG9iaiA9IGZvcm1hdHRlcnMubG9nKG9iailcbiAgfVxuICBjb25zdCB3aWxkY2FyZFN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW3dpbGRjYXJkRmlyc3RTeW1dXG4gIGxldCBwcm9wU3RyID0gJydcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgdmFsdWUgPSBvYmpba2V5XVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChzZXJpYWxpemVyc1trZXldKSB7XG4gICAgICAgIHZhbHVlID0gc2VyaWFsaXplcnNba2V5XSh2YWx1ZSlcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBlcnJvcktleSAmJiBzZXJpYWxpemVycy5lcnIpIHtcbiAgICAgICAgdmFsdWUgPSBzZXJpYWxpemVycy5lcnIodmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW2tleV0gfHwgd2lsZGNhcmRTdHJpbmdpZmllclxuXG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFwib2ZmXCIgKi9cbiAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBjYXNlIGV4cGxpY2l0bHkgZmFsbHMgdGhyb3VnaCB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgaWYgKHN0cmluZ2lmaWVyKSB2YWx1ZSA9IHN0cmluZ2lmaWVyKHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgdmFsdWUgPSAoc3RyaW5naWZpZXIgfHwgYXNTdHJpbmcpKHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFsdWUgPSAoc3RyaW5naWZpZXIgfHwgc3RyaW5naWZ5KSh2YWx1ZSwgc3RyaW5naWZ5U2FmZSlcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgY29uc3Qgc3RyS2V5ID0gYXNTdHJpbmcoa2V5KVxuICAgICAgcHJvcFN0ciArPSAnLCcgKyBzdHJLZXkgKyAnOicgKyB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIGxldCBtc2dTdHIgPSAnJ1xuICBpZiAobXNnICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IHNlcmlhbGl6ZXJzW21lc3NhZ2VLZXldID8gc2VyaWFsaXplcnNbbWVzc2FnZUtleV0obXNnKSA6IG1zZ1xuICAgIGNvbnN0IHN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW21lc3NhZ2VLZXldIHx8IHdpbGRjYXJkU3RyaW5naWZpZXJcblxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFwib2ZmXCIgKi9cbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFsdWUgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIC8vIHRoaXMgY2FzZSBleHBsaWNpdGx5IGZhbGxzIHRocm91Z2ggdG8gdGhlIG5leHQgb25lXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgaWYgKHN0cmluZ2lmaWVyKSB2YWx1ZSA9IHN0cmluZ2lmaWVyKHZhbHVlKVxuICAgICAgICBtc2dTdHIgPSAnLFwiJyArIG1lc3NhZ2VLZXkgKyAnXCI6JyArIHZhbHVlXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB2YWx1ZSA9IChzdHJpbmdpZmllciB8fCBhc1N0cmluZykodmFsdWUpXG4gICAgICAgIG1zZ1N0ciA9ICcsXCInICsgbWVzc2FnZUtleSArICdcIjonICsgdmFsdWVcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhbHVlID0gKHN0cmluZ2lmaWVyIHx8IHN0cmluZ2lmeSkodmFsdWUsIHN0cmluZ2lmeVNhZmUpXG4gICAgICAgIG1zZ1N0ciA9ICcsXCInICsgbWVzc2FnZUtleSArICdcIjonICsgdmFsdWVcbiAgICB9XG4gIH1cblxuICBpZiAodGhpc1tuZXN0ZWRLZXlTeW1dICYmIHByb3BTdHIpIHtcbiAgICAvLyBwbGFjZSBhbGwgdGhlIG9iaiBwcm9wZXJ0aWVzIHVuZGVyIHRoZSBzcGVjaWZpZWQga2V5XG4gICAgLy8gdGhlIG5lc3RlZCBrZXkgaXMgYWxyZWFkeSBmb3JtYXR0ZWQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICByZXR1cm4gZGF0YSArIHRoaXNbbmVzdGVkS2V5U3RyU3ltXSArIHByb3BTdHIuc2xpY2UoMSkgKyAnfScgKyBtc2dTdHIgKyBlbmRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YSArIHByb3BTdHIgKyBtc2dTdHIgKyBlbmRcbiAgfVxufVxuXG5mdW5jdGlvbiBhc0NoaW5kaW5ncyAoaW5zdGFuY2UsIGJpbmRpbmdzKSB7XG4gIGxldCB2YWx1ZVxuICBsZXQgZGF0YSA9IGluc3RhbmNlW2NoaW5kaW5nc1N5bV1cbiAgY29uc3Qgc3RyaW5naWZ5ID0gaW5zdGFuY2Vbc3RyaW5naWZ5U3ltXVxuICBjb25zdCBzdHJpbmdpZnlTYWZlID0gaW5zdGFuY2Vbc3RyaW5naWZ5U2FmZVN5bV1cbiAgY29uc3Qgc3RyaW5naWZpZXJzID0gaW5zdGFuY2Vbc3RyaW5naWZpZXJzU3ltXVxuICBjb25zdCB3aWxkY2FyZFN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW3dpbGRjYXJkRmlyc3RTeW1dXG4gIGNvbnN0IHNlcmlhbGl6ZXJzID0gaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dXG4gIGNvbnN0IGZvcm1hdHRlciA9IGluc3RhbmNlW2Zvcm1hdHRlcnNTeW1dLmJpbmRpbmdzXG4gIGJpbmRpbmdzID0gZm9ybWF0dGVyKGJpbmRpbmdzKVxuXG4gIGZvciAoY29uc3Qga2V5IGluIGJpbmRpbmdzKSB7XG4gICAgdmFsdWUgPSBiaW5kaW5nc1trZXldXG4gICAgY29uc3QgdmFsaWQgPSBrZXkgIT09ICdsZXZlbCcgJiZcbiAgICAgIGtleSAhPT0gJ3NlcmlhbGl6ZXJzJyAmJlxuICAgICAga2V5ICE9PSAnZm9ybWF0dGVycycgJiZcbiAgICAgIGtleSAhPT0gJ2N1c3RvbUxldmVscycgJiZcbiAgICAgIGJpbmRpbmdzLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICBpZiAodmFsaWQgPT09IHRydWUpIHtcbiAgICAgIHZhbHVlID0gc2VyaWFsaXplcnNba2V5XSA/IHNlcmlhbGl6ZXJzW2tleV0odmFsdWUpIDogdmFsdWVcbiAgICAgIHZhbHVlID0gKHN0cmluZ2lmaWVyc1trZXldIHx8IHdpbGRjYXJkU3RyaW5naWZpZXIgfHwgc3RyaW5naWZ5KSh2YWx1ZSwgc3RyaW5naWZ5U2FmZSlcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgZGF0YSArPSAnLFwiJyArIGtleSArICdcIjonICsgdmFsdWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gaGFzQmVlblRhbXBlcmVkIChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZSAhPT0gc3RyZWFtLmNvbnN0cnVjdG9yLnByb3RvdHlwZS53cml0ZVxufVxuXG5jb25zdCBoYXNOb2RlQ29kZUNvdmVyYWdlID0gcHJvY2Vzcy5lbnYuTk9ERV9WOF9DT1ZFUkFHRSB8fCBwcm9jZXNzLmVudi5WOF9DT1ZFUkFHRVxuXG5mdW5jdGlvbiBidWlsZFNhZmVTb25pY0Jvb20gKG9wdHMpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFNvbmljQm9vbShvcHRzKVxuICBzdHJlYW0ub24oJ2Vycm9yJywgZmlsdGVyQnJva2VuUGlwZSlcbiAgLy8gSWYgd2UgYXJlIHN5bmM6IGZhbHNlLCB3ZSBtdXN0IGZsdXNoIG9uIGV4aXRcbiAgLy8gV2UgbXVzdCBkaXNhYmxlIHRoaXMgaWYgdGhlcmUgaXMgbm9kZSBjb2RlIGNvdmVyYWdlIGR1ZSB0b1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MzQ0I2lzc3VlY29tbWVudC0xNzQxNzc2MzA4LlxuICBpZiAoIWhhc05vZGVDb2RlQ292ZXJhZ2UgJiYgIW9wdHMuc3luYyAmJiBpc01haW5UaHJlYWQpIHtcbiAgICBvbkV4aXQucmVnaXN0ZXIoc3RyZWFtLCBhdXRvRW5kKVxuXG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uRXhpdC51bnJlZ2lzdGVyKHN0cmVhbSlcbiAgICB9KVxuICB9XG4gIHJldHVybiBzdHJlYW1cblxuICBmdW5jdGlvbiBmaWx0ZXJCcm9rZW5QaXBlIChlcnIpIHtcbiAgICAvLyBJbXBvc3NpYmxlIHRvIHJlcGxpY2F0ZSBhY3Jvc3MgYWxsIG9wZXJhdGluZyBzeXN0ZW1zXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFUElQRScpIHtcbiAgICAgIC8vIElmIHdlIGdldCBFUElQRSwgd2Ugc2hvdWxkIHN0b3AgbG9nZ2luZyBoZXJlXG4gICAgICAvLyBob3dldmVyIHdlIGhhdmUgbm8gY29udHJvbCB0byB0aGUgY29uc3VtZXIgb2ZcbiAgICAgIC8vIFNvbmljQm9vbSwgc28gd2UganVzdCBvdmVyd3JpdGUgdGhlIHdyaXRlIG1ldGhvZFxuICAgICAgc3RyZWFtLndyaXRlID0gbm9vcFxuICAgICAgc3RyZWFtLmVuZCA9IG5vb3BcbiAgICAgIHN0cmVhbS5mbHVzaFN5bmMgPSBub29wXG4gICAgICBzdHJlYW0uZGVzdHJveSA9IG5vb3BcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZmlsdGVyQnJva2VuUGlwZSlcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXV0b0VuZCAoc3RyZWFtLCBldmVudE5hbWUpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgb25seSBvbiBzb21lIHBsYXRmb3Jtc1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2JlZm9yZUV4aXQnKSB7XG4gICAgLy8gV2Ugc3RpbGwgaGF2ZSBhbiBldmVudCBsb29wLCBsZXQncyB1c2UgaXRcbiAgICBzdHJlYW0uZmx1c2goKVxuICAgIHN0cmVhbS5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHJlYW0uZW5kKClcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIEZvciBzb21lIHJlYXNvbiBpc3RhbmJ1bCBpcyBub3QgZGV0ZWN0aW5nIHRoaXMsIGJ1dCBpdCdzIHRoZXJlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAvLyBXZSBkbyBub3QgaGF2ZSBhbiBldmVudCBsb29wLCBzbyBmbHVzaCBzeW5jaHJvbm91c2x5XG4gICAgc3RyZWFtLmZsdXNoU3luYygpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJnc05vcm1hbGl6ZXIgKGRlZmF1bHRPcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub3JtYWxpemVBcmdzIChpbnN0YW5jZSwgY2FsbGVyLCBvcHRzID0ge30sIHN0cmVhbSkge1xuICAgIC8vIHN1cHBvcnQgc3RyZWFtIGFzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgc3RyZWFtID0gYnVpbGRTYWZlU29uaWNCb29tKHsgZGVzdDogb3B0cyB9KVxuICAgICAgb3B0cyA9IHt9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyZWFtID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy50cmFuc3BvcnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29ubHkgb25lIG9mIG9wdGlvbi50cmFuc3BvcnQgb3Igc3RyZWFtIGNhbiBiZSBzcGVjaWZpZWQnKVxuICAgICAgfVxuICAgICAgc3RyZWFtID0gYnVpbGRTYWZlU29uaWNCb29tKHsgZGVzdDogc3RyZWFtIH0pXG4gICAgfSBlbHNlIGlmIChvcHRzIGluc3RhbmNlb2YgU29uaWNCb29tIHx8IG9wdHMud3JpdGFibGUgfHwgb3B0cy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgc3RyZWFtID0gb3B0c1xuICAgICAgb3B0cyA9IHt9XG4gICAgfSBlbHNlIGlmIChvcHRzLnRyYW5zcG9ydCkge1xuICAgICAgaWYgKG9wdHMudHJhbnNwb3J0IGluc3RhbmNlb2YgU29uaWNCb29tIHx8IG9wdHMudHJhbnNwb3J0LndyaXRhYmxlIHx8IG9wdHMudHJhbnNwb3J0Ll93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdvcHRpb24udHJhbnNwb3J0IGRvIG5vdCBhbGxvdyBzdHJlYW0sIHBsZWFzZSBwYXNzIHRvIG9wdGlvbiBkaXJlY3RseS4gZS5nLiBwaW5vKHRyYW5zcG9ydCknKVxuICAgICAgfVxuICAgICAgaWYgKG9wdHMudHJhbnNwb3J0LnRhcmdldHMgJiYgb3B0cy50cmFuc3BvcnQudGFyZ2V0cy5sZW5ndGggJiYgb3B0cy5mb3JtYXR0ZXJzICYmIHR5cGVvZiBvcHRzLmZvcm1hdHRlcnMubGV2ZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29wdGlvbi50cmFuc3BvcnQudGFyZ2V0cyBkbyBub3QgYWxsb3cgY3VzdG9tIGxldmVsIGZvcm1hdHRlcnMnKVxuICAgICAgfVxuXG4gICAgICBsZXQgY3VzdG9tTGV2ZWxzXG4gICAgICBpZiAob3B0cy5jdXN0b21MZXZlbHMpIHtcbiAgICAgICAgY3VzdG9tTGV2ZWxzID0gb3B0cy51c2VPbmx5Q3VzdG9tTGV2ZWxzID8gb3B0cy5jdXN0b21MZXZlbHMgOiBPYmplY3QuYXNzaWduKHt9LCBvcHRzLmxldmVscywgb3B0cy5jdXN0b21MZXZlbHMpXG4gICAgICB9XG4gICAgICBzdHJlYW0gPSB0cmFuc3BvcnQoeyBjYWxsZXIsIC4uLm9wdHMudHJhbnNwb3J0LCBsZXZlbHM6IGN1c3RvbUxldmVscyB9KVxuICAgIH1cbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdHMpXG4gICAgb3B0cy5zZXJpYWxpemVycyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLnNlcmlhbGl6ZXJzLCBvcHRzLnNlcmlhbGl6ZXJzKVxuICAgIG9wdHMuZm9ybWF0dGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLmZvcm1hdHRlcnMsIG9wdHMuZm9ybWF0dGVycylcblxuICAgIGlmIChvcHRzLnByZXR0eVByaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXR0eVByaW50IG9wdGlvbiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLCBzZWUgdGhlIHBpbm8tcHJldHR5IHBhY2thZ2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9waW5vanMvcGluby1wcmV0dHkpJylcbiAgICB9XG5cbiAgICBjb25zdCB7IGVuYWJsZWQsIG9uQ2hpbGQgfSA9IG9wdHNcbiAgICBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIG9wdHMubGV2ZWwgPSAnc2lsZW50J1xuICAgIGlmICghb25DaGlsZCkgb3B0cy5vbkNoaWxkID0gbm9vcFxuICAgIGlmICghc3RyZWFtKSB7XG4gICAgICBpZiAoIWhhc0JlZW5UYW1wZXJlZChwcm9jZXNzLnN0ZG91dCkpIHtcbiAgICAgICAgLy8gSWYgcHJvY2Vzcy5zdGRvdXQuZmQgaXMgdW5kZWZpbmVkLCBpdCBtZWFucyB0aGF0IHdlIGFyZSBydW5uaW5nXG4gICAgICAgIC8vIGluIGEgd29ya2VyIHRocmVhZC4gTGV0J3MgYXNzdW1lIHdlIGFyZSBsb2dnaW5nIHRvIGZpbGUgZGVzY3JpcHRvciAxLlxuICAgICAgICBzdHJlYW0gPSBidWlsZFNhZmVTb25pY0Jvb20oeyBmZDogcHJvY2Vzcy5zdGRvdXQuZmQgfHwgMSB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtID0gcHJvY2Vzcy5zdGRvdXRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgb3B0cywgc3RyZWFtIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgc3RyaW5naWZ5U2FmZUZuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iailcbiAgfSBjYXRjaCAoXykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJpbmdpZnkgPSBzdHJpbmdpZnlTYWZlRm4gfHwgdGhpc1tzdHJpbmdpZnlTYWZlU3ltXVxuICAgICAgcmV0dXJuIHN0cmluZ2lmeShvYmopXG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuICdcIlt1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV1cIidcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRGb3JtYXR0ZXJzIChsZXZlbCwgYmluZGluZ3MsIGxvZykge1xuICByZXR1cm4ge1xuICAgIGxldmVsLFxuICAgIGJpbmRpbmdzLFxuICAgIGxvZ1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBpbnRlZ2VyIGZpbGUgZGVzY3JpcHRvciB0byBhIHByb3BlciBuYXRpdmUgaW50ZWdlclxuICogZmlsZSBkZXNjcmlwdG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbiBUaGUgZmlsZSBkZXNjcmlwdG9yIHN0cmluZyB0byBhdHRlbXB0IHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yIChkZXN0aW5hdGlvbikge1xuICBjb25zdCBmZCA9IE51bWJlcihkZXN0aW5hdGlvbilcbiAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gJ3N0cmluZycgJiYgTnVtYmVyLmlzRmluaXRlKGZkKSkge1xuICAgIHJldHVybiBmZFxuICB9XG4gIC8vIGRlc3RpbmF0aW9uIGNvdWxkIGJlIHVuZGVmaW5lZCBpZiB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgaWYgKGRlc3RpbmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUaGlzIGlzIHN0ZG91dCBpbiBVTklYIHN5c3RlbXNcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbm9vcCxcbiAgYnVpbGRTYWZlU29uaWNCb29tLFxuICBhc0NoaW5kaW5ncyxcbiAgYXNKc29uLFxuICBnZW5Mb2csXG4gIGNyZWF0ZUFyZ3NOb3JtYWxpemVyLFxuICBzdHJpbmdpZnksXG4gIGJ1aWxkRm9ybWF0dGVycyxcbiAgbm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/tools.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/lib/transport.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/transport.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { createRequire } = __webpack_require__(/*! module */ \"module\")\nconst getCallers = __webpack_require__(/*! ./caller */ \"(rsc)/./node_modules/pino/lib/caller.js\")\nconst { join, isAbsolute, sep } = __webpack_require__(/*! node:path */ \"node:path\")\nconst sleep = __webpack_require__(/*! atomic-sleep */ \"(rsc)/./node_modules/atomic-sleep/index.js\")\nconst onExit = __webpack_require__(/*! on-exit-leak-free */ \"(rsc)/./node_modules/on-exit-leak-free/index.js\")\nconst ThreadStream = __webpack_require__(/*! thread-stream */ \"(rsc)/./node_modules/thread-stream/index.js\")\n\nfunction setupOnExit (stream) {\n  // This is leak free, it does not leave event handlers\n  onExit.register(stream, autoEnd)\n  onExit.registerBeforeExit(stream, flush)\n\n  stream.on('close', function () {\n    onExit.unregister(stream)\n  })\n}\n\nfunction buildStream (filename, workerData, workerOpts, sync) {\n  const stream = new ThreadStream({\n    filename,\n    workerData,\n    workerOpts,\n    sync\n  })\n\n  stream.on('ready', onReady)\n  stream.on('close', function () {\n    process.removeListener('exit', onExit)\n  })\n\n  process.on('exit', onExit)\n\n  function onReady () {\n    process.removeListener('exit', onExit)\n    stream.unref()\n\n    if (workerOpts.autoEnd !== false) {\n      setupOnExit(stream)\n    }\n  }\n\n  function onExit () {\n    /* istanbul ignore next */\n    if (stream.closed) {\n      return\n    }\n    stream.flushSync()\n    // Apparently there is a very sporadic race condition\n    // that in certain OS would prevent the messages to be flushed\n    // because the thread might not have been created still.\n    // Unfortunately we need to sleep(100) in this case.\n    sleep(100)\n    stream.end()\n  }\n\n  return stream\n}\n\nfunction autoEnd (stream) {\n  stream.ref()\n  stream.flushSync()\n  stream.end()\n  stream.once('close', function () {\n    stream.unref()\n  })\n}\n\nfunction flush (stream) {\n  stream.flushSync()\n}\n\nfunction transport (fullOptions) {\n  const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions\n\n  const options = {\n    ...fullOptions.options\n  }\n\n  // Backwards compatibility\n  const callers = typeof caller === 'string' ? [caller] : caller\n\n  // This will be eventually modified by bundlers\n  const bundlerOverrides = '__bundlerPathsOverrides' in globalThis ? globalThis.__bundlerPathsOverrides : {}\n\n  let target = fullOptions.target\n\n  if (target && targets) {\n    throw new Error('only one of target or targets can be specified')\n  }\n\n  if (targets) {\n    target = bundlerOverrides['pino-worker'] || join(__dirname, 'worker.js')\n    options.targets = targets.filter(dest => dest.target).map((dest) => {\n      return {\n        ...dest,\n        target: fixTarget(dest.target)\n      }\n    })\n    options.pipelines = targets.filter(dest => dest.pipeline).map((dest) => {\n      return dest.pipeline.map((t) => {\n        return {\n          ...t,\n          level: dest.level, // duplicate the pipeline `level` property defined in the upper level\n          target: fixTarget(t.target)\n        }\n      })\n    })\n  } else if (pipeline) {\n    target = bundlerOverrides['pino-worker'] || join(__dirname, 'worker.js')\n    options.pipelines = [pipeline.map((dest) => {\n      return {\n        ...dest,\n        target: fixTarget(dest.target)\n      }\n    })]\n  }\n\n  if (levels) {\n    options.levels = levels\n  }\n\n  if (dedupe) {\n    options.dedupe = dedupe\n  }\n\n  options.pinoWillSendConfig = true\n\n  return buildStream(fixTarget(target), options, worker, sync)\n\n  function fixTarget (origin) {\n    origin = bundlerOverrides[origin] || origin\n\n    if (isAbsolute(origin) || origin.indexOf('file://') === 0) {\n      return origin\n    }\n\n    if (origin === 'pino/file') {\n      return join(__dirname, '..', 'file.js')\n    }\n\n    let fixTarget\n\n    for (const filePath of callers) {\n      try {\n        const context = filePath === 'node:repl'\n          ? process.cwd() + sep\n          : filePath\n\n        fixTarget = createRequire(context).resolve(origin)\n        break\n      } catch (err) {\n        // Silent catch\n        continue\n      }\n    }\n\n    if (!fixTarget) {\n      throw new Error(`unable to determine transport target for \"${origin}\"`)\n    }\n\n    return fixTarget\n  }\n}\n\nmodule.exports = transport\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyx5REFBVTtBQUNyQyxRQUFRLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDckQsY0FBYyxtQkFBTyxDQUFDLGdFQUFjO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQywwRUFBbUI7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsa0VBQWU7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDhDQUE4Qyx3Q0FBd0M7O0FBRWhHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phc2h3YW50aHBlZGRpc2V0dHkvRG9jdW1lbnRzL2V0aGdsb2JhbC9jb250ZXh0by9ub2RlX21vZHVsZXMvcGluby9saWIvdHJhbnNwb3J0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGNyZWF0ZVJlcXVpcmUgfSA9IHJlcXVpcmUoJ21vZHVsZScpXG5jb25zdCBnZXRDYWxsZXJzID0gcmVxdWlyZSgnLi9jYWxsZXInKVxuY29uc3QgeyBqb2luLCBpc0Fic29sdXRlLCBzZXAgfSA9IHJlcXVpcmUoJ25vZGU6cGF0aCcpXG5jb25zdCBzbGVlcCA9IHJlcXVpcmUoJ2F0b21pYy1zbGVlcCcpXG5jb25zdCBvbkV4aXQgPSByZXF1aXJlKCdvbi1leGl0LWxlYWstZnJlZScpXG5jb25zdCBUaHJlYWRTdHJlYW0gPSByZXF1aXJlKCd0aHJlYWQtc3RyZWFtJylcblxuZnVuY3Rpb24gc2V0dXBPbkV4aXQgKHN0cmVhbSkge1xuICAvLyBUaGlzIGlzIGxlYWsgZnJlZSwgaXQgZG9lcyBub3QgbGVhdmUgZXZlbnQgaGFuZGxlcnNcbiAgb25FeGl0LnJlZ2lzdGVyKHN0cmVhbSwgYXV0b0VuZClcbiAgb25FeGl0LnJlZ2lzdGVyQmVmb3JlRXhpdChzdHJlYW0sIGZsdXNoKVxuXG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgb25FeGl0LnVucmVnaXN0ZXIoc3RyZWFtKVxuICB9KVxufVxuXG5mdW5jdGlvbiBidWlsZFN0cmVhbSAoZmlsZW5hbWUsIHdvcmtlckRhdGEsIHdvcmtlck9wdHMsIHN5bmMpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFRocmVhZFN0cmVhbSh7XG4gICAgZmlsZW5hbWUsXG4gICAgd29ya2VyRGF0YSxcbiAgICB3b3JrZXJPcHRzLFxuICAgIHN5bmNcbiAgfSlcblxuICBzdHJlYW0ub24oJ3JlYWR5Jywgb25SZWFkeSlcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCdleGl0Jywgb25FeGl0KVxuICB9KVxuXG4gIHByb2Nlc3Mub24oJ2V4aXQnLCBvbkV4aXQpXG5cbiAgZnVuY3Rpb24gb25SZWFkeSAoKSB7XG4gICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcignZXhpdCcsIG9uRXhpdClcbiAgICBzdHJlYW0udW5yZWYoKVxuXG4gICAgaWYgKHdvcmtlck9wdHMuYXV0b0VuZCAhPT0gZmFsc2UpIHtcbiAgICAgIHNldHVwT25FeGl0KHN0cmVhbSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkV4aXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHN0cmVhbS5jbG9zZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdHJlYW0uZmx1c2hTeW5jKClcbiAgICAvLyBBcHBhcmVudGx5IHRoZXJlIGlzIGEgdmVyeSBzcG9yYWRpYyByYWNlIGNvbmRpdGlvblxuICAgIC8vIHRoYXQgaW4gY2VydGFpbiBPUyB3b3VsZCBwcmV2ZW50IHRoZSBtZXNzYWdlcyB0byBiZSBmbHVzaGVkXG4gICAgLy8gYmVjYXVzZSB0aGUgdGhyZWFkIG1pZ2h0IG5vdCBoYXZlIGJlZW4gY3JlYXRlZCBzdGlsbC5cbiAgICAvLyBVbmZvcnR1bmF0ZWx5IHdlIG5lZWQgdG8gc2xlZXAoMTAwKSBpbiB0aGlzIGNhc2UuXG4gICAgc2xlZXAoMTAwKVxuICAgIHN0cmVhbS5lbmQoKVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5mdW5jdGlvbiBhdXRvRW5kIChzdHJlYW0pIHtcbiAgc3RyZWFtLnJlZigpXG4gIHN0cmVhbS5mbHVzaFN5bmMoKVxuICBzdHJlYW0uZW5kKClcbiAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS51bnJlZigpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZsdXNoIChzdHJlYW0pIHtcbiAgc3RyZWFtLmZsdXNoU3luYygpXG59XG5cbmZ1bmN0aW9uIHRyYW5zcG9ydCAoZnVsbE9wdGlvbnMpIHtcbiAgY29uc3QgeyBwaXBlbGluZSwgdGFyZ2V0cywgbGV2ZWxzLCBkZWR1cGUsIHdvcmtlciA9IHt9LCBjYWxsZXIgPSBnZXRDYWxsZXJzKCksIHN5bmMgPSBmYWxzZSB9ID0gZnVsbE9wdGlvbnNcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmZ1bGxPcHRpb25zLm9wdGlvbnNcbiAgfVxuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGNvbnN0IGNhbGxlcnMgPSB0eXBlb2YgY2FsbGVyID09PSAnc3RyaW5nJyA/IFtjYWxsZXJdIDogY2FsbGVyXG5cbiAgLy8gVGhpcyB3aWxsIGJlIGV2ZW50dWFsbHkgbW9kaWZpZWQgYnkgYnVuZGxlcnNcbiAgY29uc3QgYnVuZGxlck92ZXJyaWRlcyA9ICdfX2J1bmRsZXJQYXRoc092ZXJyaWRlcycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuX19idW5kbGVyUGF0aHNPdmVycmlkZXMgOiB7fVxuXG4gIGxldCB0YXJnZXQgPSBmdWxsT3B0aW9ucy50YXJnZXRcblxuICBpZiAodGFyZ2V0ICYmIHRhcmdldHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgb25lIG9mIHRhcmdldCBvciB0YXJnZXRzIGNhbiBiZSBzcGVjaWZpZWQnKVxuICB9XG5cbiAgaWYgKHRhcmdldHMpIHtcbiAgICB0YXJnZXQgPSBidW5kbGVyT3ZlcnJpZGVzWydwaW5vLXdvcmtlciddIHx8IGpvaW4oX19kaXJuYW1lLCAnd29ya2VyLmpzJylcbiAgICBvcHRpb25zLnRhcmdldHMgPSB0YXJnZXRzLmZpbHRlcihkZXN0ID0+IGRlc3QudGFyZ2V0KS5tYXAoKGRlc3QpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlc3QsXG4gICAgICAgIHRhcmdldDogZml4VGFyZ2V0KGRlc3QudGFyZ2V0KVxuICAgICAgfVxuICAgIH0pXG4gICAgb3B0aW9ucy5waXBlbGluZXMgPSB0YXJnZXRzLmZpbHRlcihkZXN0ID0+IGRlc3QucGlwZWxpbmUpLm1hcCgoZGVzdCkgPT4ge1xuICAgICAgcmV0dXJuIGRlc3QucGlwZWxpbmUubWFwKCh0KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udCxcbiAgICAgICAgICBsZXZlbDogZGVzdC5sZXZlbCwgLy8gZHVwbGljYXRlIHRoZSBwaXBlbGluZSBgbGV2ZWxgIHByb3BlcnR5IGRlZmluZWQgaW4gdGhlIHVwcGVyIGxldmVsXG4gICAgICAgICAgdGFyZ2V0OiBmaXhUYXJnZXQodC50YXJnZXQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChwaXBlbGluZSkge1xuICAgIHRhcmdldCA9IGJ1bmRsZXJPdmVycmlkZXNbJ3Bpbm8td29ya2VyJ10gfHwgam9pbihfX2Rpcm5hbWUsICd3b3JrZXIuanMnKVxuICAgIG9wdGlvbnMucGlwZWxpbmVzID0gW3BpcGVsaW5lLm1hcCgoZGVzdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVzdCxcbiAgICAgICAgdGFyZ2V0OiBmaXhUYXJnZXQoZGVzdC50YXJnZXQpXG4gICAgICB9XG4gICAgfSldXG4gIH1cblxuICBpZiAobGV2ZWxzKSB7XG4gICAgb3B0aW9ucy5sZXZlbHMgPSBsZXZlbHNcbiAgfVxuXG4gIGlmIChkZWR1cGUpIHtcbiAgICBvcHRpb25zLmRlZHVwZSA9IGRlZHVwZVxuICB9XG5cbiAgb3B0aW9ucy5waW5vV2lsbFNlbmRDb25maWcgPSB0cnVlXG5cbiAgcmV0dXJuIGJ1aWxkU3RyZWFtKGZpeFRhcmdldCh0YXJnZXQpLCBvcHRpb25zLCB3b3JrZXIsIHN5bmMpXG5cbiAgZnVuY3Rpb24gZml4VGFyZ2V0IChvcmlnaW4pIHtcbiAgICBvcmlnaW4gPSBidW5kbGVyT3ZlcnJpZGVzW29yaWdpbl0gfHwgb3JpZ2luXG5cbiAgICBpZiAoaXNBYnNvbHV0ZShvcmlnaW4pIHx8IG9yaWdpbi5pbmRleE9mKCdmaWxlOi8vJykgPT09IDApIHtcbiAgICAgIHJldHVybiBvcmlnaW5cbiAgICB9XG5cbiAgICBpZiAob3JpZ2luID09PSAncGluby9maWxlJykge1xuICAgICAgcmV0dXJuIGpvaW4oX19kaXJuYW1lLCAnLi4nLCAnZmlsZS5qcycpXG4gICAgfVxuXG4gICAgbGV0IGZpeFRhcmdldFxuXG4gICAgZm9yIChjb25zdCBmaWxlUGF0aCBvZiBjYWxsZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gZmlsZVBhdGggPT09ICdub2RlOnJlcGwnXG4gICAgICAgICAgPyBwcm9jZXNzLmN3ZCgpICsgc2VwXG4gICAgICAgICAgOiBmaWxlUGF0aFxuXG4gICAgICAgIGZpeFRhcmdldCA9IGNyZWF0ZVJlcXVpcmUoY29udGV4dCkucmVzb2x2ZShvcmlnaW4pXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gU2lsZW50IGNhdGNoXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmaXhUYXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGRldGVybWluZSB0cmFuc3BvcnQgdGFyZ2V0IGZvciBcIiR7b3JpZ2lufVwiYClcbiAgICB9XG5cbiAgICByZXR1cm4gZml4VGFyZ2V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc3BvcnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/lib/transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pino/pino.js":
/*!***********************************!*\
  !*** ./node_modules/pino/pino.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst os = __webpack_require__(/*! node:os */ \"node:os\")\nconst stdSerializers = __webpack_require__(/*! pino-std-serializers */ \"(rsc)/./node_modules/pino-std-serializers/index.js\")\nconst caller = __webpack_require__(/*! ./lib/caller */ \"(rsc)/./node_modules/pino/lib/caller.js\")\nconst redaction = __webpack_require__(/*! ./lib/redaction */ \"(rsc)/./node_modules/pino/lib/redaction.js\")\nconst time = __webpack_require__(/*! ./lib/time */ \"(rsc)/./node_modules/pino/lib/time.js\")\nconst proto = __webpack_require__(/*! ./lib/proto */ \"(rsc)/./node_modules/pino/lib/proto.js\")\nconst symbols = __webpack_require__(/*! ./lib/symbols */ \"(rsc)/./node_modules/pino/lib/symbols.js\")\nconst { configure } = __webpack_require__(/*! safe-stable-stringify */ \"(rsc)/./node_modules/safe-stable-stringify/index.js\")\nconst { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = __webpack_require__(/*! ./lib/levels */ \"(rsc)/./node_modules/pino/lib/levels.js\")\nconst { DEFAULT_LEVELS, SORTING_ORDER } = __webpack_require__(/*! ./lib/constants */ \"(rsc)/./node_modules/pino/lib/constants.js\")\nconst {\n  createArgsNormalizer,\n  asChindings,\n  buildSafeSonicBoom,\n  buildFormatters,\n  stringify,\n  normalizeDestFileDescriptor,\n  noop\n} = __webpack_require__(/*! ./lib/tools */ \"(rsc)/./node_modules/pino/lib/tools.js\")\nconst { version } = __webpack_require__(/*! ./lib/meta */ \"(rsc)/./node_modules/pino/lib/meta.js\")\nconst {\n  chindingsSym,\n  redactFmtSym,\n  serializersSym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  stringifySym,\n  stringifySafeSym,\n  stringifiersSym,\n  setLevelSym,\n  endSym,\n  formatOptsSym,\n  messageKeySym,\n  errorKeySym,\n  nestedKeySym,\n  mixinSym,\n  levelCompSym,\n  useOnlyCustomLevelsSym,\n  formattersSym,\n  hooksSym,\n  nestedKeyStrSym,\n  mixinMergeStrategySym,\n  msgPrefixSym\n} = symbols\nconst { epochTime, nullTime } = time\nconst { pid } = process\nconst hostname = os.hostname()\nconst defaultErrorSerializer = stdSerializers.err\nconst defaultOptions = {\n  level: 'info',\n  levelComparison: SORTING_ORDER.ASC,\n  levels: DEFAULT_LEVELS,\n  messageKey: 'msg',\n  errorKey: 'err',\n  nestedKey: null,\n  enabled: true,\n  base: { pid, hostname },\n  serializers: Object.assign(Object.create(null), {\n    err: defaultErrorSerializer\n  }),\n  formatters: Object.assign(Object.create(null), {\n    bindings (bindings) {\n      return bindings\n    },\n    level (label, number) {\n      return { level: number }\n    }\n  }),\n  hooks: {\n    logMethod: undefined,\n    streamWrite: undefined\n  },\n  timestamp: epochTime,\n  name: undefined,\n  redact: null,\n  customLevels: null,\n  useOnlyCustomLevels: false,\n  depthLimit: 5,\n  edgeLimit: 100\n}\n\nconst normalize = createArgsNormalizer(defaultOptions)\n\nconst serializers = Object.assign(Object.create(null), stdSerializers)\n\nfunction pino (...args) {\n  const instance = {}\n  const { opts, stream } = normalize(instance, caller(), ...args)\n\n  if (opts.level && typeof opts.level === 'string' && DEFAULT_LEVELS[opts.level.toLowerCase()] !== undefined) opts.level = opts.level.toLowerCase()\n\n  const {\n    redact,\n    crlf,\n    serializers,\n    timestamp,\n    messageKey,\n    errorKey,\n    nestedKey,\n    base,\n    name,\n    level,\n    customLevels,\n    levelComparison,\n    mixin,\n    mixinMergeStrategy,\n    useOnlyCustomLevels,\n    formatters,\n    hooks,\n    depthLimit,\n    edgeLimit,\n    onChild,\n    msgPrefix\n  } = opts\n\n  const stringifySafe = configure({\n    maximumDepth: depthLimit,\n    maximumBreadth: edgeLimit\n  })\n\n  const allFormatters = buildFormatters(\n    formatters.level,\n    formatters.bindings,\n    formatters.log\n  )\n\n  const stringifyFn = stringify.bind({\n    [stringifySafeSym]: stringifySafe\n  })\n  const stringifiers = redact ? redaction(redact, stringifyFn) : {}\n  const formatOpts = redact\n    ? { stringify: stringifiers[redactFmtSym] }\n    : { stringify: stringifyFn }\n  const end = '}' + (crlf ? '\\r\\n' : '\\n')\n  const coreChindings = asChindings.bind(null, {\n    [chindingsSym]: '',\n    [serializersSym]: serializers,\n    [stringifiersSym]: stringifiers,\n    [stringifySym]: stringify,\n    [stringifySafeSym]: stringifySafe,\n    [formattersSym]: allFormatters\n  })\n\n  let chindings = ''\n  if (base !== null) {\n    if (name === undefined) {\n      chindings = coreChindings(base)\n    } else {\n      chindings = coreChindings(Object.assign({}, base, { name }))\n    }\n  }\n\n  const time = (timestamp instanceof Function)\n    ? timestamp\n    : (timestamp ? epochTime : nullTime)\n  const timeSliceIndex = time().indexOf(':') + 1\n\n  if (useOnlyCustomLevels && !customLevels) throw Error('customLevels is required if useOnlyCustomLevels is set true')\n  if (mixin && typeof mixin !== 'function') throw Error(`Unknown mixin type \"${typeof mixin}\" - expected \"function\"`)\n  if (msgPrefix && typeof msgPrefix !== 'string') throw Error(`Unknown msgPrefix type \"${typeof msgPrefix}\" - expected \"string\"`)\n\n  assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels)\n  const levels = mappings(customLevels, useOnlyCustomLevels)\n\n  if (typeof stream.emit === 'function') {\n    stream.emit('message', { code: 'PINO_CONFIG', config: { levels, messageKey, errorKey } })\n  }\n\n  assertLevelComparison(levelComparison)\n  const levelCompFunc = genLevelComparison(levelComparison)\n\n  Object.assign(instance, {\n    levels,\n    [levelCompSym]: levelCompFunc,\n    [useOnlyCustomLevelsSym]: useOnlyCustomLevels,\n    [streamSym]: stream,\n    [timeSym]: time,\n    [timeSliceIndexSym]: timeSliceIndex,\n    [stringifySym]: stringify,\n    [stringifySafeSym]: stringifySafe,\n    [stringifiersSym]: stringifiers,\n    [endSym]: end,\n    [formatOptsSym]: formatOpts,\n    [messageKeySym]: messageKey,\n    [errorKeySym]: errorKey,\n    [nestedKeySym]: nestedKey,\n    // protect against injection\n    [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : '',\n    [serializersSym]: serializers,\n    [mixinSym]: mixin,\n    [mixinMergeStrategySym]: mixinMergeStrategy,\n    [chindingsSym]: chindings,\n    [formattersSym]: allFormatters,\n    [hooksSym]: hooks,\n    silent: noop,\n    onChild,\n    [msgPrefixSym]: msgPrefix\n  })\n\n  Object.setPrototypeOf(instance, proto())\n\n  genLsCache(instance)\n\n  instance[setLevelSym](level)\n\n  return instance\n}\n\nmodule.exports = pino\n\nmodule.exports.destination = (dest = process.stdout.fd) => {\n  if (typeof dest === 'object') {\n    dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd)\n    return buildSafeSonicBoom(dest)\n  } else {\n    return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 })\n  }\n}\n\nmodule.exports.transport = __webpack_require__(/*! ./lib/transport */ \"(rsc)/./node_modules/pino/lib/transport.js\")\nmodule.exports.multistream = __webpack_require__(/*! ./lib/multistream */ \"(rsc)/./node_modules/pino/lib/multistream.js\")\n\nmodule.exports.levels = mappings()\nmodule.exports.stdSerializers = serializers\nmodule.exports.stdTimeFunctions = Object.assign({}, time)\nmodule.exports.symbols = symbols\nmodule.exports.version = version\n\n// Enables default and name export with TypeScript and Babel\nmodule.exports[\"default\"] = pino\nmodule.exports.pino = pino\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGluby9waW5vLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQyx3QkFBUztBQUM1Qix1QkFBdUIsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDckQsZUFBZSxtQkFBTyxDQUFDLDZEQUFjO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLG1FQUFpQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMseURBQVk7QUFDakMsY0FBYyxtQkFBTyxDQUFDLDJEQUFhO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLCtEQUFlO0FBQ3ZDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0ZBQXVCO0FBQ3JELFFBQVEsMkZBQTJGLEVBQUUsbUJBQU8sQ0FBQyw2REFBYztBQUMzSCxRQUFRLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsbUVBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyREFBYTtBQUN6QixRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLHlEQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixRQUFRLHNCQUFzQjtBQUM5QixRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWU7QUFDZjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxlQUFlOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnREFBZ0QsVUFBVSxNQUFNO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrRUFBK0UsYUFBYTtBQUM1Rix5RkFBeUYsaUJBQWlCOztBQUUxRztBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLCtCQUErQixnQ0FBZ0M7QUFDNUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEIsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQ0FBZ0MsdURBQXVEO0FBQ3ZGO0FBQ0E7O0FBRUEsbUhBQXFEO0FBQ3JELHlIQUF5RDs7QUFFekQscUJBQXFCO0FBQ3JCLDZCQUE2QjtBQUM3QiwrQkFBK0IsbUJBQW1CO0FBQ2xELHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0EseUJBQXNCO0FBQ3RCLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL2phc2h3YW50aHBlZGRpc2V0dHkvRG9jdW1lbnRzL2V0aGdsb2JhbC9jb250ZXh0by9ub2RlX21vZHVsZXMvcGluby9waW5vLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ25vZGU6b3MnKVxuY29uc3Qgc3RkU2VyaWFsaXplcnMgPSByZXF1aXJlKCdwaW5vLXN0ZC1zZXJpYWxpemVycycpXG5jb25zdCBjYWxsZXIgPSByZXF1aXJlKCcuL2xpYi9jYWxsZXInKVxuY29uc3QgcmVkYWN0aW9uID0gcmVxdWlyZSgnLi9saWIvcmVkYWN0aW9uJylcbmNvbnN0IHRpbWUgPSByZXF1aXJlKCcuL2xpYi90aW1lJylcbmNvbnN0IHByb3RvID0gcmVxdWlyZSgnLi9saWIvcHJvdG8nKVxuY29uc3Qgc3ltYm9scyA9IHJlcXVpcmUoJy4vbGliL3N5bWJvbHMnKVxuY29uc3QgeyBjb25maWd1cmUgfSA9IHJlcXVpcmUoJ3NhZmUtc3RhYmxlLXN0cmluZ2lmeScpXG5jb25zdCB7IGFzc2VydERlZmF1bHRMZXZlbEZvdW5kLCBtYXBwaW5ncywgZ2VuTHNDYWNoZSwgZ2VuTGV2ZWxDb21wYXJpc29uLCBhc3NlcnRMZXZlbENvbXBhcmlzb24gfSA9IHJlcXVpcmUoJy4vbGliL2xldmVscycpXG5jb25zdCB7IERFRkFVTFRfTEVWRUxTLCBTT1JUSU5HX09SREVSIH0gPSByZXF1aXJlKCcuL2xpYi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBjcmVhdGVBcmdzTm9ybWFsaXplcixcbiAgYXNDaGluZGluZ3MsXG4gIGJ1aWxkU2FmZVNvbmljQm9vbSxcbiAgYnVpbGRGb3JtYXR0ZXJzLFxuICBzdHJpbmdpZnksXG4gIG5vcm1hbGl6ZURlc3RGaWxlRGVzY3JpcHRvcixcbiAgbm9vcFxufSA9IHJlcXVpcmUoJy4vbGliL3Rvb2xzJylcbmNvbnN0IHsgdmVyc2lvbiB9ID0gcmVxdWlyZSgnLi9saWIvbWV0YScpXG5jb25zdCB7XG4gIGNoaW5kaW5nc1N5bSxcbiAgcmVkYWN0Rm10U3ltLFxuICBzZXJpYWxpemVyc1N5bSxcbiAgdGltZVN5bSxcbiAgdGltZVNsaWNlSW5kZXhTeW0sXG4gIHN0cmVhbVN5bSxcbiAgc3RyaW5naWZ5U3ltLFxuICBzdHJpbmdpZnlTYWZlU3ltLFxuICBzdHJpbmdpZmllcnNTeW0sXG4gIHNldExldmVsU3ltLFxuICBlbmRTeW0sXG4gIGZvcm1hdE9wdHNTeW0sXG4gIG1lc3NhZ2VLZXlTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBuZXN0ZWRLZXlTeW0sXG4gIG1peGluU3ltLFxuICBsZXZlbENvbXBTeW0sXG4gIHVzZU9ubHlDdXN0b21MZXZlbHNTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIGhvb2tzU3ltLFxuICBuZXN0ZWRLZXlTdHJTeW0sXG4gIG1peGluTWVyZ2VTdHJhdGVneVN5bSxcbiAgbXNnUHJlZml4U3ltXG59ID0gc3ltYm9sc1xuY29uc3QgeyBlcG9jaFRpbWUsIG51bGxUaW1lIH0gPSB0aW1lXG5jb25zdCB7IHBpZCB9ID0gcHJvY2Vzc1xuY29uc3QgaG9zdG5hbWUgPSBvcy5ob3N0bmFtZSgpXG5jb25zdCBkZWZhdWx0RXJyb3JTZXJpYWxpemVyID0gc3RkU2VyaWFsaXplcnMuZXJyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgbGV2ZWw6ICdpbmZvJyxcbiAgbGV2ZWxDb21wYXJpc29uOiBTT1JUSU5HX09SREVSLkFTQyxcbiAgbGV2ZWxzOiBERUZBVUxUX0xFVkVMUyxcbiAgbWVzc2FnZUtleTogJ21zZycsXG4gIGVycm9yS2V5OiAnZXJyJyxcbiAgbmVzdGVkS2V5OiBudWxsLFxuICBlbmFibGVkOiB0cnVlLFxuICBiYXNlOiB7IHBpZCwgaG9zdG5hbWUgfSxcbiAgc2VyaWFsaXplcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgIGVycjogZGVmYXVsdEVycm9yU2VyaWFsaXplclxuICB9KSxcbiAgZm9ybWF0dGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgYmluZGluZ3MgKGJpbmRpbmdzKSB7XG4gICAgICByZXR1cm4gYmluZGluZ3NcbiAgICB9LFxuICAgIGxldmVsIChsYWJlbCwgbnVtYmVyKSB7XG4gICAgICByZXR1cm4geyBsZXZlbDogbnVtYmVyIH1cbiAgICB9XG4gIH0pLFxuICBob29rczoge1xuICAgIGxvZ01ldGhvZDogdW5kZWZpbmVkLFxuICAgIHN0cmVhbVdyaXRlOiB1bmRlZmluZWRcbiAgfSxcbiAgdGltZXN0YW1wOiBlcG9jaFRpbWUsXG4gIG5hbWU6IHVuZGVmaW5lZCxcbiAgcmVkYWN0OiBudWxsLFxuICBjdXN0b21MZXZlbHM6IG51bGwsXG4gIHVzZU9ubHlDdXN0b21MZXZlbHM6IGZhbHNlLFxuICBkZXB0aExpbWl0OiA1LFxuICBlZGdlTGltaXQ6IDEwMFxufVxuXG5jb25zdCBub3JtYWxpemUgPSBjcmVhdGVBcmdzTm9ybWFsaXplcihkZWZhdWx0T3B0aW9ucylcblxuY29uc3Qgc2VyaWFsaXplcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHN0ZFNlcmlhbGl6ZXJzKVxuXG5mdW5jdGlvbiBwaW5vICguLi5hcmdzKSB7XG4gIGNvbnN0IGluc3RhbmNlID0ge31cbiAgY29uc3QgeyBvcHRzLCBzdHJlYW0gfSA9IG5vcm1hbGl6ZShpbnN0YW5jZSwgY2FsbGVyKCksIC4uLmFyZ3MpXG5cbiAgaWYgKG9wdHMubGV2ZWwgJiYgdHlwZW9mIG9wdHMubGV2ZWwgPT09ICdzdHJpbmcnICYmIERFRkFVTFRfTEVWRUxTW29wdHMubGV2ZWwudG9Mb3dlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkgb3B0cy5sZXZlbCA9IG9wdHMubGV2ZWwudG9Mb3dlckNhc2UoKVxuXG4gIGNvbnN0IHtcbiAgICByZWRhY3QsXG4gICAgY3JsZixcbiAgICBzZXJpYWxpemVycyxcbiAgICB0aW1lc3RhbXAsXG4gICAgbWVzc2FnZUtleSxcbiAgICBlcnJvcktleSxcbiAgICBuZXN0ZWRLZXksXG4gICAgYmFzZSxcbiAgICBuYW1lLFxuICAgIGxldmVsLFxuICAgIGN1c3RvbUxldmVscyxcbiAgICBsZXZlbENvbXBhcmlzb24sXG4gICAgbWl4aW4sXG4gICAgbWl4aW5NZXJnZVN0cmF0ZWd5LFxuICAgIHVzZU9ubHlDdXN0b21MZXZlbHMsXG4gICAgZm9ybWF0dGVycyxcbiAgICBob29rcyxcbiAgICBkZXB0aExpbWl0LFxuICAgIGVkZ2VMaW1pdCxcbiAgICBvbkNoaWxkLFxuICAgIG1zZ1ByZWZpeFxuICB9ID0gb3B0c1xuXG4gIGNvbnN0IHN0cmluZ2lmeVNhZmUgPSBjb25maWd1cmUoe1xuICAgIG1heGltdW1EZXB0aDogZGVwdGhMaW1pdCxcbiAgICBtYXhpbXVtQnJlYWR0aDogZWRnZUxpbWl0XG4gIH0pXG5cbiAgY29uc3QgYWxsRm9ybWF0dGVycyA9IGJ1aWxkRm9ybWF0dGVycyhcbiAgICBmb3JtYXR0ZXJzLmxldmVsLFxuICAgIGZvcm1hdHRlcnMuYmluZGluZ3MsXG4gICAgZm9ybWF0dGVycy5sb2dcbiAgKVxuXG4gIGNvbnN0IHN0cmluZ2lmeUZuID0gc3RyaW5naWZ5LmJpbmQoe1xuICAgIFtzdHJpbmdpZnlTYWZlU3ltXTogc3RyaW5naWZ5U2FmZVxuICB9KVxuICBjb25zdCBzdHJpbmdpZmllcnMgPSByZWRhY3QgPyByZWRhY3Rpb24ocmVkYWN0LCBzdHJpbmdpZnlGbikgOiB7fVxuICBjb25zdCBmb3JtYXRPcHRzID0gcmVkYWN0XG4gICAgPyB7IHN0cmluZ2lmeTogc3RyaW5naWZpZXJzW3JlZGFjdEZtdFN5bV0gfVxuICAgIDogeyBzdHJpbmdpZnk6IHN0cmluZ2lmeUZuIH1cbiAgY29uc3QgZW5kID0gJ30nICsgKGNybGYgPyAnXFxyXFxuJyA6ICdcXG4nKVxuICBjb25zdCBjb3JlQ2hpbmRpbmdzID0gYXNDaGluZGluZ3MuYmluZChudWxsLCB7XG4gICAgW2NoaW5kaW5nc1N5bV06ICcnLFxuICAgIFtzZXJpYWxpemVyc1N5bV06IHNlcmlhbGl6ZXJzLFxuICAgIFtzdHJpbmdpZmllcnNTeW1dOiBzdHJpbmdpZmllcnMsXG4gICAgW3N0cmluZ2lmeVN5bV06IHN0cmluZ2lmeSxcbiAgICBbc3RyaW5naWZ5U2FmZVN5bV06IHN0cmluZ2lmeVNhZmUsXG4gICAgW2Zvcm1hdHRlcnNTeW1dOiBhbGxGb3JtYXR0ZXJzXG4gIH0pXG5cbiAgbGV0IGNoaW5kaW5ncyA9ICcnXG4gIGlmIChiYXNlICE9PSBudWxsKSB7XG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2hpbmRpbmdzID0gY29yZUNoaW5kaW5ncyhiYXNlKVxuICAgIH0gZWxzZSB7XG4gICAgICBjaGluZGluZ3MgPSBjb3JlQ2hpbmRpbmdzKE9iamVjdC5hc3NpZ24oe30sIGJhc2UsIHsgbmFtZSB9KSlcbiAgICB9XG4gIH1cblxuICBjb25zdCB0aW1lID0gKHRpbWVzdGFtcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgID8gdGltZXN0YW1wXG4gICAgOiAodGltZXN0YW1wID8gZXBvY2hUaW1lIDogbnVsbFRpbWUpXG4gIGNvbnN0IHRpbWVTbGljZUluZGV4ID0gdGltZSgpLmluZGV4T2YoJzonKSArIDFcblxuICBpZiAodXNlT25seUN1c3RvbUxldmVscyAmJiAhY3VzdG9tTGV2ZWxzKSB0aHJvdyBFcnJvcignY3VzdG9tTGV2ZWxzIGlzIHJlcXVpcmVkIGlmIHVzZU9ubHlDdXN0b21MZXZlbHMgaXMgc2V0IHRydWUnKVxuICBpZiAobWl4aW4gJiYgdHlwZW9mIG1peGluICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBFcnJvcihgVW5rbm93biBtaXhpbiB0eXBlIFwiJHt0eXBlb2YgbWl4aW59XCIgLSBleHBlY3RlZCBcImZ1bmN0aW9uXCJgKVxuICBpZiAobXNnUHJlZml4ICYmIHR5cGVvZiBtc2dQcmVmaXggIT09ICdzdHJpbmcnKSB0aHJvdyBFcnJvcihgVW5rbm93biBtc2dQcmVmaXggdHlwZSBcIiR7dHlwZW9mIG1zZ1ByZWZpeH1cIiAtIGV4cGVjdGVkIFwic3RyaW5nXCJgKVxuXG4gIGFzc2VydERlZmF1bHRMZXZlbEZvdW5kKGxldmVsLCBjdXN0b21MZXZlbHMsIHVzZU9ubHlDdXN0b21MZXZlbHMpXG4gIGNvbnN0IGxldmVscyA9IG1hcHBpbmdzKGN1c3RvbUxldmVscywgdXNlT25seUN1c3RvbUxldmVscylcblxuICBpZiAodHlwZW9mIHN0cmVhbS5lbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyZWFtLmVtaXQoJ21lc3NhZ2UnLCB7IGNvZGU6ICdQSU5PX0NPTkZJRycsIGNvbmZpZzogeyBsZXZlbHMsIG1lc3NhZ2VLZXksIGVycm9yS2V5IH0gfSlcbiAgfVxuXG4gIGFzc2VydExldmVsQ29tcGFyaXNvbihsZXZlbENvbXBhcmlzb24pXG4gIGNvbnN0IGxldmVsQ29tcEZ1bmMgPSBnZW5MZXZlbENvbXBhcmlzb24obGV2ZWxDb21wYXJpc29uKVxuXG4gIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICBsZXZlbHMsXG4gICAgW2xldmVsQ29tcFN5bV06IGxldmVsQ29tcEZ1bmMsXG4gICAgW3VzZU9ubHlDdXN0b21MZXZlbHNTeW1dOiB1c2VPbmx5Q3VzdG9tTGV2ZWxzLFxuICAgIFtzdHJlYW1TeW1dOiBzdHJlYW0sXG4gICAgW3RpbWVTeW1dOiB0aW1lLFxuICAgIFt0aW1lU2xpY2VJbmRleFN5bV06IHRpbWVTbGljZUluZGV4LFxuICAgIFtzdHJpbmdpZnlTeW1dOiBzdHJpbmdpZnksXG4gICAgW3N0cmluZ2lmeVNhZmVTeW1dOiBzdHJpbmdpZnlTYWZlLFxuICAgIFtzdHJpbmdpZmllcnNTeW1dOiBzdHJpbmdpZmllcnMsXG4gICAgW2VuZFN5bV06IGVuZCxcbiAgICBbZm9ybWF0T3B0c1N5bV06IGZvcm1hdE9wdHMsXG4gICAgW21lc3NhZ2VLZXlTeW1dOiBtZXNzYWdlS2V5LFxuICAgIFtlcnJvcktleVN5bV06IGVycm9yS2V5LFxuICAgIFtuZXN0ZWRLZXlTeW1dOiBuZXN0ZWRLZXksXG4gICAgLy8gcHJvdGVjdCBhZ2FpbnN0IGluamVjdGlvblxuICAgIFtuZXN0ZWRLZXlTdHJTeW1dOiBuZXN0ZWRLZXkgPyBgLCR7SlNPTi5zdHJpbmdpZnkobmVzdGVkS2V5KX06e2AgOiAnJyxcbiAgICBbc2VyaWFsaXplcnNTeW1dOiBzZXJpYWxpemVycyxcbiAgICBbbWl4aW5TeW1dOiBtaXhpbixcbiAgICBbbWl4aW5NZXJnZVN0cmF0ZWd5U3ltXTogbWl4aW5NZXJnZVN0cmF0ZWd5LFxuICAgIFtjaGluZGluZ3NTeW1dOiBjaGluZGluZ3MsXG4gICAgW2Zvcm1hdHRlcnNTeW1dOiBhbGxGb3JtYXR0ZXJzLFxuICAgIFtob29rc1N5bV06IGhvb2tzLFxuICAgIHNpbGVudDogbm9vcCxcbiAgICBvbkNoaWxkLFxuICAgIFttc2dQcmVmaXhTeW1dOiBtc2dQcmVmaXhcbiAgfSlcblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIHByb3RvKCkpXG5cbiAgZ2VuTHNDYWNoZShpbnN0YW5jZSlcblxuICBpbnN0YW5jZVtzZXRMZXZlbFN5bV0obGV2ZWwpXG5cbiAgcmV0dXJuIGluc3RhbmNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlub1xuXG5tb2R1bGUuZXhwb3J0cy5kZXN0aW5hdGlvbiA9IChkZXN0ID0gcHJvY2Vzcy5zdGRvdXQuZmQpID0+IHtcbiAgaWYgKHR5cGVvZiBkZXN0ID09PSAnb2JqZWN0Jykge1xuICAgIGRlc3QuZGVzdCA9IG5vcm1hbGl6ZURlc3RGaWxlRGVzY3JpcHRvcihkZXN0LmRlc3QgfHwgcHJvY2Vzcy5zdGRvdXQuZmQpXG4gICAgcmV0dXJuIGJ1aWxkU2FmZVNvbmljQm9vbShkZXN0KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWlsZFNhZmVTb25pY0Jvb20oeyBkZXN0OiBub3JtYWxpemVEZXN0RmlsZURlc2NyaXB0b3IoZGVzdCksIG1pbkxlbmd0aDogMCB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLnRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL3RyYW5zcG9ydCcpXG5tb2R1bGUuZXhwb3J0cy5tdWx0aXN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL211bHRpc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMubGV2ZWxzID0gbWFwcGluZ3MoKVxubW9kdWxlLmV4cG9ydHMuc3RkU2VyaWFsaXplcnMgPSBzZXJpYWxpemVyc1xubW9kdWxlLmV4cG9ydHMuc3RkVGltZUZ1bmN0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRpbWUpXG5tb2R1bGUuZXhwb3J0cy5zeW1ib2xzID0gc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb25cblxuLy8gRW5hYmxlcyBkZWZhdWx0IGFuZCBuYW1lIGV4cG9ydCB3aXRoIFR5cGVTY3JpcHQgYW5kIEJhYmVsXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcGlub1xubW9kdWxlLmV4cG9ydHMucGlubyA9IHBpbm9cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pino/pino.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/caller.js":
/*!*****************************************!*\
  !*** ./node_modules/pino/lib/caller.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction noOpPrepareStackTrace (_, stack) {\n  return stack\n}\n\nmodule.exports = function getCallers () {\n  const originalPrepare = Error.prepareStackTrace\n  Error.prepareStackTrace = noOpPrepareStackTrace\n  const stack = new Error().stack\n  Error.prepareStackTrace = originalPrepare\n\n  if (!Array.isArray(stack)) {\n    return undefined\n  }\n\n  const entries = stack.slice(2)\n\n  const fileNames = []\n\n  for (const entry of entries) {\n    if (!entry) {\n      continue\n    }\n\n    fileNames.push(entry.getFileName())\n  }\n\n  return fileNames\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvY2FsbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2NhbGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gbm9PcFByZXBhcmVTdGFja1RyYWNlIChfLCBzdGFjaykge1xuICByZXR1cm4gc3RhY2tcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRDYWxsZXJzICgpIHtcbiAgY29uc3Qgb3JpZ2luYWxQcmVwYXJlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2VcbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBub09wUHJlcGFyZVN0YWNrVHJhY2VcbiAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFja1xuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IG9yaWdpbmFsUHJlcGFyZVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShzdGFjaykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBlbnRyaWVzID0gc3RhY2suc2xpY2UoMilcblxuICBjb25zdCBmaWxlTmFtZXMgPSBbXVxuXG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgZmlsZU5hbWVzLnB1c2goZW50cnkuZ2V0RmlsZU5hbWUoKSlcbiAgfVxuXG4gIHJldHVybiBmaWxlTmFtZXNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/caller.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/constants.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/constants.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * Represents default log level values\n *\n * @enum {number}\n */\nconst DEFAULT_LEVELS = {\n  trace: 10,\n  debug: 20,\n  info: 30,\n  warn: 40,\n  error: 50,\n  fatal: 60\n}\n\n/**\n * Represents sort order direction: `ascending` or `descending`\n *\n * @enum {string}\n */\nconst SORTING_ORDER = {\n  ASC: 'ASC',\n  DESC: 'DESC'\n}\n\nmodule.exports = {\n  DEFAULT_LEVELS,\n  SORTING_ORDER\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlcHJlc2VudHMgZGVmYXVsdCBsb2cgbGV2ZWwgdmFsdWVzXG4gKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgREVGQVVMVF9MRVZFTFMgPSB7XG4gIHRyYWNlOiAxMCxcbiAgZGVidWc6IDIwLFxuICBpbmZvOiAzMCxcbiAgd2FybjogNDAsXG4gIGVycm9yOiA1MCxcbiAgZmF0YWw6IDYwXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBzb3J0IG9yZGVyIGRpcmVjdGlvbjogYGFzY2VuZGluZ2Agb3IgYGRlc2NlbmRpbmdgXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgU09SVElOR19PUkRFUiA9IHtcbiAgQVNDOiAnQVNDJyxcbiAgREVTQzogJ0RFU0MnXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBERUZBVUxUX0xFVkVMUyxcbiAgU09SVElOR19PUkRFUlxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/levels.js":
/*!*****************************************!*\
  !*** ./node_modules/pino/lib/levels.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint no-prototype-builtins: 0 */\nconst {\n  lsCacheSym,\n  levelValSym,\n  useOnlyCustomLevelsSym,\n  streamSym,\n  formattersSym,\n  hooksSym,\n  levelCompSym\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\")\nconst { noop, genLog } = __webpack_require__(/*! ./tools */ \"(ssr)/./node_modules/pino/lib/tools.js\")\nconst { DEFAULT_LEVELS, SORTING_ORDER } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/pino/lib/constants.js\")\n\nconst levelMethods = {\n  fatal: (hook) => {\n    const logFatal = genLog(DEFAULT_LEVELS.fatal, hook)\n    return function (...args) {\n      const stream = this[streamSym]\n      logFatal.call(this, ...args)\n      if (typeof stream.flushSync === 'function') {\n        try {\n          stream.flushSync()\n        } catch (e) {\n          // https://github.com/pinojs/pino/pull/740#discussion_r346788313\n        }\n      }\n    }\n  },\n  error: (hook) => genLog(DEFAULT_LEVELS.error, hook),\n  warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),\n  info: (hook) => genLog(DEFAULT_LEVELS.info, hook),\n  debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),\n  trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)\n}\n\nconst nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {\n  o[DEFAULT_LEVELS[k]] = k\n  return o\n}, {})\n\nconst initialLsCache = Object.keys(nums).reduce((o, k) => {\n  o[k] = '{\"level\":' + Number(k)\n  return o\n}, {})\n\nfunction genLsCache (instance) {\n  const formatter = instance[formattersSym].level\n  const { labels } = instance.levels\n  const cache = {}\n  for (const label in labels) {\n    const level = formatter(labels[label], Number(label))\n    cache[label] = JSON.stringify(level).slice(0, -1)\n  }\n  instance[lsCacheSym] = cache\n  return instance\n}\n\nfunction isStandardLevel (level, useOnlyCustomLevels) {\n  if (useOnlyCustomLevels) {\n    return false\n  }\n\n  switch (level) {\n    case 'fatal':\n    case 'error':\n    case 'warn':\n    case 'info':\n    case 'debug':\n    case 'trace':\n      return true\n    default:\n      return false\n  }\n}\n\nfunction setLevel (level) {\n  const { labels, values } = this.levels\n  if (typeof level === 'number') {\n    if (labels[level] === undefined) throw Error('unknown level value' + level)\n    level = labels[level]\n  }\n  if (values[level] === undefined) throw Error('unknown level ' + level)\n  const preLevelVal = this[levelValSym]\n  const levelVal = this[levelValSym] = values[level]\n  const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym]\n  const levelComparison = this[levelCompSym]\n  const hook = this[hooksSym].logMethod\n\n  for (const key in values) {\n    if (levelComparison(values[key], levelVal) === false) {\n      this[key] = noop\n      continue\n    }\n    this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook)\n  }\n\n  this.emit(\n    'level-change',\n    level,\n    levelVal,\n    labels[preLevelVal],\n    preLevelVal,\n    this\n  )\n}\n\nfunction getLevel (level) {\n  const { levels, levelVal } = this\n  // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)\n  return (levels && levels.labels) ? levels.labels[levelVal] : ''\n}\n\nfunction isLevelEnabled (logLevel) {\n  const { values } = this.levels\n  const logLevelVal = values[logLevel]\n  return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym])\n}\n\n/**\n * Determine if the given `current` level is enabled by comparing it\n * against the current threshold (`expected`).\n *\n * @param {SORTING_ORDER} direction comparison direction \"ASC\" or \"DESC\"\n * @param {number} current current log level number representation\n * @param {number} expected threshold value to compare with\n * @returns {boolean}\n */\nfunction compareLevel (direction, current, expected) {\n  if (direction === SORTING_ORDER.DESC) {\n    return current <= expected\n  }\n\n  return current >= expected\n}\n\n/**\n * Create a level comparison function based on `levelComparison`\n * it could a default function which compares levels either in \"ascending\" or \"descending\" order or custom comparison function\n *\n * @param {SORTING_ORDER | Function} levelComparison sort levels order direction or custom comparison function\n * @returns Function\n */\nfunction genLevelComparison (levelComparison) {\n  if (typeof levelComparison === 'string') {\n    return compareLevel.bind(null, levelComparison)\n  }\n\n  return levelComparison\n}\n\nfunction mappings (customLevels = null, useOnlyCustomLevels = false) {\n  const customNums = customLevels\n    /* eslint-disable */\n    ? Object.keys(customLevels).reduce((o, k) => {\n        o[customLevels[k]] = k\n        return o\n      }, {})\n    : null\n    /* eslint-enable */\n\n  const labels = Object.assign(\n    Object.create(Object.prototype, { Infinity: { value: 'silent' } }),\n    useOnlyCustomLevels ? null : nums,\n    customNums\n  )\n  const values = Object.assign(\n    Object.create(Object.prototype, { silent: { value: Infinity } }),\n    useOnlyCustomLevels ? null : DEFAULT_LEVELS,\n    customLevels\n  )\n  return { labels, values }\n}\n\nfunction assertDefaultLevelFound (defaultLevel, customLevels, useOnlyCustomLevels) {\n  if (typeof defaultLevel === 'number') {\n    const values = [].concat(\n      Object.keys(customLevels || {}).map(key => customLevels[key]),\n      useOnlyCustomLevels ? [] : Object.keys(nums).map(level => +level),\n      Infinity\n    )\n    if (!values.includes(defaultLevel)) {\n      throw Error(`default level:${defaultLevel} must be included in custom levels`)\n    }\n    return\n  }\n\n  const labels = Object.assign(\n    Object.create(Object.prototype, { silent: { value: Infinity } }),\n    useOnlyCustomLevels ? null : DEFAULT_LEVELS,\n    customLevels\n  )\n  if (!(defaultLevel in labels)) {\n    throw Error(`default level:${defaultLevel} must be included in custom levels`)\n  }\n}\n\nfunction assertNoLevelCollisions (levels, customLevels) {\n  const { labels, values } = levels\n  for (const k in customLevels) {\n    if (k in values) {\n      throw Error('levels cannot be overridden')\n    }\n    if (customLevels[k] in labels) {\n      throw Error('pre-existing level values cannot be used for new levels')\n    }\n  }\n}\n\n/**\n * Validates whether `levelComparison` is correct\n *\n * @throws Error\n * @param {SORTING_ORDER | Function} levelComparison - value to validate\n * @returns\n */\nfunction assertLevelComparison (levelComparison) {\n  if (typeof levelComparison === 'function') {\n    return\n  }\n\n  if (typeof levelComparison === 'string' && Object.values(SORTING_ORDER).includes(levelComparison)) {\n    return\n  }\n\n  throw new Error('Levels comparison should be one of \"ASC\", \"DESC\" or \"function\" type')\n}\n\nmodule.exports = {\n  initialLsCache,\n  genLsCache,\n  levelMethods,\n  getLevel,\n  setLevel,\n  isLevelEnabled,\n  mappings,\n  assertNoLevelCollisions,\n  assertDefaultLevelFound,\n  genLevelComparison,\n  assertLevelComparison\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbGV2ZWxzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkRBQVc7QUFDdkIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyx1REFBUztBQUMxQyxRQUFRLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsK0RBQWE7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0EsV0FBVztBQUNYO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsWUFBWSxtQkFBbUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxtQkFBbUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxVQUFVLG1CQUFtQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2xldmVscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8qIGVzbGludCBuby1wcm90b3R5cGUtYnVpbHRpbnM6IDAgKi9cbmNvbnN0IHtcbiAgbHNDYWNoZVN5bSxcbiAgbGV2ZWxWYWxTeW0sXG4gIHVzZU9ubHlDdXN0b21MZXZlbHNTeW0sXG4gIHN0cmVhbVN5bSxcbiAgZm9ybWF0dGVyc1N5bSxcbiAgaG9va3NTeW0sXG4gIGxldmVsQ29tcFN5bVxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IG5vb3AsIGdlbkxvZyB9ID0gcmVxdWlyZSgnLi90b29scycpXG5jb25zdCB7IERFRkFVTFRfTEVWRUxTLCBTT1JUSU5HX09SREVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmNvbnN0IGxldmVsTWV0aG9kcyA9IHtcbiAgZmF0YWw6IChob29rKSA9PiB7XG4gICAgY29uc3QgbG9nRmF0YWwgPSBnZW5Mb2coREVGQVVMVF9MRVZFTFMuZmF0YWwsIGhvb2spXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSB0aGlzW3N0cmVhbVN5bV1cbiAgICAgIGxvZ0ZhdGFsLmNhbGwodGhpcywgLi4uYXJncylcbiAgICAgIGlmICh0eXBlb2Ygc3RyZWFtLmZsdXNoU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0cmVhbS5mbHVzaFN5bmMoKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9waW5vL3B1bGwvNzQwI2Rpc2N1c3Npb25fcjM0Njc4ODMxM1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogKGhvb2spID0+IGdlbkxvZyhERUZBVUxUX0xFVkVMUy5lcnJvciwgaG9vayksXG4gIHdhcm46IChob29rKSA9PiBnZW5Mb2coREVGQVVMVF9MRVZFTFMud2FybiwgaG9vayksXG4gIGluZm86IChob29rKSA9PiBnZW5Mb2coREVGQVVMVF9MRVZFTFMuaW5mbywgaG9vayksXG4gIGRlYnVnOiAoaG9vaykgPT4gZ2VuTG9nKERFRkFVTFRfTEVWRUxTLmRlYnVnLCBob29rKSxcbiAgdHJhY2U6IChob29rKSA9PiBnZW5Mb2coREVGQVVMVF9MRVZFTFMudHJhY2UsIGhvb2spXG59XG5cbmNvbnN0IG51bXMgPSBPYmplY3Qua2V5cyhERUZBVUxUX0xFVkVMUykucmVkdWNlKChvLCBrKSA9PiB7XG4gIG9bREVGQVVMVF9MRVZFTFNba11dID0ga1xuICByZXR1cm4gb1xufSwge30pXG5cbmNvbnN0IGluaXRpYWxMc0NhY2hlID0gT2JqZWN0LmtleXMobnVtcykucmVkdWNlKChvLCBrKSA9PiB7XG4gIG9ba10gPSAne1wibGV2ZWxcIjonICsgTnVtYmVyKGspXG4gIHJldHVybiBvXG59LCB7fSlcblxuZnVuY3Rpb24gZ2VuTHNDYWNoZSAoaW5zdGFuY2UpIHtcbiAgY29uc3QgZm9ybWF0dGVyID0gaW5zdGFuY2VbZm9ybWF0dGVyc1N5bV0ubGV2ZWxcbiAgY29uc3QgeyBsYWJlbHMgfSA9IGluc3RhbmNlLmxldmVsc1xuICBjb25zdCBjYWNoZSA9IHt9XG4gIGZvciAoY29uc3QgbGFiZWwgaW4gbGFiZWxzKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBmb3JtYXR0ZXIobGFiZWxzW2xhYmVsXSwgTnVtYmVyKGxhYmVsKSlcbiAgICBjYWNoZVtsYWJlbF0gPSBKU09OLnN0cmluZ2lmeShsZXZlbCkuc2xpY2UoMCwgLTEpXG4gIH1cbiAgaW5zdGFuY2VbbHNDYWNoZVN5bV0gPSBjYWNoZVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cblxuZnVuY3Rpb24gaXNTdGFuZGFyZExldmVsIChsZXZlbCwgdXNlT25seUN1c3RvbUxldmVscykge1xuICBpZiAodXNlT25seUN1c3RvbUxldmVscykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgJ2ZhdGFsJzpcbiAgICBjYXNlICdlcnJvcic6XG4gICAgY2FzZSAnd2Fybic6XG4gICAgY2FzZSAnaW5mbyc6XG4gICAgY2FzZSAnZGVidWcnOlxuICAgIGNhc2UgJ3RyYWNlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldExldmVsIChsZXZlbCkge1xuICBjb25zdCB7IGxhYmVscywgdmFsdWVzIH0gPSB0aGlzLmxldmVsc1xuICBpZiAodHlwZW9mIGxldmVsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChsYWJlbHNbbGV2ZWxdID09PSB1bmRlZmluZWQpIHRocm93IEVycm9yKCd1bmtub3duIGxldmVsIHZhbHVlJyArIGxldmVsKVxuICAgIGxldmVsID0gbGFiZWxzW2xldmVsXVxuICB9XG4gIGlmICh2YWx1ZXNbbGV2ZWxdID09PSB1bmRlZmluZWQpIHRocm93IEVycm9yKCd1bmtub3duIGxldmVsICcgKyBsZXZlbClcbiAgY29uc3QgcHJlTGV2ZWxWYWwgPSB0aGlzW2xldmVsVmFsU3ltXVxuICBjb25zdCBsZXZlbFZhbCA9IHRoaXNbbGV2ZWxWYWxTeW1dID0gdmFsdWVzW2xldmVsXVxuICBjb25zdCB1c2VPbmx5Q3VzdG9tTGV2ZWxzVmFsID0gdGhpc1t1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltXVxuICBjb25zdCBsZXZlbENvbXBhcmlzb24gPSB0aGlzW2xldmVsQ29tcFN5bV1cbiAgY29uc3QgaG9vayA9IHRoaXNbaG9va3NTeW1dLmxvZ01ldGhvZFxuXG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuICAgIGlmIChsZXZlbENvbXBhcmlzb24odmFsdWVzW2tleV0sIGxldmVsVmFsKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXNba2V5XSA9IG5vb3BcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHRoaXNba2V5XSA9IGlzU3RhbmRhcmRMZXZlbChrZXksIHVzZU9ubHlDdXN0b21MZXZlbHNWYWwpID8gbGV2ZWxNZXRob2RzW2tleV0oaG9vaykgOiBnZW5Mb2codmFsdWVzW2tleV0sIGhvb2spXG4gIH1cblxuICB0aGlzLmVtaXQoXG4gICAgJ2xldmVsLWNoYW5nZScsXG4gICAgbGV2ZWwsXG4gICAgbGV2ZWxWYWwsXG4gICAgbGFiZWxzW3ByZUxldmVsVmFsXSxcbiAgICBwcmVMZXZlbFZhbCxcbiAgICB0aGlzXG4gIClcbn1cblxuZnVuY3Rpb24gZ2V0TGV2ZWwgKGxldmVsKSB7XG4gIGNvbnN0IHsgbGV2ZWxzLCBsZXZlbFZhbCB9ID0gdGhpc1xuICAvLyBwcm90ZWN0aW9uIGFnYWluc3QgcG90ZW50aWFsIGxvc3Mgb2YgUGlubyBzY29wZSBmcm9tIHNlcmlhbGl6ZXJzIChlZGdlIGNhc2Ugd2l0aCBjaXJjdWxhciByZWZzIC0gaHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9waW5vL2lzc3Vlcy84MzMpXG4gIHJldHVybiAobGV2ZWxzICYmIGxldmVscy5sYWJlbHMpID8gbGV2ZWxzLmxhYmVsc1tsZXZlbFZhbF0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc0xldmVsRW5hYmxlZCAobG9nTGV2ZWwpIHtcbiAgY29uc3QgeyB2YWx1ZXMgfSA9IHRoaXMubGV2ZWxzXG4gIGNvbnN0IGxvZ0xldmVsVmFsID0gdmFsdWVzW2xvZ0xldmVsXVxuICByZXR1cm4gbG9nTGV2ZWxWYWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzW2xldmVsQ29tcFN5bV0obG9nTGV2ZWxWYWwsIHRoaXNbbGV2ZWxWYWxTeW1dKVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gYGN1cnJlbnRgIGxldmVsIGlzIGVuYWJsZWQgYnkgY29tcGFyaW5nIGl0XG4gKiBhZ2FpbnN0IHRoZSBjdXJyZW50IHRocmVzaG9sZCAoYGV4cGVjdGVkYCkuXG4gKlxuICogQHBhcmFtIHtTT1JUSU5HX09SREVSfSBkaXJlY3Rpb24gY29tcGFyaXNvbiBkaXJlY3Rpb24gXCJBU0NcIiBvciBcIkRFU0NcIlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnQgY3VycmVudCBsb2cgbGV2ZWwgbnVtYmVyIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWQgdGhyZXNob2xkIHZhbHVlIHRvIGNvbXBhcmUgd2l0aFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVMZXZlbCAoZGlyZWN0aW9uLCBjdXJyZW50LCBleHBlY3RlZCkge1xuICBpZiAoZGlyZWN0aW9uID09PSBTT1JUSU5HX09SREVSLkRFU0MpIHtcbiAgICByZXR1cm4gY3VycmVudCA8PSBleHBlY3RlZFxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnQgPj0gZXhwZWN0ZWRcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBsZXZlbCBjb21wYXJpc29uIGZ1bmN0aW9uIGJhc2VkIG9uIGBsZXZlbENvbXBhcmlzb25gXG4gKiBpdCBjb3VsZCBhIGRlZmF1bHQgZnVuY3Rpb24gd2hpY2ggY29tcGFyZXMgbGV2ZWxzIGVpdGhlciBpbiBcImFzY2VuZGluZ1wiIG9yIFwiZGVzY2VuZGluZ1wiIG9yZGVyIG9yIGN1c3RvbSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtTT1JUSU5HX09SREVSIHwgRnVuY3Rpb259IGxldmVsQ29tcGFyaXNvbiBzb3J0IGxldmVscyBvcmRlciBkaXJlY3Rpb24gb3IgY3VzdG9tIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAqIEByZXR1cm5zIEZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdlbkxldmVsQ29tcGFyaXNvbiAobGV2ZWxDb21wYXJpc29uKSB7XG4gIGlmICh0eXBlb2YgbGV2ZWxDb21wYXJpc29uID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb21wYXJlTGV2ZWwuYmluZChudWxsLCBsZXZlbENvbXBhcmlzb24pXG4gIH1cblxuICByZXR1cm4gbGV2ZWxDb21wYXJpc29uXG59XG5cbmZ1bmN0aW9uIG1hcHBpbmdzIChjdXN0b21MZXZlbHMgPSBudWxsLCB1c2VPbmx5Q3VzdG9tTGV2ZWxzID0gZmFsc2UpIHtcbiAgY29uc3QgY3VzdG9tTnVtcyA9IGN1c3RvbUxldmVsc1xuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgPyBPYmplY3Qua2V5cyhjdXN0b21MZXZlbHMpLnJlZHVjZSgobywgaykgPT4ge1xuICAgICAgICBvW2N1c3RvbUxldmVsc1trXV0gPSBrXG4gICAgICAgIHJldHVybiBvXG4gICAgICB9LCB7fSlcbiAgICA6IG51bGxcbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmFzc2lnbihcbiAgICBPYmplY3QuY3JlYXRlKE9iamVjdC5wcm90b3R5cGUsIHsgSW5maW5pdHk6IHsgdmFsdWU6ICdzaWxlbnQnIH0gfSksXG4gICAgdXNlT25seUN1c3RvbUxldmVscyA/IG51bGwgOiBudW1zLFxuICAgIGN1c3RvbU51bXNcbiAgKVxuICBjb25zdCB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKFxuICAgIE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwgeyBzaWxlbnQ6IHsgdmFsdWU6IEluZmluaXR5IH0gfSksXG4gICAgdXNlT25seUN1c3RvbUxldmVscyA/IG51bGwgOiBERUZBVUxUX0xFVkVMUyxcbiAgICBjdXN0b21MZXZlbHNcbiAgKVxuICByZXR1cm4geyBsYWJlbHMsIHZhbHVlcyB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlZmF1bHRMZXZlbEZvdW5kIChkZWZhdWx0TGV2ZWwsIGN1c3RvbUxldmVscywgdXNlT25seUN1c3RvbUxldmVscykge1xuICBpZiAodHlwZW9mIGRlZmF1bHRMZXZlbCA9PT0gJ251bWJlcicpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5jb25jYXQoXG4gICAgICBPYmplY3Qua2V5cyhjdXN0b21MZXZlbHMgfHwge30pLm1hcChrZXkgPT4gY3VzdG9tTGV2ZWxzW2tleV0pLFxuICAgICAgdXNlT25seUN1c3RvbUxldmVscyA/IFtdIDogT2JqZWN0LmtleXMobnVtcykubWFwKGxldmVsID0+ICtsZXZlbCksXG4gICAgICBJbmZpbml0eVxuICAgIClcbiAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyhkZWZhdWx0TGV2ZWwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZGVmYXVsdCBsZXZlbDoke2RlZmF1bHRMZXZlbH0gbXVzdCBiZSBpbmNsdWRlZCBpbiBjdXN0b20gbGV2ZWxzYClcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBsYWJlbHMgPSBPYmplY3QuYXNzaWduKFxuICAgIE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwgeyBzaWxlbnQ6IHsgdmFsdWU6IEluZmluaXR5IH0gfSksXG4gICAgdXNlT25seUN1c3RvbUxldmVscyA/IG51bGwgOiBERUZBVUxUX0xFVkVMUyxcbiAgICBjdXN0b21MZXZlbHNcbiAgKVxuICBpZiAoIShkZWZhdWx0TGV2ZWwgaW4gbGFiZWxzKSkge1xuICAgIHRocm93IEVycm9yKGBkZWZhdWx0IGxldmVsOiR7ZGVmYXVsdExldmVsfSBtdXN0IGJlIGluY2x1ZGVkIGluIGN1c3RvbSBsZXZlbHNgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5vTGV2ZWxDb2xsaXNpb25zIChsZXZlbHMsIGN1c3RvbUxldmVscykge1xuICBjb25zdCB7IGxhYmVscywgdmFsdWVzIH0gPSBsZXZlbHNcbiAgZm9yIChjb25zdCBrIGluIGN1c3RvbUxldmVscykge1xuICAgIGlmIChrIGluIHZhbHVlcykge1xuICAgICAgdGhyb3cgRXJyb3IoJ2xldmVscyBjYW5ub3QgYmUgb3ZlcnJpZGRlbicpXG4gICAgfVxuICAgIGlmIChjdXN0b21MZXZlbHNba10gaW4gbGFiZWxzKSB7XG4gICAgICB0aHJvdyBFcnJvcigncHJlLWV4aXN0aW5nIGxldmVsIHZhbHVlcyBjYW5ub3QgYmUgdXNlZCBmb3IgbmV3IGxldmVscycpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgYGxldmVsQ29tcGFyaXNvbmAgaXMgY29ycmVjdFxuICpcbiAqIEB0aHJvd3MgRXJyb3JcbiAqIEBwYXJhbSB7U09SVElOR19PUkRFUiB8IEZ1bmN0aW9ufSBsZXZlbENvbXBhcmlzb24gLSB2YWx1ZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0TGV2ZWxDb21wYXJpc29uIChsZXZlbENvbXBhcmlzb24pIHtcbiAgaWYgKHR5cGVvZiBsZXZlbENvbXBhcmlzb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0eXBlb2YgbGV2ZWxDb21wYXJpc29uID09PSAnc3RyaW5nJyAmJiBPYmplY3QudmFsdWVzKFNPUlRJTkdfT1JERVIpLmluY2x1ZGVzKGxldmVsQ29tcGFyaXNvbikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignTGV2ZWxzIGNvbXBhcmlzb24gc2hvdWxkIGJlIG9uZSBvZiBcIkFTQ1wiLCBcIkRFU0NcIiBvciBcImZ1bmN0aW9uXCIgdHlwZScpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0aWFsTHNDYWNoZSxcbiAgZ2VuTHNDYWNoZSxcbiAgbGV2ZWxNZXRob2RzLFxuICBnZXRMZXZlbCxcbiAgc2V0TGV2ZWwsXG4gIGlzTGV2ZWxFbmFibGVkLFxuICBtYXBwaW5ncyxcbiAgYXNzZXJ0Tm9MZXZlbENvbGxpc2lvbnMsXG4gIGFzc2VydERlZmF1bHRMZXZlbEZvdW5kLFxuICBnZW5MZXZlbENvbXBhcmlzb24sXG4gIGFzc2VydExldmVsQ29tcGFyaXNvblxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/levels.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/meta.js":
/*!***************************************!*\
  !*** ./node_modules/pino/lib/meta.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = { version: '9.6.0' }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbWV0YS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixtQkFBbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL21ldGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnOS42LjAnIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/meta.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/multistream.js":
/*!**********************************************!*\
  !*** ./node_modules/pino/lib/multistream.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst metadata = Symbol.for('pino.metadata')\nconst { DEFAULT_LEVELS } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/pino/lib/constants.js\")\n\nconst DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info\n\nfunction multistream (streamsArray, opts) {\n  let counter = 0\n  streamsArray = streamsArray || []\n  opts = opts || { dedupe: false }\n\n  const streamLevels = Object.create(DEFAULT_LEVELS)\n  streamLevels.silent = Infinity\n  if (opts.levels && typeof opts.levels === 'object') {\n    Object.keys(opts.levels).forEach(i => {\n      streamLevels[i] = opts.levels[i]\n    })\n  }\n\n  const res = {\n    write,\n    add,\n    emit,\n    flushSync,\n    end,\n    minLevel: 0,\n    streams: [],\n    clone,\n    [metadata]: true,\n    streamLevels\n  }\n\n  if (Array.isArray(streamsArray)) {\n    streamsArray.forEach(add, res)\n  } else {\n    add.call(res, streamsArray)\n  }\n\n  // clean this object up\n  // or it will stay allocated forever\n  // as it is closed on the following closures\n  streamsArray = null\n\n  return res\n\n  // we can exit early because the streams are ordered by level\n  function write (data) {\n    let dest\n    const level = this.lastLevel\n    const { streams } = this\n    // for handling situation when several streams has the same level\n    let recordedLevel = 0\n    let stream\n\n    // if dedupe set to true we send logs to the stream with the highest level\n    // therefore, we have to change sorting order\n    for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {\n      dest = streams[i]\n      if (dest.level <= level) {\n        if (recordedLevel !== 0 && recordedLevel !== dest.level) {\n          break\n        }\n        stream = dest.stream\n        if (stream[metadata]) {\n          const { lastTime, lastMsg, lastObj, lastLogger } = this\n          stream.lastLevel = level\n          stream.lastTime = lastTime\n          stream.lastMsg = lastMsg\n          stream.lastObj = lastObj\n          stream.lastLogger = lastLogger\n        }\n        stream.write(data)\n        if (opts.dedupe) {\n          recordedLevel = dest.level\n        }\n      } else if (!opts.dedupe) {\n        break\n      }\n    }\n  }\n\n  function emit (...args) {\n    for (const { stream } of this.streams) {\n      if (typeof stream.emit === 'function') {\n        stream.emit(...args)\n      }\n    }\n  }\n\n  function flushSync () {\n    for (const { stream } of this.streams) {\n      if (typeof stream.flushSync === 'function') {\n        stream.flushSync()\n      }\n    }\n  }\n\n  function add (dest) {\n    if (!dest) {\n      return res\n    }\n\n    // Check that dest implements either StreamEntry or DestinationStream\n    const isStream = typeof dest.write === 'function' || dest.stream\n    const stream_ = dest.write ? dest : dest.stream\n    // This is necessary to provide a meaningful error message, otherwise it throws somewhere inside write()\n    if (!isStream) {\n      throw Error('stream object needs to implement either StreamEntry or DestinationStream interface')\n    }\n\n    const { streams, streamLevels } = this\n\n    let level\n    if (typeof dest.levelVal === 'number') {\n      level = dest.levelVal\n    } else if (typeof dest.level === 'string') {\n      level = streamLevels[dest.level]\n    } else if (typeof dest.level === 'number') {\n      level = dest.level\n    } else {\n      level = DEFAULT_INFO_LEVEL\n    }\n\n    const dest_ = {\n      stream: stream_,\n      level,\n      levelVal: undefined,\n      id: counter++\n    }\n\n    streams.unshift(dest_)\n    streams.sort(compareByLevel)\n\n    this.minLevel = streams[0].level\n\n    return res\n  }\n\n  function end () {\n    for (const { stream } of this.streams) {\n      if (typeof stream.flushSync === 'function') {\n        stream.flushSync()\n      }\n      stream.end()\n    }\n  }\n\n  function clone (level) {\n    const streams = new Array(this.streams.length)\n\n    for (let i = 0; i < streams.length; i++) {\n      streams[i] = {\n        level,\n        stream: this.streams[i].stream\n      }\n    }\n\n    return {\n      write,\n      add,\n      minLevel: level,\n      streams,\n      clone,\n      emit,\n      flushSync,\n      [metadata]: true\n    }\n  }\n}\n\nfunction compareByLevel (a, b) {\n  return a.level - b.level\n}\n\nfunction initLoopVar (length, dedupe) {\n  return dedupe ? length - 1 : 0\n}\n\nfunction adjustLoopVar (i, dedupe) {\n  return dedupe ? i - 1 : i + 1\n}\n\nfunction checkLoopVar (i, length, dedupe) {\n  return dedupe ? i >= 0 : i < length\n}\n\nmodule.exports = multistream\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbXVsdGlzdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsK0RBQWE7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJELDhDQUE4QztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBeUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHdCQUF3Qjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9waW5vL2xpYi9tdWx0aXN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgbWV0YWRhdGEgPSBTeW1ib2wuZm9yKCdwaW5vLm1ldGFkYXRhJylcbmNvbnN0IHsgREVGQVVMVF9MRVZFTFMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY29uc3QgREVGQVVMVF9JTkZPX0xFVkVMID0gREVGQVVMVF9MRVZFTFMuaW5mb1xuXG5mdW5jdGlvbiBtdWx0aXN0cmVhbSAoc3RyZWFtc0FycmF5LCBvcHRzKSB7XG4gIGxldCBjb3VudGVyID0gMFxuICBzdHJlYW1zQXJyYXkgPSBzdHJlYW1zQXJyYXkgfHwgW11cbiAgb3B0cyA9IG9wdHMgfHwgeyBkZWR1cGU6IGZhbHNlIH1cblxuICBjb25zdCBzdHJlYW1MZXZlbHMgPSBPYmplY3QuY3JlYXRlKERFRkFVTFRfTEVWRUxTKVxuICBzdHJlYW1MZXZlbHMuc2lsZW50ID0gSW5maW5pdHlcbiAgaWYgKG9wdHMubGV2ZWxzICYmIHR5cGVvZiBvcHRzLmxldmVscyA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3Qua2V5cyhvcHRzLmxldmVscykuZm9yRWFjaChpID0+IHtcbiAgICAgIHN0cmVhbUxldmVsc1tpXSA9IG9wdHMubGV2ZWxzW2ldXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHJlcyA9IHtcbiAgICB3cml0ZSxcbiAgICBhZGQsXG4gICAgZW1pdCxcbiAgICBmbHVzaFN5bmMsXG4gICAgZW5kLFxuICAgIG1pbkxldmVsOiAwLFxuICAgIHN0cmVhbXM6IFtdLFxuICAgIGNsb25lLFxuICAgIFttZXRhZGF0YV06IHRydWUsXG4gICAgc3RyZWFtTGV2ZWxzXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zQXJyYXkpKSB7XG4gICAgc3RyZWFtc0FycmF5LmZvckVhY2goYWRkLCByZXMpXG4gIH0gZWxzZSB7XG4gICAgYWRkLmNhbGwocmVzLCBzdHJlYW1zQXJyYXkpXG4gIH1cblxuICAvLyBjbGVhbiB0aGlzIG9iamVjdCB1cFxuICAvLyBvciBpdCB3aWxsIHN0YXkgYWxsb2NhdGVkIGZvcmV2ZXJcbiAgLy8gYXMgaXQgaXMgY2xvc2VkIG9uIHRoZSBmb2xsb3dpbmcgY2xvc3VyZXNcbiAgc3RyZWFtc0FycmF5ID0gbnVsbFxuXG4gIHJldHVybiByZXNcblxuICAvLyB3ZSBjYW4gZXhpdCBlYXJseSBiZWNhdXNlIHRoZSBzdHJlYW1zIGFyZSBvcmRlcmVkIGJ5IGxldmVsXG4gIGZ1bmN0aW9uIHdyaXRlIChkYXRhKSB7XG4gICAgbGV0IGRlc3RcbiAgICBjb25zdCBsZXZlbCA9IHRoaXMubGFzdExldmVsXG4gICAgY29uc3QgeyBzdHJlYW1zIH0gPSB0aGlzXG4gICAgLy8gZm9yIGhhbmRsaW5nIHNpdHVhdGlvbiB3aGVuIHNldmVyYWwgc3RyZWFtcyBoYXMgdGhlIHNhbWUgbGV2ZWxcbiAgICBsZXQgcmVjb3JkZWRMZXZlbCA9IDBcbiAgICBsZXQgc3RyZWFtXG5cbiAgICAvLyBpZiBkZWR1cGUgc2V0IHRvIHRydWUgd2Ugc2VuZCBsb2dzIHRvIHRoZSBzdHJlYW0gd2l0aCB0aGUgaGlnaGVzdCBsZXZlbFxuICAgIC8vIHRoZXJlZm9yZSwgd2UgaGF2ZSB0byBjaGFuZ2Ugc29ydGluZyBvcmRlclxuICAgIGZvciAobGV0IGkgPSBpbml0TG9vcFZhcihzdHJlYW1zLmxlbmd0aCwgb3B0cy5kZWR1cGUpOyBjaGVja0xvb3BWYXIoaSwgc3RyZWFtcy5sZW5ndGgsIG9wdHMuZGVkdXBlKTsgaSA9IGFkanVzdExvb3BWYXIoaSwgb3B0cy5kZWR1cGUpKSB7XG4gICAgICBkZXN0ID0gc3RyZWFtc1tpXVxuICAgICAgaWYgKGRlc3QubGV2ZWwgPD0gbGV2ZWwpIHtcbiAgICAgICAgaWYgKHJlY29yZGVkTGV2ZWwgIT09IDAgJiYgcmVjb3JkZWRMZXZlbCAhPT0gZGVzdC5sZXZlbCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtID0gZGVzdC5zdHJlYW1cbiAgICAgICAgaWYgKHN0cmVhbVttZXRhZGF0YV0pIHtcbiAgICAgICAgICBjb25zdCB7IGxhc3RUaW1lLCBsYXN0TXNnLCBsYXN0T2JqLCBsYXN0TG9nZ2VyIH0gPSB0aGlzXG4gICAgICAgICAgc3RyZWFtLmxhc3RMZXZlbCA9IGxldmVsXG4gICAgICAgICAgc3RyZWFtLmxhc3RUaW1lID0gbGFzdFRpbWVcbiAgICAgICAgICBzdHJlYW0ubGFzdE1zZyA9IGxhc3RNc2dcbiAgICAgICAgICBzdHJlYW0ubGFzdE9iaiA9IGxhc3RPYmpcbiAgICAgICAgICBzdHJlYW0ubGFzdExvZ2dlciA9IGxhc3RMb2dnZXJcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ud3JpdGUoZGF0YSlcbiAgICAgICAgaWYgKG9wdHMuZGVkdXBlKSB7XG4gICAgICAgICAgcmVjb3JkZWRMZXZlbCA9IGRlc3QubGV2ZWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghb3B0cy5kZWR1cGUpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0ICguLi5hcmdzKSB7XG4gICAgZm9yIChjb25zdCB7IHN0cmVhbSB9IG9mIHRoaXMuc3RyZWFtcykge1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW0uZW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdHJlYW0uZW1pdCguLi5hcmdzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoU3luYyAoKSB7XG4gICAgZm9yIChjb25zdCB7IHN0cmVhbSB9IG9mIHRoaXMuc3RyZWFtcykge1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW0uZmx1c2hTeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0cmVhbS5mbHVzaFN5bmMoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZCAoZGVzdCkge1xuICAgIGlmICghZGVzdCkge1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoYXQgZGVzdCBpbXBsZW1lbnRzIGVpdGhlciBTdHJlYW1FbnRyeSBvciBEZXN0aW5hdGlvblN0cmVhbVxuICAgIGNvbnN0IGlzU3RyZWFtID0gdHlwZW9mIGRlc3Qud3JpdGUgPT09ICdmdW5jdGlvbicgfHwgZGVzdC5zdHJlYW1cbiAgICBjb25zdCBzdHJlYW1fID0gZGVzdC53cml0ZSA/IGRlc3QgOiBkZXN0LnN0cmVhbVxuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHByb3ZpZGUgYSBtZWFuaW5nZnVsIGVycm9yIG1lc3NhZ2UsIG90aGVyd2lzZSBpdCB0aHJvd3Mgc29tZXdoZXJlIGluc2lkZSB3cml0ZSgpXG4gICAgaWYgKCFpc1N0cmVhbSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ3N0cmVhbSBvYmplY3QgbmVlZHMgdG8gaW1wbGVtZW50IGVpdGhlciBTdHJlYW1FbnRyeSBvciBEZXN0aW5hdGlvblN0cmVhbSBpbnRlcmZhY2UnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc3RyZWFtcywgc3RyZWFtTGV2ZWxzIH0gPSB0aGlzXG5cbiAgICBsZXQgbGV2ZWxcbiAgICBpZiAodHlwZW9mIGRlc3QubGV2ZWxWYWwgPT09ICdudW1iZXInKSB7XG4gICAgICBsZXZlbCA9IGRlc3QubGV2ZWxWYWxcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0LmxldmVsID09PSAnc3RyaW5nJykge1xuICAgICAgbGV2ZWwgPSBzdHJlYW1MZXZlbHNbZGVzdC5sZXZlbF1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0LmxldmVsID09PSAnbnVtYmVyJykge1xuICAgICAgbGV2ZWwgPSBkZXN0LmxldmVsXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsID0gREVGQVVMVF9JTkZPX0xFVkVMXG4gICAgfVxuXG4gICAgY29uc3QgZGVzdF8gPSB7XG4gICAgICBzdHJlYW06IHN0cmVhbV8sXG4gICAgICBsZXZlbCxcbiAgICAgIGxldmVsVmFsOiB1bmRlZmluZWQsXG4gICAgICBpZDogY291bnRlcisrXG4gICAgfVxuXG4gICAgc3RyZWFtcy51bnNoaWZ0KGRlc3RfKVxuICAgIHN0cmVhbXMuc29ydChjb21wYXJlQnlMZXZlbClcblxuICAgIHRoaXMubWluTGV2ZWwgPSBzdHJlYW1zWzBdLmxldmVsXG5cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBlbmQgKCkge1xuICAgIGZvciAoY29uc3QgeyBzdHJlYW0gfSBvZiB0aGlzLnN0cmVhbXMpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyZWFtLmZsdXNoU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdHJlYW0uZmx1c2hTeW5jKClcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5lbmQoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lIChsZXZlbCkge1xuICAgIGNvbnN0IHN0cmVhbXMgPSBuZXcgQXJyYXkodGhpcy5zdHJlYW1zLmxlbmd0aClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3RyZWFtc1tpXSA9IHtcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIHN0cmVhbTogdGhpcy5zdHJlYW1zW2ldLnN0cmVhbVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3cml0ZSxcbiAgICAgIGFkZCxcbiAgICAgIG1pbkxldmVsOiBsZXZlbCxcbiAgICAgIHN0cmVhbXMsXG4gICAgICBjbG9uZSxcbiAgICAgIGVtaXQsXG4gICAgICBmbHVzaFN5bmMsXG4gICAgICBbbWV0YWRhdGFdOiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVCeUxldmVsIChhLCBiKSB7XG4gIHJldHVybiBhLmxldmVsIC0gYi5sZXZlbFxufVxuXG5mdW5jdGlvbiBpbml0TG9vcFZhciAobGVuZ3RoLCBkZWR1cGUpIHtcbiAgcmV0dXJuIGRlZHVwZSA/IGxlbmd0aCAtIDEgOiAwXG59XG5cbmZ1bmN0aW9uIGFkanVzdExvb3BWYXIgKGksIGRlZHVwZSkge1xuICByZXR1cm4gZGVkdXBlID8gaSAtIDEgOiBpICsgMVxufVxuXG5mdW5jdGlvbiBjaGVja0xvb3BWYXIgKGksIGxlbmd0aCwgZGVkdXBlKSB7XG4gIHJldHVybiBkZWR1cGUgPyBpID49IDAgOiBpIDwgbGVuZ3RoXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbXVsdGlzdHJlYW1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/multistream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/proto.js":
/*!****************************************!*\
  !*** ./node_modules/pino/lib/proto.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint no-prototype-builtins: 0 */\n\nconst { EventEmitter } = __webpack_require__(/*! node:events */ \"node:events\")\nconst {\n  lsCacheSym,\n  levelValSym,\n  setLevelSym,\n  getLevelSym,\n  chindingsSym,\n  parsedChindingsSym,\n  mixinSym,\n  asJsonSym,\n  writeSym,\n  mixinMergeStrategySym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  serializersSym,\n  formattersSym,\n  errorKeySym,\n  messageKeySym,\n  useOnlyCustomLevelsSym,\n  needsMetadataGsym,\n  redactFmtSym,\n  stringifySym,\n  formatOptsSym,\n  stringifiersSym,\n  msgPrefixSym,\n  hooksSym\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\")\nconst {\n  getLevel,\n  setLevel,\n  isLevelEnabled,\n  mappings,\n  initialLsCache,\n  genLsCache,\n  assertNoLevelCollisions\n} = __webpack_require__(/*! ./levels */ \"(ssr)/./node_modules/pino/lib/levels.js\")\nconst {\n  asChindings,\n  asJson,\n  buildFormatters,\n  stringify\n} = __webpack_require__(/*! ./tools */ \"(ssr)/./node_modules/pino/lib/tools.js\")\nconst {\n  version\n} = __webpack_require__(/*! ./meta */ \"(ssr)/./node_modules/pino/lib/meta.js\")\nconst redaction = __webpack_require__(/*! ./redaction */ \"(ssr)/./node_modules/pino/lib/redaction.js\")\n\n// note: use of class is satirical\n// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127\nconst constructor = class Pino {}\nconst prototype = {\n  constructor,\n  child,\n  bindings,\n  setBindings,\n  flush,\n  isLevelEnabled,\n  version,\n  get level () { return this[getLevelSym]() },\n  set level (lvl) { this[setLevelSym](lvl) },\n  get levelVal () { return this[levelValSym] },\n  set levelVal (n) { throw Error('levelVal is read-only') },\n  [lsCacheSym]: initialLsCache,\n  [writeSym]: write,\n  [asJsonSym]: asJson,\n  [getLevelSym]: getLevel,\n  [setLevelSym]: setLevel\n}\n\nObject.setPrototypeOf(prototype, EventEmitter.prototype)\n\n// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing\nmodule.exports = function () {\n  return Object.create(prototype)\n}\n\nconst resetChildingsFormatter = bindings => bindings\nfunction child (bindings, options) {\n  if (!bindings) {\n    throw Error('missing bindings for child Pino')\n  }\n  options = options || {} // default options to empty object\n  const serializers = this[serializersSym]\n  const formatters = this[formattersSym]\n  const instance = Object.create(this)\n\n  if (options.hasOwnProperty('serializers') === true) {\n    instance[serializersSym] = Object.create(null)\n\n    for (const k in serializers) {\n      instance[serializersSym][k] = serializers[k]\n    }\n    const parentSymbols = Object.getOwnPropertySymbols(serializers)\n    /* eslint no-var: off */\n    for (var i = 0; i < parentSymbols.length; i++) {\n      const ks = parentSymbols[i]\n      instance[serializersSym][ks] = serializers[ks]\n    }\n\n    for (const bk in options.serializers) {\n      instance[serializersSym][bk] = options.serializers[bk]\n    }\n    const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers)\n    for (var bi = 0; bi < bindingsSymbols.length; bi++) {\n      const bks = bindingsSymbols[bi]\n      instance[serializersSym][bks] = options.serializers[bks]\n    }\n  } else instance[serializersSym] = serializers\n  if (options.hasOwnProperty('formatters')) {\n    const { level, bindings: chindings, log } = options.formatters\n    instance[formattersSym] = buildFormatters(\n      level || formatters.level,\n      chindings || resetChildingsFormatter,\n      log || formatters.log\n    )\n  } else {\n    instance[formattersSym] = buildFormatters(\n      formatters.level,\n      resetChildingsFormatter,\n      formatters.log\n    )\n  }\n  if (options.hasOwnProperty('customLevels') === true) {\n    assertNoLevelCollisions(this.levels, options.customLevels)\n    instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym])\n    genLsCache(instance)\n  }\n\n  // redact must place before asChindings and only replace if exist\n  if ((typeof options.redact === 'object' && options.redact !== null) || Array.isArray(options.redact)) {\n    instance.redact = options.redact // replace redact directly\n    const stringifiers = redaction(instance.redact, stringify)\n    const formatOpts = { stringify: stringifiers[redactFmtSym] }\n    instance[stringifySym] = stringify\n    instance[stringifiersSym] = stringifiers\n    instance[formatOptsSym] = formatOpts\n  }\n\n  if (typeof options.msgPrefix === 'string') {\n    instance[msgPrefixSym] = (this[msgPrefixSym] || '') + options.msgPrefix\n  }\n\n  instance[chindingsSym] = asChindings(instance, bindings)\n  const childLevel = options.level || this.level\n  instance[setLevelSym](childLevel)\n  this.onChild(instance)\n  return instance\n}\n\nfunction bindings () {\n  const chindings = this[chindingsSym]\n  const chindingsJson = `{${chindings.substr(1)}}` // at least contains ,\"pid\":7068,\"hostname\":\"myMac\"\n  const bindingsFromJson = JSON.parse(chindingsJson)\n  delete bindingsFromJson.pid\n  delete bindingsFromJson.hostname\n  return bindingsFromJson\n}\n\nfunction setBindings (newBindings) {\n  const chindings = asChindings(this, newBindings)\n  this[chindingsSym] = chindings\n  delete this[parsedChindingsSym]\n}\n\n/**\n * Default strategy for creating `mergeObject` from arguments and the result from `mixin()`.\n * Fields from `mergeObject` have higher priority in this strategy.\n *\n * @param {Object} mergeObject The object a user has supplied to the logging function.\n * @param {Object} mixinObject The result of the `mixin` method.\n * @return {Object}\n */\nfunction defaultMixinMergeStrategy (mergeObject, mixinObject) {\n  return Object.assign(mixinObject, mergeObject)\n}\n\nfunction write (_obj, msg, num) {\n  const t = this[timeSym]()\n  const mixin = this[mixinSym]\n  const errorKey = this[errorKeySym]\n  const messageKey = this[messageKeySym]\n  const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy\n  let obj\n  const streamWriteHook = this[hooksSym].streamWrite\n\n  if (_obj === undefined || _obj === null) {\n    obj = {}\n  } else if (_obj instanceof Error) {\n    obj = { [errorKey]: _obj }\n    if (msg === undefined) {\n      msg = _obj.message\n    }\n  } else {\n    obj = _obj\n    if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {\n      msg = _obj[errorKey].message\n    }\n  }\n\n  if (mixin) {\n    obj = mixinMergeStrategy(obj, mixin(obj, num, this))\n  }\n\n  const s = this[asJsonSym](obj, msg, num, t)\n\n  const stream = this[streamSym]\n  if (stream[needsMetadataGsym] === true) {\n    stream.lastLevel = num\n    stream.lastObj = obj\n    stream.lastMsg = msg\n    stream.lastTime = t.slice(this[timeSliceIndexSym])\n    stream.lastLogger = this // for child loggers\n  }\n  stream.write(streamWriteHook ? streamWriteHook(s) : s)\n}\n\nfunction noop () {}\n\nfunction flush (cb) {\n  if (cb != null && typeof cb !== 'function') {\n    throw Error('callback must be a function')\n  }\n\n  const stream = this[streamSym]\n\n  if (typeof stream.flush === 'function') {\n    stream.flush(cb || noop)\n  } else if (cb) cb()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvcHJvdG8uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUEsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkRBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHlEQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx1REFBUztBQUNyQjtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscURBQVE7QUFDcEIsa0JBQWtCLG1CQUFPLENBQUMsK0RBQWE7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDLG9CQUFvQix3QkFBd0I7QUFDNUMsb0JBQW9CLDBCQUEwQjtBQUM5QyxxQkFBcUIsc0NBQXNDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixFQUFFLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9waW5vL2xpYi9wcm90by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyogZXNsaW50IG5vLXByb3RvdHlwZS1idWlsdGluczogMCAqL1xuXG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuY29uc3Qge1xuICBsc0NhY2hlU3ltLFxuICBsZXZlbFZhbFN5bSxcbiAgc2V0TGV2ZWxTeW0sXG4gIGdldExldmVsU3ltLFxuICBjaGluZGluZ3NTeW0sXG4gIHBhcnNlZENoaW5kaW5nc1N5bSxcbiAgbWl4aW5TeW0sXG4gIGFzSnNvblN5bSxcbiAgd3JpdGVTeW0sXG4gIG1peGluTWVyZ2VTdHJhdGVneVN5bSxcbiAgdGltZVN5bSxcbiAgdGltZVNsaWNlSW5kZXhTeW0sXG4gIHN0cmVhbVN5bSxcbiAgc2VyaWFsaXplcnNTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBtZXNzYWdlS2V5U3ltLFxuICB1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltLFxuICBuZWVkc01ldGFkYXRhR3N5bSxcbiAgcmVkYWN0Rm10U3ltLFxuICBzdHJpbmdpZnlTeW0sXG4gIGZvcm1hdE9wdHNTeW0sXG4gIHN0cmluZ2lmaWVyc1N5bSxcbiAgbXNnUHJlZml4U3ltLFxuICBob29rc1N5bVxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7XG4gIGdldExldmVsLFxuICBzZXRMZXZlbCxcbiAgaXNMZXZlbEVuYWJsZWQsXG4gIG1hcHBpbmdzLFxuICBpbml0aWFsTHNDYWNoZSxcbiAgZ2VuTHNDYWNoZSxcbiAgYXNzZXJ0Tm9MZXZlbENvbGxpc2lvbnNcbn0gPSByZXF1aXJlKCcuL2xldmVscycpXG5jb25zdCB7XG4gIGFzQ2hpbmRpbmdzLFxuICBhc0pzb24sXG4gIGJ1aWxkRm9ybWF0dGVycyxcbiAgc3RyaW5naWZ5XG59ID0gcmVxdWlyZSgnLi90b29scycpXG5jb25zdCB7XG4gIHZlcnNpb25cbn0gPSByZXF1aXJlKCcuL21ldGEnKVxuY29uc3QgcmVkYWN0aW9uID0gcmVxdWlyZSgnLi9yZWRhY3Rpb24nKVxuXG4vLyBub3RlOiB1c2Ugb2YgY2xhc3MgaXMgc2F0aXJpY2FsXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGlub2pzL3Bpbm8vcHVsbC80MzMjcHVsbHJlcXVlc3RyZXZpZXctMTI3NzAzMTI3XG5jb25zdCBjb25zdHJ1Y3RvciA9IGNsYXNzIFBpbm8ge31cbmNvbnN0IHByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3IsXG4gIGNoaWxkLFxuICBiaW5kaW5ncyxcbiAgc2V0QmluZGluZ3MsXG4gIGZsdXNoLFxuICBpc0xldmVsRW5hYmxlZCxcbiAgdmVyc2lvbixcbiAgZ2V0IGxldmVsICgpIHsgcmV0dXJuIHRoaXNbZ2V0TGV2ZWxTeW1dKCkgfSxcbiAgc2V0IGxldmVsIChsdmwpIHsgdGhpc1tzZXRMZXZlbFN5bV0obHZsKSB9LFxuICBnZXQgbGV2ZWxWYWwgKCkgeyByZXR1cm4gdGhpc1tsZXZlbFZhbFN5bV0gfSxcbiAgc2V0IGxldmVsVmFsIChuKSB7IHRocm93IEVycm9yKCdsZXZlbFZhbCBpcyByZWFkLW9ubHknKSB9LFxuICBbbHNDYWNoZVN5bV06IGluaXRpYWxMc0NhY2hlLFxuICBbd3JpdGVTeW1dOiB3cml0ZSxcbiAgW2FzSnNvblN5bV06IGFzSnNvbixcbiAgW2dldExldmVsU3ltXTogZ2V0TGV2ZWwsXG4gIFtzZXRMZXZlbFN5bV06IHNldExldmVsXG59XG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90b3R5cGUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpXG5cbi8vIGV4cG9ydGluZyBhbmQgY29uc3VtaW5nIHRoZSBwcm90b3R5cGUgb2JqZWN0IHVzaW5nIGZhY3RvcnkgcGF0dGVybiBmaXhlcyBzY29waW5nIGlzc3VlcyB3aXRoIGdldHRlcnMgd2hlbiBzZXJpYWxpemluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSlcbn1cblxuY29uc3QgcmVzZXRDaGlsZGluZ3NGb3JtYXR0ZXIgPSBiaW5kaW5ncyA9PiBiaW5kaW5nc1xuZnVuY3Rpb24gY2hpbGQgKGJpbmRpbmdzLCBvcHRpb25zKSB7XG4gIGlmICghYmluZGluZ3MpIHtcbiAgICB0aHJvdyBFcnJvcignbWlzc2luZyBiaW5kaW5ncyBmb3IgY2hpbGQgUGlubycpXG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge30gLy8gZGVmYXVsdCBvcHRpb25zIHRvIGVtcHR5IG9iamVjdFxuICBjb25zdCBzZXJpYWxpemVycyA9IHRoaXNbc2VyaWFsaXplcnNTeW1dXG4gIGNvbnN0IGZvcm1hdHRlcnMgPSB0aGlzW2Zvcm1hdHRlcnNTeW1dXG4gIGNvbnN0IGluc3RhbmNlID0gT2JqZWN0LmNyZWF0ZSh0aGlzKVxuXG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdzZXJpYWxpemVycycpID09PSB0cnVlKSB7XG4gICAgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgZm9yIChjb25zdCBrIGluIHNlcmlhbGl6ZXJzKSB7XG4gICAgICBpbnN0YW5jZVtzZXJpYWxpemVyc1N5bV1ba10gPSBzZXJpYWxpemVyc1trXVxuICAgIH1cbiAgICBjb25zdCBwYXJlbnRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzZXJpYWxpemVycylcbiAgICAvKiBlc2xpbnQgbm8tdmFyOiBvZmYgKi9cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtzID0gcGFyZW50U3ltYm9sc1tpXVxuICAgICAgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dW2tzXSA9IHNlcmlhbGl6ZXJzW2tzXVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgYmsgaW4gb3B0aW9ucy5zZXJpYWxpemVycykge1xuICAgICAgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dW2JrXSA9IG9wdGlvbnMuc2VyaWFsaXplcnNbYmtdXG4gICAgfVxuICAgIGNvbnN0IGJpbmRpbmdzU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob3B0aW9ucy5zZXJpYWxpemVycylcbiAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYmluZGluZ3NTeW1ib2xzLmxlbmd0aDsgYmkrKykge1xuICAgICAgY29uc3QgYmtzID0gYmluZGluZ3NTeW1ib2xzW2JpXVxuICAgICAgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dW2Jrc10gPSBvcHRpb25zLnNlcmlhbGl6ZXJzW2Jrc11cbiAgICB9XG4gIH0gZWxzZSBpbnN0YW5jZVtzZXJpYWxpemVyc1N5bV0gPSBzZXJpYWxpemVyc1xuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZm9ybWF0dGVycycpKSB7XG4gICAgY29uc3QgeyBsZXZlbCwgYmluZGluZ3M6IGNoaW5kaW5ncywgbG9nIH0gPSBvcHRpb25zLmZvcm1hdHRlcnNcbiAgICBpbnN0YW5jZVtmb3JtYXR0ZXJzU3ltXSA9IGJ1aWxkRm9ybWF0dGVycyhcbiAgICAgIGxldmVsIHx8IGZvcm1hdHRlcnMubGV2ZWwsXG4gICAgICBjaGluZGluZ3MgfHwgcmVzZXRDaGlsZGluZ3NGb3JtYXR0ZXIsXG4gICAgICBsb2cgfHwgZm9ybWF0dGVycy5sb2dcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2VbZm9ybWF0dGVyc1N5bV0gPSBidWlsZEZvcm1hdHRlcnMoXG4gICAgICBmb3JtYXR0ZXJzLmxldmVsLFxuICAgICAgcmVzZXRDaGlsZGluZ3NGb3JtYXR0ZXIsXG4gICAgICBmb3JtYXR0ZXJzLmxvZ1xuICAgIClcbiAgfVxuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnY3VzdG9tTGV2ZWxzJykgPT09IHRydWUpIHtcbiAgICBhc3NlcnROb0xldmVsQ29sbGlzaW9ucyh0aGlzLmxldmVscywgb3B0aW9ucy5jdXN0b21MZXZlbHMpXG4gICAgaW5zdGFuY2UubGV2ZWxzID0gbWFwcGluZ3Mob3B0aW9ucy5jdXN0b21MZXZlbHMsIGluc3RhbmNlW3VzZU9ubHlDdXN0b21MZXZlbHNTeW1dKVxuICAgIGdlbkxzQ2FjaGUoaW5zdGFuY2UpXG4gIH1cblxuICAvLyByZWRhY3QgbXVzdCBwbGFjZSBiZWZvcmUgYXNDaGluZGluZ3MgYW5kIG9ubHkgcmVwbGFjZSBpZiBleGlzdFxuICBpZiAoKHR5cGVvZiBvcHRpb25zLnJlZGFjdCA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucy5yZWRhY3QgIT09IG51bGwpIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZWRhY3QpKSB7XG4gICAgaW5zdGFuY2UucmVkYWN0ID0gb3B0aW9ucy5yZWRhY3QgLy8gcmVwbGFjZSByZWRhY3QgZGlyZWN0bHlcbiAgICBjb25zdCBzdHJpbmdpZmllcnMgPSByZWRhY3Rpb24oaW5zdGFuY2UucmVkYWN0LCBzdHJpbmdpZnkpXG4gICAgY29uc3QgZm9ybWF0T3B0cyA9IHsgc3RyaW5naWZ5OiBzdHJpbmdpZmllcnNbcmVkYWN0Rm10U3ltXSB9XG4gICAgaW5zdGFuY2Vbc3RyaW5naWZ5U3ltXSA9IHN0cmluZ2lmeVxuICAgIGluc3RhbmNlW3N0cmluZ2lmaWVyc1N5bV0gPSBzdHJpbmdpZmllcnNcbiAgICBpbnN0YW5jZVtmb3JtYXRPcHRzU3ltXSA9IGZvcm1hdE9wdHNcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5tc2dQcmVmaXggPT09ICdzdHJpbmcnKSB7XG4gICAgaW5zdGFuY2VbbXNnUHJlZml4U3ltXSA9ICh0aGlzW21zZ1ByZWZpeFN5bV0gfHwgJycpICsgb3B0aW9ucy5tc2dQcmVmaXhcbiAgfVxuXG4gIGluc3RhbmNlW2NoaW5kaW5nc1N5bV0gPSBhc0NoaW5kaW5ncyhpbnN0YW5jZSwgYmluZGluZ3MpXG4gIGNvbnN0IGNoaWxkTGV2ZWwgPSBvcHRpb25zLmxldmVsIHx8IHRoaXMubGV2ZWxcbiAgaW5zdGFuY2Vbc2V0TGV2ZWxTeW1dKGNoaWxkTGV2ZWwpXG4gIHRoaXMub25DaGlsZChpbnN0YW5jZSlcbiAgcmV0dXJuIGluc3RhbmNlXG59XG5cbmZ1bmN0aW9uIGJpbmRpbmdzICgpIHtcbiAgY29uc3QgY2hpbmRpbmdzID0gdGhpc1tjaGluZGluZ3NTeW1dXG4gIGNvbnN0IGNoaW5kaW5nc0pzb24gPSBgeyR7Y2hpbmRpbmdzLnN1YnN0cigxKX19YCAvLyBhdCBsZWFzdCBjb250YWlucyAsXCJwaWRcIjo3MDY4LFwiaG9zdG5hbWVcIjpcIm15TWFjXCJcbiAgY29uc3QgYmluZGluZ3NGcm9tSnNvbiA9IEpTT04ucGFyc2UoY2hpbmRpbmdzSnNvbilcbiAgZGVsZXRlIGJpbmRpbmdzRnJvbUpzb24ucGlkXG4gIGRlbGV0ZSBiaW5kaW5nc0Zyb21Kc29uLmhvc3RuYW1lXG4gIHJldHVybiBiaW5kaW5nc0Zyb21Kc29uXG59XG5cbmZ1bmN0aW9uIHNldEJpbmRpbmdzIChuZXdCaW5kaW5ncykge1xuICBjb25zdCBjaGluZGluZ3MgPSBhc0NoaW5kaW5ncyh0aGlzLCBuZXdCaW5kaW5ncylcbiAgdGhpc1tjaGluZGluZ3NTeW1dID0gY2hpbmRpbmdzXG4gIGRlbGV0ZSB0aGlzW3BhcnNlZENoaW5kaW5nc1N5bV1cbn1cblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5IGZvciBjcmVhdGluZyBgbWVyZ2VPYmplY3RgIGZyb20gYXJndW1lbnRzIGFuZCB0aGUgcmVzdWx0IGZyb20gYG1peGluKClgLlxuICogRmllbGRzIGZyb20gYG1lcmdlT2JqZWN0YCBoYXZlIGhpZ2hlciBwcmlvcml0eSBpbiB0aGlzIHN0cmF0ZWd5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZXJnZU9iamVjdCBUaGUgb2JqZWN0IGEgdXNlciBoYXMgc3VwcGxpZWQgdG8gdGhlIGxvZ2dpbmcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gbWl4aW5PYmplY3QgVGhlIHJlc3VsdCBvZiB0aGUgYG1peGluYCBtZXRob2QuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRNaXhpbk1lcmdlU3RyYXRlZ3kgKG1lcmdlT2JqZWN0LCBtaXhpbk9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihtaXhpbk9iamVjdCwgbWVyZ2VPYmplY3QpXG59XG5cbmZ1bmN0aW9uIHdyaXRlIChfb2JqLCBtc2csIG51bSkge1xuICBjb25zdCB0ID0gdGhpc1t0aW1lU3ltXSgpXG4gIGNvbnN0IG1peGluID0gdGhpc1ttaXhpblN5bV1cbiAgY29uc3QgZXJyb3JLZXkgPSB0aGlzW2Vycm9yS2V5U3ltXVxuICBjb25zdCBtZXNzYWdlS2V5ID0gdGhpc1ttZXNzYWdlS2V5U3ltXVxuICBjb25zdCBtaXhpbk1lcmdlU3RyYXRlZ3kgPSB0aGlzW21peGluTWVyZ2VTdHJhdGVneVN5bV0gfHwgZGVmYXVsdE1peGluTWVyZ2VTdHJhdGVneVxuICBsZXQgb2JqXG4gIGNvbnN0IHN0cmVhbVdyaXRlSG9vayA9IHRoaXNbaG9va3NTeW1dLnN0cmVhbVdyaXRlXG5cbiAgaWYgKF9vYmogPT09IHVuZGVmaW5lZCB8fCBfb2JqID09PSBudWxsKSB7XG4gICAgb2JqID0ge31cbiAgfSBlbHNlIGlmIChfb2JqIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBvYmogPSB7IFtlcnJvcktleV06IF9vYmogfVxuICAgIGlmIChtc2cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbXNnID0gX29iai5tZXNzYWdlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9iaiA9IF9vYmpcbiAgICBpZiAobXNnID09PSB1bmRlZmluZWQgJiYgX29ialttZXNzYWdlS2V5XSA9PT0gdW5kZWZpbmVkICYmIF9vYmpbZXJyb3JLZXldKSB7XG4gICAgICBtc2cgPSBfb2JqW2Vycm9yS2V5XS5tZXNzYWdlXG4gICAgfVxuICB9XG5cbiAgaWYgKG1peGluKSB7XG4gICAgb2JqID0gbWl4aW5NZXJnZVN0cmF0ZWd5KG9iaiwgbWl4aW4ob2JqLCBudW0sIHRoaXMpKVxuICB9XG5cbiAgY29uc3QgcyA9IHRoaXNbYXNKc29uU3ltXShvYmosIG1zZywgbnVtLCB0KVxuXG4gIGNvbnN0IHN0cmVhbSA9IHRoaXNbc3RyZWFtU3ltXVxuICBpZiAoc3RyZWFtW25lZWRzTWV0YWRhdGFHc3ltXSA9PT0gdHJ1ZSkge1xuICAgIHN0cmVhbS5sYXN0TGV2ZWwgPSBudW1cbiAgICBzdHJlYW0ubGFzdE9iaiA9IG9ialxuICAgIHN0cmVhbS5sYXN0TXNnID0gbXNnXG4gICAgc3RyZWFtLmxhc3RUaW1lID0gdC5zbGljZSh0aGlzW3RpbWVTbGljZUluZGV4U3ltXSlcbiAgICBzdHJlYW0ubGFzdExvZ2dlciA9IHRoaXMgLy8gZm9yIGNoaWxkIGxvZ2dlcnNcbiAgfVxuICBzdHJlYW0ud3JpdGUoc3RyZWFtV3JpdGVIb29rID8gc3RyZWFtV3JpdGVIb29rKHMpIDogcylcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBmbHVzaCAoY2IpIHtcbiAgaWYgKGNiICE9IG51bGwgJiYgdHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gIH1cblxuICBjb25zdCBzdHJlYW0gPSB0aGlzW3N0cmVhbVN5bV1cblxuICBpZiAodHlwZW9mIHN0cmVhbS5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0cmVhbS5mbHVzaChjYiB8fCBub29wKVxuICB9IGVsc2UgaWYgKGNiKSBjYigpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/proto.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/redaction.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/redaction.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fastRedact = __webpack_require__(/*! fast-redact */ \"(ssr)/./node_modules/fast-redact/index.js\")\nconst { redactFmtSym, wildcardFirstSym } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\")\nconst { rx, validator } = fastRedact\n\nconst validate = validator({\n  ERR_PATHS_MUST_BE_STRINGS: () => 'pino – redacted paths must be strings',\n  ERR_INVALID_PATH: (s) => `pino – redact paths array contains an invalid path (${s})`\n})\n\nconst CENSOR = '[Redacted]'\nconst strict = false // TODO should this be configurable?\n\nfunction redaction (opts, serialize) {\n  const { paths, censor } = handle(opts)\n\n  const shape = paths.reduce((o, str) => {\n    rx.lastIndex = 0\n    const first = rx.exec(str)\n    const next = rx.exec(str)\n\n    // ns is the top-level path segment, brackets + quoting removed.\n    let ns = first[1] !== undefined\n      ? first[1].replace(/^(?:\"|'|`)(.*)(?:\"|'|`)$/, '$1')\n      : first[0]\n\n    if (ns === '*') {\n      ns = wildcardFirstSym\n    }\n\n    // top level key:\n    if (next === null) {\n      o[ns] = null\n      return o\n    }\n\n    // path with at least two segments:\n    // if ns is already redacted at the top level, ignore lower level redactions\n    if (o[ns] === null) {\n      return o\n    }\n\n    const { index } = next\n    const nextPath = `${str.substr(index, str.length - 1)}`\n\n    o[ns] = o[ns] || []\n\n    // shape is a mix of paths beginning with literal values and wildcard\n    // paths [ \"a.b.c\", \"*.b.z\" ] should reduce to a shape of\n    // { \"a\": [ \"b.c\", \"b.z\" ], *: [ \"b.z\" ] }\n    // note: \"b.z\" is in both \"a\" and * arrays because \"a\" matches the wildcard.\n    // (* entry has wildcardFirstSym as key)\n    if (ns !== wildcardFirstSym && o[ns].length === 0) {\n      // first time ns's get all '*' redactions so far\n      o[ns].push(...(o[wildcardFirstSym] || []))\n    }\n\n    if (ns === wildcardFirstSym) {\n      // new * path gets added to all previously registered literal ns's.\n      Object.keys(o).forEach(function (k) {\n        if (o[k]) {\n          o[k].push(nextPath)\n        }\n      })\n    }\n\n    o[ns].push(nextPath)\n    return o\n  }, {})\n\n  // the redactor assigned to the format symbol key\n  // provides top level redaction for instances where\n  // an object is interpolated into the msg string\n  const result = {\n    [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })\n  }\n\n  const topCensor = (...args) => {\n    return typeof censor === 'function' ? serialize(censor(...args)) : serialize(censor)\n  }\n\n  return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {\n    // top level key:\n    if (shape[k] === null) {\n      o[k] = (value) => topCensor(value, [k])\n    } else {\n      const wrappedCensor = typeof censor === 'function'\n        ? (value, path) => {\n            return censor(value, [k, ...path])\n          }\n        : censor\n      o[k] = fastRedact({\n        paths: shape[k],\n        censor: wrappedCensor,\n        serialize,\n        strict\n      })\n    }\n    return o\n  }, result)\n}\n\nfunction handle (opts) {\n  if (Array.isArray(opts)) {\n    opts = { paths: opts, censor: CENSOR }\n    validate(opts)\n    return opts\n  }\n  let { paths, censor = CENSOR, remove } = opts\n  if (Array.isArray(paths) === false) { throw Error('pino – redact must contain an array of strings') }\n  if (remove === true) censor = undefined\n  validate({ paths, censor })\n\n  return { paths, censor }\n}\n\nmodule.exports = redaction\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvcmVkYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLG1CQUFtQixtQkFBTyxDQUFDLDhEQUFhO0FBQ3hDLFFBQVEsaUNBQWlDLEVBQUUsbUJBQU8sQ0FBQywyREFBVztBQUM5RCxRQUFRLGdCQUFnQjs7QUFFeEI7QUFDQTtBQUNBLGtGQUFrRixFQUFFO0FBQ3BGLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLFVBQVUsZ0JBQWdCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksUUFBUTtBQUNwQix3QkFBd0Isa0NBQWtDOztBQUUxRDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEdBQUcsSUFBSTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQ0FBa0M7QUFDbkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6Qyx3Q0FBd0M7QUFDeEM7QUFDQSxhQUFhLGVBQWU7O0FBRTVCLFdBQVc7QUFDWDs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phc2h3YW50aHBlZGRpc2V0dHkvRG9jdW1lbnRzL2V0aGdsb2JhbC9jb250ZXh0by9ub2RlX21vZHVsZXMvcGluby9saWIvcmVkYWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmYXN0UmVkYWN0ID0gcmVxdWlyZSgnZmFzdC1yZWRhY3QnKVxuY29uc3QgeyByZWRhY3RGbXRTeW0sIHdpbGRjYXJkRmlyc3RTeW0gfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHJ4LCB2YWxpZGF0b3IgfSA9IGZhc3RSZWRhY3RcblxuY29uc3QgdmFsaWRhdGUgPSB2YWxpZGF0b3Ioe1xuICBFUlJfUEFUSFNfTVVTVF9CRV9TVFJJTkdTOiAoKSA9PiAncGlubyDigJMgcmVkYWN0ZWQgcGF0aHMgbXVzdCBiZSBzdHJpbmdzJyxcbiAgRVJSX0lOVkFMSURfUEFUSDogKHMpID0+IGBwaW5vIOKAkyByZWRhY3QgcGF0aHMgYXJyYXkgY29udGFpbnMgYW4gaW52YWxpZCBwYXRoICgke3N9KWBcbn0pXG5cbmNvbnN0IENFTlNPUiA9ICdbUmVkYWN0ZWRdJ1xuY29uc3Qgc3RyaWN0ID0gZmFsc2UgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBjb25maWd1cmFibGU/XG5cbmZ1bmN0aW9uIHJlZGFjdGlvbiAob3B0cywgc2VyaWFsaXplKSB7XG4gIGNvbnN0IHsgcGF0aHMsIGNlbnNvciB9ID0gaGFuZGxlKG9wdHMpXG5cbiAgY29uc3Qgc2hhcGUgPSBwYXRocy5yZWR1Y2UoKG8sIHN0cikgPT4ge1xuICAgIHJ4Lmxhc3RJbmRleCA9IDBcbiAgICBjb25zdCBmaXJzdCA9IHJ4LmV4ZWMoc3RyKVxuICAgIGNvbnN0IG5leHQgPSByeC5leGVjKHN0cilcblxuICAgIC8vIG5zIGlzIHRoZSB0b3AtbGV2ZWwgcGF0aCBzZWdtZW50LCBicmFja2V0cyArIHF1b3RpbmcgcmVtb3ZlZC5cbiAgICBsZXQgbnMgPSBmaXJzdFsxXSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZpcnN0WzFdLnJlcGxhY2UoL14oPzpcInwnfGApKC4qKSg/OlwifCd8YCkkLywgJyQxJylcbiAgICAgIDogZmlyc3RbMF1cblxuICAgIGlmIChucyA9PT0gJyonKSB7XG4gICAgICBucyA9IHdpbGRjYXJkRmlyc3RTeW1cbiAgICB9XG5cbiAgICAvLyB0b3AgbGV2ZWwga2V5OlxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICBvW25zXSA9IG51bGxcbiAgICAgIHJldHVybiBvXG4gICAgfVxuXG4gICAgLy8gcGF0aCB3aXRoIGF0IGxlYXN0IHR3byBzZWdtZW50czpcbiAgICAvLyBpZiBucyBpcyBhbHJlYWR5IHJlZGFjdGVkIGF0IHRoZSB0b3AgbGV2ZWwsIGlnbm9yZSBsb3dlciBsZXZlbCByZWRhY3Rpb25zXG4gICAgaWYgKG9bbnNdID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gb1xuICAgIH1cblxuICAgIGNvbnN0IHsgaW5kZXggfSA9IG5leHRcbiAgICBjb25zdCBuZXh0UGF0aCA9IGAke3N0ci5zdWJzdHIoaW5kZXgsIHN0ci5sZW5ndGggLSAxKX1gXG5cbiAgICBvW25zXSA9IG9bbnNdIHx8IFtdXG5cbiAgICAvLyBzaGFwZSBpcyBhIG1peCBvZiBwYXRocyBiZWdpbm5pbmcgd2l0aCBsaXRlcmFsIHZhbHVlcyBhbmQgd2lsZGNhcmRcbiAgICAvLyBwYXRocyBbIFwiYS5iLmNcIiwgXCIqLmIuelwiIF0gc2hvdWxkIHJlZHVjZSB0byBhIHNoYXBlIG9mXG4gICAgLy8geyBcImFcIjogWyBcImIuY1wiLCBcImIuelwiIF0sICo6IFsgXCJiLnpcIiBdIH1cbiAgICAvLyBub3RlOiBcImIuelwiIGlzIGluIGJvdGggXCJhXCIgYW5kICogYXJyYXlzIGJlY2F1c2UgXCJhXCIgbWF0Y2hlcyB0aGUgd2lsZGNhcmQuXG4gICAgLy8gKCogZW50cnkgaGFzIHdpbGRjYXJkRmlyc3RTeW0gYXMga2V5KVxuICAgIGlmIChucyAhPT0gd2lsZGNhcmRGaXJzdFN5bSAmJiBvW25zXS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGZpcnN0IHRpbWUgbnMncyBnZXQgYWxsICcqJyByZWRhY3Rpb25zIHNvIGZhclxuICAgICAgb1tuc10ucHVzaCguLi4ob1t3aWxkY2FyZEZpcnN0U3ltXSB8fCBbXSkpXG4gICAgfVxuXG4gICAgaWYgKG5zID09PSB3aWxkY2FyZEZpcnN0U3ltKSB7XG4gICAgICAvLyBuZXcgKiBwYXRoIGdldHMgYWRkZWQgdG8gYWxsIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBsaXRlcmFsIG5zJ3MuXG4gICAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChvW2tdKSB7XG4gICAgICAgICAgb1trXS5wdXNoKG5leHRQYXRoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIG9bbnNdLnB1c2gobmV4dFBhdGgpXG4gICAgcmV0dXJuIG9cbiAgfSwge30pXG5cbiAgLy8gdGhlIHJlZGFjdG9yIGFzc2lnbmVkIHRvIHRoZSBmb3JtYXQgc3ltYm9sIGtleVxuICAvLyBwcm92aWRlcyB0b3AgbGV2ZWwgcmVkYWN0aW9uIGZvciBpbnN0YW5jZXMgd2hlcmVcbiAgLy8gYW4gb2JqZWN0IGlzIGludGVycG9sYXRlZCBpbnRvIHRoZSBtc2cgc3RyaW5nXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBbcmVkYWN0Rm10U3ltXTogZmFzdFJlZGFjdCh7IHBhdGhzLCBjZW5zb3IsIHNlcmlhbGl6ZSwgc3RyaWN0IH0pXG4gIH1cblxuICBjb25zdCB0b3BDZW5zb3IgPSAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nID8gc2VyaWFsaXplKGNlbnNvciguLi5hcmdzKSkgOiBzZXJpYWxpemUoY2Vuc29yKVxuICB9XG5cbiAgcmV0dXJuIFsuLi5PYmplY3Qua2V5cyhzaGFwZSksIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc2hhcGUpXS5yZWR1Y2UoKG8sIGspID0+IHtcbiAgICAvLyB0b3AgbGV2ZWwga2V5OlxuICAgIGlmIChzaGFwZVtrXSA9PT0gbnVsbCkge1xuICAgICAgb1trXSA9ICh2YWx1ZSkgPT4gdG9wQ2Vuc29yKHZhbHVlLCBba10pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyYXBwZWRDZW5zb3IgPSB0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gKHZhbHVlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2Vuc29yKHZhbHVlLCBbaywgLi4ucGF0aF0pXG4gICAgICAgICAgfVxuICAgICAgICA6IGNlbnNvclxuICAgICAgb1trXSA9IGZhc3RSZWRhY3Qoe1xuICAgICAgICBwYXRoczogc2hhcGVba10sXG4gICAgICAgIGNlbnNvcjogd3JhcHBlZENlbnNvcixcbiAgICAgICAgc2VyaWFsaXplLFxuICAgICAgICBzdHJpY3RcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBvXG4gIH0sIHJlc3VsdClcbn1cblxuZnVuY3Rpb24gaGFuZGxlIChvcHRzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgb3B0cyA9IHsgcGF0aHM6IG9wdHMsIGNlbnNvcjogQ0VOU09SIH1cbiAgICB2YWxpZGF0ZShvcHRzKVxuICAgIHJldHVybiBvcHRzXG4gIH1cbiAgbGV0IHsgcGF0aHMsIGNlbnNvciA9IENFTlNPUiwgcmVtb3ZlIH0gPSBvcHRzXG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGhzKSA9PT0gZmFsc2UpIHsgdGhyb3cgRXJyb3IoJ3Bpbm8g4oCTIHJlZGFjdCBtdXN0IGNvbnRhaW4gYW4gYXJyYXkgb2Ygc3RyaW5ncycpIH1cbiAgaWYgKHJlbW92ZSA9PT0gdHJ1ZSkgY2Vuc29yID0gdW5kZWZpbmVkXG4gIHZhbGlkYXRlKHsgcGF0aHMsIGNlbnNvciB9KVxuXG4gIHJldHVybiB7IHBhdGhzLCBjZW5zb3IgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZGFjdGlvblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/redaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/symbols.js":
/*!******************************************!*\
  !*** ./node_modules/pino/lib/symbols.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst setLevelSym = Symbol('pino.setLevel')\nconst getLevelSym = Symbol('pino.getLevel')\nconst levelValSym = Symbol('pino.levelVal')\nconst levelCompSym = Symbol('pino.levelComp')\nconst useLevelLabelsSym = Symbol('pino.useLevelLabels')\nconst useOnlyCustomLevelsSym = Symbol('pino.useOnlyCustomLevels')\nconst mixinSym = Symbol('pino.mixin')\n\nconst lsCacheSym = Symbol('pino.lsCache')\nconst chindingsSym = Symbol('pino.chindings')\n\nconst asJsonSym = Symbol('pino.asJson')\nconst writeSym = Symbol('pino.write')\nconst redactFmtSym = Symbol('pino.redactFmt')\n\nconst timeSym = Symbol('pino.time')\nconst timeSliceIndexSym = Symbol('pino.timeSliceIndex')\nconst streamSym = Symbol('pino.stream')\nconst stringifySym = Symbol('pino.stringify')\nconst stringifySafeSym = Symbol('pino.stringifySafe')\nconst stringifiersSym = Symbol('pino.stringifiers')\nconst endSym = Symbol('pino.end')\nconst formatOptsSym = Symbol('pino.formatOpts')\nconst messageKeySym = Symbol('pino.messageKey')\nconst errorKeySym = Symbol('pino.errorKey')\nconst nestedKeySym = Symbol('pino.nestedKey')\nconst nestedKeyStrSym = Symbol('pino.nestedKeyStr')\nconst mixinMergeStrategySym = Symbol('pino.mixinMergeStrategy')\nconst msgPrefixSym = Symbol('pino.msgPrefix')\n\nconst wildcardFirstSym = Symbol('pino.wildcardFirst')\n\n// public symbols, no need to use the same pino\n// version for these\nconst serializersSym = Symbol.for('pino.serializers')\nconst formattersSym = Symbol.for('pino.formatters')\nconst hooksSym = Symbol.for('pino.hooks')\nconst needsMetadataGsym = Symbol.for('pino.metadata')\n\nmodule.exports = {\n  setLevelSym,\n  getLevelSym,\n  levelValSym,\n  levelCompSym,\n  useLevelLabelsSym,\n  mixinSym,\n  lsCacheSym,\n  chindingsSym,\n  asJsonSym,\n  writeSym,\n  serializersSym,\n  redactFmtSym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  stringifySym,\n  stringifySafeSym,\n  stringifiersSym,\n  endSym,\n  formatOptsSym,\n  messageKeySym,\n  errorKeySym,\n  nestedKeySym,\n  wildcardFirstSym,\n  needsMetadataGsym,\n  useOnlyCustomLevelsSym,\n  formattersSym,\n  hooksSym,\n  nestedKeyStrSym,\n  mixinMergeStrategySym,\n  msgPrefixSym\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNod2FudGhwZWRkaXNldHR5L0RvY3VtZW50cy9ldGhnbG9iYWwvY29udGV4dG8vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL3N5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHNldExldmVsU3ltID0gU3ltYm9sKCdwaW5vLnNldExldmVsJylcbmNvbnN0IGdldExldmVsU3ltID0gU3ltYm9sKCdwaW5vLmdldExldmVsJylcbmNvbnN0IGxldmVsVmFsU3ltID0gU3ltYm9sKCdwaW5vLmxldmVsVmFsJylcbmNvbnN0IGxldmVsQ29tcFN5bSA9IFN5bWJvbCgncGluby5sZXZlbENvbXAnKVxuY29uc3QgdXNlTGV2ZWxMYWJlbHNTeW0gPSBTeW1ib2woJ3Bpbm8udXNlTGV2ZWxMYWJlbHMnKVxuY29uc3QgdXNlT25seUN1c3RvbUxldmVsc1N5bSA9IFN5bWJvbCgncGluby51c2VPbmx5Q3VzdG9tTGV2ZWxzJylcbmNvbnN0IG1peGluU3ltID0gU3ltYm9sKCdwaW5vLm1peGluJylcblxuY29uc3QgbHNDYWNoZVN5bSA9IFN5bWJvbCgncGluby5sc0NhY2hlJylcbmNvbnN0IGNoaW5kaW5nc1N5bSA9IFN5bWJvbCgncGluby5jaGluZGluZ3MnKVxuXG5jb25zdCBhc0pzb25TeW0gPSBTeW1ib2woJ3Bpbm8uYXNKc29uJylcbmNvbnN0IHdyaXRlU3ltID0gU3ltYm9sKCdwaW5vLndyaXRlJylcbmNvbnN0IHJlZGFjdEZtdFN5bSA9IFN5bWJvbCgncGluby5yZWRhY3RGbXQnKVxuXG5jb25zdCB0aW1lU3ltID0gU3ltYm9sKCdwaW5vLnRpbWUnKVxuY29uc3QgdGltZVNsaWNlSW5kZXhTeW0gPSBTeW1ib2woJ3Bpbm8udGltZVNsaWNlSW5kZXgnKVxuY29uc3Qgc3RyZWFtU3ltID0gU3ltYm9sKCdwaW5vLnN0cmVhbScpXG5jb25zdCBzdHJpbmdpZnlTeW0gPSBTeW1ib2woJ3Bpbm8uc3RyaW5naWZ5JylcbmNvbnN0IHN0cmluZ2lmeVNhZmVTeW0gPSBTeW1ib2woJ3Bpbm8uc3RyaW5naWZ5U2FmZScpXG5jb25zdCBzdHJpbmdpZmllcnNTeW0gPSBTeW1ib2woJ3Bpbm8uc3RyaW5naWZpZXJzJylcbmNvbnN0IGVuZFN5bSA9IFN5bWJvbCgncGluby5lbmQnKVxuY29uc3QgZm9ybWF0T3B0c1N5bSA9IFN5bWJvbCgncGluby5mb3JtYXRPcHRzJylcbmNvbnN0IG1lc3NhZ2VLZXlTeW0gPSBTeW1ib2woJ3Bpbm8ubWVzc2FnZUtleScpXG5jb25zdCBlcnJvcktleVN5bSA9IFN5bWJvbCgncGluby5lcnJvcktleScpXG5jb25zdCBuZXN0ZWRLZXlTeW0gPSBTeW1ib2woJ3Bpbm8ubmVzdGVkS2V5JylcbmNvbnN0IG5lc3RlZEtleVN0clN5bSA9IFN5bWJvbCgncGluby5uZXN0ZWRLZXlTdHInKVxuY29uc3QgbWl4aW5NZXJnZVN0cmF0ZWd5U3ltID0gU3ltYm9sKCdwaW5vLm1peGluTWVyZ2VTdHJhdGVneScpXG5jb25zdCBtc2dQcmVmaXhTeW0gPSBTeW1ib2woJ3Bpbm8ubXNnUHJlZml4JylcblxuY29uc3Qgd2lsZGNhcmRGaXJzdFN5bSA9IFN5bWJvbCgncGluby53aWxkY2FyZEZpcnN0JylcblxuLy8gcHVibGljIHN5bWJvbHMsIG5vIG5lZWQgdG8gdXNlIHRoZSBzYW1lIHBpbm9cbi8vIHZlcnNpb24gZm9yIHRoZXNlXG5jb25zdCBzZXJpYWxpemVyc1N5bSA9IFN5bWJvbC5mb3IoJ3Bpbm8uc2VyaWFsaXplcnMnKVxuY29uc3QgZm9ybWF0dGVyc1N5bSA9IFN5bWJvbC5mb3IoJ3Bpbm8uZm9ybWF0dGVycycpXG5jb25zdCBob29rc1N5bSA9IFN5bWJvbC5mb3IoJ3Bpbm8uaG9va3MnKVxuY29uc3QgbmVlZHNNZXRhZGF0YUdzeW0gPSBTeW1ib2wuZm9yKCdwaW5vLm1ldGFkYXRhJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldExldmVsU3ltLFxuICBnZXRMZXZlbFN5bSxcbiAgbGV2ZWxWYWxTeW0sXG4gIGxldmVsQ29tcFN5bSxcbiAgdXNlTGV2ZWxMYWJlbHNTeW0sXG4gIG1peGluU3ltLFxuICBsc0NhY2hlU3ltLFxuICBjaGluZGluZ3NTeW0sXG4gIGFzSnNvblN5bSxcbiAgd3JpdGVTeW0sXG4gIHNlcmlhbGl6ZXJzU3ltLFxuICByZWRhY3RGbXRTeW0sXG4gIHRpbWVTeW0sXG4gIHRpbWVTbGljZUluZGV4U3ltLFxuICBzdHJlYW1TeW0sXG4gIHN0cmluZ2lmeVN5bSxcbiAgc3RyaW5naWZ5U2FmZVN5bSxcbiAgc3RyaW5naWZpZXJzU3ltLFxuICBlbmRTeW0sXG4gIGZvcm1hdE9wdHNTeW0sXG4gIG1lc3NhZ2VLZXlTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBuZXN0ZWRLZXlTeW0sXG4gIHdpbGRjYXJkRmlyc3RTeW0sXG4gIG5lZWRzTWV0YWRhdGFHc3ltLFxuICB1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltLFxuICBmb3JtYXR0ZXJzU3ltLFxuICBob29rc1N5bSxcbiAgbmVzdGVkS2V5U3RyU3ltLFxuICBtaXhpbk1lcmdlU3RyYXRlZ3lTeW0sXG4gIG1zZ1ByZWZpeFN5bVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/time.js":
/*!***************************************!*\
  !*** ./node_modules/pino/lib/time.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst nullTime = () => ''\n\nconst epochTime = () => `,\"time\":${Date.now()}`\n\nconst unixTime = () => `,\"time\":${Math.round(Date.now() / 1000.0)}`\n\nconst isoTime = () => `,\"time\":\"${new Date(Date.now()).toISOString()}\"` // using Date.now() for testability\n\nmodule.exports = { nullTime, epochTime, unixTime, isoTime }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQSxtQ0FBbUMsV0FBVzs7QUFFOUMsa0NBQWtDLGdDQUFnQzs7QUFFbEUsa0NBQWtDLG1DQUFtQzs7QUFFckUsbUJBQW1CIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9waW5vL2xpYi90aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBudWxsVGltZSA9ICgpID0+ICcnXG5cbmNvbnN0IGVwb2NoVGltZSA9ICgpID0+IGAsXCJ0aW1lXCI6JHtEYXRlLm5vdygpfWBcblxuY29uc3QgdW5peFRpbWUgPSAoKSA9PiBgLFwidGltZVwiOiR7TWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMC4wKX1gXG5cbmNvbnN0IGlzb1RpbWUgPSAoKSA9PiBgLFwidGltZVwiOlwiJHtuZXcgRGF0ZShEYXRlLm5vdygpKS50b0lTT1N0cmluZygpfVwiYCAvLyB1c2luZyBEYXRlLm5vdygpIGZvciB0ZXN0YWJpbGl0eVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgbnVsbFRpbWUsIGVwb2NoVGltZSwgdW5peFRpbWUsIGlzb1RpbWUgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/time.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/tools.js":
/*!****************************************!*\
  !*** ./node_modules/pino/lib/tools.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint no-prototype-builtins: 0 */\n\nconst format = __webpack_require__(/*! quick-format-unescaped */ \"(ssr)/./node_modules/quick-format-unescaped/index.js\")\nconst { mapHttpRequest, mapHttpResponse } = __webpack_require__(/*! pino-std-serializers */ \"(ssr)/./node_modules/pino-std-serializers/index.js\")\nconst SonicBoom = __webpack_require__(/*! sonic-boom */ \"(ssr)/./node_modules/sonic-boom/index.js\")\nconst onExit = __webpack_require__(/*! on-exit-leak-free */ \"(ssr)/./node_modules/on-exit-leak-free/index.js\")\nconst {\n  lsCacheSym,\n  chindingsSym,\n  writeSym,\n  serializersSym,\n  formatOptsSym,\n  endSym,\n  stringifiersSym,\n  stringifySym,\n  stringifySafeSym,\n  wildcardFirstSym,\n  nestedKeySym,\n  formattersSym,\n  messageKeySym,\n  errorKeySym,\n  nestedKeyStrSym,\n  msgPrefixSym\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\")\nconst { isMainThread } = __webpack_require__(/*! worker_threads */ \"worker_threads\")\nconst transport = __webpack_require__(/*! ./transport */ \"(ssr)/./node_modules/pino/lib/transport.js\")\n\nfunction noop () {\n}\n\nfunction genLog (level, hook) {\n  if (!hook) return LOG\n\n  return function hookWrappedLog (...args) {\n    hook.call(this, args, LOG, level)\n  }\n\n  function LOG (o, ...n) {\n    if (typeof o === 'object') {\n      let msg = o\n      if (o !== null) {\n        if (o.method && o.headers && o.socket) {\n          o = mapHttpRequest(o)\n        } else if (typeof o.setHeader === 'function') {\n          o = mapHttpResponse(o)\n        }\n      }\n      let formatParams\n      if (msg === null && n.length === 0) {\n        formatParams = [null]\n      } else {\n        msg = n.shift()\n        formatParams = n\n      }\n      // We do not use a coercive check for `msg` as it is\n      // measurably slower than the explicit checks.\n      if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {\n        msg = this[msgPrefixSym] + msg\n      }\n      this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level)\n    } else {\n      let msg = o === undefined ? n.shift() : o\n\n      // We do not use a coercive check for `msg` as it is\n      // measurably slower than the explicit checks.\n      if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {\n        msg = this[msgPrefixSym] + msg\n      }\n      this[writeSym](null, format(msg, n, this[formatOptsSym]), level)\n    }\n  }\n}\n\n// magically escape strings for json\n// relying on their charCodeAt\n// everything below 32 needs JSON.stringify()\n// 34 and 92 happens all the time, so we\n// have a fast case for them\nfunction asString (str) {\n  let result = ''\n  let last = 0\n  let found = false\n  let point = 255\n  const l = str.length\n  if (l > 100) {\n    return JSON.stringify(str)\n  }\n  for (var i = 0; i < l && point >= 32; i++) {\n    point = str.charCodeAt(i)\n    if (point === 34 || point === 92) {\n      result += str.slice(last, i) + '\\\\'\n      last = i\n      found = true\n    }\n  }\n  if (!found) {\n    result = str\n  } else {\n    result += str.slice(last)\n  }\n  return point < 32 ? JSON.stringify(str) : '\"' + result + '\"'\n}\n\nfunction asJson (obj, msg, num, time) {\n  const stringify = this[stringifySym]\n  const stringifySafe = this[stringifySafeSym]\n  const stringifiers = this[stringifiersSym]\n  const end = this[endSym]\n  const chindings = this[chindingsSym]\n  const serializers = this[serializersSym]\n  const formatters = this[formattersSym]\n  const messageKey = this[messageKeySym]\n  const errorKey = this[errorKeySym]\n  let data = this[lsCacheSym][num] + time\n\n  // we need the child bindings added to the output first so instance logged\n  // objects can take precedence when JSON.parse-ing the resulting log line\n  data = data + chindings\n\n  let value\n  if (formatters.log) {\n    obj = formatters.log(obj)\n  }\n  const wildcardStringifier = stringifiers[wildcardFirstSym]\n  let propStr = ''\n  for (const key in obj) {\n    value = obj[key]\n    if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {\n      if (serializers[key]) {\n        value = serializers[key](value)\n      } else if (key === errorKey && serializers.err) {\n        value = serializers.err(value)\n      }\n\n      const stringifier = stringifiers[key] || wildcardStringifier\n\n      switch (typeof value) {\n        case 'undefined':\n        case 'function':\n          continue\n        case 'number':\n          /* eslint no-fallthrough: \"off\" */\n          if (Number.isFinite(value) === false) {\n            value = null\n          }\n        // this case explicitly falls through to the next one\n        case 'boolean':\n          if (stringifier) value = stringifier(value)\n          break\n        case 'string':\n          value = (stringifier || asString)(value)\n          break\n        default:\n          value = (stringifier || stringify)(value, stringifySafe)\n      }\n      if (value === undefined) continue\n      const strKey = asString(key)\n      propStr += ',' + strKey + ':' + value\n    }\n  }\n\n  let msgStr = ''\n  if (msg !== undefined) {\n    value = serializers[messageKey] ? serializers[messageKey](msg) : msg\n    const stringifier = stringifiers[messageKey] || wildcardStringifier\n\n    switch (typeof value) {\n      case 'function':\n        break\n      case 'number':\n        /* eslint no-fallthrough: \"off\" */\n        if (Number.isFinite(value) === false) {\n          value = null\n        }\n      // this case explicitly falls through to the next one\n      case 'boolean':\n        if (stringifier) value = stringifier(value)\n        msgStr = ',\"' + messageKey + '\":' + value\n        break\n      case 'string':\n        value = (stringifier || asString)(value)\n        msgStr = ',\"' + messageKey + '\":' + value\n        break\n      default:\n        value = (stringifier || stringify)(value, stringifySafe)\n        msgStr = ',\"' + messageKey + '\":' + value\n    }\n  }\n\n  if (this[nestedKeySym] && propStr) {\n    // place all the obj properties under the specified key\n    // the nested key is already formatted from the constructor\n    return data + this[nestedKeyStrSym] + propStr.slice(1) + '}' + msgStr + end\n  } else {\n    return data + propStr + msgStr + end\n  }\n}\n\nfunction asChindings (instance, bindings) {\n  let value\n  let data = instance[chindingsSym]\n  const stringify = instance[stringifySym]\n  const stringifySafe = instance[stringifySafeSym]\n  const stringifiers = instance[stringifiersSym]\n  const wildcardStringifier = stringifiers[wildcardFirstSym]\n  const serializers = instance[serializersSym]\n  const formatter = instance[formattersSym].bindings\n  bindings = formatter(bindings)\n\n  for (const key in bindings) {\n    value = bindings[key]\n    const valid = key !== 'level' &&\n      key !== 'serializers' &&\n      key !== 'formatters' &&\n      key !== 'customLevels' &&\n      bindings.hasOwnProperty(key) &&\n      value !== undefined\n    if (valid === true) {\n      value = serializers[key] ? serializers[key](value) : value\n      value = (stringifiers[key] || wildcardStringifier || stringify)(value, stringifySafe)\n      if (value === undefined) continue\n      data += ',\"' + key + '\":' + value\n    }\n  }\n  return data\n}\n\nfunction hasBeenTampered (stream) {\n  return stream.write !== stream.constructor.prototype.write\n}\n\nconst hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE\n\nfunction buildSafeSonicBoom (opts) {\n  const stream = new SonicBoom(opts)\n  stream.on('error', filterBrokenPipe)\n  // If we are sync: false, we must flush on exit\n  // We must disable this if there is node code coverage due to\n  // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308.\n  if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {\n    onExit.register(stream, autoEnd)\n\n    stream.on('close', function () {\n      onExit.unregister(stream)\n    })\n  }\n  return stream\n\n  function filterBrokenPipe (err) {\n    // Impossible to replicate across all operating systems\n    /* istanbul ignore next */\n    if (err.code === 'EPIPE') {\n      // If we get EPIPE, we should stop logging here\n      // however we have no control to the consumer of\n      // SonicBoom, so we just overwrite the write method\n      stream.write = noop\n      stream.end = noop\n      stream.flushSync = noop\n      stream.destroy = noop\n      return\n    }\n    stream.removeListener('error', filterBrokenPipe)\n    stream.emit('error', err)\n  }\n}\n\nfunction autoEnd (stream, eventName) {\n  // This check is needed only on some platforms\n  /* istanbul ignore next */\n  if (stream.destroyed) {\n    return\n  }\n\n  if (eventName === 'beforeExit') {\n    // We still have an event loop, let's use it\n    stream.flush()\n    stream.on('drain', function () {\n      stream.end()\n    })\n  } else {\n    // For some reason istanbul is not detecting this, but it's there\n    /* istanbul ignore next */\n    // We do not have an event loop, so flush synchronously\n    stream.flushSync()\n  }\n}\n\nfunction createArgsNormalizer (defaultOptions) {\n  return function normalizeArgs (instance, caller, opts = {}, stream) {\n    // support stream as a string\n    if (typeof opts === 'string') {\n      stream = buildSafeSonicBoom({ dest: opts })\n      opts = {}\n    } else if (typeof stream === 'string') {\n      if (opts && opts.transport) {\n        throw Error('only one of option.transport or stream can be specified')\n      }\n      stream = buildSafeSonicBoom({ dest: stream })\n    } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {\n      stream = opts\n      opts = {}\n    } else if (opts.transport) {\n      if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {\n        throw Error('option.transport do not allow stream, please pass to option directly. e.g. pino(transport)')\n      }\n      if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === 'function') {\n        throw Error('option.transport.targets do not allow custom level formatters')\n      }\n\n      let customLevels\n      if (opts.customLevels) {\n        customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels)\n      }\n      stream = transport({ caller, ...opts.transport, levels: customLevels })\n    }\n    opts = Object.assign({}, defaultOptions, opts)\n    opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers)\n    opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters)\n\n    if (opts.prettyPrint) {\n      throw new Error('prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)')\n    }\n\n    const { enabled, onChild } = opts\n    if (enabled === false) opts.level = 'silent'\n    if (!onChild) opts.onChild = noop\n    if (!stream) {\n      if (!hasBeenTampered(process.stdout)) {\n        // If process.stdout.fd is undefined, it means that we are running\n        // in a worker thread. Let's assume we are logging to file descriptor 1.\n        stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 })\n      } else {\n        stream = process.stdout\n      }\n    }\n    return { opts, stream }\n  }\n}\n\nfunction stringify (obj, stringifySafeFn) {\n  try {\n    return JSON.stringify(obj)\n  } catch (_) {\n    try {\n      const stringify = stringifySafeFn || this[stringifySafeSym]\n      return stringify(obj)\n    } catch (_) {\n      return '\"[unable to serialize, circular reference is too complex to analyze]\"'\n    }\n  }\n}\n\nfunction buildFormatters (level, bindings, log) {\n  return {\n    level,\n    bindings,\n    log\n  }\n}\n\n/**\n * Convert a string integer file descriptor to a proper native integer\n * file descriptor.\n *\n * @param {string} destination The file descriptor string to attempt to convert.\n *\n * @returns {Number}\n */\nfunction normalizeDestFileDescriptor (destination) {\n  const fd = Number(destination)\n  if (typeof destination === 'string' && Number.isFinite(fd)) {\n    return fd\n  }\n  // destination could be undefined if we are in a worker\n  if (destination === undefined) {\n    // This is stdout in UNIX systems\n    return 1\n  }\n  return destination\n}\n\nmodule.exports = {\n  noop,\n  buildSafeSonicBoom,\n  asChindings,\n  asJson,\n  genLog,\n  createArgsNormalizer,\n  stringify,\n  buildFormatters,\n  normalizeDestFileDescriptor\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdG9vbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLG9GQUF3QjtBQUMvQyxRQUFRLGtDQUFrQyxFQUFFLG1CQUFPLENBQUMsZ0ZBQXNCO0FBQzFFLGtCQUFrQixtQkFBTyxDQUFDLDREQUFZO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQywwRUFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJEQUFXO0FBQ3ZCLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsc0NBQWdCO0FBQ2pELGtCQUFrQixtQkFBTyxDQUFDLCtEQUFhOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xELE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0EsMkJBQTJCLGlEQUFpRDtBQUM1RTtBQUNBLDJCQUEyQjtBQUMzQix1Q0FBdUM7QUFDdkMsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUEsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDRCQUE0QjtBQUNsRSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvamFzaHdhbnRocGVkZGlzZXR0eS9Eb2N1bWVudHMvZXRoZ2xvYmFsL2NvbnRleHRvL25vZGVfbW9kdWxlcy9waW5vL2xpYi90b29scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyogZXNsaW50IG5vLXByb3RvdHlwZS1idWlsdGluczogMCAqL1xuXG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCdxdWljay1mb3JtYXQtdW5lc2NhcGVkJylcbmNvbnN0IHsgbWFwSHR0cFJlcXVlc3QsIG1hcEh0dHBSZXNwb25zZSB9ID0gcmVxdWlyZSgncGluby1zdGQtc2VyaWFsaXplcnMnKVxuY29uc3QgU29uaWNCb29tID0gcmVxdWlyZSgnc29uaWMtYm9vbScpXG5jb25zdCBvbkV4aXQgPSByZXF1aXJlKCdvbi1leGl0LWxlYWstZnJlZScpXG5jb25zdCB7XG4gIGxzQ2FjaGVTeW0sXG4gIGNoaW5kaW5nc1N5bSxcbiAgd3JpdGVTeW0sXG4gIHNlcmlhbGl6ZXJzU3ltLFxuICBmb3JtYXRPcHRzU3ltLFxuICBlbmRTeW0sXG4gIHN0cmluZ2lmaWVyc1N5bSxcbiAgc3RyaW5naWZ5U3ltLFxuICBzdHJpbmdpZnlTYWZlU3ltLFxuICB3aWxkY2FyZEZpcnN0U3ltLFxuICBuZXN0ZWRLZXlTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIG1lc3NhZ2VLZXlTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBuZXN0ZWRLZXlTdHJTeW0sXG4gIG1zZ1ByZWZpeFN5bVxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGlzTWFpblRocmVhZCB9ID0gcmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKVxuY29uc3QgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKVxuXG5mdW5jdGlvbiBub29wICgpIHtcbn1cblxuZnVuY3Rpb24gZ2VuTG9nIChsZXZlbCwgaG9vaykge1xuICBpZiAoIWhvb2spIHJldHVybiBMT0dcblxuICByZXR1cm4gZnVuY3Rpb24gaG9va1dyYXBwZWRMb2cgKC4uLmFyZ3MpIHtcbiAgICBob29rLmNhbGwodGhpcywgYXJncywgTE9HLCBsZXZlbClcbiAgfVxuXG4gIGZ1bmN0aW9uIExPRyAobywgLi4ubikge1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGxldCBtc2cgPSBvXG4gICAgICBpZiAobyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoby5tZXRob2QgJiYgby5oZWFkZXJzICYmIG8uc29ja2V0KSB7XG4gICAgICAgICAgbyA9IG1hcEh0dHBSZXF1ZXN0KG8pXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG8uc2V0SGVhZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbyA9IG1hcEh0dHBSZXNwb25zZShvKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgZm9ybWF0UGFyYW1zXG4gICAgICBpZiAobXNnID09PSBudWxsICYmIG4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZvcm1hdFBhcmFtcyA9IFtudWxsXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXNnID0gbi5zaGlmdCgpXG4gICAgICAgIGZvcm1hdFBhcmFtcyA9IG5cbiAgICAgIH1cbiAgICAgIC8vIFdlIGRvIG5vdCB1c2UgYSBjb2VyY2l2ZSBjaGVjayBmb3IgYG1zZ2AgYXMgaXQgaXNcbiAgICAgIC8vIG1lYXN1cmFibHkgc2xvd2VyIHRoYW4gdGhlIGV4cGxpY2l0IGNoZWNrcy5cbiAgICAgIGlmICh0eXBlb2YgdGhpc1ttc2dQcmVmaXhTeW1dID09PSAnc3RyaW5nJyAmJiBtc2cgIT09IHVuZGVmaW5lZCAmJiBtc2cgIT09IG51bGwpIHtcbiAgICAgICAgbXNnID0gdGhpc1ttc2dQcmVmaXhTeW1dICsgbXNnXG4gICAgICB9XG4gICAgICB0aGlzW3dyaXRlU3ltXShvLCBmb3JtYXQobXNnLCBmb3JtYXRQYXJhbXMsIHRoaXNbZm9ybWF0T3B0c1N5bV0pLCBsZXZlbClcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1zZyA9IG8gPT09IHVuZGVmaW5lZCA/IG4uc2hpZnQoKSA6IG9cblxuICAgICAgLy8gV2UgZG8gbm90IHVzZSBhIGNvZXJjaXZlIGNoZWNrIGZvciBgbXNnYCBhcyBpdCBpc1xuICAgICAgLy8gbWVhc3VyYWJseSBzbG93ZXIgdGhhbiB0aGUgZXhwbGljaXQgY2hlY2tzLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzW21zZ1ByZWZpeFN5bV0gPT09ICdzdHJpbmcnICYmIG1zZyAhPT0gdW5kZWZpbmVkICYmIG1zZyAhPT0gbnVsbCkge1xuICAgICAgICBtc2cgPSB0aGlzW21zZ1ByZWZpeFN5bV0gKyBtc2dcbiAgICAgIH1cbiAgICAgIHRoaXNbd3JpdGVTeW1dKG51bGwsIGZvcm1hdChtc2csIG4sIHRoaXNbZm9ybWF0T3B0c1N5bV0pLCBsZXZlbClcbiAgICB9XG4gIH1cbn1cblxuLy8gbWFnaWNhbGx5IGVzY2FwZSBzdHJpbmdzIGZvciBqc29uXG4vLyByZWx5aW5nIG9uIHRoZWlyIGNoYXJDb2RlQXRcbi8vIGV2ZXJ5dGhpbmcgYmVsb3cgMzIgbmVlZHMgSlNPTi5zdHJpbmdpZnkoKVxuLy8gMzQgYW5kIDkyIGhhcHBlbnMgYWxsIHRoZSB0aW1lLCBzbyB3ZVxuLy8gaGF2ZSBhIGZhc3QgY2FzZSBmb3IgdGhlbVxuZnVuY3Rpb24gYXNTdHJpbmcgKHN0cikge1xuICBsZXQgcmVzdWx0ID0gJydcbiAgbGV0IGxhc3QgPSAwXG4gIGxldCBmb3VuZCA9IGZhbHNlXG4gIGxldCBwb2ludCA9IDI1NVxuICBjb25zdCBsID0gc3RyLmxlbmd0aFxuICBpZiAobCA+IDEwMCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsICYmIHBvaW50ID49IDMyOyBpKyspIHtcbiAgICBwb2ludCA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKHBvaW50ID09PSAzNCB8fCBwb2ludCA9PT0gOTIpIHtcbiAgICAgIHJlc3VsdCArPSBzdHIuc2xpY2UobGFzdCwgaSkgKyAnXFxcXCdcbiAgICAgIGxhc3QgPSBpXG4gICAgICBmb3VuZCA9IHRydWVcbiAgICB9XG4gIH1cbiAgaWYgKCFmb3VuZCkge1xuICAgIHJlc3VsdCA9IHN0clxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBzdHIuc2xpY2UobGFzdClcbiAgfVxuICByZXR1cm4gcG9pbnQgPCAzMiA/IEpTT04uc3RyaW5naWZ5KHN0cikgOiAnXCInICsgcmVzdWx0ICsgJ1wiJ1xufVxuXG5mdW5jdGlvbiBhc0pzb24gKG9iaiwgbXNnLCBudW0sIHRpbWUpIHtcbiAgY29uc3Qgc3RyaW5naWZ5ID0gdGhpc1tzdHJpbmdpZnlTeW1dXG4gIGNvbnN0IHN0cmluZ2lmeVNhZmUgPSB0aGlzW3N0cmluZ2lmeVNhZmVTeW1dXG4gIGNvbnN0IHN0cmluZ2lmaWVycyA9IHRoaXNbc3RyaW5naWZpZXJzU3ltXVxuICBjb25zdCBlbmQgPSB0aGlzW2VuZFN5bV1cbiAgY29uc3QgY2hpbmRpbmdzID0gdGhpc1tjaGluZGluZ3NTeW1dXG4gIGNvbnN0IHNlcmlhbGl6ZXJzID0gdGhpc1tzZXJpYWxpemVyc1N5bV1cbiAgY29uc3QgZm9ybWF0dGVycyA9IHRoaXNbZm9ybWF0dGVyc1N5bV1cbiAgY29uc3QgbWVzc2FnZUtleSA9IHRoaXNbbWVzc2FnZUtleVN5bV1cbiAgY29uc3QgZXJyb3JLZXkgPSB0aGlzW2Vycm9yS2V5U3ltXVxuICBsZXQgZGF0YSA9IHRoaXNbbHNDYWNoZVN5bV1bbnVtXSArIHRpbWVcblxuICAvLyB3ZSBuZWVkIHRoZSBjaGlsZCBiaW5kaW5ncyBhZGRlZCB0byB0aGUgb3V0cHV0IGZpcnN0IHNvIGluc3RhbmNlIGxvZ2dlZFxuICAvLyBvYmplY3RzIGNhbiB0YWtlIHByZWNlZGVuY2Ugd2hlbiBKU09OLnBhcnNlLWluZyB0aGUgcmVzdWx0aW5nIGxvZyBsaW5lXG4gIGRhdGEgPSBkYXRhICsgY2hpbmRpbmdzXG5cbiAgbGV0IHZhbHVlXG4gIGlmIChmb3JtYXR0ZXJzLmxvZykge1xuICAgIG9iaiA9IGZvcm1hdHRlcnMubG9nKG9iailcbiAgfVxuICBjb25zdCB3aWxkY2FyZFN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW3dpbGRjYXJkRmlyc3RTeW1dXG4gIGxldCBwcm9wU3RyID0gJydcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgdmFsdWUgPSBvYmpba2V5XVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChzZXJpYWxpemVyc1trZXldKSB7XG4gICAgICAgIHZhbHVlID0gc2VyaWFsaXplcnNba2V5XSh2YWx1ZSlcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBlcnJvcktleSAmJiBzZXJpYWxpemVycy5lcnIpIHtcbiAgICAgICAgdmFsdWUgPSBzZXJpYWxpemVycy5lcnIodmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW2tleV0gfHwgd2lsZGNhcmRTdHJpbmdpZmllclxuXG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFwib2ZmXCIgKi9cbiAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBjYXNlIGV4cGxpY2l0bHkgZmFsbHMgdGhyb3VnaCB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgaWYgKHN0cmluZ2lmaWVyKSB2YWx1ZSA9IHN0cmluZ2lmaWVyKHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgdmFsdWUgPSAoc3RyaW5naWZpZXIgfHwgYXNTdHJpbmcpKHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFsdWUgPSAoc3RyaW5naWZpZXIgfHwgc3RyaW5naWZ5KSh2YWx1ZSwgc3RyaW5naWZ5U2FmZSlcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgY29uc3Qgc3RyS2V5ID0gYXNTdHJpbmcoa2V5KVxuICAgICAgcHJvcFN0ciArPSAnLCcgKyBzdHJLZXkgKyAnOicgKyB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIGxldCBtc2dTdHIgPSAnJ1xuICBpZiAobXNnICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IHNlcmlhbGl6ZXJzW21lc3NhZ2VLZXldID8gc2VyaWFsaXplcnNbbWVzc2FnZUtleV0obXNnKSA6IG1zZ1xuICAgIGNvbnN0IHN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW21lc3NhZ2VLZXldIHx8IHdpbGRjYXJkU3RyaW5naWZpZXJcblxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFwib2ZmXCIgKi9cbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFsdWUgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIC8vIHRoaXMgY2FzZSBleHBsaWNpdGx5IGZhbGxzIHRocm91Z2ggdG8gdGhlIG5leHQgb25lXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgaWYgKHN0cmluZ2lmaWVyKSB2YWx1ZSA9IHN0cmluZ2lmaWVyKHZhbHVlKVxuICAgICAgICBtc2dTdHIgPSAnLFwiJyArIG1lc3NhZ2VLZXkgKyAnXCI6JyArIHZhbHVlXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB2YWx1ZSA9IChzdHJpbmdpZmllciB8fCBhc1N0cmluZykodmFsdWUpXG4gICAgICAgIG1zZ1N0ciA9ICcsXCInICsgbWVzc2FnZUtleSArICdcIjonICsgdmFsdWVcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhbHVlID0gKHN0cmluZ2lmaWVyIHx8IHN0cmluZ2lmeSkodmFsdWUsIHN0cmluZ2lmeVNhZmUpXG4gICAgICAgIG1zZ1N0ciA9ICcsXCInICsgbWVzc2FnZUtleSArICdcIjonICsgdmFsdWVcbiAgICB9XG4gIH1cblxuICBpZiAodGhpc1tuZXN0ZWRLZXlTeW1dICYmIHByb3BTdHIpIHtcbiAgICAvLyBwbGFjZSBhbGwgdGhlIG9iaiBwcm9wZXJ0aWVzIHVuZGVyIHRoZSBzcGVjaWZpZWQga2V5XG4gICAgLy8gdGhlIG5lc3RlZCBrZXkgaXMgYWxyZWFkeSBmb3JtYXR0ZWQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICByZXR1cm4gZGF0YSArIHRoaXNbbmVzdGVkS2V5U3RyU3ltXSArIHByb3BTdHIuc2xpY2UoMSkgKyAnfScgKyBtc2dTdHIgKyBlbmRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YSArIHByb3BTdHIgKyBtc2dTdHIgKyBlbmRcbiAgfVxufVxuXG5mdW5jdGlvbiBhc0NoaW5kaW5ncyAoaW5zdGFuY2UsIGJpbmRpbmdzKSB7XG4gIGxldCB2YWx1ZVxuICBsZXQgZGF0YSA9IGluc3RhbmNlW2NoaW5kaW5nc1N5bV1cbiAgY29uc3Qgc3RyaW5naWZ5ID0gaW5zdGFuY2Vbc3RyaW5naWZ5U3ltXVxuICBjb25zdCBzdHJpbmdpZnlTYWZlID0gaW5zdGFuY2Vbc3RyaW5naWZ5U2FmZVN5bV1cbiAgY29uc3Qgc3RyaW5naWZpZXJzID0gaW5zdGFuY2Vbc3RyaW5naWZpZXJzU3ltXVxuICBjb25zdCB3aWxkY2FyZFN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXJzW3dpbGRjYXJkRmlyc3RTeW1dXG4gIGNvbnN0IHNlcmlhbGl6ZXJzID0gaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dXG4gIGNvbnN0IGZvcm1hdHRlciA9IGluc3RhbmNlW2Zvcm1hdHRlcnNTeW1dLmJpbmRpbmdzXG4gIGJpbmRpbmdzID0gZm9ybWF0dGVyKGJpbmRpbmdzKVxuXG4gIGZvciAoY29uc3Qga2V5IGluIGJpbmRpbmdzKSB7XG4gICAgdmFsdWUgPSBiaW5kaW5nc1trZXldXG4gICAgY29uc3QgdmFsaWQgPSBrZXkgIT09ICdsZXZlbCcgJiZcbiAgICAgIGtleSAhPT0gJ3NlcmlhbGl6ZXJzJyAmJlxuICAgICAga2V5ICE9PSAnZm9ybWF0dGVycycgJiZcbiAgICAgIGtleSAhPT0gJ2N1c3RvbUxldmVscycgJiZcbiAgICAgIGJpbmRpbmdzLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICBpZiAodmFsaWQgPT09IHRydWUpIHtcbiAgICAgIHZhbHVlID0gc2VyaWFsaXplcnNba2V5XSA/IHNlcmlhbGl6ZXJzW2tleV0odmFsdWUpIDogdmFsdWVcbiAgICAgIHZhbHVlID0gKHN0cmluZ2lmaWVyc1trZXldIHx8IHdpbGRjYXJkU3RyaW5naWZpZXIgfHwgc3RyaW5naWZ5KSh2YWx1ZSwgc3RyaW5naWZ5U2FmZSlcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgZGF0YSArPSAnLFwiJyArIGtleSArICdcIjonICsgdmFsdWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gaGFzQmVlblRhbXBlcmVkIChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZSAhPT0gc3RyZWFtLmNvbnN0cnVjdG9yLnByb3RvdHlwZS53cml0ZVxufVxuXG5jb25zdCBoYXNOb2RlQ29kZUNvdmVyYWdlID0gcHJvY2Vzcy5lbnYuTk9ERV9WOF9DT1ZFUkFHRSB8fCBwcm9jZXNzLmVudi5WOF9DT1ZFUkFHRVxuXG5mdW5jdGlvbiBidWlsZFNhZmVTb25pY0Jvb20gKG9wdHMpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFNvbmljQm9vbShvcHRzKVxuICBzdHJlYW0ub24oJ2Vycm9yJywgZmlsdGVyQnJva2VuUGlwZSlcbiAgLy8gSWYgd2UgYXJlIHN5bmM6IGZhbHNlLCB3ZSBtdXN0IGZsdXNoIG9uIGV4aXRcbiAgLy8gV2UgbXVzdCBkaXNhYmxlIHRoaXMgaWYgdGhlcmUgaXMgbm9kZSBjb2RlIGNvdmVyYWdlIGR1ZSB0b1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MzQ0I2lzc3VlY29tbWVudC0xNzQxNzc2MzA4LlxuICBpZiAoIWhhc05vZGVDb2RlQ292ZXJhZ2UgJiYgIW9wdHMuc3luYyAmJiBpc01haW5UaHJlYWQpIHtcbiAgICBvbkV4aXQucmVnaXN0ZXIoc3RyZWFtLCBhdXRvRW5kKVxuXG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uRXhpdC51bnJlZ2lzdGVyKHN0cmVhbSlcbiAgICB9KVxuICB9XG4gIHJldHVybiBzdHJlYW1cblxuICBmdW5jdGlvbiBmaWx0ZXJCcm9rZW5QaXBlIChlcnIpIHtcbiAgICAvLyBJbXBvc3NpYmxlIHRvIHJlcGxpY2F0ZSBhY3Jvc3MgYWxsIG9wZXJhdGluZyBzeXN0ZW1zXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFUElQRScpIHtcbiAgICAgIC8vIElmIHdlIGdldCBFUElQRSwgd2Ugc2hvdWxkIHN0b3AgbG9nZ2luZyBoZXJlXG4gICAgICAvLyBob3dldmVyIHdlIGhhdmUgbm8gY29udHJvbCB0byB0aGUgY29uc3VtZXIgb2ZcbiAgICAgIC8vIFNvbmljQm9vbSwgc28gd2UganVzdCBvdmVyd3JpdGUgdGhlIHdyaXRlIG1ldGhvZFxuICAgICAgc3RyZWFtLndyaXRlID0gbm9vcFxuICAgICAgc3RyZWFtLmVuZCA9IG5vb3BcbiAgICAgIHN0cmVhbS5mbHVzaFN5bmMgPSBub29wXG4gICAgICBzdHJlYW0uZGVzdHJveSA9IG5vb3BcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZmlsdGVyQnJva2VuUGlwZSlcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXV0b0VuZCAoc3RyZWFtLCBldmVudE5hbWUpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgb25seSBvbiBzb21lIHBsYXRmb3Jtc1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2JlZm9yZUV4aXQnKSB7XG4gICAgLy8gV2Ugc3RpbGwgaGF2ZSBhbiBldmVudCBsb29wLCBsZXQncyB1c2UgaXRcbiAgICBzdHJlYW0uZmx1c2goKVxuICAgIHN0cmVhbS5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHJlYW0uZW5kKClcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIC8vIEZvciBzb21lIHJlYXNvbiBpc3RhbmJ1bCBpcyBub3QgZGV0ZWN0aW5nIHRoaXMsIGJ1dCBpdCdzIHRoZXJlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAvLyBXZSBkbyBub3QgaGF2ZSBhbiBldmVudCBsb29wLCBzbyBmbHVzaCBzeW5jaHJvbm91c2x5XG4gICAgc3RyZWFtLmZsdXNoU3luYygpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJnc05vcm1hbGl6ZXIgKGRlZmF1bHRPcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub3JtYWxpemVBcmdzIChpbnN0YW5jZSwgY2FsbGVyLCBvcHRzID0ge30sIHN0cmVhbSkge1xuICAgIC8vIHN1cHBvcnQgc3RyZWFtIGFzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgc3RyZWFtID0gYnVpbGRTYWZlU29uaWNCb29tKHsgZGVzdDogb3B0cyB9KVxuICAgICAgb3B0cyA9IHt9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyZWFtID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy50cmFuc3BvcnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29ubHkgb25lIG9mIG9wdGlvbi50cmFuc3BvcnQgb3Igc3RyZWFtIGNhbiBiZSBzcGVjaWZpZWQnKVxuICAgICAgfVxuICAgICAgc3RyZWFtID0gYnVpbGRTYWZlU29uaWNCb29tKHsgZGVzdDogc3RyZWFtIH0pXG4gICAgfSBlbHNlIGlmIChvcHRzIGluc3RhbmNlb2YgU29uaWNCb29tIHx8IG9wdHMud3JpdGFibGUgfHwgb3B0cy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgc3RyZWFtID0gb3B0c1xuICAgICAgb3B0cyA9IHt9XG4gICAgfSBlbHNlIGlmIChvcHRzLnRyYW5zcG9ydCkge1xuICAgICAgaWYgKG9wdHMudHJhbnNwb3J0IGluc3RhbmNlb2YgU29uaWNCb29tIHx8IG9wdHMudHJhbnNwb3J0LndyaXRhYmxlIHx8IG9wdHMudHJhbnNwb3J0Ll93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdvcHRpb24udHJhbnNwb3J0IGRvIG5vdCBhbGxvdyBzdHJlYW0sIHBsZWFzZSBwYXNzIHRvIG9wdGlvbiBkaXJlY3RseS4gZS5nLiBwaW5vKHRyYW5zcG9ydCknKVxuICAgICAgfVxuICAgICAgaWYgKG9wdHMudHJhbnNwb3J0LnRhcmdldHMgJiYgb3B0cy50cmFuc3BvcnQudGFyZ2V0cy5sZW5ndGggJiYgb3B0cy5mb3JtYXR0ZXJzICYmIHR5cGVvZiBvcHRzLmZvcm1hdHRlcnMubGV2ZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29wdGlvbi50cmFuc3BvcnQudGFyZ2V0cyBkbyBub3QgYWxsb3cgY3VzdG9tIGxldmVsIGZvcm1hdHRlcnMnKVxuICAgICAgfVxuXG4gICAgICBsZXQgY3VzdG9tTGV2ZWxzXG4gICAgICBpZiAob3B0cy5jdXN0b21MZXZlbHMpIHtcbiAgICAgICAgY3VzdG9tTGV2ZWxzID0gb3B0cy51c2VPbmx5Q3VzdG9tTGV2ZWxzID8gb3B0cy5jdXN0b21MZXZlbHMgOiBPYmplY3QuYXNzaWduKHt9LCBvcHRzLmxldmVscywgb3B0cy5jdXN0b21MZXZlbHMpXG4gICAgICB9XG4gICAgICBzdHJlYW0gPSB0cmFuc3BvcnQoeyBjYWxsZXIsIC4uLm9wdHMudHJhbnNwb3J0LCBsZXZlbHM6IGN1c3RvbUxldmVscyB9KVxuICAgIH1cbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdHMpXG4gICAgb3B0cy5zZXJpYWxpemVycyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLnNlcmlhbGl6ZXJzLCBvcHRzLnNlcmlhbGl6ZXJzKVxuICAgIG9wdHMuZm9ybWF0dGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLmZvcm1hdHRlcnMsIG9wdHMuZm9ybWF0dGVycylcblxuICAgIGlmIChvcHRzLnByZXR0eVByaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXR0eVByaW50IG9wdGlvbiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLCBzZWUgdGhlIHBpbm8tcHJldHR5IHBhY2thZ2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9waW5vanMvcGluby1wcmV0dHkpJylcbiAgICB9XG5cbiAgICBjb25zdCB7IGVuYWJsZWQsIG9uQ2hpbGQgfSA9IG9wdHNcbiAgICBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIG9wdHMubGV2ZWwgPSAnc2lsZW50J1xuICAgIGlmICghb25DaGlsZCkgb3B0cy5vbkNoaWxkID0gbm9vcFxuICAgIGlmICghc3RyZWFtKSB7XG4gICAgICBpZiAoIWhhc0JlZW5UYW1wZXJlZChwcm9jZXNzLnN0ZG91dCkpIHtcbiAgICAgICAgLy8gSWYgcHJvY2Vzcy5zdGRvdXQuZmQgaXMgdW5kZWZpbmVkLCBpdCBtZWFucyB0aGF0IHdlIGFyZSBydW5uaW5nXG4gICAgICAgIC8vIGluIGEgd29ya2VyIHRocmVhZC4gTGV0J3MgYXNzdW1lIHdlIGFyZSBsb2dnaW5nIHRvIGZpbGUgZGVzY3JpcHRvciAxLlxuICAgICAgICBzdHJlYW0gPSBidWlsZFNhZmVTb25pY0Jvb20oeyBmZDogcHJvY2Vzcy5zdGRvdXQuZmQgfHwgMSB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtID0gcHJvY2Vzcy5zdGRvdXRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgb3B0cywgc3RyZWFtIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgc3RyaW5naWZ5U2FmZUZuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iailcbiAgfSBjYXRjaCAoXykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJpbmdpZnkgPSBzdHJpbmdpZnlTYWZlRm4gfHwgdGhpc1tzdHJpbmdpZnlTYWZlU3ltXVxuICAgICAgcmV0dXJuIHN0cmluZ2lmeShvYmopXG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuICdcIlt1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV1cIidcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRGb3JtYXR0ZXJzIChsZXZlbCwgYmluZGluZ3MsIGxvZykge1xuICByZXR1cm4ge1xuICAgIGxldmVsLFxuICAgIGJpbmRpbmdzLFxuICAgIGxvZ1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBpbnRlZ2VyIGZpbGUgZGVzY3JpcHRvciB0byBhIHByb3BlciBuYXRpdmUgaW50ZWdlclxuICogZmlsZSBkZXNjcmlwdG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbiBUaGUgZmlsZSBkZXNjcmlwdG9yIHN0cmluZyB0byBhdHRlbXB0IHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yIChkZXN0aW5hdGlvbikge1xuICBjb25zdCBmZCA9IE51bWJlcihkZXN0aW5hdGlvbilcbiAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiA9PT0gJ3N0cmluZycgJiYgTnVtYmVyLmlzRmluaXRlKGZkKSkge1xuICAgIHJldHVybiBmZFxuICB9XG4gIC8vIGRlc3RpbmF0aW9uIGNvdWxkIGJlIHVuZGVmaW5lZCBpZiB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgaWYgKGRlc3RpbmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUaGlzIGlzIHN0ZG91dCBpbiBVTklYIHN5c3RlbXNcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbm9vcCxcbiAgYnVpbGRTYWZlU29uaWNCb29tLFxuICBhc0NoaW5kaW5ncyxcbiAgYXNKc29uLFxuICBnZW5Mb2csXG4gIGNyZWF0ZUFyZ3NOb3JtYWxpemVyLFxuICBzdHJpbmdpZnksXG4gIGJ1aWxkRm9ybWF0dGVycyxcbiAgbm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/tools.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/transport.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/transport.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { createRequire } = __webpack_require__(/*! module */ \"module\")\nconst getCallers = __webpack_require__(/*! ./caller */ \"(ssr)/./node_modules/pino/lib/caller.js\")\nconst { join, isAbsolute, sep } = __webpack_require__(/*! node:path */ \"node:path\")\nconst sleep = __webpack_require__(/*! atomic-sleep */ \"(ssr)/./node_modules/atomic-sleep/index.js\")\nconst onExit = __webpack_require__(/*! on-exit-leak-free */ \"(ssr)/./node_modules/on-exit-leak-free/index.js\")\nconst ThreadStream = __webpack_require__(/*! thread-stream */ \"(ssr)/./node_modules/thread-stream/index.js\")\n\nfunction setupOnExit (stream) {\n  // This is leak free, it does not leave event handlers\n  onExit.register(stream, autoEnd)\n  onExit.registerBeforeExit(stream, flush)\n\n  stream.on('close', function () {\n    onExit.unregister(stream)\n  })\n}\n\nfunction buildStream (filename, workerData, workerOpts, sync) {\n  const stream = new ThreadStream({\n    filename,\n    workerData,\n    workerOpts,\n    sync\n  })\n\n  stream.on('ready', onReady)\n  stream.on('close', function () {\n    process.removeListener('exit', onExit)\n  })\n\n  process.on('exit', onExit)\n\n  function onReady () {\n    process.removeListener('exit', onExit)\n    stream.unref()\n\n    if (workerOpts.autoEnd !== false) {\n      setupOnExit(stream)\n    }\n  }\n\n  function onExit () {\n    /* istanbul ignore next */\n    if (stream.closed) {\n      return\n    }\n    stream.flushSync()\n    // Apparently there is a very sporadic race condition\n    // that in certain OS would prevent the messages to be flushed\n    // because the thread might not have been created still.\n    // Unfortunately we need to sleep(100) in this case.\n    sleep(100)\n    stream.end()\n  }\n\n  return stream\n}\n\nfunction autoEnd (stream) {\n  stream.ref()\n  stream.flushSync()\n  stream.end()\n  stream.once('close', function () {\n    stream.unref()\n  })\n}\n\nfunction flush (stream) {\n  stream.flushSync()\n}\n\nfunction transport (fullOptions) {\n  const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions\n\n  const options = {\n    ...fullOptions.options\n  }\n\n  // Backwards compatibility\n  const callers = typeof caller === 'string' ? [caller] : caller\n\n  // This will be eventually modified by bundlers\n  const bundlerOverrides = '__bundlerPathsOverrides' in globalThis ? globalThis.__bundlerPathsOverrides : {}\n\n  let target = fullOptions.target\n\n  if (target && targets) {\n    throw new Error('only one of target or targets can be specified')\n  }\n\n  if (targets) {\n    target = bundlerOverrides['pino-worker'] || join(__dirname, 'worker.js')\n    options.targets = targets.filter(dest => dest.target).map((dest) => {\n      return {\n        ...dest,\n        target: fixTarget(dest.target)\n      }\n    })\n    options.pipelines = targets.filter(dest => dest.pipeline).map((dest) => {\n      return dest.pipeline.map((t) => {\n        return {\n          ...t,\n          level: dest.level, // duplicate the pipeline `level` property defined in the upper level\n          target: fixTarget(t.target)\n        }\n      })\n    })\n  } else if (pipeline) {\n    target = bundlerOverrides['pino-worker'] || join(__dirname, 'worker.js')\n    options.pipelines = [pipeline.map((dest) => {\n      return {\n        ...dest,\n        target: fixTarget(dest.target)\n      }\n    })]\n  }\n\n  if (levels) {\n    options.levels = levels\n  }\n\n  if (dedupe) {\n    options.dedupe = dedupe\n  }\n\n  options.pinoWillSendConfig = true\n\n  return buildStream(fixTarget(target), options, worker, sync)\n\n  function fixTarget (origin) {\n    origin = bundlerOverrides[origin] || origin\n\n    if (isAbsolute(origin) || origin.indexOf('file://') === 0) {\n      return origin\n    }\n\n    if (origin === 'pino/file') {\n      return join(__dirname, '..', 'file.js')\n    }\n\n    let fixTarget\n\n    for (const filePath of callers) {\n      try {\n        const context = filePath === 'node:repl'\n          ? process.cwd() + sep\n          : filePath\n\n        fixTarget = createRequire(context).resolve(origin)\n        break\n      } catch (err) {\n        // Silent catch\n        continue\n      }\n    }\n\n    if (!fixTarget) {\n      throw new Error(`unable to determine transport target for \"${origin}\"`)\n    }\n\n    return fixTarget\n  }\n}\n\nmodule.exports = transport\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyx5REFBVTtBQUNyQyxRQUFRLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDckQsY0FBYyxtQkFBTyxDQUFDLGdFQUFjO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQywwRUFBbUI7QUFDMUMscUJBQXFCLG1CQUFPLENBQUMsa0VBQWU7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDhDQUE4Qyx3Q0FBd0M7O0FBRWhHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2phc2h3YW50aHBlZGRpc2V0dHkvRG9jdW1lbnRzL2V0aGdsb2JhbC9jb250ZXh0by9ub2RlX21vZHVsZXMvcGluby9saWIvdHJhbnNwb3J0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGNyZWF0ZVJlcXVpcmUgfSA9IHJlcXVpcmUoJ21vZHVsZScpXG5jb25zdCBnZXRDYWxsZXJzID0gcmVxdWlyZSgnLi9jYWxsZXInKVxuY29uc3QgeyBqb2luLCBpc0Fic29sdXRlLCBzZXAgfSA9IHJlcXVpcmUoJ25vZGU6cGF0aCcpXG5jb25zdCBzbGVlcCA9IHJlcXVpcmUoJ2F0b21pYy1zbGVlcCcpXG5jb25zdCBvbkV4aXQgPSByZXF1aXJlKCdvbi1leGl0LWxlYWstZnJlZScpXG5jb25zdCBUaHJlYWRTdHJlYW0gPSByZXF1aXJlKCd0aHJlYWQtc3RyZWFtJylcblxuZnVuY3Rpb24gc2V0dXBPbkV4aXQgKHN0cmVhbSkge1xuICAvLyBUaGlzIGlzIGxlYWsgZnJlZSwgaXQgZG9lcyBub3QgbGVhdmUgZXZlbnQgaGFuZGxlcnNcbiAgb25FeGl0LnJlZ2lzdGVyKHN0cmVhbSwgYXV0b0VuZClcbiAgb25FeGl0LnJlZ2lzdGVyQmVmb3JlRXhpdChzdHJlYW0sIGZsdXNoKVxuXG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgb25FeGl0LnVucmVnaXN0ZXIoc3RyZWFtKVxuICB9KVxufVxuXG5mdW5jdGlvbiBidWlsZFN0cmVhbSAoZmlsZW5hbWUsIHdvcmtlckRhdGEsIHdvcmtlck9wdHMsIHN5bmMpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFRocmVhZFN0cmVhbSh7XG4gICAgZmlsZW5hbWUsXG4gICAgd29ya2VyRGF0YSxcbiAgICB3b3JrZXJPcHRzLFxuICAgIHN5bmNcbiAgfSlcblxuICBzdHJlYW0ub24oJ3JlYWR5Jywgb25SZWFkeSlcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCdleGl0Jywgb25FeGl0KVxuICB9KVxuXG4gIHByb2Nlc3Mub24oJ2V4aXQnLCBvbkV4aXQpXG5cbiAgZnVuY3Rpb24gb25SZWFkeSAoKSB7XG4gICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcignZXhpdCcsIG9uRXhpdClcbiAgICBzdHJlYW0udW5yZWYoKVxuXG4gICAgaWYgKHdvcmtlck9wdHMuYXV0b0VuZCAhPT0gZmFsc2UpIHtcbiAgICAgIHNldHVwT25FeGl0KHN0cmVhbSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkV4aXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHN0cmVhbS5jbG9zZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdHJlYW0uZmx1c2hTeW5jKClcbiAgICAvLyBBcHBhcmVudGx5IHRoZXJlIGlzIGEgdmVyeSBzcG9yYWRpYyByYWNlIGNvbmRpdGlvblxuICAgIC8vIHRoYXQgaW4gY2VydGFpbiBPUyB3b3VsZCBwcmV2ZW50IHRoZSBtZXNzYWdlcyB0byBiZSBmbHVzaGVkXG4gICAgLy8gYmVjYXVzZSB0aGUgdGhyZWFkIG1pZ2h0IG5vdCBoYXZlIGJlZW4gY3JlYXRlZCBzdGlsbC5cbiAgICAvLyBVbmZvcnR1bmF0ZWx5IHdlIG5lZWQgdG8gc2xlZXAoMTAwKSBpbiB0aGlzIGNhc2UuXG4gICAgc2xlZXAoMTAwKVxuICAgIHN0cmVhbS5lbmQoKVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5mdW5jdGlvbiBhdXRvRW5kIChzdHJlYW0pIHtcbiAgc3RyZWFtLnJlZigpXG4gIHN0cmVhbS5mbHVzaFN5bmMoKVxuICBzdHJlYW0uZW5kKClcbiAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS51bnJlZigpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZsdXNoIChzdHJlYW0pIHtcbiAgc3RyZWFtLmZsdXNoU3luYygpXG59XG5cbmZ1bmN0aW9uIHRyYW5zcG9ydCAoZnVsbE9wdGlvbnMpIHtcbiAgY29uc3QgeyBwaXBlbGluZSwgdGFyZ2V0cywgbGV2ZWxzLCBkZWR1cGUsIHdvcmtlciA9IHt9LCBjYWxsZXIgPSBnZXRDYWxsZXJzKCksIHN5bmMgPSBmYWxzZSB9ID0gZnVsbE9wdGlvbnNcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmZ1bGxPcHRpb25zLm9wdGlvbnNcbiAgfVxuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGNvbnN0IGNhbGxlcnMgPSB0eXBlb2YgY2FsbGVyID09PSAnc3RyaW5nJyA/IFtjYWxsZXJdIDogY2FsbGVyXG5cbiAgLy8gVGhpcyB3aWxsIGJlIGV2ZW50dWFsbHkgbW9kaWZpZWQgYnkgYnVuZGxlcnNcbiAgY29uc3QgYnVuZGxlck92ZXJyaWRlcyA9ICdfX2J1bmRsZXJQYXRoc092ZXJyaWRlcycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuX19idW5kbGVyUGF0aHNPdmVycmlkZXMgOiB7fVxuXG4gIGxldCB0YXJnZXQgPSBmdWxsT3B0aW9ucy50YXJnZXRcblxuICBpZiAodGFyZ2V0ICYmIHRhcmdldHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgb25lIG9mIHRhcmdldCBvciB0YXJnZXRzIGNhbiBiZSBzcGVjaWZpZWQnKVxuICB9XG5cbiAgaWYgKHRhcmdldHMpIHtcbiAgICB0YXJnZXQgPSBidW5kbGVyT3ZlcnJpZGVzWydwaW5vLXdvcmtlciddIHx8IGpvaW4oX19kaXJuYW1lLCAnd29ya2VyLmpzJylcbiAgICBvcHRpb25zLnRhcmdldHMgPSB0YXJnZXRzLmZpbHRlcihkZXN0ID0+IGRlc3QudGFyZ2V0KS5tYXAoKGRlc3QpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlc3QsXG4gICAgICAgIHRhcmdldDogZml4VGFyZ2V0KGRlc3QudGFyZ2V0KVxuICAgICAgfVxuICAgIH0pXG4gICAgb3B0aW9ucy5waXBlbGluZXMgPSB0YXJnZXRzLmZpbHRlcihkZXN0ID0+IGRlc3QucGlwZWxpbmUpLm1hcCgoZGVzdCkgPT4ge1xuICAgICAgcmV0dXJuIGRlc3QucGlwZWxpbmUubWFwKCh0KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udCxcbiAgICAgICAgICBsZXZlbDogZGVzdC5sZXZlbCwgLy8gZHVwbGljYXRlIHRoZSBwaXBlbGluZSBgbGV2ZWxgIHByb3BlcnR5IGRlZmluZWQgaW4gdGhlIHVwcGVyIGxldmVsXG4gICAgICAgICAgdGFyZ2V0OiBmaXhUYXJnZXQodC50YXJnZXQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChwaXBlbGluZSkge1xuICAgIHRhcmdldCA9IGJ1bmRsZXJPdmVycmlkZXNbJ3Bpbm8td29ya2VyJ10gfHwgam9pbihfX2Rpcm5hbWUsICd3b3JrZXIuanMnKVxuICAgIG9wdGlvbnMucGlwZWxpbmVzID0gW3BpcGVsaW5lLm1hcCgoZGVzdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVzdCxcbiAgICAgICAgdGFyZ2V0OiBmaXhUYXJnZXQoZGVzdC50YXJnZXQpXG4gICAgICB9XG4gICAgfSldXG4gIH1cblxuICBpZiAobGV2ZWxzKSB7XG4gICAgb3B0aW9ucy5sZXZlbHMgPSBsZXZlbHNcbiAgfVxuXG4gIGlmIChkZWR1cGUpIHtcbiAgICBvcHRpb25zLmRlZHVwZSA9IGRlZHVwZVxuICB9XG5cbiAgb3B0aW9ucy5waW5vV2lsbFNlbmRDb25maWcgPSB0cnVlXG5cbiAgcmV0dXJuIGJ1aWxkU3RyZWFtKGZpeFRhcmdldCh0YXJnZXQpLCBvcHRpb25zLCB3b3JrZXIsIHN5bmMpXG5cbiAgZnVuY3Rpb24gZml4VGFyZ2V0IChvcmlnaW4pIHtcbiAgICBvcmlnaW4gPSBidW5kbGVyT3ZlcnJpZGVzW29yaWdpbl0gfHwgb3JpZ2luXG5cbiAgICBpZiAoaXNBYnNvbHV0ZShvcmlnaW4pIHx8IG9yaWdpbi5pbmRleE9mKCdmaWxlOi8vJykgPT09IDApIHtcbiAgICAgIHJldHVybiBvcmlnaW5cbiAgICB9XG5cbiAgICBpZiAob3JpZ2luID09PSAncGluby9maWxlJykge1xuICAgICAgcmV0dXJuIGpvaW4oX19kaXJuYW1lLCAnLi4nLCAnZmlsZS5qcycpXG4gICAgfVxuXG4gICAgbGV0IGZpeFRhcmdldFxuXG4gICAgZm9yIChjb25zdCBmaWxlUGF0aCBvZiBjYWxsZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gZmlsZVBhdGggPT09ICdub2RlOnJlcGwnXG4gICAgICAgICAgPyBwcm9jZXNzLmN3ZCgpICsgc2VwXG4gICAgICAgICAgOiBmaWxlUGF0aFxuXG4gICAgICAgIGZpeFRhcmdldCA9IGNyZWF0ZVJlcXVpcmUoY29udGV4dCkucmVzb2x2ZShvcmlnaW4pXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gU2lsZW50IGNhdGNoXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmaXhUYXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGRldGVybWluZSB0cmFuc3BvcnQgdGFyZ2V0IGZvciBcIiR7b3JpZ2lufVwiYClcbiAgICB9XG5cbiAgICByZXR1cm4gZml4VGFyZ2V0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc3BvcnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/transport.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/pino.js":
/*!***********************************!*\
  !*** ./node_modules/pino/pino.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst os = __webpack_require__(/*! node:os */ \"node:os\")\nconst stdSerializers = __webpack_require__(/*! pino-std-serializers */ \"(ssr)/./node_modules/pino-std-serializers/index.js\")\nconst caller = __webpack_require__(/*! ./lib/caller */ \"(ssr)/./node_modules/pino/lib/caller.js\")\nconst redaction = __webpack_require__(/*! ./lib/redaction */ \"(ssr)/./node_modules/pino/lib/redaction.js\")\nconst time = __webpack_require__(/*! ./lib/time */ \"(ssr)/./node_modules/pino/lib/time.js\")\nconst proto = __webpack_require__(/*! ./lib/proto */ \"(ssr)/./node_modules/pino/lib/proto.js\")\nconst symbols = __webpack_require__(/*! ./lib/symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\")\nconst { configure } = __webpack_require__(/*! safe-stable-stringify */ \"(ssr)/./node_modules/safe-stable-stringify/index.js\")\nconst { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = __webpack_require__(/*! ./lib/levels */ \"(ssr)/./node_modules/pino/lib/levels.js\")\nconst { DEFAULT_LEVELS, SORTING_ORDER } = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/pino/lib/constants.js\")\nconst {\n  createArgsNormalizer,\n  asChindings,\n  buildSafeSonicBoom,\n  buildFormatters,\n  stringify,\n  normalizeDestFileDescriptor,\n  noop\n} = __webpack_require__(/*! ./lib/tools */ \"(ssr)/./node_modules/pino/lib/tools.js\")\nconst { version } = __webpack_require__(/*! ./lib/meta */ \"(ssr)/./node_modules/pino/lib/meta.js\")\nconst {\n  chindingsSym,\n  redactFmtSym,\n  serializersSym,\n  timeSym,\n  timeSliceIndexSym,\n  streamSym,\n  stringifySym,\n  stringifySafeSym,\n  stringifiersSym,\n  setLevelSym,\n  endSym,\n  formatOptsSym,\n  messageKeySym,\n  errorKeySym,\n  nestedKeySym,\n  mixinSym,\n  levelCompSym,\n  useOnlyCustomLevelsSym,\n  formattersSym,\n  hooksSym,\n  nestedKeyStrSym,\n  mixinMergeStrategySym,\n  msgPrefixSym\n} = symbols\nconst { epochTime, nullTime } = time\nconst { pid } = process\nconst hostname = os.hostname()\nconst defaultErrorSerializer = stdSerializers.err\nconst defaultOptions = {\n  level: 'info',\n  levelComparison: SORTING_ORDER.ASC,\n  levels: DEFAULT_LEVELS,\n  messageKey: 'msg',\n  errorKey: 'err',\n  nestedKey: null,\n  enabled: true,\n  base: { pid, hostname },\n  serializers: Object.assign(Object.create(null), {\n    err: defaultErrorSerializer\n  }),\n  formatters: Object.assign(Object.create(null), {\n    bindings (bindings) {\n      return bindings\n    },\n    level (label, number) {\n      return { level: number }\n    }\n  }),\n  hooks: {\n    logMethod: undefined,\n    streamWrite: undefined\n  },\n  timestamp: epochTime,\n  name: undefined,\n  redact: null,\n  customLevels: null,\n  useOnlyCustomLevels: false,\n  depthLimit: 5,\n  edgeLimit: 100\n}\n\nconst normalize = createArgsNormalizer(defaultOptions)\n\nconst serializers = Object.assign(Object.create(null), stdSerializers)\n\nfunction pino (...args) {\n  const instance = {}\n  const { opts, stream } = normalize(instance, caller(), ...args)\n\n  if (opts.level && typeof opts.level === 'string' && DEFAULT_LEVELS[opts.level.toLowerCase()] !== undefined) opts.level = opts.level.toLowerCase()\n\n  const {\n    redact,\n    crlf,\n    serializers,\n    timestamp,\n    messageKey,\n    errorKey,\n    nestedKey,\n    base,\n    name,\n    level,\n    customLevels,\n    levelComparison,\n    mixin,\n    mixinMergeStrategy,\n    useOnlyCustomLevels,\n    formatters,\n    hooks,\n    depthLimit,\n    edgeLimit,\n    onChild,\n    msgPrefix\n  } = opts\n\n  const stringifySafe = configure({\n    maximumDepth: depthLimit,\n    maximumBreadth: edgeLimit\n  })\n\n  const allFormatters = buildFormatters(\n    formatters.level,\n    formatters.bindings,\n    formatters.log\n  )\n\n  const stringifyFn = stringify.bind({\n    [stringifySafeSym]: stringifySafe\n  })\n  const stringifiers = redact ? redaction(redact, stringifyFn) : {}\n  const formatOpts = redact\n    ? { stringify: stringifiers[redactFmtSym] }\n    : { stringify: stringifyFn }\n  const end = '}' + (crlf ? '\\r\\n' : '\\n')\n  const coreChindings = asChindings.bind(null, {\n    [chindingsSym]: '',\n    [serializersSym]: serializers,\n    [stringifiersSym]: stringifiers,\n    [stringifySym]: stringify,\n    [stringifySafeSym]: stringifySafe,\n    [formattersSym]: allFormatters\n  })\n\n  let chindings = ''\n  if (base !== null) {\n    if (name === undefined) {\n      chindings = coreChindings(base)\n    } else {\n      chindings = coreChindings(Object.assign({}, base, { name }))\n    }\n  }\n\n  const time = (timestamp instanceof Function)\n    ? timestamp\n    : (timestamp ? epochTime : nullTime)\n  const timeSliceIndex = time().indexOf(':') + 1\n\n  if (useOnlyCustomLevels && !customLevels) throw Error('customLevels is required if useOnlyCustomLevels is set true')\n  if (mixin && typeof mixin !== 'function') throw Error(`Unknown mixin type \"${typeof mixin}\" - expected \"function\"`)\n  if (msgPrefix && typeof msgPrefix !== 'string') throw Error(`Unknown msgPrefix type \"${typeof msgPrefix}\" - expected \"string\"`)\n\n  assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels)\n  const levels = mappings(customLevels, useOnlyCustomLevels)\n\n  if (typeof stream.emit === 'function') {\n    stream.emit('message', { code: 'PINO_CONFIG', config: { levels, messageKey, errorKey } })\n  }\n\n  assertLevelComparison(levelComparison)\n  const levelCompFunc = genLevelComparison(levelComparison)\n\n  Object.assign(instance, {\n    levels,\n    [levelCompSym]: levelCompFunc,\n    [useOnlyCustomLevelsSym]: useOnlyCustomLevels,\n    [streamSym]: stream,\n    [timeSym]: time,\n    [timeSliceIndexSym]: timeSliceIndex,\n    [stringifySym]: stringify,\n    [stringifySafeSym]: stringifySafe,\n    [stringifiersSym]: stringifiers,\n    [endSym]: end,\n    [formatOptsSym]: formatOpts,\n    [messageKeySym]: messageKey,\n    [errorKeySym]: errorKey,\n    [nestedKeySym]: nestedKey,\n    // protect against injection\n    [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : '',\n    [serializersSym]: serializers,\n    [mixinSym]: mixin,\n    [mixinMergeStrategySym]: mixinMergeStrategy,\n    [chindingsSym]: chindings,\n    [formattersSym]: allFormatters,\n    [hooksSym]: hooks,\n    silent: noop,\n    onChild,\n    [msgPrefixSym]: msgPrefix\n  })\n\n  Object.setPrototypeOf(instance, proto())\n\n  genLsCache(instance)\n\n  instance[setLevelSym](level)\n\n  return instance\n}\n\nmodule.exports = pino\n\nmodule.exports.destination = (dest = process.stdout.fd) => {\n  if (typeof dest === 'object') {\n    dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd)\n    return buildSafeSonicBoom(dest)\n  } else {\n    return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 })\n  }\n}\n\nmodule.exports.transport = __webpack_require__(/*! ./lib/transport */ \"(ssr)/./node_modules/pino/lib/transport.js\")\nmodule.exports.multistream = __webpack_require__(/*! ./lib/multistream */ \"(ssr)/./node_modules/pino/lib/multistream.js\")\n\nmodule.exports.levels = mappings()\nmodule.exports.stdSerializers = serializers\nmodule.exports.stdTimeFunctions = Object.assign({}, time)\nmodule.exports.symbols = symbols\nmodule.exports.version = version\n\n// Enables default and name export with TypeScript and Babel\nmodule.exports[\"default\"] = pino\nmodule.exports.pino = pino\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9waW5vLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQyx3QkFBUztBQUM1Qix1QkFBdUIsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDckQsZUFBZSxtQkFBTyxDQUFDLDZEQUFjO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLG1FQUFpQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMseURBQVk7QUFDakMsY0FBYyxtQkFBTyxDQUFDLDJEQUFhO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLCtEQUFlO0FBQ3ZDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0ZBQXVCO0FBQ3JELFFBQVEsMkZBQTJGLEVBQUUsbUJBQU8sQ0FBQyw2REFBYztBQUMzSCxRQUFRLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsbUVBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyREFBYTtBQUN6QixRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLHlEQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixRQUFRLHNCQUFzQjtBQUM5QixRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWU7QUFDZjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxlQUFlOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnREFBZ0QsVUFBVSxNQUFNO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrRUFBK0UsYUFBYTtBQUM1Rix5RkFBeUYsaUJBQWlCOztBQUUxRztBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLCtCQUErQixnQ0FBZ0M7QUFDNUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEIsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQ0FBZ0MsdURBQXVEO0FBQ3ZGO0FBQ0E7O0FBRUEsbUhBQXFEO0FBQ3JELHlIQUF5RDs7QUFFekQscUJBQXFCO0FBQ3JCLDZCQUE2QjtBQUM3QiwrQkFBK0IsbUJBQW1CO0FBQ2xELHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0EseUJBQXNCO0FBQ3RCLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL2phc2h3YW50aHBlZGRpc2V0dHkvRG9jdW1lbnRzL2V0aGdsb2JhbC9jb250ZXh0by9ub2RlX21vZHVsZXMvcGluby9waW5vLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ25vZGU6b3MnKVxuY29uc3Qgc3RkU2VyaWFsaXplcnMgPSByZXF1aXJlKCdwaW5vLXN0ZC1zZXJpYWxpemVycycpXG5jb25zdCBjYWxsZXIgPSByZXF1aXJlKCcuL2xpYi9jYWxsZXInKVxuY29uc3QgcmVkYWN0aW9uID0gcmVxdWlyZSgnLi9saWIvcmVkYWN0aW9uJylcbmNvbnN0IHRpbWUgPSByZXF1aXJlKCcuL2xpYi90aW1lJylcbmNvbnN0IHByb3RvID0gcmVxdWlyZSgnLi9saWIvcHJvdG8nKVxuY29uc3Qgc3ltYm9scyA9IHJlcXVpcmUoJy4vbGliL3N5bWJvbHMnKVxuY29uc3QgeyBjb25maWd1cmUgfSA9IHJlcXVpcmUoJ3NhZmUtc3RhYmxlLXN0cmluZ2lmeScpXG5jb25zdCB7IGFzc2VydERlZmF1bHRMZXZlbEZvdW5kLCBtYXBwaW5ncywgZ2VuTHNDYWNoZSwgZ2VuTGV2ZWxDb21wYXJpc29uLCBhc3NlcnRMZXZlbENvbXBhcmlzb24gfSA9IHJlcXVpcmUoJy4vbGliL2xldmVscycpXG5jb25zdCB7IERFRkFVTFRfTEVWRUxTLCBTT1JUSU5HX09SREVSIH0gPSByZXF1aXJlKCcuL2xpYi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBjcmVhdGVBcmdzTm9ybWFsaXplcixcbiAgYXNDaGluZGluZ3MsXG4gIGJ1aWxkU2FmZVNvbmljQm9vbSxcbiAgYnVpbGRGb3JtYXR0ZXJzLFxuICBzdHJpbmdpZnksXG4gIG5vcm1hbGl6ZURlc3RGaWxlRGVzY3JpcHRvcixcbiAgbm9vcFxufSA9IHJlcXVpcmUoJy4vbGliL3Rvb2xzJylcbmNvbnN0IHsgdmVyc2lvbiB9ID0gcmVxdWlyZSgnLi9saWIvbWV0YScpXG5jb25zdCB7XG4gIGNoaW5kaW5nc1N5bSxcbiAgcmVkYWN0Rm10U3ltLFxuICBzZXJpYWxpemVyc1N5bSxcbiAgdGltZVN5bSxcbiAgdGltZVNsaWNlSW5kZXhTeW0sXG4gIHN0cmVhbVN5bSxcbiAgc3RyaW5naWZ5U3ltLFxuICBzdHJpbmdpZnlTYWZlU3ltLFxuICBzdHJpbmdpZmllcnNTeW0sXG4gIHNldExldmVsU3ltLFxuICBlbmRTeW0sXG4gIGZvcm1hdE9wdHNTeW0sXG4gIG1lc3NhZ2VLZXlTeW0sXG4gIGVycm9yS2V5U3ltLFxuICBuZXN0ZWRLZXlTeW0sXG4gIG1peGluU3ltLFxuICBsZXZlbENvbXBTeW0sXG4gIHVzZU9ubHlDdXN0b21MZXZlbHNTeW0sXG4gIGZvcm1hdHRlcnNTeW0sXG4gIGhvb2tzU3ltLFxuICBuZXN0ZWRLZXlTdHJTeW0sXG4gIG1peGluTWVyZ2VTdHJhdGVneVN5bSxcbiAgbXNnUHJlZml4U3ltXG59ID0gc3ltYm9sc1xuY29uc3QgeyBlcG9jaFRpbWUsIG51bGxUaW1lIH0gPSB0aW1lXG5jb25zdCB7IHBpZCB9ID0gcHJvY2Vzc1xuY29uc3QgaG9zdG5hbWUgPSBvcy5ob3N0bmFtZSgpXG5jb25zdCBkZWZhdWx0RXJyb3JTZXJpYWxpemVyID0gc3RkU2VyaWFsaXplcnMuZXJyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgbGV2ZWw6ICdpbmZvJyxcbiAgbGV2ZWxDb21wYXJpc29uOiBTT1JUSU5HX09SREVSLkFTQyxcbiAgbGV2ZWxzOiBERUZBVUxUX0xFVkVMUyxcbiAgbWVzc2FnZUtleTogJ21zZycsXG4gIGVycm9yS2V5OiAnZXJyJyxcbiAgbmVzdGVkS2V5OiBudWxsLFxuICBlbmFibGVkOiB0cnVlLFxuICBiYXNlOiB7IHBpZCwgaG9zdG5hbWUgfSxcbiAgc2VyaWFsaXplcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgIGVycjogZGVmYXVsdEVycm9yU2VyaWFsaXplclxuICB9KSxcbiAgZm9ybWF0dGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgYmluZGluZ3MgKGJpbmRpbmdzKSB7XG4gICAgICByZXR1cm4gYmluZGluZ3NcbiAgICB9LFxuICAgIGxldmVsIChsYWJlbCwgbnVtYmVyKSB7XG4gICAgICByZXR1cm4geyBsZXZlbDogbnVtYmVyIH1cbiAgICB9XG4gIH0pLFxuICBob29rczoge1xuICAgIGxvZ01ldGhvZDogdW5kZWZpbmVkLFxuICAgIHN0cmVhbVdyaXRlOiB1bmRlZmluZWRcbiAgfSxcbiAgdGltZXN0YW1wOiBlcG9jaFRpbWUsXG4gIG5hbWU6IHVuZGVmaW5lZCxcbiAgcmVkYWN0OiBudWxsLFxuICBjdXN0b21MZXZlbHM6IG51bGwsXG4gIHVzZU9ubHlDdXN0b21MZXZlbHM6IGZhbHNlLFxuICBkZXB0aExpbWl0OiA1LFxuICBlZGdlTGltaXQ6IDEwMFxufVxuXG5jb25zdCBub3JtYWxpemUgPSBjcmVhdGVBcmdzTm9ybWFsaXplcihkZWZhdWx0T3B0aW9ucylcblxuY29uc3Qgc2VyaWFsaXplcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHN0ZFNlcmlhbGl6ZXJzKVxuXG5mdW5jdGlvbiBwaW5vICguLi5hcmdzKSB7XG4gIGNvbnN0IGluc3RhbmNlID0ge31cbiAgY29uc3QgeyBvcHRzLCBzdHJlYW0gfSA9IG5vcm1hbGl6ZShpbnN0YW5jZSwgY2FsbGVyKCksIC4uLmFyZ3MpXG5cbiAgaWYgKG9wdHMubGV2ZWwgJiYgdHlwZW9mIG9wdHMubGV2ZWwgPT09ICdzdHJpbmcnICYmIERFRkFVTFRfTEVWRUxTW29wdHMubGV2ZWwudG9Mb3dlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkgb3B0cy5sZXZlbCA9IG9wdHMubGV2ZWwudG9Mb3dlckNhc2UoKVxuXG4gIGNvbnN0IHtcbiAgICByZWRhY3QsXG4gICAgY3JsZixcbiAgICBzZXJpYWxpemVycyxcbiAgICB0aW1lc3RhbXAsXG4gICAgbWVzc2FnZUtleSxcbiAgICBlcnJvcktleSxcbiAgICBuZXN0ZWRLZXksXG4gICAgYmFzZSxcbiAgICBuYW1lLFxuICAgIGxldmVsLFxuICAgIGN1c3RvbUxldmVscyxcbiAgICBsZXZlbENvbXBhcmlzb24sXG4gICAgbWl4aW4sXG4gICAgbWl4aW5NZXJnZVN0cmF0ZWd5LFxuICAgIHVzZU9ubHlDdXN0b21MZXZlbHMsXG4gICAgZm9ybWF0dGVycyxcbiAgICBob29rcyxcbiAgICBkZXB0aExpbWl0LFxuICAgIGVkZ2VMaW1pdCxcbiAgICBvbkNoaWxkLFxuICAgIG1zZ1ByZWZpeFxuICB9ID0gb3B0c1xuXG4gIGNvbnN0IHN0cmluZ2lmeVNhZmUgPSBjb25maWd1cmUoe1xuICAgIG1heGltdW1EZXB0aDogZGVwdGhMaW1pdCxcbiAgICBtYXhpbXVtQnJlYWR0aDogZWRnZUxpbWl0XG4gIH0pXG5cbiAgY29uc3QgYWxsRm9ybWF0dGVycyA9IGJ1aWxkRm9ybWF0dGVycyhcbiAgICBmb3JtYXR0ZXJzLmxldmVsLFxuICAgIGZvcm1hdHRlcnMuYmluZGluZ3MsXG4gICAgZm9ybWF0dGVycy5sb2dcbiAgKVxuXG4gIGNvbnN0IHN0cmluZ2lmeUZuID0gc3RyaW5naWZ5LmJpbmQoe1xuICAgIFtzdHJpbmdpZnlTYWZlU3ltXTogc3RyaW5naWZ5U2FmZVxuICB9KVxuICBjb25zdCBzdHJpbmdpZmllcnMgPSByZWRhY3QgPyByZWRhY3Rpb24ocmVkYWN0LCBzdHJpbmdpZnlGbikgOiB7fVxuICBjb25zdCBmb3JtYXRPcHRzID0gcmVkYWN0XG4gICAgPyB7IHN0cmluZ2lmeTogc3RyaW5naWZpZXJzW3JlZGFjdEZtdFN5bV0gfVxuICAgIDogeyBzdHJpbmdpZnk6IHN0cmluZ2lmeUZuIH1cbiAgY29uc3QgZW5kID0gJ30nICsgKGNybGYgPyAnXFxyXFxuJyA6ICdcXG4nKVxuICBjb25zdCBjb3JlQ2hpbmRpbmdzID0gYXNDaGluZGluZ3MuYmluZChudWxsLCB7XG4gICAgW2NoaW5kaW5nc1N5bV06ICcnLFxuICAgIFtzZXJpYWxpemVyc1N5bV06IHNlcmlhbGl6ZXJzLFxuICAgIFtzdHJpbmdpZmllcnNTeW1dOiBzdHJpbmdpZmllcnMsXG4gICAgW3N0cmluZ2lmeVN5bV06IHN0cmluZ2lmeSxcbiAgICBbc3RyaW5naWZ5U2FmZVN5bV06IHN0cmluZ2lmeVNhZmUsXG4gICAgW2Zvcm1hdHRlcnNTeW1dOiBhbGxGb3JtYXR0ZXJzXG4gIH0pXG5cbiAgbGV0IGNoaW5kaW5ncyA9ICcnXG4gIGlmIChiYXNlICE9PSBudWxsKSB7XG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2hpbmRpbmdzID0gY29yZUNoaW5kaW5ncyhiYXNlKVxuICAgIH0gZWxzZSB7XG4gICAgICBjaGluZGluZ3MgPSBjb3JlQ2hpbmRpbmdzKE9iamVjdC5hc3NpZ24oe30sIGJhc2UsIHsgbmFtZSB9KSlcbiAgICB9XG4gIH1cblxuICBjb25zdCB0aW1lID0gKHRpbWVzdGFtcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgID8gdGltZXN0YW1wXG4gICAgOiAodGltZXN0YW1wID8gZXBvY2hUaW1lIDogbnVsbFRpbWUpXG4gIGNvbnN0IHRpbWVTbGljZUluZGV4ID0gdGltZSgpLmluZGV4T2YoJzonKSArIDFcblxuICBpZiAodXNlT25seUN1c3RvbUxldmVscyAmJiAhY3VzdG9tTGV2ZWxzKSB0aHJvdyBFcnJvcignY3VzdG9tTGV2ZWxzIGlzIHJlcXVpcmVkIGlmIHVzZU9ubHlDdXN0b21MZXZlbHMgaXMgc2V0IHRydWUnKVxuICBpZiAobWl4aW4gJiYgdHlwZW9mIG1peGluICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBFcnJvcihgVW5rbm93biBtaXhpbiB0eXBlIFwiJHt0eXBlb2YgbWl4aW59XCIgLSBleHBlY3RlZCBcImZ1bmN0aW9uXCJgKVxuICBpZiAobXNnUHJlZml4ICYmIHR5cGVvZiBtc2dQcmVmaXggIT09ICdzdHJpbmcnKSB0aHJvdyBFcnJvcihgVW5rbm93biBtc2dQcmVmaXggdHlwZSBcIiR7dHlwZW9mIG1zZ1ByZWZpeH1cIiAtIGV4cGVjdGVkIFwic3RyaW5nXCJgKVxuXG4gIGFzc2VydERlZmF1bHRMZXZlbEZvdW5kKGxldmVsLCBjdXN0b21MZXZlbHMsIHVzZU9ubHlDdXN0b21MZXZlbHMpXG4gIGNvbnN0IGxldmVscyA9IG1hcHBpbmdzKGN1c3RvbUxldmVscywgdXNlT25seUN1c3RvbUxldmVscylcblxuICBpZiAodHlwZW9mIHN0cmVhbS5lbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyZWFtLmVtaXQoJ21lc3NhZ2UnLCB7IGNvZGU6ICdQSU5PX0NPTkZJRycsIGNvbmZpZzogeyBsZXZlbHMsIG1lc3NhZ2VLZXksIGVycm9yS2V5IH0gfSlcbiAgfVxuXG4gIGFzc2VydExldmVsQ29tcGFyaXNvbihsZXZlbENvbXBhcmlzb24pXG4gIGNvbnN0IGxldmVsQ29tcEZ1bmMgPSBnZW5MZXZlbENvbXBhcmlzb24obGV2ZWxDb21wYXJpc29uKVxuXG4gIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICBsZXZlbHMsXG4gICAgW2xldmVsQ29tcFN5bV06IGxldmVsQ29tcEZ1bmMsXG4gICAgW3VzZU9ubHlDdXN0b21MZXZlbHNTeW1dOiB1c2VPbmx5Q3VzdG9tTGV2ZWxzLFxuICAgIFtzdHJlYW1TeW1dOiBzdHJlYW0sXG4gICAgW3RpbWVTeW1dOiB0aW1lLFxuICAgIFt0aW1lU2xpY2VJbmRleFN5bV06IHRpbWVTbGljZUluZGV4LFxuICAgIFtzdHJpbmdpZnlTeW1dOiBzdHJpbmdpZnksXG4gICAgW3N0cmluZ2lmeVNhZmVTeW1dOiBzdHJpbmdpZnlTYWZlLFxuICAgIFtzdHJpbmdpZmllcnNTeW1dOiBzdHJpbmdpZmllcnMsXG4gICAgW2VuZFN5bV06IGVuZCxcbiAgICBbZm9ybWF0T3B0c1N5bV06IGZvcm1hdE9wdHMsXG4gICAgW21lc3NhZ2VLZXlTeW1dOiBtZXNzYWdlS2V5LFxuICAgIFtlcnJvcktleVN5bV06IGVycm9yS2V5LFxuICAgIFtuZXN0ZWRLZXlTeW1dOiBuZXN0ZWRLZXksXG4gICAgLy8gcHJvdGVjdCBhZ2FpbnN0IGluamVjdGlvblxuICAgIFtuZXN0ZWRLZXlTdHJTeW1dOiBuZXN0ZWRLZXkgPyBgLCR7SlNPTi5zdHJpbmdpZnkobmVzdGVkS2V5KX06e2AgOiAnJyxcbiAgICBbc2VyaWFsaXplcnNTeW1dOiBzZXJpYWxpemVycyxcbiAgICBbbWl4aW5TeW1dOiBtaXhpbixcbiAgICBbbWl4aW5NZXJnZVN0cmF0ZWd5U3ltXTogbWl4aW5NZXJnZVN0cmF0ZWd5LFxuICAgIFtjaGluZGluZ3NTeW1dOiBjaGluZGluZ3MsXG4gICAgW2Zvcm1hdHRlcnNTeW1dOiBhbGxGb3JtYXR0ZXJzLFxuICAgIFtob29rc1N5bV06IGhvb2tzLFxuICAgIHNpbGVudDogbm9vcCxcbiAgICBvbkNoaWxkLFxuICAgIFttc2dQcmVmaXhTeW1dOiBtc2dQcmVmaXhcbiAgfSlcblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIHByb3RvKCkpXG5cbiAgZ2VuTHNDYWNoZShpbnN0YW5jZSlcblxuICBpbnN0YW5jZVtzZXRMZXZlbFN5bV0obGV2ZWwpXG5cbiAgcmV0dXJuIGluc3RhbmNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlub1xuXG5tb2R1bGUuZXhwb3J0cy5kZXN0aW5hdGlvbiA9IChkZXN0ID0gcHJvY2Vzcy5zdGRvdXQuZmQpID0+IHtcbiAgaWYgKHR5cGVvZiBkZXN0ID09PSAnb2JqZWN0Jykge1xuICAgIGRlc3QuZGVzdCA9IG5vcm1hbGl6ZURlc3RGaWxlRGVzY3JpcHRvcihkZXN0LmRlc3QgfHwgcHJvY2Vzcy5zdGRvdXQuZmQpXG4gICAgcmV0dXJuIGJ1aWxkU2FmZVNvbmljQm9vbShkZXN0KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWlsZFNhZmVTb25pY0Jvb20oeyBkZXN0OiBub3JtYWxpemVEZXN0RmlsZURlc2NyaXB0b3IoZGVzdCksIG1pbkxlbmd0aDogMCB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLnRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL3RyYW5zcG9ydCcpXG5tb2R1bGUuZXhwb3J0cy5tdWx0aXN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL211bHRpc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMubGV2ZWxzID0gbWFwcGluZ3MoKVxubW9kdWxlLmV4cG9ydHMuc3RkU2VyaWFsaXplcnMgPSBzZXJpYWxpemVyc1xubW9kdWxlLmV4cG9ydHMuc3RkVGltZUZ1bmN0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRpbWUpXG5tb2R1bGUuZXhwb3J0cy5zeW1ib2xzID0gc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb25cblxuLy8gRW5hYmxlcyBkZWZhdWx0IGFuZCBuYW1lIGV4cG9ydCB3aXRoIFR5cGVTY3JpcHQgYW5kIEJhYmVsXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcGlub1xubW9kdWxlLmV4cG9ydHMucGlubyA9IHBpbm9cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/pino.js\n");

/***/ })

};
;